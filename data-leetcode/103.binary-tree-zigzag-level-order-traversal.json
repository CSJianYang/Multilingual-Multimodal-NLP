[
    {
        "title": "Binary Tree Zigzag Level Order Traversal",
        "question_content": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).\n&nbsp;\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[20,9],[15,7]]\nExample 2:\nInput: root = [1]\nOutput: [[1]]\nExample 3:\nInput: root = []\nOutput: []\n&nbsp;\nConstraints:\n\tThe number of nodes in the tree is in the range [0, 2000].\n\t-100 <= Node.val <= 100",
        "solutions": [
            {
                "id": 33825,
                "title": "c-5ms-version-one-queue-and-without-reverse-operation-by-using-size-of-each-level",
                "content": "  \\nAssuming after traversing the 1st level, nodes in queue are {9, 20, 8}, And we are going to traverse 2nd level, which is even line and should print value from right to left [8, 20, 9]. \\n\\nWe know there are 3 nodes in current queue, so the vector for this level in final result should be of size 3. \\nThen,     queue [i] -> goes to ->  vector[queue.size() - 1 - i]\\ni.e. the ith node in current queue should be placed in (queue.size() - 1 - i) position in vector for that line.\\n \\nFor example, for node(9), it's index in queue is 0, so its index in vector should be (3-1-0) = 2. \\n\\n\\n    vector<vector<int> > zigzagLevelOrder(TreeNode* root) {\\n        if (root == NULL) {\\n            return vector<vector<int> > ();\\n        }\\n        vector<vector<int> > result;\\n    \\n        queue<TreeNode*> nodesQueue;\\n        nodesQueue.push(root);\\n        bool leftToRight = true;\\n    \\n        while ( !nodesQueue.empty()) {\\n            int size = nodesQueue.size();\\n            vector<int> row(size);\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* node = nodesQueue.front();\\n                nodesQueue.pop();\\n\\n                // find position to fill node's value\\n                int index = (leftToRight) ? i : (size - 1 - i);\\n\\n                row[index] = node->val;\\n                if (node->left) {\\n                    nodesQueue.push(node->left);\\n                }\\n                if (node->right) {\\n                    nodesQueue.push(node->right);\\n                }\\n            }\\n            // after this level\\n            leftToRight = !leftToRight;\\n            result.push_back(row);\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "  \\nAssuming after traversing the 1st level, nodes in queue are {9, 20, 8}, And we are going to traverse 2nd level, which is even line and should print value from right to left [8, 20, 9]. \\n\\nWe know there are 3 nodes in current queue, so the vector for this level in final result should be of size 3. \\nThen,     queue [i] -> goes to ->  vector[queue.size() - 1 - i]\\ni.e. the ith node in current queue should be placed in (queue.size() - 1 - i) position in vector for that line.\\n \\nFor example, for node(9), it's index in queue is 0, so its index in vector should be (3-1-0) = 2. \\n\\n\\n    vector<vector<int> > zigzagLevelOrder(TreeNode* root) {\\n        if (root == NULL) {\\n            return vector<vector<int> > ();\\n        }\\n        vector<vector<int> > result;\\n    \\n        queue<TreeNode*> nodesQueue;\\n        nodesQueue.push(root);\\n        bool leftToRight = true;\\n    \\n        while ( !nodesQueue.empty()) {\\n            int size = nodesQueue.size();\\n            vector<int> row(size);\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* node = nodesQueue.front();\\n                nodesQueue.pop();\\n\\n                // find position to fill node's value\\n                int index = (leftToRight) ? i : (size - 1 - i);\\n\\n                row[index] = node->val;\\n                if (node->left) {\\n                    nodesQueue.push(node->left);\\n                }\\n                if (node->right) {\\n                    nodesQueue.push(node->right);\\n                }\\n            }\\n            // after this level\\n            leftToRight = !leftToRight;\\n            result.push_back(row);\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33815,
                "title": "my-accepted-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> zigzagLevelOrder(TreeNode root) \\n        {\\n            List<List<Integer>> sol = new ArrayList<>();\\n            travel(root, sol, 0);\\n            return sol;\\n        }\\n        \\n        private void travel(TreeNode curr, List<List<Integer>> sol, int level)\\n        {\\n            if(curr == null) return;\\n            \\n            if(sol.size() <= level)\\n            {\\n                List<Integer> newLevel = new LinkedList<>();\\n                sol.add(newLevel);\\n            }\\n            \\n            List<Integer> collection  = sol.get(level);\\n            if(level % 2 == 0) collection.add(curr.val);\\n            else collection.add(0, curr.val);\\n            \\n            travel(curr.left, sol, level + 1);\\n            travel(curr.right, sol, level + 1);\\n        }\\n    }\\n\\n1.  O(n) solution by using LinkedList along with ArrayList.  So insertion in the inner list and outer list are both O(1),\\n2.  Using DFS and creating new lists when needed.\\n\\nshould be quite straightforward.  any better answer?",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> zigzagLevelOrder(TreeNode root) \\n        {\\n            List<List<Integer>> sol = new ArrayList<>();\\n            travel(root, sol, 0);\\n            return sol;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 33904,
                "title": "java-double-stack-solution",
                "content": "    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n       TreeNode c=root;\\n       List<List<Integer>> ans =new ArrayList<List<Integer>>();\\n       if(c==null) return ans;\\n       Stack<TreeNode> s1=new Stack<TreeNode>();\\n       Stack<TreeNode> s2=new Stack<TreeNode>();\\n       s1.push(root);\\n       while(!s1.isEmpty()||!s2.isEmpty())\\n       {\\n           List<Integer> tmp=new ArrayList<Integer>();\\n            while(!s1.isEmpty())\\n            {\\n                c=s1.pop();\\n                tmp.add(c.val);\\n                if(c.left!=null) s2.push(c.left);\\n                if(c.right!=null) s2.push(c.right);\\n            }\\n            ans.add(tmp);\\n            tmp=new ArrayList<Integer>();\\n            while(!s2.isEmpty())\\n            {\\n                c=s2.pop();\\n                tmp.add(c.val);\\n                if(c.right!=null)s1.push(c.right);\\n                if(c.left!=null)s1.push(c.left);\\n            }\\n            if(!tmp.isEmpty()) ans.add(tmp);\\n       }\\n       return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n       TreeNode c=root;\\n       List<List<Integer>> ans =new ArrayList<List<Integer>>();\\n       if(c==null) return ans;\\n       Stack<TreeNode> s1=new Stack<TreeNode>();\\n       Stack<TreeNode> s2=new Stack<TreeNode>();\\n       s1.push(root);\\n       while(!s1.isEmpty()||!s2.isEmpty())\\n       {\\n           List<Integer> tmp=new ArrayList<Integer>();\\n            while(!s1.isEmpty())\\n            {\\n                c=s1.pop();\\n                tmp.add(c.val);\\n                if(c.left!=null) s2.push(c.left);\\n                if(c.right!=null) s2.push(c.right);\\n            }\\n            ans.add(tmp);\\n            tmp=new ArrayList<Integer>();\\n            while(!s2.isEmpty())\\n            {\\n                c=s2.pop();\\n                tmp.add(c.val);\\n                if(c.right!=null)s1.push(c.right);\\n                if(c.left!=null)s1.push(c.left);\\n            }\\n            if(!tmp.isEmpty()) ans.add(tmp);\\n       }\\n       return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 174644,
                "title": "c-easy-to-understand-one-approach-to-solve-zigzag-level-order-traversal",
                "content": "This approch can be used to solve both level order traversal & zig zag traversal.\\nIt\\'s easy to start with the level order traversal. I hope the comments are clear.\\n\\n```\\nvector<vector<int>> levelOrder(TreeNode* root) {\\n        if (!root) return {}; // return if root is null\\n        queue<TreeNode*> q;\\n        q.push(root); //push the root node.\\n        vector<vector<int>> out; //result vector\\n      \\n\\t\\t /*\\n\\t\\t * Idea is to create a vector for every level based on the queue size.\\n\\t\\t * eg: if a level has four elements say 1, 2, 3, 4 -> Then create a vector of size 4.\\n\\t\\t * \\n\\t\\t * note: size of the queue is computed before the loop, so that we don\\'t consider \\n\\t\\t * newly pushed elements.\\n\\t\\t */\\n\\t\\t \\n        while (!q.empty()) {\\n            \\n            int sz = q.size(); /* current queue size */\\n            vector<int> curr(sz); /* vector of size sz */\\n\\t\\t\\t\\t\\t\\t\\n            for (int i = 0; i < sz; i++) {\\n                TreeNode* tmp = q.front();\\n                q.pop();\\n                curr[i] = tmp->val; /* insert to the correct index */\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* Add the left & right nodes to the queue in the loop. */\\n                if (tmp->left) q.push(tmp->left);\\n                if (tmp->right) q.push(tmp->right);\\n            }\\n            out.push_back(curr); /* once the level is done, push the vector to output vector. */\\n        }\\n        return out;\\n    }\\n```\\n\\nThe same idea can be extended to zig-zag traversal. The only difference would be, if we are on an even level (say second level)** insert into the vector from end. Odd levels insert from beginning.**\\n```\\n\\nvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        \\n        if (!root) return {};\\n        \\n        queue<TreeNode*> q;\\n        vector<vector<int>> out;\\n            \\n        q.push(root);  \\n        int level = 0; /* to alternate levels, or a bool variable */\\n        \\n        while (!q.empty()) {\\n            \\n            int sz = q.size();  \\n            vector<int> curr(sz); \\n            \\n            for (int i = 0; i < sz; i++) {\\n                \\n                TreeNode* tmp = q.front();\\n                q.pop();\\n                \\n                if (level == 0) {\\n                    curr[i] = tmp->val; // odd level, insert like 0, 1, 2, 3 etc. \\n                } else {\\n                    curr[sz - i - 1] = tmp->val; /* even level insert from end. 3, 2, 1, 0. (sz - i - 1) to get the index from end */\\n                }\\n                \\n                if (tmp->left) q.push(tmp->left);\\n                if (tmp->right) q.push(tmp->right);\\n            }\\n            out.push_back(curr); // now push the level traversed to output vector\\n            level = !level; // toggle the level using negation. or level == 0 ? level = 1 : level = 0;\\n        }\\n        return out;\\n```\\n\\nThank you for reading. Please let me your comments/feedback.",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nvector<vector<int>> levelOrder(TreeNode* root) {\\n        if (!root) return {}; // return if root is null\\n        queue<TreeNode*> q;\\n        q.push(root); //push the root node.\\n        vector<vector<int>> out; //result vector\\n      \\n\\t\\t /*\\n\\t\\t * Idea is to create a vector for every level based on the queue size.\\n\\t\\t * eg: if a level has four elements say 1, 2, 3, 4 -> Then create a vector of size 4.\\n\\t\\t * \\n\\t\\t * note: size of the queue is computed before the loop, so that we don\\'t consider \\n\\t\\t * newly pushed elements.\\n\\t\\t */\\n\\t\\t \\n        while (!q.empty()) {\\n            \\n            int sz = q.size(); /* current queue size */\\n            vector<int> curr(sz); /* vector of size sz */\\n\\t\\t\\t\\t\\t\\t\\n            for (int i = 0; i < sz; i++) {\\n                TreeNode* tmp = q.front();\\n                q.pop();\\n                curr[i] = tmp->val; /* insert to the correct index */\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* Add the left & right nodes to the queue in the loop. */\\n                if (tmp->left) q.push(tmp->left);\\n                if (tmp->right) q.push(tmp->right);\\n            }\\n            out.push_back(curr); /* once the level is done, push the vector to output vector. */\\n        }\\n        return out;\\n    }\\n```\n```\\n\\nvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        \\n        if (!root) return {};\\n        \\n        queue<TreeNode*> q;\\n        vector<vector<int>> out;\\n            \\n        q.push(root);  \\n        int level = 0; /* to alternate levels, or a bool variable */\\n        \\n        while (!q.empty()) {\\n            \\n            int sz = q.size();  \\n            vector<int> curr(sz); \\n            \\n            for (int i = 0; i < sz; i++) {\\n                \\n                TreeNode* tmp = q.front();\\n                q.pop();\\n                \\n                if (level == 0) {\\n                    curr[i] = tmp->val; // odd level, insert like 0, 1, 2, 3 etc. \\n                } else {\\n                    curr[sz - i - 1] = tmp->val; /* even level insert from end. 3, 2, 1, 0. (sz - i - 1) to get the index from end */\\n                }\\n                \\n                if (tmp->left) q.push(tmp->left);\\n                if (tmp->right) q.push(tmp->right);\\n            }\\n            out.push_back(curr); // now push the level traversed to output vector\\n            level = !level; // toggle the level using negation. or level == 0 ? level = 1 : level = 0;\\n        }\\n        return out;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 749036,
                "title": "python-clean-bfs-solution-explained",
                "content": "In this problem we need to traverse binary tree level by level. When we see levels in binary tree, we need to think about **bfs**, because it is its logic: it first traverse all neighbors, before we go deeper. Here we also need to change direction on each level as well. So, algorithm is the following:\\n\\n1. We create **queue**, where we first put our root.\\n2. `result` is to keep final result and `direction`, equal to `1` or `-1` is direction of traverse.\\n3. Then we start to traverse level by level: if we have `k` elements in queue currently, we remove them all and put their children instead. We continue to do this until our queue is empty. Meanwile we form `level` list and then add it to `result`, using correct direction and change direction after.\\n\\n**Complexity**: time complexity is `O(n)`, where `n` is number of nodes in our binary tree. Space complexity is also `O(n)`, because our `result` has this size in the end. If we do not count output as additional space, then it will be `O(w)`, where `w` is width of tree. It can be reduces to `O(1)` I think if we traverse levels in different order directly, but it is just not worth it.\\n\\n```\\nclass Solution:\\n    def zigzagLevelOrder(self, root):\\n        if not root: return []\\n        queue = deque([root])\\n        result, direction = [], 1\\n        \\n        while queue:\\n            level = []\\n            for i in range(len(queue)):\\n                node = queue.popleft()\\n                level.append(node.val)\\n                if node.left:  queue.append(node.left)\\n                if node.right: queue.append(node.right)\\n            result.append(level[::direction])\\n            direction *= (-1)\\n        return result\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root):\\n        if not root: return []\\n        queue = deque([root])\\n        result, direction = [], 1\\n        \\n        while queue:\\n            level = []\\n            for i in range(len(queue)):\\n                node = queue.popleft()\\n                level.append(node.val)\\n                if node.left:  queue.append(node.left)\\n                if node.right: queue.append(node.right)\\n            result.append(level[::direction])\\n            direction *= (-1)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33814,
                "title": "a-concise-and-easy-understanding-java-solution",
                "content": "public class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(root == null) return res;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        boolean order = true;\\n        int size = 1;\\n\\n        while(!q.isEmpty()) {\\n            List<Integer> tmp = new ArrayList<>();\\n            for(int i = 0; i < size; ++i) {\\n                TreeNode n = q.poll();\\n                if(order) {\\n                    tmp.add(n.val);\\n                } else {\\n                    tmp.add(0, n.val);\\n                }\\n                if(n.left != null) q.add(n.left);\\n                if(n.right != null) q.add(n.right);\\n            }\\n            res.add(tmp);\\n            size = q.size();\\n            order = order ? false : true;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(root == null) return res;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        boolean order = true;\\n        int size = 1;\\n\\n        while(!q.isEmpty()) {\\n            List<Integer> tmp = new ArrayList<>();\\n            for(int i = 0; i < size; ++i) {\\n                TreeNode n = q.poll();\\n                if(order) {\\n                    tmp.add(n.val);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 33834,
                "title": "python-simple-bfs",
                "content": "Simple straightforward solution using flag to decide whether from left to right or from right to left\\n\\n    class Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root: return []\\n        res, temp, stack, flag=[], [], [root], 1\\n        while stack:\\n            for i in xrange(len(stack)):\\n                node=stack.pop(0)\\n                temp+=[node.val]\\n                if node.left: stack+=[node.left]\\n                if node.right: stack+=[node.right]\\n            res+=[temp[::flag]]\\n            temp=[]\\n            flag*=-1\\n        return res",
                "solutionTags": [],
                "code": "Simple straightforward solution using flag to decide whether from left to right or from right to left\\n\\n    class Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root: return []\\n        res, temp, stack, flag=[], [], [root], 1\\n        while stack:\\n            for i in xrange(len(stack)):\\n                node=stack.pop(0)\\n                temp+=[node.val]\\n                if node.left: stack+=[node.left]\\n                if node.right: stack+=[node.right]\\n            res+=[temp[::flag]]\\n            temp=[]\\n            flag*=-1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 33931,
                "title": "clear-iterative-solution-with-deque-no-reverse",
                "content": " for zig, pop_back, push_front, left then right, \\n\\n for zag, pop_front, push_back, right then left\\n\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> res;\\n        if(!root) return res;\\n        std::deque<TreeNode*> deq;\\n        deq.push_back(root);\\n        int iszig=1;\\n        while(!deq.empty()) {\\n            int sz=deq.size();\\n            iszig=iszig^1;\\n            vector<int> row;\\n            while(sz--) {\\n                if(iszig) { // pop_front, push_back, right then left\\n                    root=deq.front();deq.pop_front();\\n                    row.push_back(root->val);\\n                    if(root->right) deq.push_back(root->right);\\n                    if(root->left) deq.push_back(root->left);\\n                }\\n                else { // pop_back, push_front, left then right\\n                    root=deq.back();deq.pop_back();\\n                    row.push_back(root->val);\\n                    if(root->left) deq.push_front(root->left);\\n                    if(root->right) deq.push_front(root->right);\\n                }\\n            }\\n            res.push_back(row);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": " for zig, pop_back, push_front, left then right, \\n\\n for zag, pop_front, push_back, right then left\\n\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> res;\\n        if(!root) return res;\\n        std::deque<TreeNode*> deq;\\n        deq.push_back(root);\\n        int iszig=1;\\n        while(!deq.empty()) {\\n            int sz=deq.size();\\n            iszig=iszig^1;\\n            vector<int> row;\\n            while(sz--) {\\n                if(iszig) { // pop_front, push_back, right then left\\n                    root=deq.front();deq.pop_front();\\n                    row.push_back(root->val);\\n                    if(root->right) deq.push_back(root->right);\\n                    if(root->left) deq.push_back(root->left);\\n                }\\n                else { // pop_back, push_front, left then right\\n                    root=deq.back();deq.pop_back();\\n                    row.push_back(root->val);\\n                    if(root->left) deq.push_front(root->left);\\n                    if(root->right) deq.push_front(root->right);\\n                }\\n            }\\n            res.push_back(row);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33832,
                "title": "8-liner-python",
                "content": "```\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res, level, direction = [], [root], 1\\n        while level:\\n            res.append([n.val for n in level][::direction])\\n            direction *= -1\\n            level = [kid for node in level for kid in (node.left, node.right) if kid]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res, level, direction = [], [root], 1\\n        while level:\\n            res.append([n.val for n in level][::direction])\\n            direction *= -1\\n            level = [kid for node in level for kid in (node.left, node.right) if kid]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113532,
                "title": "two-simple-approaches-o-n",
                "content": "**1.)Recursion:** After doing level order traversal using recursion, we simply reverse the vectors at alternate levels\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode*root,vector<vector<int>>&res,int level)\\n    {\\n        if(!root) return;   \\n        if(level>=res.size())\\n            res.push_back({});\\n        res[level].push_back(root->val);\\n        helper(root->left,res,level+1);\\n        helper(root->right,res,level+1);\\n    }\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>res;\\n        if(!root)   return res;\\n        helper(root,res,0); \\n        for(int i=1;i<res.size();i=i+2)\\n        {\\n            reverse(res[i].begin(),res[i].end());\\n        }\\n        return res;\\n    }\\n};\\n```\\n*Runtime:0ms\\nSpace: O(n) for res vector\\nTime:O(n)*\\n\\n**2.)Using queue(BFS):**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>res;\\n        if(!root)   return res;\\n        vector<int>row;\\n        queue<TreeNode*>q;\\n        int x=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode*root=q.front();\\n                q.pop();\\n                row.push_back(root->val);\\n                if(root->left!=NULL)\\n                    q.push(root->left);\\n                if(root->right!=NULL)\\n                    q.push(root->right);\\n            }\\n            if(x%2==0)\\n                res.push_back(row);\\n            else\\n            {\\n                reverse(row.begin(),row.end());\\n                res.push_back(row);\\n            }\\n            row.clear();\\n            x+=1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n*Runtime:0ms\\nSpace:O(n)\\nTime:O(n)*\\n\\nI hope this helped!!\\nIf you like, please **UPVOTE**\\'\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode*root,vector<vector<int>>&res,int level)\\n    {\\n        if(!root) return;   \\n        if(level>=res.size())\\n            res.push_back({});\\n        res[level].push_back(root->val);\\n        helper(root->left,res,level+1);\\n        helper(root->right,res,level+1);\\n    }\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>res;\\n        if(!root)   return res;\\n        helper(root,res,0); \\n        for(int i=1;i<res.size();i=i+2)\\n        {\\n            reverse(res[i].begin(),res[i].end());\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>res;\\n        if(!root)   return res;\\n        vector<int>row;\\n        queue<TreeNode*>q;\\n        int x=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode*root=q.front();\\n                q.pop();\\n                row.push_back(root->val);\\n                if(root->left!=NULL)\\n                    q.push(root->left);\\n                if(root->right!=NULL)\\n                    q.push(root->right);\\n            }\\n            if(x%2==0)\\n                res.push_back(row);\\n            else\\n            {\\n                reverse(row.begin(),row.end());\\n                res.push_back(row);\\n            }\\n            row.clear();\\n            x+=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750132,
                "title": "four-python-solutions",
                "content": "#### Approach - 1\\nUsing single ended queue and reverse. Although we are using `deque` we are utilizing only single ended queue functionality here.\\n```python\\ndef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\tif not root: return []\\n\\tqueue = collections.deque([root])\\n\\tres = []\\n\\teven_level = False\\n\\twhile queue:\\n\\t\\tn = len(queue)\\n\\t\\tlevel = []\\n\\t\\tfor _ in range(n):\\n\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\tlevel.append(node.val)\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\tif node.right:\\n\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\tif even_level:\\n\\t\\t\\tres.append(level[::-1])\\n\\t\\telse:\\n\\t\\t\\tres.append(level)\\n\\t\\teven_level = not even_level\\n\\treturn res\\n```\\n\\n#### Appraoch - 2\\nUsing single ended queue and initializing array instead of reversing. \\n```python\\ndef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\tif not root: return []\\n\\tqueue = collections.deque([root])\\n\\tres = []\\n\\teven_level = False\\n\\twhile queue:\\n\\t\\tn = len(queue)\\n\\t\\tlevel = [0] * n # initalize the array since we know the length\\n\\t\\tfor i in range(n):\\n\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\tif node.right:\\n\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\t\\tif even_level:\\n\\t\\t\\t\\tlevel[n-1-i] = node.val\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlevel[i] = node.val\\n\\t\\tres.append(level)\\n\\t\\teven_level = not even_level\\n\\n\\treturn res\\n```\\n#### Approach - 3\\nUsing the double ended queue functionality. We pop from left in odd levels and pop from right in even levels. Trick is to flip the order of left and right when we are appending from left. \\n```python\\ndef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\tif not root: return []\\n\\tqueue = collections.deque([root])\\n\\tres = []\\n\\teven_level = False\\n\\twhile queue:\\n\\t\\tn = len(queue)\\n\\t\\tlevel = []\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif even_level:\\n\\t\\t\\t\\t# pop from right and append from left.\\n\\t\\t\\t\\tnode = queue.pop()\\n\\t\\t\\t\\t# to maintain the order of nodes in the format of [left, right, left, right] \\n\\t\\t\\t\\t# we push right first since we are appending from left\\n\\t\\t\\t\\tif node.right: queue.appendleft(node.right)\\n\\t\\t\\t\\tif node.left: queue.appendleft(node.left)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# pop from left and append from right\\n\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\t# here the order is maintained in the format [left, right, left, right] \\n\\t\\t\\t\\tif node.left: queue.append(node.left)\\n\\t\\t\\t\\tif node.right: queue.append(node.right)\\n\\t\\t\\tlevel.append(node.val)\\n\\t\\tres.append(level)\\n\\t\\teven_level = not even_level\\n\\treturn res\\n```\\n\\n#### Approach - 4\\nUsing deque for each level instead of list.\\n```python\\ndef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n    if not root: return []\\n    res = []\\n    queue = collections.deque([root])\\n    even_level = False\\n    while queue:\\n        n = len(queue)\\n        level = collections.deque()\\n        for _ in range(n):\\n            node = queue.popleft()\\n            if even_level:\\n                level.appendleft(node.val)\\n            else:\\n                level.append(node.val)\\n            if node.left:\\n                queue.append(node.left)\\n            if node.right:\\n                queue.append(node.right)\\n        res.append(list(level))\\n        even_level = not even_level\\n    return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```python\\ndef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\tif not root: return []\\n\\tqueue = collections.deque([root])\\n\\tres = []\\n\\teven_level = False\\n\\twhile queue:\\n\\t\\tn = len(queue)\\n\\t\\tlevel = []\\n\\t\\tfor _ in range(n):\\n\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\tlevel.append(node.val)\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\tif node.right:\\n\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\tif even_level:\\n\\t\\t\\tres.append(level[::-1])\\n\\t\\telse:\\n\\t\\t\\tres.append(level)\\n\\t\\teven_level = not even_level\\n\\treturn res\\n```\n```python\\ndef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\tif not root: return []\\n\\tqueue = collections.deque([root])\\n\\tres = []\\n\\teven_level = False\\n\\twhile queue:\\n\\t\\tn = len(queue)\\n\\t\\tlevel = [0] * n # initalize the array since we know the length\\n\\t\\tfor i in range(n):\\n\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\tif node.right:\\n\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\t\\tif even_level:\\n\\t\\t\\t\\tlevel[n-1-i] = node.val\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlevel[i] = node.val\\n\\t\\tres.append(level)\\n\\t\\teven_level = not even_level\\n\\n\\treturn res\\n```\n```python\\ndef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\tif not root: return []\\n\\tqueue = collections.deque([root])\\n\\tres = []\\n\\teven_level = False\\n\\twhile queue:\\n\\t\\tn = len(queue)\\n\\t\\tlevel = []\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif even_level:\\n\\t\\t\\t\\t# pop from right and append from left.\\n\\t\\t\\t\\tnode = queue.pop()\\n\\t\\t\\t\\t# to maintain the order of nodes in the format of [left, right, left, right] \\n\\t\\t\\t\\t# we push right first since we are appending from left\\n\\t\\t\\t\\tif node.right: queue.appendleft(node.right)\\n\\t\\t\\t\\tif node.left: queue.appendleft(node.left)\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# pop from left and append from right\\n\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\t# here the order is maintained in the format [left, right, left, right] \\n\\t\\t\\t\\tif node.left: queue.append(node.left)\\n\\t\\t\\t\\tif node.right: queue.append(node.right)\\n\\t\\t\\tlevel.append(node.val)\\n\\t\\tres.append(level)\\n\\t\\teven_level = not even_level\\n\\treturn res\\n```\n```python\\ndef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n    if not root: return []\\n    res = []\\n    queue = collections.deque([root])\\n    even_level = False\\n    while queue:\\n        n = len(queue)\\n        level = collections.deque()\\n        for _ in range(n):\\n            node = queue.popleft()\\n            if even_level:\\n                level.appendleft(node.val)\\n            else:\\n                level.append(node.val)\\n            if node.left:\\n                queue.append(node.left)\\n            if node.right:\\n                queue.append(node.right)\\n        res.append(list(level))\\n        even_level = not even_level\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3198360,
                "title": "c-level-order-traversal-beats-100-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo Do Simple Level order but alternately revrse the elemnts of level.\\n- Either we can  reverse the vector storing the elemnts f that level\\n- Or we just insert from last index so that it will be in reverse order itself.(More Efficient)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Level Order Traversal: For More Understanding  [Refer Here](https://leetcode.com/problems/binary-tree-level-order-traversal/solutions/3196962/c-bfs-dfs-on-explained/)\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Level Order Traversal by Reversing vector alternately**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(!root)return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int i=0;\\n        while(!q.empty()){\\n           int sz=q.size();\\n           vector<int>v;\\n           while(sz--){\\n               TreeNode * f=q.front();\\n               v.push_back(q.front()->val);\\n               q.pop();\\n               if(f->left)q.push(f->left);\\n               if(f->right)q.push(f->right);\\n\\n           }\\n           if(i++%2)\\n           reverse(v.begin(),v.end());\\n           ans.push_back(v);\\n\\n        }\\n        return ans;\\n    \\n    }\\n};\\n```\\n**More Optimized Level Order Wihtout Reversing Vector**\\n```\\nvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(!root)return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int i=0;\\n        while(!q.empty()){\\n           int sz=q.size();\\n           vector<int>v(sz);\\n           int j=0,n=sz;\\n           while(sz--){\\n               TreeNode * f=q.front();\\n               q.pop();\\n               if(i%2==0)\\n               v[j]=f->val;\\n               else v[n-j-1]=f->val;\\n               j++;\\n               if(f->left)q.push(f->left);\\n               if(f->right)q.push(f->right);\\n           }\\n           i++;\\n           ans.push_back(v);\\n\\n        }\\n        return ans;\\n    \\n    }\\n```\\n# Upvote If Help full",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(!root)return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int i=0;\\n        while(!q.empty()){\\n           int sz=q.size();\\n           vector<int>v;\\n           while(sz--){\\n               TreeNode * f=q.front();\\n               v.push_back(q.front()->val);\\n               q.pop();\\n               if(f->left)q.push(f->left);\\n               if(f->right)q.push(f->right);\\n\\n           }\\n           if(i++%2)\\n           reverse(v.begin(),v.end());\\n           ans.push_back(v);\\n\\n        }\\n        return ans;\\n    \\n    }\\n};\\n```\n```\\nvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(!root)return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int i=0;\\n        while(!q.empty()){\\n           int sz=q.size();\\n           vector<int>v(sz);\\n           int j=0,n=sz;\\n           while(sz--){\\n               TreeNode * f=q.front();\\n               q.pop();\\n               if(i%2==0)\\n               v[j]=f->val;\\n               else v[n-j-1]=f->val;\\n               j++;\\n               if(f->left)q.push(f->left);\\n               if(f->right)q.push(f->right);\\n           }\\n           i++;\\n           ans.push_back(v);\\n\\n        }\\n        return ans;\\n    \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203450,
                "title": "simplest-solution-full-explanation-c-python3",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n# Intuition\\nIntuition of this problem is very simple.\\nWe use the **Level Order Traversal** of Binary tree.\\nFor the Zig Zag Movement we are using a variable `level` when it is **zero**  we **move from Left to Right** and when it is `one` we move from **Right to Left**.\\nFor Level order traversal I am using a **Queue**.\\nInitially we push `root` element in the queue. Traverse all elements of the tree.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : BFS, Level Order Traversal\\n    Example : `root` = [3,9,20,null,null,15,7]\\n\\n    Initially `queue` = [3], level = 0\\n    In first pass\\n        size = 1 `queue` = [3]\\n        `curr[0]` = 3\\n        We push 3->left and 3->right in queue\\n        `queue` = [9, 20]\\n        So our loop only run 1 time beacuase size is 1.\\n\\n    Now we push curr to `output` vector `output` = [[3]]\\n    Now `level` = 1\\n\\n    In Second pass\\n        size = 2 `queue` = [9, 20]\\n        `curr[1]` = 20\\n        `curr[0]` = 9\\n        We push 20->left and 20->right in queue\\n        `queue` = [15, 7]\\n        And 9->left = NULL , 9->right = NULL so we do not push it.\\n        So our loop run 2 times beacuase size is 2.\\n\\n    Now we push curr to `output` vector `output` = [[3], [20, 9]]\\n    Now `level` = 0\\n\\n    In this way me iterate for the 15 and 7.\\n    So answer is `[[3], [20, 9], [15, 7]]`\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(W) width of the tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        \\n        if (!root) return {};\\n        \\n        queue<TreeNode*> q;\\n        vector<vector<int>> out;\\n            \\n        q.push(root);  \\n        int level = 0; /* to alternate levels, or a bool variable */\\n        \\n        while (!q.empty()) {\\n            \\n            int sz = q.size();  \\n            vector<int> curr(sz); \\n            \\n            for (int i = 0; i < sz; i++) {\\n                \\n                TreeNode* tmp = q.front();\\n                q.pop();\\n                \\n                if (level == 0) {\\n                    curr[i] = tmp->val; // odd level, insert like 0, 1, 2, 3 etc. \\n                } else {\\n                    curr[sz - i - 1] = tmp->val; /* even level insert from end. 3, 2, 1, 0. (sz - i - 1) to get the index from end */\\n                }\\n                \\n                if (tmp->left) q.push(tmp->left);\\n                if (tmp->right) q.push(tmp->right);\\n            }\\n            out.push_back(curr); // now push the level traversed to output vector\\n            level = !level; // toggle the level using negation. or level == 0 ? level = 1 : level = 0;\\n        }\\n        return out;\\n    }\\n};\\n\\n```\\n```python []\\nfrom queue import Queue\\nclass Solution:\\n    def zigzagLevelOrder(self, A: TreeNode) -> List[List[int]]:\\n        if not A:\\n            return []\\n        queue = Queue()\\n        queue.put(A)\\n        output = []\\n        curr = []\\n        level = 0\\n        while not queue.empty():\\n            size = queue.qsize()\\n            curr = []\\n            for i in range(size):\\n                temp = queue.get()\\n                if level % 2 == 0:\\n                    curr.append(temp.val)\\n                else:\\n                    curr.insert(0, temp.val)\\n                if temp.left:\\n                    queue.put(temp.left)\\n                if temp.right:\\n                    queue.put(temp.right)\\n            level = not level\\n            output.append(curr)\\n        return output\\n```\\n```\\n                    Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        \\n        if (!root) return {};\\n        \\n        queue<TreeNode*> q;\\n        vector<vector<int>> out;\\n            \\n        q.push(root);  \\n        int level = 0; /* to alternate levels, or a bool variable */\\n        \\n        while (!q.empty()) {\\n            \\n            int sz = q.size();  \\n            vector<int> curr(sz); \\n            \\n            for (int i = 0; i < sz; i++) {\\n                \\n                TreeNode* tmp = q.front();\\n                q.pop();\\n                \\n                if (level == 0) {\\n                    curr[i] = tmp->val; // odd level, insert like 0, 1, 2, 3 etc. \\n                } else {\\n                    curr[sz - i - 1] = tmp->val; /* even level insert from end. 3, 2, 1, 0. (sz - i - 1) to get the index from end */\\n                }\\n                \\n                if (tmp->left) q.push(tmp->left);\\n                if (tmp->right) q.push(tmp->right);\\n            }\\n            out.push_back(curr); // now push the level traversed to output vector\\n            level = !level; // toggle the level using negation. or level == 0 ? level = 1 : level = 0;\\n        }\\n        return out;\\n    }\\n};\\n\\n```\n```python []\\nfrom queue import Queue\\nclass Solution:\\n    def zigzagLevelOrder(self, A: TreeNode) -> List[List[int]]:\\n        if not A:\\n            return []\\n        queue = Queue()\\n        queue.put(A)\\n        output = []\\n        curr = []\\n        level = 0\\n        while not queue.empty():\\n            size = queue.qsize()\\n            curr = []\\n            for i in range(size):\\n                temp = queue.get()\\n                if level % 2 == 0:\\n                    curr.append(temp.val)\\n                else:\\n                    curr.insert(0, temp.val)\\n                if temp.left:\\n                    queue.put(temp.left)\\n                if temp.right:\\n                    queue.put(temp.right)\\n            level = not level\\n            output.append(curr)\\n        return output\\n```\n```\\n                    Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34049,
                "title": "my-java-solution-beats-98",
                "content": "    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> res = new ArrayList();\\n        travel(res, 0, root);\\n        return res;\\n    }\\n    private void travel(List<List<Integer>> res, int level, TreeNode cur) {\\n        if (cur == null) return;\\n        if (res.size() <= level) {\\n            res.add(new ArrayList<Integer>());\\n        }\\n        if (level % 2 == 0) {\\n            res.get(level).add(cur.val);\\n        }   else {\\n            res.get(level).add(0, cur.val);\\n        }\\n        travel(res, level + 1, cur.left);\\n        travel(res, level + 1, cur.right);\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> res = new ArrayList();\\n        travel(res, 0, root);\\n        return res;\\n    }\\n    private void travel(List<List<Integer>> res, int level, TreeNode cur) {\\n        if (cur == null) return;\\n        if (res.size() <= level) {\\n            res.add(new ArrayList<Integer>());\\n        }\\n        if (level % 2 == 0) {\\n            res.get(level).add(cur.val);\\n        }   else {\\n            res.get(level).add(0, cur.val);\\n        }\\n        travel(res, level + 1, cur.left);\\n        travel(res, level + 1, cur.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 34033,
                "title": "java-iterative-and-recursive-solutions",
                "content": "        \\n    // bfs \\n    public List<List<Integer>> zigzagLevelOrder1(TreeNode root) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int l = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> level = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                if (node != null) {\\n                    level.add(node.val);\\n                    queue.add(node.left);\\n                    queue.add(node.right);\\n                }\\n            }\\n            if (!level.isEmpty()) {\\n                if (l % 2 == 1) {\\n                    Collections.reverse(level);\\n                }\\n                ret.add(level);\\n            }\\n            l++;\\n        }\\n        return ret;\\n     }\\n     \\n     // dfs recursively\\n     public List<List<Integer>> zigzagLevelOrder2(TreeNode root) {\\n         List<List<Integer>> ret = new ArrayList<>();\\n         dfs(root, 0, ret);\\n         return ret;\\n     }\\n     \\n     private void dfs(TreeNode node, int l, List<List<Integer>> ret) {\\n         if (node != null) {\\n             if (l == ret.size()) {\\n                 List<Integer> level = new ArrayList<>();\\n                 ret.add(level);\\n             }\\n             if (l % 2 == 1) {\\n                ret.get(l).add(0, node.val);  // insert at the beginning\\n             } else {\\n                ret.get(l).add(node.val);\\n             }\\n             dfs(node.left, l+1, ret);\\n             dfs(node.right, l+1, ret);\\n         }\\n     }\\n     \\n     // dfs iteratively\\n     // import javafx.util.Pair;\\n     public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n         List<List<Integer>> ret = new ArrayList<>();\\n         Deque<Pair<TreeNode, Integer>> stack = new LinkedList<>();\\n         stack.push(new Pair(root, 0));\\n         while (!stack.isEmpty()) {\\n             Pair<TreeNode, Integer> p = stack.pop();\\n             TreeNode node = p.getKey();\\n             int l = p.getValue();\\n             if (node != null) {\\n                if (l == ret.size()) {\\n                    ret.add(new ArrayList<>());\\n                }\\n                if (l % 2 == 1) {\\n                    ret.get(l).add(0, node.val);\\n                } else {\\n                    ret.get(l).add(node.val);\\n                }\\n                stack.push(new Pair(node.right, l+1));\\n                stack.push(new Pair(node.left, l+1));\\n             }\\n         }\\n         return ret;\\n     }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "        \\n    // bfs \\n    public List<List<Integer>> zigzagLevelOrder1(TreeNode root) {\\n        List<List<Integer>> ret = new ArrayList<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int l = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> level = new ArrayList<>();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                if (node != null) {\\n                    level.add(node.val);\\n                    queue.add(node.left);\\n                    queue.add(node.right);\\n                }\\n            }\\n            if (!level.isEmpty()) {\\n                if (l % 2 == 1) {\\n                    Collections.reverse(level);\\n                }\\n                ret.add(level);\\n            }\\n            l++;\\n        }\\n        return ret;\\n     }\\n     \\n     // dfs recursively\\n     public List<List<Integer>> zigzagLevelOrder2(TreeNode root) {\\n         List<List<Integer>> ret = new ArrayList<>();\\n         dfs(root, 0, ret);\\n         return ret;\\n     }\\n     \\n     private void dfs(TreeNode node, int l, List<List<Integer>> ret) {\\n         if (node != null) {\\n             if (l == ret.size()) {\\n                 List<Integer> level = new ArrayList<>();\\n                 ret.add(level);\\n             }\\n             if (l % 2 == 1) {\\n                ret.get(l).add(0, node.val);  // insert at the beginning\\n             } else {\\n                ret.get(l).add(node.val);\\n             }\\n             dfs(node.left, l+1, ret);\\n             dfs(node.right, l+1, ret);\\n         }\\n     }\\n     \\n     // dfs iteratively\\n     // import javafx.util.Pair;\\n     public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n         List<List<Integer>> ret = new ArrayList<>();\\n         Deque<Pair<TreeNode, Integer>> stack = new LinkedList<>();\\n         stack.push(new Pair(root, 0));\\n         while (!stack.isEmpty()) {\\n             Pair<TreeNode, Integer> p = stack.pop();\\n             TreeNode node = p.getKey();\\n             int l = p.getValue();\\n             if (node != null) {\\n                if (l == ret.size()) {\\n                    ret.add(new ArrayList<>());\\n                }\\n                if (l % 2 == 1) {\\n                    ret.get(l).add(0, node.val);\\n                } else {\\n                    ret.get(l).add(node.val);\\n                }\\n                stack.push(new Pair(node.right, l+1));\\n                stack.push(new Pair(node.left, l+1));\\n             }\\n         }\\n         return ret;\\n     }",
                "codeTag": "Python3"
            },
            {
                "id": 132982,
                "title": "javascript-solution",
                "content": "```\\nconst zigzagLevelOrder = (root) => {\\n  let res = [];\\n\\n  const go = (node, lvl) => {\\n    if (node == null) return;\\n    if (res[lvl] == null) res[lvl] = [];\\n\\n    if (lvl % 2 === 0) {\\n      res[lvl].push(node.val);\\n    } else {\\n      res[lvl].unshift(node.val);\\n    }\\n\\n    go(node.left, lvl + 1);\\n    go(node.right, lvl + 1);\\n  };\\n\\n  go(root, 0);\\n  return res;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst zigzagLevelOrder = (root) => {\\n  let res = [];\\n\\n  const go = (node, lvl) => {\\n    if (node == null) return;\\n    if (res[lvl] == null) res[lvl] = [];\\n\\n    if (lvl % 2 === 0) {\\n      res[lvl].push(node.val);\\n    } else {\\n      res[lvl].unshift(node.val);\\n    }\\n\\n    go(node.left, lvl + 1);\\n    go(node.right, lvl + 1);\\n  };\\n\\n  go(root, 0);\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 34152,
                "title": "short-and-clear-python-code",
                "content": "    class Solution:\\n    # @param root, a tree node\\n    # @return a list of lists of integers\\n    def zigzagLevelOrder(self, root):\\n        queue = collections.deque([root])\\n        res = []\\n        while queue:\\n            r = []\\n            for _ in range(len(queue)):\\n                q = queue.popleft()\\n                if q:\\n                    r.append(q.val)\\n                    queue.append(q.left)\\n                    queue.append(q.right)\\n            r = r[::-1] if len(res) % 2 else r\\n            if r:\\n                res.append(r)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param root, a tree node\\n    # @return a list of lists of integers\\n    def zigzagLevelOrder(self, root):\\n        queue = collections.deque([root])\\n        res = []\\n        while queue:\\n            r = []\\n            for _ in range(len(queue)):\\n                q = queue.popleft()\\n                if q:\\n                    r.append(q.val)\\n                    queue.append(q.left)\\n                    queue.append(q.right)\\n            r = r[::-1] if len(res) % 2 else r\\n            if r:\\n                res.append(r)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3204462,
                "title": "java-solution",
                "content": "# Code\\n``` JAVA []\\npublic class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) \\n    {\\n        List<List<Integer>> sol = new ArrayList<>();\\n        travel(root, sol, 0);\\n        return sol;\\n    }\\n    \\n    private void travel(TreeNode curr, List<List<Integer>> sol, int level)\\n    {\\n        if(curr == null) return;\\n        \\n        if(sol.size() <= level)\\n        {\\n            List<Integer> newLevel = new LinkedList<>();\\n            sol.add(newLevel);\\n        }\\n        \\n        List<Integer> collection  = sol.get(level);\\n        if(level % 2 == 0) collection.add(curr.val);\\n        else collection.add(0, curr.val);\\n        \\n        travel(curr.left, sol, level + 1);\\n        travel(curr.right, sol, level + 1);\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/4b501662-d825-408e-b0c1-dae2ae5b2132_1676786757.2180564.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\npublic class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) \\n    {\\n        List<List<Integer>> sol = new ArrayList<>();\\n        travel(root, sol, 0);\\n        return sol;\\n    }\\n    \\n    private void travel(TreeNode curr, List<List<Integer>> sol, int level)\\n    {\\n        if(curr == null) return;\\n        \\n        if(sol.size() <= level)\\n        {\\n            List<Integer> newLevel = new LinkedList<>();\\n            sol.add(newLevel);\\n        }\\n        \\n        List<Integer> collection  = sol.get(level);\\n        if(level % 2 == 0) collection.add(curr.val);\\n        else collection.add(0, curr.val);\\n        \\n        travel(curr.left, sol, level + 1);\\n        travel(curr.right, sol, level + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33840,
                "title": "two-stacks-javascript-solution",
                "content": "We can easily solve this problem using two stacks. The first stack `s1` is used to traverse the current level of the tree, and the second stack `s2` is used to track the nodes in the next level. Also, we need to have a `flag` to indicate the traversal direction has been flipped when the current level has been traversed completely.\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {number[][]}\\n */\\nvar zigzagLevelOrder = function(root) {\\n    if (!root) return []; // Sanity check\\n    \\n    var result = [], level = [], s1 = [root], s2 = [], flag = true;\\n    \\n    while (s1.length > 0) {\\n        var node = s1.pop(), left = node.left, right = node.right;\\n\\n        // Handle the current node\\n        level.push(node.val);\\n\\n        // Get ready for the next level\\n        // the key of zigzag traversal is to control the order of pushing\\n        // left and right sub children\\n        if (flag) {\\n            if (left)  s2.push(left);\\n            if (right) s2.push(right);\\n        } else {\\n            if (right) s2.push(right);\\n            if (left)  s2.push(left);\\n        }\\n        \\n        // We just finish traversing the current level\\n        if (s1.length === 0) {\\n            result.push(level);\\n            level = [];\\n            flag = !flag;\\n            // Continue to traverse the next level\\n            s1 = s2;\\n            s2 = [];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\n\\nTime complexity: `O(n)`\\nSpace complexity: The max width of the tree",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {number[][]}\\n */\\nvar zigzagLevelOrder = function(root) {\\n    if (!root) return []; // Sanity check\\n    \\n    var result = [], level = [], s1 = [root], s2 = [], flag = true;\\n    \\n    while (s1.length > 0) {\\n        var node = s1.pop(), left = node.left, right = node.right;\\n\\n        // Handle the current node\\n        level.push(node.val);\\n\\n        // Get ready for the next level\\n        // the key of zigzag traversal is to control the order of pushing\\n        // left and right sub children\\n        if (flag) {\\n            if (left)  s2.push(left);\\n            if (right) s2.push(right);\\n        } else {\\n            if (right) s2.push(right);\\n            if (left)  s2.push(left);\\n        }\\n        \\n        // We just finish traversing the current level\\n        if (s1.length === 0) {\\n            result.push(level);\\n            level = [];\\n            flag = !flag;\\n            // Continue to traverse the next level\\n            s1 = s2;\\n            s2 = [];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796879,
                "title": "clean-c-solution-using-two-stacks-1-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        \\n        stack<TreeNode*> LtoR, RtoL;\\n        int lvl = 1;\\n        \\n        vector<vector<int>> ans;\\n        \\n        if(!root) return ans;\\n\\n        RtoL.push(root);\\n\\n        while(!RtoL.empty() || !LtoR.empty()) {\\n            \\n            vector<int> v;\\n            \\n            if(lvl % 2 == 1) {\\n                                \\n                while(!RtoL.empty()) {\\n\\n                    TreeNode* curr = RtoL.top();\\n                    RtoL.pop();\\n                    v.push_back(curr -> val);\\n\\n                    if(curr -> left) LtoR.push(curr -> left);\\n                    if(curr -> right) LtoR.push(curr -> right);        \\n                }   \\n\\n            } else {\\n                \\n                while(!LtoR.empty()) {\\n\\n                    TreeNode *curr = LtoR.top();\\n                    LtoR.pop();\\n                    v.push_back(curr -> val);\\n\\n                    if(curr -> right) RtoL.push(curr -> right);\\n                    if(curr -> left) RtoL.push(curr -> left);                \\n                } \\n            }\\n            \\n            ans.push_back(v);\\n            lvl++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        \\n        stack<TreeNode*> LtoR, RtoL;\\n        int lvl = 1;\\n        \\n        vector<vector<int>> ans;\\n        \\n        if(!root) return ans;\\n\\n        RtoL.push(root);\\n\\n        while(!RtoL.empty() || !LtoR.empty()) {\\n            \\n            vector<int> v;\\n            \\n            if(lvl % 2 == 1) {\\n                                \\n                while(!RtoL.empty()) {\\n\\n                    TreeNode* curr = RtoL.top();\\n                    RtoL.pop();\\n                    v.push_back(curr -> val);\\n\\n                    if(curr -> left) LtoR.push(curr -> left);\\n                    if(curr -> right) LtoR.push(curr -> right);        \\n                }   \\n\\n            } else {\\n                \\n                while(!LtoR.empty()) {\\n\\n                    TreeNode *curr = LtoR.top();\\n                    LtoR.pop();\\n                    v.push_back(curr -> val);\\n\\n                    if(curr -> right) RtoL.push(curr -> right);\\n                    if(curr -> left) RtoL.push(curr -> left);                \\n                } \\n            }\\n            \\n            ans.push_back(v);\\n            lvl++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580306,
                "title": "javascript-bfs",
                "content": "Its a standard BFS with but the difference is we are keeping track of the depth at each level and that\\'s determines  if were adding to the front of the level array or the back of the level array. \\n\\n```\\nvar zigzagLevelOrder = function(root) {\\n  if(!root) return [];\\n  let queue = [root];\\n  let output = [];\\n  let deep = 0;\\n  while(queue.length > 0){\\n    const size = queue.length;\\n    const level = [];\\n    \\n    for(let i=0; i< size; i++){\\n      const node = queue.shift();\\n      if(deep % 2 == 0) level.push(node.val);\\n      else level.unshift(node.val);\\n      \\n      if(node.left) queue.push(node.left)\\n      if(node.right) queue.push(node.right)\\n    }\\n    output.push(level)\\n    deep++;\\n  }\\n  \\n  \\n  return output\\n  \\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar zigzagLevelOrder = function(root) {\\n  if(!root) return [];\\n  let queue = [root];\\n  let output = [];\\n  let deep = 0;\\n  while(queue.length > 0){\\n    const size = queue.length;\\n    const level = [];\\n    \\n    for(let i=0; i< size; i++){\\n      const node = queue.shift();\\n      if(deep % 2 == 0) level.push(node.val);\\n      else level.unshift(node.val);\\n      \\n      if(node.left) queue.push(node.left)\\n      if(node.right) queue.push(node.right)\\n    }\\n    output.push(level)\\n    deep++;\\n  }\\n  \\n  \\n  return output\\n  \\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 33833,
                "title": "simple-and-clear-python-solution-with-explain",
                "content": "I use a additional function addLevel to record the level number of nodes, then according to the level number, I can easily deal with the level order, see the code for details\\n\\n    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @return a list of lists of integers\\n        def zigzagLevelOrder(self, root):\\n            ans = []\\n            self.addLevel(ans, 0, root)#level from 0\\n            return ans\\n            \\n            \\n        def addLevel(self, ans, level, root):\\n            if not root:\\n                return\\n            elif len(ans) <= level:\\n                    ans.append([root.val])\\n            elif not level%2:#if it is an even level, then then level ans should be inversed, so I use extend founction\\n                ans[level].extend([root.val])\\n            else:\\n                ans[level].insert(0,root.val)# if it is an odd level, then level ans should be ordinal, so I use insert function\\n            self.addLevel(ans, level + 1, root.left)\\n            self.addLevel(ans, level + 1, root.right)",
                "solutionTags": [
                    "Python"
                ],
                "code": "I use a additional function addLevel to record the level number of nodes, then according to the level number, I can easily deal with the level order, see the code for details\\n\\n    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @return a list of lists of integers\\n        def zigzagLevelOrder(self, root):\\n            ans = []\\n            self.addLevel(ans, 0, root)#level from 0\\n            return ans\\n            \\n            \\n        def addLevel(self, ans, level, root):\\n            if not root:\\n                return\\n            elif len(ans) <= level:\\n                    ans.append([root.val])\\n            elif not level%2:#if it is an even level, then then level ans should be inversed, so I use extend founction\\n                ans[level].extend([root.val])\\n            else:\\n                ans[level].insert(0,root.val)# if it is an odd level, then level ans should be ordinal, so I use insert function\\n            self.addLevel(ans, level + 1, root.left)\\n            self.addLevel(ans, level + 1, root.right)",
                "codeTag": "Java"
            },
            {
                "id": 965181,
                "title": "python-iterative-bfs-using-deque",
                "content": "With even or odd level, change the pop/append direction of the deque accordingly.\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        dq = deque([root])\\n        res = []\\n        lvl = 0\\n        while dq:\\n            size = len(dq)\\n            curr = []\\n            for i in range(size):\\n                if lvl % 2 == 0:\\n                    p = dq.popleft()\\n                    curr.append(p.val)\\n                    if p.left:\\n                        dq.append(p.left)\\n                    if p.right:\\n                        dq.append(p.right)\\n                else:\\n                    p = dq.pop()\\n                    curr.append(p.val)\\n                    if p.right:\\n                        dq.appendleft(p.right)\\n                    if p.left:\\n                        dq.appendleft(p.left)\\n            res.append(curr)\\n            lvl += 1\\n        return res\\n",
                "solutionTags": [],
                "code": "With even or odd level, change the pop/append direction of the deque accordingly.\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        dq = deque([root])\\n        res = []\\n        lvl = 0\\n        while dq:\\n            size = len(dq)\\n            curr = []\\n            for i in range(size):\\n                if lvl % 2 == 0:\\n                    p = dq.popleft()\\n                    curr.append(p.val)\\n                    if p.left:\\n                        dq.append(p.left)\\n                    if p.right:\\n                        dq.append(p.right)\\n                else:\\n                    p = dq.pop()\\n                    curr.append(p.val)\\n                    if p.right:\\n                        dq.appendleft(p.right)\\n                    if p.left:\\n                        dq.appendleft(p.left)\\n            res.append(curr)\\n            lvl += 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 749008,
                "title": "java-o-n-time-o-log-n-space-bfs-single-deque-1ms",
                "content": "The main idea is to \\n1. Read from Front : left-to-right\\n2. Write to Rear the left child followed by the right child\\n3. Read from Rear : right-to-left\\n4. Write to Front the right child followed by the left child\\n\\nAs each item is removed from either end of the queue it is added to the result list\\n![image](https://assets.leetcode.com/users/images/c06f30df-9e15-4abb-ae17-6dc58a0f0e9f_1595413106.21344.png)\\n```\\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        if(root==null) {\\n            return Collections.emptyList();\\n        }\\n        \\n        ArrayDeque<TreeNode> deque = new ArrayDeque<>();\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n        List<Integer> row  = null;\\n\\t\\tTreeNode node = null;\\n        deque.addFirst(root);\\n        \\n        while(!deque.isEmpty()) {\\n            \\n            row = new ArrayList<>();\\n            result.add(row);\\n            int size = deque.size();\\n\\t\\t\\t\\n            while(size>0) {\\n                node = deque.removeFirst();                \\n                row.add(node.val);\\n                \\n                if(node.left!=null) {\\n                    deque.addLast(node.left);\\n                }\\n                \\n                if(node.right!=null) {\\n                    deque.addLast(node.right);\\n                }\\n                \\n                size--;\\n            }\\n            \\n            size = deque.size();\\n            if(size > 0) {\\n                row = new ArrayList<>();\\n                result.add(row);\\n            }\\n            \\n            while(size > 0) {\\n                node = deque.removeLast();\\n                row.add(node.val);\\n                \\n                if(node.right!=null) {\\n                    deque.addFirst(node.right);\\n                }\\n                \\n                if(node.left!=null) {\\n                    deque.addFirst(node.left);\\n                }    \\n                \\n                size--;\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\nTime Complexity : **O(n)** \\nBecause, each item is put into the queue and read back only once.\\nSpace Complexity: **O(log n)** \\nBecause, in a complete binary tree for each removal, 2 addition will happen. Thus at any level with m nodes the queue will have at most 2m nodes.\\nEg: a complete binary tree with 15 nodes, the queue will have a maximal length of 8 nodes.",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        if(root==null) {\\n            return Collections.emptyList();\\n        }\\n        \\n        ArrayDeque<TreeNode> deque = new ArrayDeque<>();\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n        List<Integer> row  = null;\\n\\t\\tTreeNode node = null;\\n        deque.addFirst(root);\\n        \\n        while(!deque.isEmpty()) {\\n            \\n            row = new ArrayList<>();\\n            result.add(row);\\n            int size = deque.size();\\n\\t\\t\\t\\n            while(size>0) {\\n                node = deque.removeFirst();                \\n                row.add(node.val);\\n                \\n                if(node.left!=null) {\\n                    deque.addLast(node.left);\\n                }\\n                \\n                if(node.right!=null) {\\n                    deque.addLast(node.right);\\n                }\\n                \\n                size--;\\n            }\\n            \\n            size = deque.size();\\n            if(size > 0) {\\n                row = new ArrayList<>();\\n                result.add(row);\\n            }\\n            \\n            while(size > 0) {\\n                node = deque.removeLast();\\n                row.add(node.val);\\n                \\n                if(node.right!=null) {\\n                    deque.addFirst(node.right);\\n                }\\n                \\n                if(node.left!=null) {\\n                    deque.addFirst(node.left);\\n                }    \\n                \\n                size--;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559036,
                "title": "simple-java-solution-0ms-100-faster-using-queue-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> op = new LinkedList<>();\\n        if(root==null){\\n            return op;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        boolean odd=true;\\n        while(!queue.isEmpty()) {\\n           int size = queue.size();\\n           LinkedList<Integer> res = new LinkedList<>();\\n           for(int i=1;i<=size;i++){\\n               TreeNode node = queue.poll();\\n               if(odd){\\n                   res.add(node.val);   \\n               } else {\\n                   res.addFirst(node.val);\\n               }\\n               if(node.left!=null) {\\n                       queue.add(node.left);\\n               }\\n            if(node.right!=null){\\n                        queue.add(node.right);\\n                   }\\n               \\n           }\\n            op.add(res);\\n            odd=!odd;\\n        }\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> op = new LinkedList<>();\\n        if(root==null){\\n            return op;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        boolean odd=true;\\n        while(!queue.isEmpty()) {\\n           int size = queue.size();\\n           LinkedList<Integer> res = new LinkedList<>();\\n           for(int i=1;i<=size;i++){\\n               TreeNode node = queue.poll();\\n               if(odd){\\n                   res.add(node.val);   \\n               } else {\\n                   res.addFirst(node.val);\\n               }\\n               if(node.left!=null) {\\n                       queue.add(node.left);\\n               }\\n            if(node.right!=null){\\n                        queue.add(node.right);\\n                   }\\n               \\n           }\\n            op.add(res);\\n            odd=!odd;\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471798,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(root == NULL)\\n            return ans;\\n        queue<TreeNode*> info;\\n        info.push(root);\\n        bool flag = false;\\n        while(!info.empty()){\\n            int n = info.size();\\n            vector<int> inter;\\n            for(; n>0; n--){\\n                TreeNode* top = info.front();\\n                info.pop();\\n                if(top->left != NULL)\\n                    info.push(top->left);\\n                if(top->right != NULL)\\n                    info.push(top->right);\\n                inter.push_back(top->val);\\n            }\\n            if(flag)\\n                reverse(inter.begin(), inter.end());\\n            ans.push_back(inter);\\n            flag = !flag;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(root == NULL)\\n            return ans;\\n        queue<TreeNode*> info;\\n        info.push(root);\\n        bool flag = false;\\n        while(!info.empty()){\\n            int n = info.size();\\n            vector<int> inter;\\n            for(; n>0; n--){\\n                TreeNode* top = info.front();\\n                info.pop();\\n                if(top->left != NULL)\\n                    info.push(top->left);\\n                if(top->right != NULL)\\n                    info.push(top->right);\\n                inter.push_back(top->val);\\n            }\\n            if(flag)\\n                reverse(inter.begin(), inter.end());\\n            ans.push_back(inter);\\n            flag = !flag;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257155,
                "title": "easy-c-solution-just-a-small-change-in-level-order",
                "content": "Obervesion: We just need to reverse the alternate levels, rest is same as Level Ordering.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) \\n    {\\n        vector <vector<int>> v;\\n        if(!root) // if root is null return\\n            return v;\\n        queue <TreeNode*> q;\\n        q.push(root);\\n        int count = 1; // we want reverse the list at alternate order\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector <int> l;\\n            \\n            while(n--)\\n            {\\n                root=q.front();\\n                q.pop();\\n                l.push_back(root->val);\\n                if(root->left)\\n                    q.push(root->left);\\n                if(root->right)\\n                    q.push(root->right);\\n            }\\n            if(count%2==0) // we want reverse the list at alternate order\\n                reverse(l.begin(),l.end());\\n            v.push_back(l);\\n            count++;\\n        }\\n        \\n        return v;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) \\n    {\\n        vector <vector<int>> v;\\n        if(!root) // if root is null return\\n            return v;\\n        queue <TreeNode*> q;\\n        q.push(root);\\n        int count = 1; // we want reverse the list at alternate order\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector <int> l;\\n            \\n            while(n--)\\n            {\\n                root=q.front();\\n                q.pop();\\n                l.push_back(root->val);\\n                if(root->left)\\n                    q.push(root->left);\\n                if(root->right)\\n                    q.push(root->right);\\n            }\\n            if(count%2==0) // we want reverse the list at alternate order\\n                reverse(l.begin(),l.end());\\n            v.push_back(l);\\n            count++;\\n        }\\n        \\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34162,
                "title": "my-ac-java-code",
                "content": "I use two stacks, one for processing current layer and one for storing nodes for the next layer. I also use a flag (order in your code) to indicate the direction. It is straightforward\\n\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> output = new ArrayList<List<Integer>>();\\n        if (root == null) return output;\\n        Stack<TreeNode> cur_layer = new Stack<TreeNode>(); cur_layer.push(root);\\n        Stack<TreeNode> next_layer = new Stack<TreeNode>();\\n        List<Integer> layer_output = new ArrayList<Integer>();\\n        int d = 0; // 0: left to right; 1: right to left.\\n        \\n        while (!cur_layer.isEmpty()){\\n        \\tTreeNode node = cur_layer.pop();\\n        \\tlayer_output.add(node.val);\\n        \\tif(d==0){\\n        \\t\\tif (node.left != null) next_layer.push(node.left);\\n        \\t\\tif (node.right != null) next_layer.push(node.right);\\n        \\t}else{\\n        \\t\\tif (node.right != null) next_layer.push(node.right);\\n        \\t\\tif (node.left != null) next_layer.push(node.left);\\n        \\t}\\n        \\t\\n        \\tif (cur_layer.isEmpty()){\\n        \\t\\toutput.add(layer_output);\\n        \\t\\tlayer_output = new ArrayList<Integer>();\\n        \\t\\tcur_layer = next_layer;\\n        \\t\\tnext_layer = new Stack<TreeNode>();;\\n        \\t\\td ^= 1;\\n        \\t}\\n        }\\n        return output;\\n    }",
                "solutionTags": [],
                "code": "I use two stacks, one for processing current layer and one for storing nodes for the next layer. I also use a flag (order in your code) to indicate the direction. It is straightforward\\n\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> output = new ArrayList<List<Integer>>();\\n        if (root == null) return output;\\n        Stack<TreeNode> cur_layer = new Stack<TreeNode>(); cur_layer.push(root);\\n        Stack<TreeNode> next_layer = new Stack<TreeNode>();\\n        List<Integer> layer_output = new ArrayList<Integer>();\\n        int d = 0; // 0: left to right; 1: right to left.\\n        \\n        while (!cur_layer.isEmpty()){\\n        \\tTreeNode node = cur_layer.pop();\\n        \\tlayer_output.add(node.val);\\n        \\tif(d==0){\\n        \\t\\tif (node.left != null) next_layer.push(node.left);\\n        \\t\\tif (node.right != null) next_layer.push(node.right);\\n        \\t}else{\\n        \\t\\tif (node.right != null) next_layer.push(node.right);\\n        \\t\\tif (node.left != null) next_layer.push(node.left);\\n        \\t}\\n        \\t\\n        \\tif (cur_layer.isEmpty()){\\n        \\t\\toutput.add(layer_output);\\n        \\t\\tlayer_output = new ArrayList<Integer>();\\n        \\t\\tcur_layer = next_layer;\\n        \\t\\tnext_layer = new Stack<TreeNode>();;\\n        \\t\\td ^= 1;\\n        \\t}\\n        }\\n        return output;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3203465,
                "title": "day-50-bfs-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\nThe problem asks us to perform a level-order traversal of a binary tree, but with a slight modification - we need to return the nodes of each level in a zigzag order, starting from left to right and then right to left for the next level, and so on.\\n\\nThe intuition behind this problem is to use a queue-based BFS (Breadth First Search) approach to traverse the tree level by level, and maintain the order of the nodes in each level by keeping track of the level number. For every even numbered level, we add the nodes to the result list from left to right, and for every odd numbered level, we add the nodes to the result list from right to left.\\n\\nBy using this approach, we can ensure that we visit all the nodes in the tree in a level-order manner, while maintaining the zigzag order of the nodes at each level.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. If the root node is null, return an empty vector.\\n2. Initialize a queue of type TreeNode* and push the root node into it.\\n3. Initialize a variable to keep track of the current level (even or odd). We start with even level.\\n4. While the queue is not empty:\\n    - a. Get the size of the queue and create a new vector to hold the elements of the current level.\\n    - b. Loop through the nodes at the current level and add their values to the vector.\\n    - c. If the current level is even, add the node\\'s value to the end of the vector; otherwise, add it to the beginning.\\n    - d. If the node has a left child, add it to the queue.\\n    - e. If the node has a right child, add it to the queue.\\n    - f. Increment the level counter.\\n    - g. Add the vector containing the elements of the current level to the answer vector.\\n1. Return the answer vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if (root == nullptr)\\n            return {};\\n        vector<vector<int>> ans;\\n        queue<TreeNode*> q;\\n        //strating from even level\\n        int isLevelEvenOrOdd = 0;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int nodesInLevel = q.size();\\n            vector<int> tempVec;\\n            while (nodesInLevel--) {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                if (isLevelEvenOrOdd % 2 == 0) \\n                    tempVec.push_back(temp -> val);\\n                else \\n                    tempVec.insert(tempVec.begin(), temp -> val);\\n                    \\n                if (temp -> left != nullptr)\\n                    q.push(temp -> left);\\n                if (temp -> right != nullptr)\\n                    q.push(temp -> right);\\n            }   \\n            isLevelEvenOrOdd++;\\n            ans.push_back(tempVec);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> result;\\n        if (root == nullptr) {\\n            return result;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool left_to_right = true;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            vector<int> level(size);\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if (left_to_right)\\n                    level[i] = node->val;\\n                else\\n                    level[size - i - 1] = node->val;\\n                if (node->left) {\\n                    q.push(node->left);\\n                }\\n                if (node->right) {\\n                    q.push(node->right);\\n                }\\n            }\\n            result.push_back(level);\\n            left_to_right = !left_to_right;\\n        }\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (root == null)\\n            return ans;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int level = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            List<Integer> levelNodes = new ArrayList<>();\\n            while (size-- > 0) {\\n                TreeNode curr = q.poll();\\n                if (level % 2 == 0) {\\n                    levelNodes.add(curr.val);\\n                } else {\\n                    levelNodes.add(0, curr.val);\\n                }\\n                if (curr.left != null) {\\n                    q.offer(curr.left);\\n                }\\n                if (curr.right != null) {\\n                    q.offer(curr.right);\\n                }\\n            }\\n            level++;\\n            ans.add(levelNodes);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([root])\\n        level = 0\\n        ans = []\\n        while q:\\n            level_nodes = []\\n            for _ in range(len(q)):\\n                curr = q.popleft()\\n                if level % 2 == 0:\\n                    level_nodes.append(curr.val)\\n                else:\\n                    level_nodes.insert(0, curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(level_nodes)\\n            level += 1\\n        return ans\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the number of nodes in the binary tree, since we need to traverse all the nodes.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(w)**, where w is the maximum width of the binary tree (i.e., the maximum number of nodes at any level). In the worst case, the queue will contain all the nodes at the last level, so the space complexity is proportional to the width of the tree.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if (root == nullptr)\\n            return {};\\n        vector<vector<int>> ans;\\n        queue<TreeNode*> q;\\n        //strating from even level\\n        int isLevelEvenOrOdd = 0;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int nodesInLevel = q.size();\\n            vector<int> tempVec;\\n            while (nodesInLevel--) {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                if (isLevelEvenOrOdd % 2 == 0) \\n                    tempVec.push_back(temp -> val);\\n                else \\n                    tempVec.insert(tempVec.begin(), temp -> val);\\n                    \\n                if (temp -> left != nullptr)\\n                    q.push(temp -> left);\\n                if (temp -> right != nullptr)\\n                    q.push(temp -> right);\\n            }   \\n            isLevelEvenOrOdd++;\\n            ans.push_back(tempVec);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> result;\\n        if (root == nullptr) {\\n            return result;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool left_to_right = true;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            vector<int> level(size);\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if (left_to_right)\\n                    level[i] = node->val;\\n                else\\n                    level[size - i - 1] = node->val;\\n                if (node->left) {\\n                    q.push(node->left);\\n                }\\n                if (node->right) {\\n                    q.push(node->right);\\n                }\\n            }\\n            result.push_back(level);\\n            left_to_right = !left_to_right;\\n        }\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (root == null)\\n            return ans;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int level = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            List<Integer> levelNodes = new ArrayList<>();\\n            while (size-- > 0) {\\n                TreeNode curr = q.poll();\\n                if (level % 2 == 0) {\\n                    levelNodes.add(curr.val);\\n                } else {\\n                    levelNodes.add(0, curr.val);\\n                }\\n                if (curr.left != null) {\\n                    q.offer(curr.left);\\n                }\\n                if (curr.right != null) {\\n                    q.offer(curr.right);\\n                }\\n            }\\n            level++;\\n            ans.add(levelNodes);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([root])\\n        level = 0\\n        ans = []\\n        while q:\\n            level_nodes = []\\n            for _ in range(len(q)):\\n                curr = q.popleft()\\n                if level % 2 == 0:\\n                    level_nodes.append(curr.val)\\n                else:\\n                    level_nodes.insert(0, curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(level_nodes)\\n            level += 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34115,
                "title": "python-easy-to-understand-deque-solution",
                "content": "```\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        deque = collections.deque()\\n        if root:\\n            deque.append(root)\\n        res, level = [], 0\\n        while deque:\\n            l, size = [], len(deque)\\n            for _ in range(size): # process level by level\\n                node = deque.popleft()\\n                l.append(node.val)\\n                if node.left:\\n                    deque.append(node.left)\\n                if node.right:\\n                    deque.append(node.right)\\n            if level % 2 == 1:\\n                l.reverse()\\n            res.append(l)\\n            level += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        deque = collections.deque()\\n        if root:\\n            deque.append(root)\\n        res, level = [], 0\\n        while deque:\\n            l, size = [], len(deque)\\n            for _ in range(size): # process level by level\\n                node = deque.popleft()\\n                l.append(node.val)\\n                if node.left:\\n                    deque.append(node.left)\\n                if node.right:\\n                    deque.append(node.right)\\n            if level % 2 == 1:\\n                l.reverse()\\n            res.append(l)\\n            level += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928001,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes.\\n    //   - space: O(n), where n is the number of nodes.\\n\\n    func zigzagLevelOrder(_ root: TreeNode?) -> [[Int]] {\\n        var ans = [[Int]]()\\n        dfs(root, level: 0, ans: &ans)\\n        return ans\\n    }\\n\\n\\n    private func dfs(_ node: TreeNode?, level: Int, ans: inout [[Int]]) {\\n        guard let node = node else { return }\\n        if ans.count <= level { ans.append([Int]()) }\\n\\n        if level % 2 == 0 {\\n            ans[level].append(node.val)\\n        } else {\\n            ans[level].insert(node.val, at: 0)\\n        }\\n\\n        dfs(node.left, level: level + 1, ans: &ans)\\n        dfs(node.right, level: level + 1, ans: &ans)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes.\\n    //   - space: O(n), where n is the number of nodes.\\n\\n    func zigzagLevelOrder(_ root: TreeNode?) -> [[Int]] {\\n        var ans = [[Int]]()\\n        dfs(root, level: 0, ans: &ans)\\n        return ans\\n    }\\n\\n\\n    private func dfs(_ node: TreeNode?, level: Int, ans: inout [[Int]]) {\\n        guard let node = node else { return }\\n        if ans.count <= level { ans.append([Int]()) }\\n\\n        if level % 2 == 0 {\\n            ans[level].append(node.val)\\n        } else {\\n            ans[level].insert(node.val, at: 0)\\n        }\\n\\n        dfs(node.left, level: level + 1, ans: &ans)\\n        dfs(node.right, level: level + 1, ans: &ans)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539875,
                "title": "c-simple-code-using-2-stacks-o-n",
                "content": "```\\n vector<vector<int>> zigzagLevelOrder(TreeNode* root) {        \\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        stack<TreeNode*> dqL;\\n        stack<TreeNode*> dqR;\\n        TreeNode* cur = root;\\n        dqL.push(cur);\\n        \\n        while(!dqL.empty() || !dqR.empty()){\\n            vector<int> curLevel;            \\n            while(!dqL.empty()){\\n                    cur = dqL.top();\\n                    dqL.pop();\\n                    curLevel.push_back(cur->val);\\n                    if(cur->left) dqR.push(cur->left);\\n                    if(cur->right) dqR.push(cur->right);                    \\n            }\\n            if(curLevel.size() > 0){\\n                ans.push_back(curLevel);\\n                curLevel.clear();\\n            }\\n            while(!dqR.empty()){\\n                    cur = dqR.top();\\n                    dqR.pop();\\n                    curLevel.push_back(cur->val);\\n                    if(cur->right) dqL.push(cur->right);                \\n                    if(cur->left) dqL.push(cur->left);\\n            }\\n            if(curLevel.size() > 0){                \\n                ans.push_back(curLevel);\\n                curLevel.clear(); \\n            }           \\n        }\\n        \\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\n vector<vector<int>> zigzagLevelOrder(TreeNode* root) {        \\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        stack<TreeNode*> dqL;\\n        stack<TreeNode*> dqR;\\n        TreeNode* cur = root;\\n        dqL.push(cur);\\n        \\n        while(!dqL.empty() || !dqR.empty()){\\n            vector<int> curLevel;            \\n            while(!dqL.empty()){\\n                    cur = dqL.top();\\n                    dqL.pop();\\n                    curLevel.push_back(cur->val);\\n                    if(cur->left) dqR.push(cur->left);\\n                    if(cur->right) dqR.push(cur->right);                    \\n            }\\n            if(curLevel.size() > 0){\\n                ans.push_back(curLevel);\\n                curLevel.clear();\\n            }\\n            while(!dqR.empty()){\\n                    cur = dqR.top();\\n                    dqR.pop();\\n                    curLevel.push_back(cur->val);\\n                    if(cur->right) dqL.push(cur->right);                \\n                    if(cur->left) dqL.push(cur->left);\\n            }\\n            if(curLevel.size() > 0){                \\n                ans.push_back(curLevel);\\n                curLevel.clear(); \\n            }           \\n        }\\n        \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1347011,
                "title": "easy-python-solution-level-order-traversal",
                "content": "\\tdef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn []\\n\\t\\t\\tlevel = 1\\n\\t\\t\\tres, curr, nxt = [], [root], [] \\n\\t\\t\\twhile curr:\\n\\t\\t\\t\\tfor i in curr:\\n\\t\\t\\t\\t\\tif i.left:\\n\\t\\t\\t\\t\\t\\tnxt.append(i.left)\\n\\t\\t\\t\\t\\tif i.right:\\n\\t\\t\\t\\t\\t\\tnxt.append(i.right)\\n\\t\\t\\t\\tif level%2 == 0:\\n\\t\\t\\t\\t\\tcurr.reverse()\\n\\t\\t\\t\\tres.append([i.val for i in curr])\\n\\t\\t\\t\\tcurr = nxt\\n\\t\\t\\t\\tif nxt:\\n\\t\\t\\t\\t\\tlevel +=1\\n\\t\\t\\t\\tnxt = []\\n\\t\\t\\treturn res\\n\\t\\t\\t\\nHey you viewer, if you understand my solution, do **UPVOTE**, it motivates me. Keep practicing!!!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn []\\n\\t\\t\\tlevel = 1\\n\\t\\t\\tres, curr, nxt = [], [root], [] \\n\\t\\t\\twhile curr:\\n\\t\\t\\t\\tfor i in curr:\\n\\t\\t\\t\\t\\tif i.left:\\n\\t\\t\\t\\t\\t\\tnxt.append(i.left)\\n\\t\\t\\t\\t\\tif i.right:\\n\\t\\t\\t\\t\\t\\tnxt.append(i.right)\\n\\t\\t\\t\\tif level%2 == 0:\\n\\t\\t\\t\\t\\tcurr.reverse()\\n\\t\\t\\t\\tres.append([i.val for i in curr])\\n\\t\\t\\t\\tcurr = nxt\\n\\t\\t\\t\\tif nxt:\\n\\t\\t\\t\\t\\tlevel +=1\\n\\t\\t\\t\\tnxt = []\\n\\t\\t\\treturn res\\n\\t\\t\\t\\nHey you viewer, if you understand my solution, do **UPVOTE**, it motivates me. Keep practicing!!!",
                "codeTag": "Python3"
            },
            {
                "id": 437007,
                "title": "0ms-beats-100-easy-to-understand-recursive-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        zigzagHelp(root, 0, res);\\n        return res;\\n        \\n    }\\n    \\n    public void zigzagHelp(TreeNode root, int level, List<List<Integer>> list) {\\n        \\n        if (root == null) {\\n            return;\\n        }\\n        \\n        if (list.size() <= level) {\\n            list.add(new ArrayList<>());      \\n        } \\n        \\n        if (level % 2 == 0) {\\n            list.get(level).add(root.val);\\n        }\\n        else {\\n           list.get(level).add(0, root.val);   \\n        }\\n        \\n        zigzagHelp(root.left, level + 1, list);\\n        zigzagHelp(root.right, level + 1, list);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        zigzagHelp(root, 0, res);\\n        return res;\\n        \\n    }\\n    \\n    public void zigzagHelp(TreeNode root, int level, List<List<Integer>> list) {\\n        \\n        if (root == null) {\\n            return;\\n        }\\n        \\n        if (list.size() <= level) {\\n            list.add(new ArrayList<>());      \\n        } \\n        \\n        if (level % 2 == 0) {\\n            list.get(level).add(root.val);\\n        }\\n        else {\\n           list.get(level).add(0, root.val);   \\n        }\\n        \\n        zigzagHelp(root.left, level + 1, list);\\n        zigzagHelp(root.right, level + 1, list);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203581,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=SDFFhfwEIiY&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=19) if you are interested.\\n\\n---\\n\\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # Level traversal -> BFS\\n    # reverse the list for odd-index level\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        # if there is no root, then return []\\n        if not root: return []\\n        # init ans and queue with initial node `root`\\n        ans, q = [], [root]\\n        # BFS\\n        while q:\\n            # direction - 1 for even-index level and -1 for odd-index level\\n            d = -1 if len(ans) % 2 == 1 else 1\\n            # put all node values to a list with the correct direction \\n            # and add to `ans` \\n            ans.append([n.val for n in q][::d])\\n            # for each node in the queue, \\n            # we add the left or right node to the queue if applicable\\n            q = [n for node in q for n in (node.left, node.right) if n]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # Level traversal -> BFS\\n    # reverse the list for odd-index level\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        # if there is no root, then return []\\n        if not root: return []\\n        # init ans and queue with initial node `root`\\n        ans, q = [], [root]\\n        # BFS\\n        while q:\\n            # direction - 1 for even-index level and -1 for odd-index level\\n            d = -1 if len(ans) % 2 == 1 else 1\\n            # put all node values to a list with the correct direction \\n            # and add to `ans` \\n            ans.append([n.val for n in q][::d])\\n            # for each node in the queue, \\n            # we add the left or right node to the queue if applicable\\n            q = [n for node in q for n in (node.left, node.right) if n]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242921,
                "title": "c-using-deque-runtime-0-ms-memory-usage-12-2-mb",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(!root)\\n            return ans;\\n        deque<TreeNode*> dq;\\n        dq.push_back(root);\\n        bool isLTR = true;\\n        while(!dq.empty()) {\\n            int n = dq.size();\\n            vector<int> currLevel;\\n            if(isLTR) {\\n                isLTR = false;\\n                for(int i=0;i<n;++i) {\\n                    auto curr = dq.front();\\n                    dq.pop_front();\\n                    currLevel.push_back(curr->val);\\n                    if(curr->left)\\n                        dq.push_back(curr->left);\\n                    if(curr->right)\\n                        dq.push_back(curr->right);\\n                }\\n            } else {\\n                isLTR = true;\\n                for(int i=0;i<n;++i) {\\n                    auto curr = dq.back();\\n                    dq.pop_back();\\n                    currLevel.push_back(curr->val);\\n                    if(curr->right)\\n                        dq.push_front(curr->right);\\n                    if(curr->left)\\n                        dq.push_front(curr->left);\\n                }\\n            }\\n            ans.push_back(currLevel);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(!root)\\n            return ans;\\n        deque<TreeNode*> dq;\\n        dq.push_back(root);\\n        bool isLTR = true;\\n        while(!dq.empty()) {\\n            int n = dq.size();\\n            vector<int> currLevel;\\n            if(isLTR) {\\n                isLTR = false;\\n                for(int i=0;i<n;++i) {\\n                    auto curr = dq.front();\\n                    dq.pop_front();\\n                    currLevel.push_back(curr->val);\\n                    if(curr->left)\\n                        dq.push_back(curr->left);\\n                    if(curr->right)\\n                        dq.push_back(curr->right);\\n                }\\n            } else {\\n                isLTR = true;\\n                for(int i=0;i<n;++i) {\\n                    auto curr = dq.back();\\n                    dq.pop_back();\\n                    currLevel.push_back(curr->val);\\n                    if(curr->right)\\n                        dq.push_front(curr->right);\\n                    if(curr->left)\\n                        dq.push_front(curr->left);\\n                }\\n            }\\n            ans.push_back(currLevel);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877603,
                "title": "easy-to-understand-c-10-liner-no-reverse-used",
                "content": "**Idea**\\nAll you have to do is do the standard bfs(with two stacks instead) with two adjustments -\\n\\n1) instead of dequeueing from a queue, pop() from our first stack pointer. Simmilarly instead of enqueueing push to our second stack pointer.\\n2) In queue you will push in left child then right child in every level. Here we alternately first push right and left (why? because you want to have level two in reverse order), then in second iteration left and right and so on.\\n\\nAt the end of each level just swap the stack pointers before moving to next level.\\n\\nI tried to keep it simple for you, hope I was able to do that. If I missed anything trying to do so, let me know in the comments would be happy to help.\\n\\n**Code**\\n```cpp\\n\\t#define tn TreeNode\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans; if(!root) return ans;\\n        stack<tn*> a, b;\\n        stack<tn*> *stk1 = &a, *stk2 = &b; a.push(root);\\n        while(!stk1->empty()){\\n            ans.push_back(vector<int> (0));\\n            while(!stk1->empty()){\\n                tn *cur = stk1->top();\\n                stk1->pop();\\n                ans.back().push_back(cur->val);\\n                if(stk1 != &b && cur->left) stk2->push(cur->left);\\n                if(cur->right)stk2->push(cur->right);\\n                if(stk1 == &b && cur->left) stk2->push(cur->left);\\n            }\\n            swap(stk1, stk2);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\n\\t#define tn TreeNode\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans; if(!root) return ans;\\n        stack<tn*> a, b;\\n        stack<tn*> *stk1 = &a, *stk2 = &b; a.push(root);\\n        while(!stk1->empty()){\\n            ans.push_back(vector<int> (0));\\n            while(!stk1->empty()){\\n                tn *cur = stk1->top();\\n                stk1->pop();\\n                ans.back().push_back(cur->val);\\n                if(stk1 != &b && cur->left) stk2->push(cur->left);\\n                if(cur->right)stk2->push(cur->right);\\n                if(stk1 == &b && cur->left) stk2->push(cur->left);\\n            }\\n            swap(stk1, stk2);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 286135,
                "title": "c-queue",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ZigzagLevelOrder(TreeNode root) {\\n        var result = new List<IList<int>>();\\n        if (root == null) return result;\\n\\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n\\n        while (queue.Any()) {\\n            var size = queue.Count;\\n            var oneResult = new List<int>();\\n            for (int s = 0; s < size; s++) {\\n                var cur = queue.Dequeue();\\n                oneResult.Add(cur.val);\\n\\n                if (cur.left != null) {\\n                    queue.Enqueue(cur.left);\\n                }\\n\\n                if (cur.right != null) {\\n                    queue.Enqueue(cur.right);\\n                }\\n            }\\n\\n            if (result.Count % 2 == 1) {\\n                oneResult.Reverse();\\n            }\\n            result.Add(oneResult);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ZigzagLevelOrder(TreeNode root) {\\n        var result = new List<IList<int>>();\\n        if (root == null) return result;\\n\\n        var queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n\\n        while (queue.Any()) {\\n            var size = queue.Count;\\n            var oneResult = new List<int>();\\n            for (int s = 0; s < size; s++) {\\n                var cur = queue.Dequeue();\\n                oneResult.Add(cur.val);\\n\\n                if (cur.left != null) {\\n                    queue.Enqueue(cur.left);\\n                }\\n\\n                if (cur.right != null) {\\n                    queue.Enqueue(cur.right);\\n                }\\n            }\\n\\n            if (result.Count % 2 == 1) {\\n                oneResult.Reverse();\\n            }\\n            result.Add(oneResult);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008737,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n   TreeNode c=root;\\n   List<List<Integer>> ans =new ArrayList<List<Integer>>();\\n   if(c==null) return ans;\\n   Stack<TreeNode> s1=new Stack<TreeNode>();\\n   Stack<TreeNode> s2=new Stack<TreeNode>();\\n   s1.push(root);\\n   while(!s1.isEmpty()||!s2.isEmpty())\\n   {\\n       List<Integer> tmp=new ArrayList<Integer>();\\n        while(!s1.isEmpty())\\n        {\\n            c=s1.pop();\\n            tmp.add(c.val);\\n            if(c.left!=null) s2.push(c.left);\\n            if(c.right!=null) s2.push(c.right);\\n        }\\n        ans.add(tmp);\\n        tmp=new ArrayList<Integer>();\\n        while(!s2.isEmpty())\\n        {\\n            c=s2.pop();\\n            tmp.add(c.val);\\n            if(c.right!=null)s1.push(c.right);\\n            if(c.left!=null)s1.push(c.left);\\n        }\\n        if(!tmp.isEmpty()) ans.add(tmp);\\n   }\\n   return ans;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode*root,vector<vector<int>>&res,int level)\\n    {\\n        if(!root) return;   \\n        if(level>=res.size())\\n            res.push_back({});\\n        res[level].push_back(root->val);\\n        helper(root->left,res,level+1);\\n        helper(root->right,res,level+1);\\n    }\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>res;\\n        if(!root)   return res;\\n        helper(root,res,0); \\n        for(int i=1;i<res.size();i=i+2)\\n        {\\n            reverse(res[i].begin(),res[i].end());\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\tif not root: return []\\n\\tqueue = collections.deque([root])\\n\\tres = []\\n\\teven_level = False\\n\\twhile queue:\\n\\t\\tn = len(queue)\\n\\t\\tlevel = []\\n\\t\\tfor _ in range(n):\\n\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\tlevel.append(node.val)\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\tif node.right:\\n\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\tif even_level:\\n\\t\\t\\tres.append(level[::-1])\\n\\t\\telse:\\n\\t\\t\\tres.append(level)\\n\\t\\teven_level = not even_level\\n\\treturn res\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nfunction zigzagLevelOrder(root) {\\n  let res = [];\\n  go(root, 0, res);\\n  return res;\\n}\\n\\nfunction go(node, l, res) {  // l means level\\n  if (!node) return;\\n\\n  if (res[l] == null) {\\n    res.push([]);\\n  }\\n\\n  if (l % 2 === 0) {\\n    res[l].push(node.val);\\n  } else {\\n    res[l].unshift(node.val);\\n  }\\n\\n  go(node.left, l + 1, res);\\n  go(node.right, l + 1, res);\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\n fun zigzagLevelOrder(root: TreeNode?): List<List<Int>> {\\n        val queue : Queue<TreeNode> = LinkedList()\\n        val result = mutableListOf<LinkedList<Int>>()\\n        if (root == null) return result\\n        var leftToRight = true // if true, add elements in normally else add in reverse\\n        queue.add(root)\\n        while (queue.isNotEmpty()) {\\n            val thisLevel = LinkedList<Int>()\\n            var size = queue.size\\n            while (size > 0) {\\n                var current = queue.poll()\\n                if (leftToRight.not()) thisLevel.addFirst(current.`val`) // reverse\\n                else thisLevel.add(current.`val`) // normal\\n                current.left?.let { queue.offer(it) }\\n                current.right?.let { queue.offer(it) }\\n                --size\\n            }\\n            result.add(thisLevel)\\n            leftToRight = leftToRight.not()\\n        }\\n        return result\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes.\\n    //   - space: O(n), where n is the number of nodes.\\n\\n    func zigzagLevelOrder(_ root: TreeNode?) -> [[Int]] {\\n        var ans = [[Int]]()\\n        dfs(root, level: 0, ans: &ans)\\n        return ans\\n    }\\n\\n\\n    private func dfs(_ node: TreeNode?, level: Int, ans: inout [[Int]]) {\\n        guard let node = node else { return }\\n        if ans.count <= level { ans.append([Int]()) }\\n\\n        if level % 2 == 0 {\\n            ans[level].append(node.val)\\n        } else {\\n            ans[level].insert(node.val, at: 0)\\n        }\\n\\n        dfs(node.left, level: level + 1, ans: &ans)\\n        dfs(node.right, level: level + 1, ans: &ans)\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n   TreeNode c=root;\\n   List<List<Integer>> ans =new ArrayList<List<Integer>>();\\n   if(c==null) return ans;\\n   Stack<TreeNode> s1=new Stack<TreeNode>();\\n   Stack<TreeNode> s2=new Stack<TreeNode>();\\n   s1.push(root);\\n   while(!s1.isEmpty()||!s2.isEmpty())\\n   {\\n       List<Integer> tmp=new ArrayList<Integer>();\\n        while(!s1.isEmpty())\\n        {\\n            c=s1.pop();\\n            tmp.add(c.val);\\n            if(c.left!=null) s2.push(c.left);\\n            if(c.right!=null) s2.push(c.right);\\n        }\\n        ans.add(tmp);\\n        tmp=new ArrayList<Integer>();\\n        while(!s2.isEmpty())\\n        {\\n            c=s2.pop();\\n            tmp.add(c.val);\\n            if(c.right!=null)s1.push(c.right);\\n            if(c.left!=null)s1.push(c.left);\\n        }\\n        if(!tmp.isEmpty()) ans.add(tmp);\\n   }\\n   return ans;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode*root,vector<vector<int>>&res,int level)\\n    {\\n        if(!root) return;   \\n        if(level>=res.size())\\n            res.push_back({});\\n        res[level].push_back(root->val);\\n        helper(root->left,res,level+1);\\n        helper(root->right,res,level+1);\\n    }\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>res;\\n        if(!root)   return res;\\n        helper(root,res,0); \\n        for(int i=1;i<res.size();i=i+2)\\n        {\\n            reverse(res[i].begin(),res[i].end());\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\ndef zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n\\tif not root: return []\\n\\tqueue = collections.deque([root])\\n\\tres = []\\n\\teven_level = False\\n\\twhile queue:\\n\\t\\tn = len(queue)\\n\\t\\tlevel = []\\n\\t\\tfor _ in range(n):\\n\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\tlevel.append(node.val)\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\tif node.right:\\n\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\tif even_level:\\n\\t\\t\\tres.append(level[::-1])\\n\\t\\telse:\\n\\t\\t\\tres.append(level)\\n\\t\\teven_level = not even_level\\n\\treturn res\\n```\n```\\n```\n```\\n```\n```\\nfunction zigzagLevelOrder(root) {\\n  let res = [];\\n  go(root, 0, res);\\n  return res;\\n}\\n\\nfunction go(node, l, res) {  // l means level\\n  if (!node) return;\\n\\n  if (res[l] == null) {\\n    res.push([]);\\n  }\\n\\n  if (l % 2 === 0) {\\n    res[l].push(node.val);\\n  } else {\\n    res[l].unshift(node.val);\\n  }\\n\\n  go(node.left, l + 1, res);\\n  go(node.right, l + 1, res);\\n}\\n```\n```\\n```\n```\\n```\n```\\n fun zigzagLevelOrder(root: TreeNode?): List<List<Int>> {\\n        val queue : Queue<TreeNode> = LinkedList()\\n        val result = mutableListOf<LinkedList<Int>>()\\n        if (root == null) return result\\n        var leftToRight = true // if true, add elements in normally else add in reverse\\n        queue.add(root)\\n        while (queue.isNotEmpty()) {\\n            val thisLevel = LinkedList<Int>()\\n            var size = queue.size\\n            while (size > 0) {\\n                var current = queue.poll()\\n                if (leftToRight.not()) thisLevel.addFirst(current.`val`) // reverse\\n                else thisLevel.add(current.`val`) // normal\\n                current.left?.let { queue.offer(it) }\\n                current.right?.let { queue.offer(it) }\\n                --size\\n            }\\n            result.add(thisLevel)\\n            leftToRight = leftToRight.not()\\n        }\\n        return result\\n    }\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes.\\n    //   - space: O(n), where n is the number of nodes.\\n\\n    func zigzagLevelOrder(_ root: TreeNode?) -> [[Int]] {\\n        var ans = [[Int]]()\\n        dfs(root, level: 0, ans: &ans)\\n        return ans\\n    }\\n\\n\\n    private func dfs(_ node: TreeNode?, level: Int, ans: inout [[Int]]) {\\n        guard let node = node else { return }\\n        if ans.count <= level { ans.append([Int]()) }\\n\\n        if level % 2 == 0 {\\n            ans[level].append(node.val)\\n        } else {\\n            ans[level].insert(node.val, at: 0)\\n        }\\n\\n        dfs(node.left, level: level + 1, ans: &ans)\\n        dfs(node.right, level: level + 1, ans: &ans)\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501722,
                "title": "java-easy-solution-with-level-order-traversal-using-queue",
                "content": "I traverse by level using queue.\\nFor even level elements are reversed and the other uses original order.\\n\\n```\\nclass Solution {\\n    public static List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(root == null) return res;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        int level = 0; // the number of level !!\\n        while(!queue.isEmpty()) {\\n            List<Integer> list = new ArrayList<>();\\n            int size = queue.size();\\n            for(int i=0; i<size; i++) {\\n                TreeNode node = queue.poll();\\n                list.add(node.val);\\n                if(node.left != null) queue.offer(node.left);\\n                if(node.right != null) queue.offer(node.right);\\n            }\\n            if(level % 2 == 1) { //reverse data\\n                Collections.reverse(list);\\n            }\\n            res.add(list);\\n\\n            level++; // after traverse all member of element in same level, go next level\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public static List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(root == null) return res;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        int level = 0; // the number of level !!\\n        while(!queue.isEmpty()) {\\n            List<Integer> list = new ArrayList<>();\\n            int size = queue.size();\\n            for(int i=0; i<size; i++) {\\n                TreeNode node = queue.poll();\\n                list.add(node.val);\\n                if(node.left != null) queue.offer(node.left);\\n                if(node.right != null) queue.offer(node.right);\\n            }\\n            if(level % 2 == 1) { //reverse data\\n                Collections.reverse(list);\\n            }\\n            res.add(list);\\n\\n            level++; // after traverse all member of element in same level, go next level\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33846,
                "title": "c-clean-code",
                "content": "```\\n/**\\n *         -> 1->\\n *     <- 2   <    3 <-\\n *  -> 4  > 5 >  6  >  7 ->\\n * <- 8 9 10 11 12 13 14 15 <-\\n *\\n * level % 2 = 0 - forward popping.  push to back: left  + right\\n * level % 2 = 1 - backward popping. push to front: right + left \\n */\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if (!root) return {};\\n        vector<vector<int>> lines;\\n        deque<TreeNode*> q;\\n        q.push_front(root);\\n\\n        for (int l = 0; !q.empty(); l++) {\\n            lines.push_back({});\\n            for (int n = q.size(); n > 0; n--) {\\n                TreeNode* node = l % 2 == 0 ? q.front() : q.back();\\n                l % 2 == 0 ? q.pop_front() : q.pop_back();\\n                lines[l].push_back(node->val);\\n                if (l % 2 == 0) {\\n                    if (node->left) q.push_back(node->left);\\n                    if (node->right) q.push_back(node->right);\\n                }\\n                else {\\n                    if (node->right) q.push_front(node->right);\\n                    if (node->left) q.push_front(node->left);\\n                }\\n            }\\n        }\\n\\n        return lines;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n *         -> 1->\\n *     <- 2   <    3 <-\\n *  -> 4  > 5 >  6  >  7 ->\\n * <- 8 9 10 11 12 13 14 15 <-\\n *\\n * level % 2 = 0 - forward popping.  push to back: left  + right\\n * level % 2 = 1 - backward popping. push to front: right + left \\n */\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if (!root) return {};\\n        vector<vector<int>> lines;\\n        deque<TreeNode*> q;\\n        q.push_front(root);\\n\\n        for (int l = 0; !q.empty(); l++) {\\n            lines.push_back({});\\n            for (int n = q.size(); n > 0; n--) {\\n                TreeNode* node = l % 2 == 0 ? q.front() : q.back();\\n                l % 2 == 0 ? q.pop_front() : q.pop_back();\\n                lines[l].push_back(node->val);\\n                if (l % 2 == 0) {\\n                    if (node->left) q.push_back(node->left);\\n                    if (node->right) q.push_back(node->right);\\n                }\\n                else {\\n                    if (node->right) q.push_front(node->right);\\n                    if (node->left) q.push_front(node->left);\\n                }\\n            }\\n        }\\n\\n        return lines;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34041,
                "title": "java-easy-understand-recursive-methods-beats-96-attach-easy-bfs-methods",
                "content": "    //recursive method\\n      public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n            List<LinkedList<Integer>> res = new ArrayList<>();\\n            \\n            helper(res,root,0);\\n            \\n            List<List<Integer>> finalRes = new ArrayList<>();\\n            finalRes.addAll(res);\\n            return finalRes;\\n        }\\n        \\n        public void helper(List<LinkedList<Integer>> res, TreeNode root, int level){\\n            if(root == null)\\n                return;\\n            if(res.size() <= level)\\n                res.add(new LinkedList<>());\\n            \\n            if((level + 1) % 2 != 0)\\n                res.get(level).add(root.val);\\n            else\\n                res.get(level).addFirst(root.val);\\n            \\n            helper(res,root.left,level + 1);\\n            helper(res,root.right,level + 1);     \\n        }\\n    \\n    \\n       //BFS method\\n      public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(root == null)\\n            return res;\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int level = 1;\\n        while(!q.isEmpty()){\\n            LinkedList<Integer> path = new LinkedList<>();\\n            int levelNums = q.size();\\n            \\n            for(int i = 0; i < levelNums; i++){\\n                root = q.poll();\\n                if(level % 2 != 0){\\n                    path.add(root.val);\\n                }else{\\n                    path.addFirst(root.val);\\n                }\\n                \\n                if(root.left != null)\\n                    q.offer(root.left);\\n                if(root.right != null)\\n                    q.offer(root.right);\\n            }\\n            res.add(path);\\n            level++;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    //recursive method\\n      public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n            List<LinkedList<Integer>> res = new ArrayList<>();\\n            \\n            helper(res,root,0);\\n            \\n            List<List<Integer>> finalRes = new ArrayList<>();\\n            finalRes.addAll(res);\\n            return finalRes;\\n        }\\n        \\n        public void helper(List<LinkedList<Integer>> res, TreeNode root, int level){\\n            if(root == null)\\n                return;\\n            if(res.size() <= level)\\n                res.add(new LinkedList<>());\\n            \\n            if((level + 1) % 2 != 0)\\n                res.get(level).add(root.val);\\n            else\\n                res.get(level).addFirst(root.val);\\n            \\n            helper(res,root.left,level + 1);\\n            helper(res,root.right,level + 1);     \\n        }\\n    \\n    \\n       //BFS method\\n      public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(root == null)\\n            return res;\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int level = 1;\\n        while(!q.isEmpty()){\\n            LinkedList<Integer> path = new LinkedList<>();\\n            int levelNums = q.size();\\n            \\n            for(int i = 0; i < levelNums; i++){\\n                root = q.poll();\\n                if(level % 2 != 0){\\n                    path.add(root.val);\\n                }else{\\n                    path.addFirst(root.val);\\n                }\\n                \\n                if(root.left != null)\\n                    q.offer(root.left);\\n                if(root.right != null)\\n                    q.offer(root.right);\\n            }\\n            res.add(path);\\n            level++;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2098804,
                "title": "python3-clean-solution-using-queue-level-order-traversal",
                "content": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root):\\n        \\n        res = []\\n        if not root: return res\\n        zigzag = True\\n        \\n        q = collections.deque()\\n        q.append(root)\\n        \\n        while q:\\n            n = len(q)\\n            nodesOfThisLevel = []\\n            \\n            for i in range(n):\\n                node = q.popleft()\\n                nodesOfThisLevel.append(node.val)\\n                \\n                if node.left: q.append(node.left)\\n                if node.right: q.append(node.right)\\n                    \\n            if zigzag:\\n                res.append(nodesOfThisLevel)\\n                zigzag = False\\n            else:\\n                res.append(nodesOfThisLevel[::-1])\\n                zigzag = True\\n        \\n        return res\\n    \\n# Time: O(N)\\n# Space: O(N)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root):\\n        \\n        res = []\\n        if not root: return res\\n        zigzag = True\\n        \\n        q = collections.deque()\\n        q.append(root)\\n        \\n        while q:\\n            n = len(q)\\n            nodesOfThisLevel = []\\n            \\n            for i in range(n):\\n                node = q.popleft()\\n                nodesOfThisLevel.append(node.val)\\n                \\n                if node.left: q.append(node.left)\\n                if node.right: q.append(node.right)\\n                    \\n            if zigzag:\\n                res.append(nodesOfThisLevel)\\n                zigzag = False\\n            else:\\n                res.append(nodesOfThisLevel[::-1])\\n                zigzag = True\\n        \\n        return res\\n    \\n# Time: O(N)\\n# Space: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778310,
                "title": "easy-to-understand-python-code",
                "content": "```\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if root is None:\\n            return\\n        myqueue=queue.Queue()\\n        myqueue.put(root)\\n        myqueue.put(None)\\n        final=[]\\n        small=[]\\n        left2right=True\\n        while myqueue.empty()==False:\\n            front=myqueue.get()\\n            if front is not None:\\n                if front.left!= None:\\n                    myqueue.put(front.left)\\n                if front.right!=None:\\n                    myqueue.put(front.right)    \\n                small.append(front.val)\\n            else:\\n                if myqueue.empty()==True:\\n                    if left2right:\\n                        final.append(small)\\n                    else:\\n                        final.append(small[-1::-1])\\n                    break\\n                else:\\n                    if left2right:\\n                        final.append(small)\\n                        left2right=False\\n                    else:\\n                        rev=small[-1::-1]\\n                        final.append(rev)\\n                        left2right=True\\n                    small=[]\\n                    myqueue.put(None)\\n        return final            \\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if root is None:\\n            return\\n        myqueue=queue.Queue()\\n        myqueue.put(root)\\n        myqueue.put(None)\\n        final=[]\\n        small=[]\\n        left2right=True\\n        while myqueue.empty()==False:\\n            front=myqueue.get()\\n            if front is not None:\\n                if front.left!= None:\\n                    myqueue.put(front.left)\\n                if front.right!=None:\\n                    myqueue.put(front.right)    \\n                small.append(front.val)\\n            else:\\n                if myqueue.empty()==True:\\n                    if left2right:\\n                        final.append(small)\\n                    else:\\n                        final.append(small[-1::-1])\\n                    break\\n                else:\\n                    if left2right:\\n                        final.append(small)\\n                        left2right=False\\n                    else:\\n                        rev=small[-1::-1]\\n                        final.append(rev)\\n                        left2right=True\\n                    small=[]\\n                    myqueue.put(None)\\n        return final            \\n                    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 642801,
                "title": "easy-to-understand-2-solution-dfs-bfs-simple-python-solution",
                "content": "```\\n    def recursive(self, root):\\n        #inspired by the solution somewhat\\n        out = []\\n        def rec(node, height):\\n            if node:\\n                if len(out) <= height:\\n                    out.append([])\\n                out[height].append(node.val)\\n                rec(node.left, height + 1)\\n                rec(node.right, height + 1)\\n        rec(root, 0)\\n        return [out[i] if i%2==0 else out[i][::-1] for i in range(len(out))]\\n    \\n    def iterative(self, root):\\n        # here, the stack should be replaced by queue but I guess, I am lazy ;)\\n        if not root: return []\\n        stack = [root]\\n        out = []\\n        reverse = True\\n        while len(stack):\\n            temp = []\\n            out.append([i.val for i in (stack if reverse else stack[::-1])])\\n            reverse = not reverse\\n            while len(stack):\\n                top = stack.pop(0)\\n                if top.left: temp.append(top.left)\\n                if top.right: temp.append(top.right)\\n            \\n            stack = temp\\n        return out\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n    def recursive(self, root):\\n        #inspired by the solution somewhat\\n        out = []\\n        def rec(node, height):\\n            if node:\\n                if len(out) <= height:\\n                    out.append([])\\n                out[height].append(node.val)\\n                rec(node.left, height + 1)\\n                rec(node.right, height + 1)\\n        rec(root, 0)\\n        return [out[i] if i%2==0 else out[i][::-1] for i in range(len(out))]\\n    \\n    def iterative(self, root):\\n        # here, the stack should be replaced by queue but I guess, I am lazy ;)\\n        if not root: return []\\n        stack = [root]\\n        out = []\\n        reverse = True\\n        while len(stack):\\n            temp = []\\n            out.append([i.val for i in (stack if reverse else stack[::-1])])\\n            reverse = not reverse\\n            while len(stack):\\n                top = stack.pop(0)\\n                if top.left: temp.append(top.left)\\n                if top.right: temp.append(top.right)\\n            \\n            stack = temp\\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 284836,
                "title": "swift-bfs",
                "content": "The idea here is to simply proceed our level order traverse left to right but append items to end or to begin of sub arrays following current swapping direction.\\n```\\nclass Solution {\\n    private enum Direction {\\n        case right\\n        case left\\n    }\\n\\n    func zigzagLevelOrder(_ root: TreeNode?) -> [[Int]] {\\n        var ans = [[Int]]()\\n        guard let root = root else { return ans }\\n        var queue = [root]\\n        var direction = Direction.left\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            var sub = [Int]()\\n            for i in 0..<count {\\n                let curr = queue.removeFirst()\\n                switch direction {\\n                case .right:\\n                    sub.append(curr.val)\\n                case .left:\\n                    sub.insert(curr.val, at: 0)\\n                }\\n                if let right = curr.right {\\n                    queue.append(right)\\n                }\\n                if let left = curr.left {\\n                    queue.append(left)\\n                }\\n            }\\n            ans.append(sub)\\n            direction = direction == .left ? .right : .left\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private enum Direction {\\n        case right\\n        case left\\n    }\\n\\n    func zigzagLevelOrder(_ root: TreeNode?) -> [[Int]] {\\n        var ans = [[Int]]()\\n        guard let root = root else { return ans }\\n        var queue = [root]\\n        var direction = Direction.left\\n        while !queue.isEmpty {\\n            let count = queue.count\\n            var sub = [Int]()\\n            for i in 0..<count {\\n                let curr = queue.removeFirst()\\n                switch direction {\\n                case .right:\\n                    sub.append(curr.val)\\n                case .left:\\n                    sub.insert(curr.val, at: 0)\\n                }\\n                if let right = curr.right {\\n                    queue.append(right)\\n                }\\n                if let left = curr.left {\\n                    queue.append(left)\\n                }\\n            }\\n            ans.append(sub)\\n            direction = direction == .left ? .right : .left\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626050,
                "title": "binary-tree-zigzag-level-order-traversal-in-java-simple-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- Create an empty list to store the final result.\\n- If the root of the tree is null, return the empty list.\\n- Create a queue to store the nodes of each level of the tree.\\n- Add the root node to the queue.\\n- Create a temporary node variable and a boolean variable to indicate the zigzag order.\\n- Create an empty sublist to store the values of each level.\\n- While the queue is not empty, do the following:\\n  - Get the size of the queue, which is the number of nodes in the current level.\\n  - For each node in the current level, do the following:\\n    - Remove the node from the queue and assign it to the temporary node variable.\\n    - Add its value to the sublist.\\n    - If it has a left child, add it to the queue.\\n    - If it has a right child, add it to the queue.\\n  - If the zigzag order is false, reverse the sublist.\\n  - Add the sublist to the final result list.\\n  - Toggle the zigzag order variable.\\n- Return the final result list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        if(root == null){\\n            return list;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        TreeNode temp = null;\\n        Boolean zigZag = true;\\n        List<Integer> subList;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            subList = new ArrayList<>();\\n            for(int i = 0; i<size; i++){\\n                temp = queue.remove();\\n                subList.add(temp.val);\\n                if(temp.left != null){\\n                   queue.add(temp.left);\\n                }\\n                if(temp.right != null){\\n                   queue.add(temp.right);\\n                }\\n            }\\n            if(zigZag == false){\\n                Collections.reverse(subList);\\n            }\\n            list.add(subList);\\n            zigZag = !zigZag;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        if(root == null){\\n            return list;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        TreeNode temp = null;\\n        Boolean zigZag = true;\\n        List<Integer> subList;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            subList = new ArrayList<>();\\n            for(int i = 0; i<size; i++){\\n                temp = queue.remove();\\n                subList.add(temp.val);\\n                if(temp.left != null){\\n                   queue.add(temp.left);\\n                }\\n                if(temp.right != null){\\n                   queue.add(temp.right);\\n                }\\n            }\\n            if(zigZag == false){\\n                Collections.reverse(subList);\\n            }\\n            list.add(subList);\\n            zigZag = !zigZag;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205561,
                "title": "putta-easy-solution-c-beats-100-runtime-0ms-funday",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Queue , placing the values at right indexes .\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<vector<int>> ans; // answer vector\\n        bool left = false;\\n        if(root == NULL) return ans; //if tree is empty\\n        while(!q.empty()){ //level order traversal\\n            int n= q.size();\\n            vector<int> ans1(n); \\n            for(int i=0;i<n;i++){\\n                TreeNode* temp = q.front();\\n                if(left == false) ans1[i] = temp->val;\\n                else ans1[n-i-1] = temp->val;\\n                q.pop();\\n                // pushing next level into queue\\n                if(temp->left != NULL) q.push(temp->left);\\n                if(temp->right != NULL) q.push(temp->right);\\n            }\\n            left = !left; // changing the zig-Zag order\\n            ans.push_back(ans1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![Screenshot (8).png](https://assets.leetcode.com/users/images/90f6f168-24b2-4a18-8cb7-2521712a6b38_1676804866.9230862.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<vector<int>> ans; // answer vector\\n        bool left = false;\\n        if(root == NULL) return ans; //if tree is empty\\n        while(!q.empty()){ //level order traversal\\n            int n= q.size();\\n            vector<int> ans1(n); \\n            for(int i=0;i<n;i++){\\n                TreeNode* temp = q.front();\\n                if(left == false) ans1[i] = temp->val;\\n                else ans1[n-i-1] = temp->val;\\n                q.pop();\\n                // pushing next level into queue\\n                if(temp->left != NULL) q.push(temp->left);\\n                if(temp->right != NULL) q.push(temp->right);\\n            }\\n            left = !left; // changing the zig-Zag order\\n            ans.push_back(ans1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931799,
                "title": "c-level-order-traversal-bfs-faster-than-100-clean-concise-code",
                "content": "\\n\\n# Code\\n# Please Do Upvote!!!!\\n##### Connect with me on Linkedin -> https://www.linkedin.com/in/md-kamran-55b98521a/\\n```\\n\\n\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        \\n         vector<vector<int>>res;\\n\\n        if(root == NULL) return res;\\n\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int cnt = -1;\\n\\n        while(!q.empty())\\n        {\\n          int n = q.size();\\n\\n          vector<int>l;\\n\\n          for(int i = 0; i < n; ++i)\\n          {\\n            \\n            auto temp = q.front();\\n            q.pop();\\n\\n            if(temp->left!=NULL) q.push(temp->left);\\n            if(temp->right!=NULL) q.push(temp->right);\\n\\n            l.push_back(temp->val);\\n\\n          }\\n\\n          cnt++;\\n         \\n          if(cnt % 2 != 0) reverse(l.begin(),l.end());\\n\\n          res.push_back(l);\\n          \\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/98b7adbc-5abf-45f7-9b5b-538574194654_1676344687.6513524.png)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        \\n         vector<vector<int>>res;\\n\\n        if(root == NULL) return res;\\n\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int cnt = -1;\\n\\n        while(!q.empty())\\n        {\\n          int n = q.size();\\n\\n          vector<int>l;\\n\\n          for(int i = 0; i < n; ++i)\\n          {\\n            \\n            auto temp = q.front();\\n            q.pop();\\n\\n            if(temp->left!=NULL) q.push(temp->left);\\n            if(temp->right!=NULL) q.push(temp->right);\\n\\n            l.push_back(temp->val);\\n\\n          }\\n\\n          cnt++;\\n         \\n          if(cnt % 2 != 0) reverse(l.begin(),l.end());\\n\\n          res.push_back(l);\\n          \\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357152,
                "title": "intuitive-solution-using-deque-with-clean-code-and-visual-representation-of-the-deque",
                "content": "### Approach:\\n\\n* **When we have to print in right direction**: We take the nodes from the front of the deque and push the children in the back of the deque\\n* **When we have to print in left direction**: We take the nodes from the back of the deque and push the children in the front of the deque in reverse order since we are traversing the current elements in reverse itself.\\n\\n\\n![image](https://assets.leetcode.com/users/images/54da592b-6f25-44ba-9e05-f1e57a870e70_1627041938.234792.png)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) \\n    {        \\n        vector<vector<int>> ans;\\n        \\n        if(!root)\\n            return ans;\\n        \\n        deque<TreeNode*> nodes;\\n        \\n        bool right = true;\\n        \\n        TreeNode *levelEnd = new TreeNode(-1);\\n        \\n        nodes.push_back(root);\\n        nodes.push_back(levelEnd);\\n        \\n        vector<int> currAns;\\n        \\n        while(nodes.size() > 1)\\n        {\\n            if(right)\\n            {\\n                TreeNode *currNode = nodes.front();\\n                \\n                if(currNode == levelEnd)\\n                {\\n                    ans.push_back(currAns);\\n                    currAns.clear();\\n\\n                    right = !right;\\n                }\\n                else\\n                {\\n                    nodes.pop_front();\\n                    \\n                    currAns.push_back(currNode->val);\\n                    \\n                    if(currNode->left)\\n                        nodes.push_back(currNode->left);\\n                        \\n                    if(currNode->right)\\n                        nodes.push_back(currNode->right);\\n                }\\n            }\\n            \\n            else\\n            {\\n                TreeNode *currNode = nodes.back();\\n                \\n                if(currNode == levelEnd)\\n                {\\n                    ans.push_back(currAns);\\n                    currAns.clear();\\n\\n                    right = !right;\\n                }\\n                else\\n                {\\n                    nodes.pop_back();\\n                    \\n                    currAns.push_back(currNode->val);\\n\\n                    if(currNode->right)\\n                        nodes.push_front(currNode->right);\\n                    \\n                    if(currNode->left)\\n                        nodes.push_front(currNode->left);\\n                }\\n            }\\n        }\\n        ans.push_back(currAns);        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) \\n    {        \\n        vector<vector<int>> ans;\\n        \\n        if(!root)\\n            return ans;\\n        \\n        deque<TreeNode*> nodes;\\n        \\n        bool right = true;\\n        \\n        TreeNode *levelEnd = new TreeNode(-1);\\n        \\n        nodes.push_back(root);\\n        nodes.push_back(levelEnd);\\n        \\n        vector<int> currAns;\\n        \\n        while(nodes.size() > 1)\\n        {\\n            if(right)\\n            {\\n                TreeNode *currNode = nodes.front();\\n                \\n                if(currNode == levelEnd)\\n                {\\n                    ans.push_back(currAns);\\n                    currAns.clear();\\n\\n                    right = !right;\\n                }\\n                else\\n                {\\n                    nodes.pop_front();\\n                    \\n                    currAns.push_back(currNode->val);\\n                    \\n                    if(currNode->left)\\n                        nodes.push_back(currNode->left);\\n                        \\n                    if(currNode->right)\\n                        nodes.push_back(currNode->right);\\n                }\\n            }\\n            \\n            else\\n            {\\n                TreeNode *currNode = nodes.back();\\n                \\n                if(currNode == levelEnd)\\n                {\\n                    ans.push_back(currAns);\\n                    currAns.clear();\\n\\n                    right = !right;\\n                }\\n                else\\n                {\\n                    nodes.pop_back();\\n                    \\n                    currAns.push_back(currNode->val);\\n\\n                    if(currNode->right)\\n                        nodes.push_front(currNode->right);\\n                    \\n                    if(currNode->left)\\n                        nodes.push_front(currNode->left);\\n                }\\n            }\\n        }\\n        ans.push_back(currAns);        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33969,
                "title": "simple-java-solution-same-as-level-order-traversal-with-a-flag-no-recursion",
                "content": "```\\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if(root==null) return result;\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        Boolean reverse = false;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> temp = new ArrayList<>();\\n            for(int i=0;i<size;i++){\\n                TreeNode node = q.poll();\\n                if(!reverse)\\n                    temp.add(node.val);\\n                else\\n                    temp.add(0,node.val);\\n                if(node.left!=null) q.add(node.left);\\n                if(node.right!= null) q.add(node.right);\\n            }\\n            result.add(temp);\\n            reverse=!reverse;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if(root==null) return result;\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        Boolean reverse = false;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> temp = new ArrayList<>();\\n            for(int i=0;i<size;i++){\\n                TreeNode node = q.poll();\\n                if(!reverse)\\n                    temp.add(node.val);\\n                else\\n                    temp.add(0,node.val);\\n                if(node.left!=null) q.add(node.left);\\n                if(node.right!= null) q.add(node.right);\\n            }\\n            result.add(temp);\\n            reverse=!reverse;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 34032,
                "title": "4ms-concise-dfs-c-implementation",
                "content": "1 Calculate depth in each recursion.\\n2 Switch directions for adding current value based on (depth % 2).\\n\\n      vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n            vector<vector<int>> rst;\\n            traverse(root, 0, rst);\\n            return rst;\\n        }\\n        \\n    void traverse(TreeNode* root, int depth, vector<vector<int>> & rst) {\\n        if (!root)\\n            return;\\n        if (rst.size() == depth) {\\n            vector<int> temp;\\n            rst.push_back(temp);\\n        }\\n        if (depth % 2 == 0)   \\n            rst[depth].push_back(root ->val);\\n        else{\\n            rst[depth].insert(rst[depth].begin(), root -> val);   \\n        }\\n        traverse(root -> left, depth + 1, rst);  \\n        traverse(root -> right, depth  +1, rst);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "1 Calculate depth in each recursion.\\n2 Switch directions for adding current value based on (depth % 2).\\n\\n      vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n            vector<vector<int>> rst;\\n            traverse(root, 0, rst);\\n            return rst;\\n        }\\n        \\n    void traverse(TreeNode* root, int depth, vector<vector<int>> & rst) {\\n        if (!root)\\n            return;\\n        if (rst.size() == depth) {\\n            vector<int> temp;\\n            rst.push_back(temp);\\n        }\\n        if (depth % 2 == 0)   \\n            rst[depth].push_back(root ->val);\\n        else{\\n            rst[depth].insert(rst[depth].begin(), root -> val);   \\n        }\\n        traverse(root -> left, depth + 1, rst);  \\n        traverse(root -> right, depth  +1, rst);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 34126,
                "title": "consice-recursive-c-solution",
                "content": "The idea is to solve the problem normally if it was about traversing every level separately then reverse odd rows.\\n\\n    class Solution {\\n    public:\\n        void build(TreeNode* n, vector<vector<int>>& R, int d) {\\n            if (!n) return;\\n            if (d == R.size()) R.push_back(vector<int>());\\n            R[d].push_back(n->val);\\n            build(n->left, R, d + 1);\\n            build(n->right, R, d + 1);\\n        }\\n        \\n        vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n            vector<vector<int>> R;\\n            build(root, R, 0);\\n            for (int i = 1; i < R.size(); i += 2) reverse(R[i].begin(), R[i].end());\\n            return R;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void build(TreeNode* n, vector<vector<int>>& R, int d) {\\n            if (!n) return;\\n            if (d == R.size()) R.push_back(vector<int>());\\n            R[d].push_back(n->val);\\n            build(n->left, R, d + 1);\\n            build(n->right, R, d + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 34034,
                "title": "accepted-c-recursive-solution-with-no-queues",
                "content": "Simple algorithm: \\n\\n 1. do depth first recursive tree search\\n 2. populate all vectors for each tree level from left to right\\n 3. reverse even levels to conform with zigzar requirement\\n\\n.\\n\\n    class Solution {\\n    vector<vector<int> > result;\\n    public:\\n    vector<vector<int> > zigzagLevelOrder(TreeNode *root) {\\n        \\n        if(root!=NULL)\\n        {\\n            traverse(root, 0);\\n        }\\n        \\n        for(int i=1;i<result.size();i+=2)\\n        {\\n            vector<int>* v = &result[i];\\n            std:reverse(v->begin(), v->end());\\n        }\\n        return result;\\n    }\\n    \\n    void traverse(TreeNode* node, int level)\\n    {\\n        if(node == NULL) return;\\n        \\n        vector<int>* row = getRow(level);\\n        row->push_back(node->val);\\n        \\n        traverse(node->left, level+1);\\n        traverse(node->right, level+1);\\n    }\\n    \\n    vector<int>* getRow(int level)\\n    {\\n        if(result.size()<=level)\\n        {\\n            vector<int> newRow;\\n            result.push_back(newRow);\\n        }\\n        return &result[level];\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    vector<vector<int> > result;\\n    public:\\n    vector<vector<int> > zigzagLevelOrder(TreeNode *root) {\\n        \\n        if(root!=NULL)\\n        {\\n            traverse(root, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3516663,
                "title": "intutive-c-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        int c=0;\\n        vector<vector<int>>v;\\n         if(!root)\\n         return {};\\n\\n         q.push(root);\\n         \\n\\n         while(!q.empty()){\\n             vector<int>a;\\n             int size=q.size();\\n             c++;\\n\\n             while(size--){\\n                 TreeNode* curr=q.front();\\n                 q.pop();\\n\\n                 \\n\\n                 a.push_back(curr->val);\\n                 if(curr->left)\\n                 q.push(curr->left);\\n\\n                 if(curr->right)\\n                 q.push(curr->right);\\n             }\\n             if(c%2==0)\\n             reverse(a.begin(),a.end());\\n             v.push_back(a);\\n\\n         }\\n         return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        int c=0;\\n        vector<vector<int>>v;\\n         if(!root)\\n         return {};\\n\\n         q.push(root);\\n         \\n\\n         while(!q.empty()){\\n             vector<int>a;\\n             int size=q.size();\\n             c++;\\n\\n             while(size--){\\n                 TreeNode* curr=q.front();\\n                 q.pop();\\n\\n                 \\n\\n                 a.push_back(curr->val);\\n                 if(curr->left)\\n                 q.push(curr->left);\\n\\n                 if(curr->right)\\n                 q.push(curr->right);\\n             }\\n             if(c%2==0)\\n             reverse(a.begin(),a.end());\\n             v.push_back(a);\\n\\n         }\\n         return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366117,
                "title": "easiest-java-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/967e082c-1572-4190-a249-35b49767a9a2_1680359653.9038227.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        // Create a queue to store the tree nodes\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\n        // Create an array list to store the final result\\n        List<List<Integer>> wrapList = new ArrayList<>();\\n     \\n        // If the root node is null, return an empty list\\n        if(root == null){\\n            return wrapList;\\n        }\\n     \\n        // Add the root node to the queue\\n        queue.add(root);\\n     \\n        // Set the flag to true for left to right traversal\\n        boolean flag = true;\\n     \\n        // Traverse the tree level by level\\n        while(!queue.isEmpty()){\\n            \\n            // Get the number of nodes at the current level\\n            int size = queue.size();\\n\\n            // Create an array list to store the nodes\\' values at the current level\\n            List<Integer> subList = new ArrayList<>();\\n         \\n            // Traverse the nodes at the current level\\n            for(int i =0; i < size; i++){\\n\\n                // Check the left and right child of the current node and add them to the queue if they are not null\\n                if(queue.peek().left != null){\\n                    queue.add(queue.peek().left);\\n                }\\n                if(queue.peek().right != null){\\n                    queue.add(queue.peek().right);\\n                }\\n\\n                // For left to right traversal\\n                if(flag == true){\\n                    // Add the node\\'s value to the end of the subList\\n                    subList.add(queue.poll().val);\\n                }\\n                // For right to left traversal\\n                else{\\n                    // Add the node\\'s value to the beginning of the subList\\n                    subList.add(0,queue.poll().val);\\n                }\\n            }\\n            // Toggle the flag to switch between left to right and right to left traversal\\n            flag = !flag;\\n         \\n            // Add the subList to the wrapList\\n            wrapList.add(subList);\\n        }\\n        // Return the final result\\n        return wrapList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        // Create a queue to store the tree nodes\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\n        // Create an array list to store the final result\\n        List<List<Integer>> wrapList = new ArrayList<>();\\n     \\n        // If the root node is null, return an empty list\\n        if(root == null){\\n            return wrapList;\\n        }\\n     \\n        // Add the root node to the queue\\n        queue.add(root);\\n     \\n        // Set the flag to true for left to right traversal\\n        boolean flag = true;\\n     \\n        // Traverse the tree level by level\\n        while(!queue.isEmpty()){\\n            \\n            // Get the number of nodes at the current level\\n            int size = queue.size();\\n\\n            // Create an array list to store the nodes\\' values at the current level\\n            List<Integer> subList = new ArrayList<>();\\n         \\n            // Traverse the nodes at the current level\\n            for(int i =0; i < size; i++){\\n\\n                // Check the left and right child of the current node and add them to the queue if they are not null\\n                if(queue.peek().left != null){\\n                    queue.add(queue.peek().left);\\n                }\\n                if(queue.peek().right != null){\\n                    queue.add(queue.peek().right);\\n                }\\n\\n                // For left to right traversal\\n                if(flag == true){\\n                    // Add the node\\'s value to the end of the subList\\n                    subList.add(queue.poll().val);\\n                }\\n                // For right to left traversal\\n                else{\\n                    // Add the node\\'s value to the beginning of the subList\\n                    subList.add(0,queue.poll().val);\\n                }\\n            }\\n            // Toggle the flag to switch between left to right and right to left traversal\\n            flag = !flag;\\n         \\n            // Add the subList to the wrapList\\n            wrapList.add(subList);\\n        }\\n        // Return the final result\\n        return wrapList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203820,
                "title": "python-c-simple-solution-using-bfs-iterative-manner-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code Upvote Please \\uD83D\\uDE4C\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result=[]\\n        if not root:\\n            return []\\n        queue = [root]\\n        level=0\\n        while queue:\\n            rev = []\\n            for i in range(len(queue)):\\n                curr = queue.pop(0)\\n                rev.append(curr.val)\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n            if level%2:\\n                result.append(rev[::-1])\\n            else: \\n                result.append(rev)\\n            level += 1\\n        return result\\n```\\n\\n# Find Helpful Please Upvote \\uD83E\\uDD1E\\uD83D\\uDE09",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result=[]\\n        if not root:\\n            return []\\n        queue = [root]\\n        level=0\\n        while queue:\\n            rev = []\\n            for i in range(len(queue)):\\n                curr = queue.pop(0)\\n                rev.append(curr.val)\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n            if level%2:\\n                result.append(rev[::-1])\\n            else: \\n                result.append(rev)\\n            level += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197613,
                "title": "c-o-n-100-fast-using-level-order-traversal-explained-using-comments",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will do Level Order Traversal for each level.\\nTake a integer and for each increasing level we will also increment this integer and also push elements of level in a 1D vector and when this integer is divisible by 2, we will reverse the vector and then push back this vector to the 2D vector. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for queue and vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) \\n    {\\n        int i=0;\\n        vector<vector<int>> v;\\n        // <<IF THE ROOT IS null>>\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        TreeNode* t=root;\\n        // <<PUSH THE ROOT NODE IN THE QUEUE>>\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            // INCREMENT THE INTEGER FOR EVERY LEVEL\\n            i++;\\n            vector<int> v1;\\n            int s=q.size();\\n            // <<ITERATING OVER THE CURRENT SIZE OF THE QUEUE>>\\n            for(int i=0;i<s;i++)\\n            {\\n                t=q.front();\\n                v1.push_back(t->val);\\n                q.pop();\\n                if(t->left)q.push(t->left);\\n                if(t->right)q.push(t->right);\\n            }\\n            // <<IF THE INT IS DIVISIBLE BY 2 THEN REVERSE THE 1D VECTOR>>\\n            if(i%2==0)\\n                reverse(v1.begin(),v1.end());\\n            // <<PUSHING 1D VECTOR IN FINAL 2D VECTOR>>\\n            v.push_back(v1);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) \\n    {\\n        int i=0;\\n        vector<vector<int>> v;\\n        // <<IF THE ROOT IS null>>\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        TreeNode* t=root;\\n        // <<PUSH THE ROOT NODE IN THE QUEUE>>\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            // INCREMENT THE INTEGER FOR EVERY LEVEL\\n            i++;\\n            vector<int> v1;\\n            int s=q.size();\\n            // <<ITERATING OVER THE CURRENT SIZE OF THE QUEUE>>\\n            for(int i=0;i<s;i++)\\n            {\\n                t=q.front();\\n                v1.push_back(t->val);\\n                q.pop();\\n                if(t->left)q.push(t->left);\\n                if(t->right)q.push(t->right);\\n            }\\n            // <<IF THE INT IS DIVISIBLE BY 2 THEN REVERSE THE 1D VECTOR>>\\n            if(i%2==0)\\n                reverse(v1.begin(),v1.end());\\n            // <<PUSHING 1D VECTOR IN FINAL 2D VECTOR>>\\n            v.push_back(v1);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178070,
                "title": "two-stack-approach-c-solution",
                "content": "This can be solve using two stack current and next.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(TreeNode* root,vector<vector<int>> &ans){\\n        if(root==NULL) return ;\\n        \\n        stack<TreeNode*> curr;\\n        stack<TreeNode*> next;\\n        \\n        bool leftToRight=true;\\n        \\n\\t\\t//push  root to the curr\\n        curr.push(root);\\n         vector<int> v;\\n        while(!curr.empty()){\\n            TreeNode* node=curr.top();\\n            curr.pop();\\n            if(node){\\n                v.push_back(node->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//add data in the next according to the order (leftToRight)\\n                if(leftToRight){\\n                    if(node->left){\\n                        next.push(node->left);\\n                    }\\n                    if(node->right){\\n                        next.push(node->right);\\n                    }\\n                }\\n                else{\\n                    if(node->right){\\n                        next.push(node->right);\\n                    }\\n                    if(node->left){\\n                        next.push(node->left);\\n                    }\\n                }\\n            }\\n            \\n            if(curr.empty()){\\n                ans.push_back(v);\\n                leftToRight=!leftToRight;\\n                swap(curr,next);\\n                v.clear();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Time complexity:** **O(n)** (We are traversing through all nodes once )\\n**Space complexity:** **O(n) + O(n)** (For two stacks curr and next)",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(TreeNode* root,vector<vector<int>> &ans){\\n        if(root==NULL) return ;\\n        \\n        stack<TreeNode*> curr;\\n        stack<TreeNode*> next;\\n        \\n        bool leftToRight=true;\\n        \\n\\t\\t//push  root to the curr\\n        curr.push(root);\\n         vector<int> v;\\n        while(!curr.empty()){\\n            TreeNode* node=curr.top();\\n            curr.pop();\\n            if(node){\\n                v.push_back(node->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//add data in the next according to the order (leftToRight)\\n                if(leftToRight){\\n                    if(node->left){\\n                        next.push(node->left);\\n                    }\\n                    if(node->right){\\n                        next.push(node->right);\\n                    }\\n                }\\n                else{\\n                    if(node->right){\\n                        next.push(node->right);\\n                    }\\n                    if(node->left){\\n                        next.push(node->left);\\n                    }\\n                }\\n            }\\n            \\n            if(curr.empty()){\\n                ans.push_back(v);\\n                leftToRight=!leftToRight;\\n                swap(curr,next);\\n                v.clear();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581148,
                "title": "java-dfs-based-solution-beats-100",
                "content": "Using dfs to generate level order traversal and then reversing every odd level.\\n```\\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        dfs(root,0,ans);\\n        for(int i = 0; i < ans.size(); i++) if((i&1) == 1) Collections.reverse(ans.get(i));\\n        return ans;\\n    }\\n    public void dfs(TreeNode root,int level,List<List<Integer>> list){\\n        if(root == null) return;\\n        if(list.size() == level) list.add(new ArrayList<>());\\n        list.get(level).add(root.val);\\n        dfs(root.left,level+1,list);\\n        dfs(root.right,level+1,list);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        dfs(root,0,ans);\\n        for(int i = 0; i < ans.size(); i++) if((i&1) == 1) Collections.reverse(ans.get(i));\\n        return ans;\\n    }\\n    public void dfs(TreeNode root,int level,List<List<Integer>> list){\\n        if(root == null) return;\\n        if(list.size() == level) list.add(new ArrayList<>());\\n        list.get(level).add(root.val);\\n        dfs(root.left,level+1,list);\\n        dfs(root.right,level+1,list);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305512,
                "title": "bfs-c-0ms-simple-solution",
                "content": "This is not the best solution to this problem. This is just an approach in which I am using a bool variable for the zigzag traversal along with an eliminator for clearing out temp before reaching next level.\\n \\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root)\\n     {\\n        \\n\\t\\tif(root == NULL)\\n            return {};\\n\\t\\t\\t\\n        vector<vector<int> > ans;\\n        deque<TreeNode*> deque;\\n        TreeNode* eliminator = new TreeNode(404);\\n        bool right = true;\\n        vector<int> temp;\\n        \\n        deque.push_back(root);\\n        deque.push_back(eliminator);\\n        \\n        while(deque.size() > 1)\\n        {   \\n            if(right)\\n            {\\n                TreeNode* front = deque.front();\\n                \\n                if(front == eliminator)\\n                {\\n                    ans.push_back(temp);\\n                    right = !right;\\n                    temp.clear();\\n                }\\n                \\n                else\\n                {\\n                    temp.push_back(front->val);\\n                    deque.pop_front(); \\n                    \\n                    if(front->left)\\n                       deque.push_back(front->left);\\n                    if(front->right)\\n                       deque.push_back(front->right);      \\n                }\\n            }\\n            \\n            else\\n            {\\n                TreeNode* back = deque.back();\\n                \\n                if(back == eliminator)\\n                {\\n                    ans.push_back(temp);\\n                    right = !right;\\n                    temp.clear();\\n                }\\n                \\n                else\\n                {\\n                    temp.push_back(back->val);\\n                    deque.pop_back();\\n                    \\n                    if(back->right)\\n                       deque.push_front(back->right); \\n                    if(back->left)\\n                       deque.push_front(back->left);\\n                }\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "This is not the best solution to this problem. This is just an approach in which I am using a bool variable for the zigzag traversal along with an eliminator for clearing out temp before reaching next level.\\n \\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root)\\n     {\\n        \\n\\t\\tif(root == NULL)\\n            return {};\\n\\t\\t\\t\\n        vector<vector<int> > ans;\\n        deque<TreeNode*> deque;\\n        TreeNode* eliminator = new TreeNode(404);\\n        bool right = true;\\n        vector<int> temp;\\n        \\n        deque.push_back(root);\\n        deque.push_back(eliminator);\\n        \\n        while(deque.size() > 1)\\n        {   \\n            if(right)\\n            {\\n                TreeNode* front = deque.front();\\n                \\n                if(front == eliminator)\\n                {\\n                    ans.push_back(temp);\\n                    right = !right;\\n                    temp.clear();\\n                }\\n                \\n                else\\n                {\\n                    temp.push_back(front->val);\\n                    deque.pop_front(); \\n                    \\n                    if(front->left)\\n                       deque.push_back(front->left);\\n                    if(front->right)\\n                       deque.push_back(front->right);      \\n                }\\n            }\\n            \\n            else\\n            {\\n                TreeNode* back = deque.back();\\n                \\n                if(back == eliminator)\\n                {\\n                    ans.push_back(temp);\\n                    right = !right;\\n                    temp.clear();\\n                }\\n                \\n                else\\n                {\\n                    temp.push_back(back->val);\\n                    deque.pop_back();\\n                    \\n                    if(back->right)\\n                       deque.push_front(back->right); \\n                    if(back->left)\\n                       deque.push_front(back->left);\\n                }\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1233203,
                "title": "java-solution-using-bfs-with-comments-time-and-space-o-n",
                "content": "This is a typical level order traversal with the only difference being that we need to keep track of the direction in which our node values in each level will be returned. If we want a left to right result, we insert values at the end of the list. Otherwise, we insert values at the beginning of the list to achieve a right to left result. For this, we will use a boolean variable to keep track of the direction to traverse.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        // initialize an empty result list\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\n        // edge case\\n        if (root == null) return result;\\n        \\n        // boolean variable to keep track of the direction to traverse nodes in a level\\n        boolean leftToRight = true;\\n        \\n        // we\\'ll be doing a BFS traversal\\n        // so declare an empty queue\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int levelSize = queue.size();\\n            \\n            // we\\'ll use LinkedList here instead of ArrayList\\n            // since for right to left traversal\\n            // we will insert node values at the beginning\\n            // and with LinkedList we won\\'t have to shift elements to the right when we do so\\n            // which is the case in ArrayList\\n            List<Integer> currentLevel = new LinkedList<>();\\n            \\n            for (int i = 0; i < levelSize; i++) {\\n                TreeNode currentNode = queue.poll();\\n                \\n                if (leftToRight) {\\n                    // add node value to end of list\\n                    currentLevel.add(currentNode.val);\\n                } else {\\n                    // add node value to beginning of list\\n                    currentLevel.add(0, currentNode.val);\\n                }\\n                \\n                // add the children of the node to the queue\\n                if (currentNode.left != null) {\\n                    queue.offer(currentNode.left);\\n                }\\n                \\n                if (currentNode.right != null) {\\n                    queue.offer(currentNode.right);\\n                }\\n            }\\n            \\n            result.add(currentLevel);\\n            \\n            // reverse the direction for next level\\n            leftToRight = !leftToRight;\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "This is a typical level order traversal with the only difference being that we need to keep track of the direction in which our node values in each level will be returned. If we want a left to right result, we insert values at the end of the list. Otherwise, we insert values at the beginning of the list to achieve a right to left result. For this, we will use a boolean variable to keep track of the direction to traverse.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        // initialize an empty result list\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\n        // edge case\\n        if (root == null) return result;\\n        \\n        // boolean variable to keep track of the direction to traverse nodes in a level\\n        boolean leftToRight = true;\\n        \\n        // we\\'ll be doing a BFS traversal\\n        // so declare an empty queue\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int levelSize = queue.size();\\n            \\n            // we\\'ll use LinkedList here instead of ArrayList\\n            // since for right to left traversal\\n            // we will insert node values at the beginning\\n            // and with LinkedList we won\\'t have to shift elements to the right when we do so\\n            // which is the case in ArrayList\\n            List<Integer> currentLevel = new LinkedList<>();\\n            \\n            for (int i = 0; i < levelSize; i++) {\\n                TreeNode currentNode = queue.poll();\\n                \\n                if (leftToRight) {\\n                    // add node value to end of list\\n                    currentLevel.add(currentNode.val);\\n                } else {\\n                    // add node value to beginning of list\\n                    currentLevel.add(0, currentNode.val);\\n                }\\n                \\n                // add the children of the node to the queue\\n                if (currentNode.left != null) {\\n                    queue.offer(currentNode.left);\\n                }\\n                \\n                if (currentNode.right != null) {\\n                    queue.offer(currentNode.right);\\n                }\\n            }\\n            \\n            result.add(currentLevel);\\n            \\n            // reverse the direction for next level\\n            leftToRight = !leftToRight;\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 253819,
                "title": "java-four-solutions-with-explanations",
                "content": "Four solutions can be used to solve this problem that are:\\n\\n- Deque\\n- Queue with Linked List\\n- Recursive\\n- Double Stack\\n\\nPlease check below for details.\\n\\n### Solution 1: Deque\\n**Idea:**\\n- If direction is left->right, poll nodes from end, offer left and right childs to the front\\n- If direction is right->left, poll nodes from front, offer right and left childs to the end\\n\\n**Code:**\\n```java\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (root == null) {\\n            return result;\\n        }\\n        Deque<TreeNode> deque = new LinkedList<>();\\n        deque.offerLast(root);\\n        boolean direction = true; // true: left->right, false: right->left\\n        while (!deque.isEmpty()) {\\n            int length = deque.size(); // Level length\\n            List<Integer> line = new ArrayList<>();\\n            while (length-- > 0) {\\n                TreeNode node = direction ? deque.pollLast() : deque.pollFirst();\\n                line.add(node.val);\\n                if (direction) {\\n                    if (node.left != null) {\\n                        deque.offerFirst(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        deque.offerFirst(node.right);\\n                    }\\n                } else {\\n                    if (node.right != null) {\\n                        deque.offerLast(node.right);\\n                    }\\n                    if (node.left != null) {\\n                        deque.offerLast(node.left);\\n                    }\\n                }\\n            }\\n            direction = !direction;\\n            result.add(line);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n### Solution 2: Queue with Linked List\\n**Idea:**\\n- Poll nodes from queue\\n- If direction is left->right, add values to list\\'s tail\\n- If direction is right->left, add valus to list\\'s head\\n\\n**Reference:**\\n- https://leetcode.com/explore/interview/card/top-interview-questions-medium/108/trees-and-graphs/787/discuss/33814/A-concise-and-easy-understanding-Java-solution\\n\\n**Code:**\\n```java\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (root == null) {\\n            return result;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        boolean direction = true; // true: left->right, false: right->left\\n        while (!queue.isEmpty()) {\\n            int length = queue.size(); // Level length\\n            List<Integer> line = new LinkedList<>(); // Use linked list so that add(0, node.val) is O(1)\\n            while (length-- > 0) {\\n                TreeNode node = queue.poll();\\n                if (direction) {\\n                    line.add(node.val); // Add to tail\\n                } else {\\n                    line.add(0, node.val); // Add to head\\n                }\\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                }\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                }\\n            }\\n            result.add(line);\\n            direction = !direction;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n### Solution 3: Recursive\\n**Idea:**\\n- When traversing the tree recursively, keep track of the current visting level (**beginning from 0**)\\n- If level is odd, add nodes to the list head\\n- If level is even, add nodes to the list tail\\n\\n**Reference:**\\n- https://leetcode.com/explore/interview/card/top-interview-questions-medium/108/trees-and-graphs/787/discuss/33815/My-accepted-JAVA-solution\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        zigzagTraverse(root, result, 0); // Level begins from 0\\n        return result;\\n    }\\n    \\n    private void zigzagTraverse(TreeNode root, List<List<Integer>> result, int level) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (level == result.size()) {\\n            result.add(new LinkedList<>()); // Use linked list so that add(0, val) is O(1)\\n        }\\n        if ((level & 1) == 1) { // Odd level\\n            result.get(level).add(0, root.val);\\n        } else {\\n            result.get(level).add(root.val);\\n        }\\n        zigzagTraverse(root.left, result, level+1);\\n        zigzagTraverse(root.right, result, level+1);\\n    }\\n}\\n```\\n\\n### Solution 4: Double Stack\\n**Idea:**\\n- Travese two stacks seperatedly, and add child nodes to the other stack\\n- When traversing stack1, push childs left to right\\n- When traversing stack2, push childs right to left\\n\\n**Reference:**\\n- https://leetcode.com/explore/interview/card/top-interview-questions-medium/108/trees-and-graphs/787/discuss/33904/JAVA-Double-Stack-Solution\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (root == null) {\\n            return result;\\n        }\\n        Stack<TreeNode> stack1 = new Stack<>();\\n        Stack<TreeNode> stack2 = new Stack<>();\\n        stack1.push(root);\\n        while (!stack1.isEmpty() || !stack2.isEmpty()) {\\n            List<Integer> line = new ArrayList<>();\\n            TreeNode node;\\n            while (!stack1.isEmpty()) { // Traverse stack1 and push childs to stack2 left to right\\n                node = stack1.pop();\\n                line.add(node.val);\\n                if (node.left != null) {\\n                    stack2.push(node.left);\\n                }\\n                if (node.right != null) {\\n                    stack2.push(node.right);\\n                }\\n            }\\n            if (!line.isEmpty()) {\\n                result.add(line);\\n            }\\n            line = new ArrayList<>();\\n            while (!stack2.isEmpty()) { // Traverse stack2 and push childs to stack1 right to left\\n                node = stack2.pop();\\n                line.add(node.val);\\n                if (node.right != null) {\\n                    stack1.push(node.right);\\n                }\\n                if (node.left != null) {\\n                    stack1.push(node.left);\\n                }\\n            }\\n            if (!line.isEmpty()) {\\n                result.add(line);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (root == null) {\\n            return result;\\n        }\\n        Deque<TreeNode> deque = new LinkedList<>();\\n        deque.offerLast(root);\\n        boolean direction = true; // true: left->right, false: right->left\\n        while (!deque.isEmpty()) {\\n            int length = deque.size(); // Level length\\n            List<Integer> line = new ArrayList<>();\\n            while (length-- > 0) {\\n                TreeNode node = direction ? deque.pollLast() : deque.pollFirst();\\n                line.add(node.val);\\n                if (direction) {\\n                    if (node.left != null) {\\n                        deque.offerFirst(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        deque.offerFirst(node.right);\\n                    }\\n                } else {\\n                    if (node.right != null) {\\n                        deque.offerLast(node.right);\\n                    }\\n                    if (node.left != null) {\\n                        deque.offerLast(node.left);\\n                    }\\n                }\\n            }\\n            direction = !direction;\\n            result.add(line);\\n        }\\n        return result;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (root == null) {\\n            return result;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        boolean direction = true; // true: left->right, false: right->left\\n        while (!queue.isEmpty()) {\\n            int length = queue.size(); // Level length\\n            List<Integer> line = new LinkedList<>(); // Use linked list so that add(0, node.val) is O(1)\\n            while (length-- > 0) {\\n                TreeNode node = queue.poll();\\n                if (direction) {\\n                    line.add(node.val); // Add to tail\\n                } else {\\n                    line.add(0, node.val); // Add to head\\n                }\\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                }\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                }\\n            }\\n            result.add(line);\\n            direction = !direction;\\n        }\\n        return result;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        zigzagTraverse(root, result, 0); // Level begins from 0\\n        return result;\\n    }\\n    \\n    private void zigzagTraverse(TreeNode root, List<List<Integer>> result, int level) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (level == result.size()) {\\n            result.add(new LinkedList<>()); // Use linked list so that add(0, val) is O(1)\\n        }\\n        if ((level & 1) == 1) { // Odd level\\n            result.get(level).add(0, root.val);\\n        } else {\\n            result.get(level).add(root.val);\\n        }\\n        zigzagTraverse(root.left, result, level+1);\\n        zigzagTraverse(root.right, result, level+1);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (root == null) {\\n            return result;\\n        }\\n        Stack<TreeNode> stack1 = new Stack<>();\\n        Stack<TreeNode> stack2 = new Stack<>();\\n        stack1.push(root);\\n        while (!stack1.isEmpty() || !stack2.isEmpty()) {\\n            List<Integer> line = new ArrayList<>();\\n            TreeNode node;\\n            while (!stack1.isEmpty()) { // Traverse stack1 and push childs to stack2 left to right\\n                node = stack1.pop();\\n                line.add(node.val);\\n                if (node.left != null) {\\n                    stack2.push(node.left);\\n                }\\n                if (node.right != null) {\\n                    stack2.push(node.right);\\n                }\\n            }\\n            if (!line.isEmpty()) {\\n                result.add(line);\\n            }\\n            line = new ArrayList<>();\\n            while (!stack2.isEmpty()) { // Traverse stack2 and push childs to stack1 right to left\\n                node = stack2.pop();\\n                line.add(node.val);\\n                if (node.right != null) {\\n                    stack1.push(node.right);\\n                }\\n                if (node.left != null) {\\n                    stack1.push(node.left);\\n                }\\n            }\\n            if (!line.isEmpty()) {\\n                result.add(line);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377657,
                "title": "easy-clear-solution-python-3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        res=[]\\n        def add(i,tree):\\n            if len(res)<=i:\\n                res.append([tree.val])\\n            else:\\n                res[i].append(tree.val)\\n            i+=1\\n            if tree.left: add(i,tree.left)\\n            if tree.right: add(i,tree.right)\\n        if root:   \\n            add(0,root)\\n        for i in range(len(res)):\\n            if i%2==1:\\n                res[i].reverse()\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        res=[]\\n        def add(i,tree):\\n            if len(res)<=i:\\n                res.append([tree.val])\\n            else:\\n                res[i].append(tree.val)\\n            i+=1\\n            if tree.left: add(i,tree.left)\\n            if tree.right: add(i,tree.right)\\n        if root:   \\n            add(0,root)\\n        for i in range(len(res)):\\n            if i%2==1:\\n                res[i].reverse()\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205284,
                "title": "bfs-level-order-traversal-c",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int level=0;\\n    queue<TreeNode*>tobetraversed;\\n    void Traverse(vector<vector<int>>&ans)\\n    {\\n        int thisiteration=tobetraversed.size();\\n        vector<int>values;\\n        while(thisiteration--)\\n        {\\n            if(tobetraversed.front()==NULL)\\n            {\\n                tobetraversed.pop();\\n                continue;\\n            }\\n            if(tobetraversed.front()->left!=NULL)\\n            {\\n                tobetraversed.push(tobetraversed.front()->left);\\n            }\\n            if(tobetraversed.front()->right!=NULL)\\n            {\\n                tobetraversed.push(tobetraversed.front()->right);\\n            }\\n            values.push_back(tobetraversed.front()->val);\\n            tobetraversed.pop();\\n        }\\n        if(level%2==1)\\n        {\\n            reverse(values.begin(),values.end());\\n        }\\n        level++;\\n        ans.push_back(values);\\n        if(tobetraversed.size()!=0)\\n        {\\n            Traverse(ans);\\n        }\\n        return;\\n    }\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        tobetraversed.push(root);\\n        Traverse(ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int level=0;\\n    queue<TreeNode*>tobetraversed;\\n    void Traverse(vector<vector<int>>&ans)\\n    {\\n        int thisiteration=tobetraversed.size();\\n        vector<int>values;\\n        while(thisiteration--)\\n        {\\n            if(tobetraversed.front()==NULL)\\n            {\\n                tobetraversed.pop();\\n                continue;\\n            }\\n            if(tobetraversed.front()->left!=NULL)\\n            {\\n                tobetraversed.push(tobetraversed.front()->left);\\n            }\\n            if(tobetraversed.front()->right!=NULL)\\n            {\\n                tobetraversed.push(tobetraversed.front()->right);\\n            }\\n            values.push_back(tobetraversed.front()->val);\\n            tobetraversed.pop();\\n        }\\n        if(level%2==1)\\n        {\\n            reverse(values.begin(),values.end());\\n        }\\n        level++;\\n        ans.push_back(values);\\n        if(tobetraversed.size()!=0)\\n        {\\n            Traverse(ans);\\n        }\\n        return;\\n    }\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        tobetraversed.push(root);\\n        Traverse(ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204744,
                "title": "c-3-methods-2queue-1queue",
                "content": "\\n\\n# Method-1 -> By 2 Stacks\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if(root==NULL)return {};\\n        stack<TreeNode*>st1,st2;\\n        st1.push(root);\\n        vector<vector<int>>res;\\n        while(!st1.empty()){\\n            vector<int>t;\\n            while(!st1.empty()){\\n                 TreeNode*p=st1.top();\\n                 st1.pop();\\n                  t.push_back(p->val);\\n                  if(p->left)st2.push(p->left);\\n                  if(p->right)st2.push(p->right);\\n            }\\n            if(t.size()) res.push_back(t);\\n            t={};\\n            while(!st2.empty()){\\n                 TreeNode*p=st2.top();\\n                 st2.pop();\\n                  t.push_back(p->val);\\n                  if(p->right)st1.push(p->right);\\n                  if(p->left)st1.push(p->left);\\n            }\\n            if(t.size()) res.push_back(t);\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Method-2 ->By 2queue\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n    if(!root) return {};\\n    queue<TreeNode*>q1; //this will use for even levels\\n    queue<TreeNode*>q2; //this will use for odd levels\\n    q1.push(root);\\n    q2.push(root);\\n    int lvl=0;\\n    vector<vector<int>>res;\\n    while(!q1.empty()){\\n       int size=q1.size();\\n       vector<int>tmp;\\n       for(int i=0;i<size;i++){\\n        TreeNode*front1=q1.front();\\n        TreeNode*front2=q2.front();\\n        q1.pop();\\n        q2.pop();\\n        if(lvl%2==0) tmp.push_back(front1->val);       \\n        \\n        else tmp.push_back(front2->val);\\n        \\n        \\n        if(front1->left)q1.push(front1->left);\\n        if(front1->right)q1.push(front1->right);\\n         //second queue is for odd levels so first we insert right child then left   \\n        if(front2->right)q2.push(front2->right);\\n        if(front2->left)q2.push(front2->left);\\n            \\n       }\\n       res.push_back(tmp);\\n          lvl++;\\n    }\\n    return res;\\n    }\\n};\\n```\\n# Method-3 By 1 queue\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if(root==NULL)return {};\\n        //optimised one by one queue\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        vector<vector<int>>res;\\n        bool islefttoright=true;\\n        while(!q.empty()){\\n            int s=q.size();\\n            vector<int>t;\\n            for(int i=0;i<s;i++){\\n                  TreeNode*front=q.front();\\n                  q.pop();\\n                 t.push_back(front->val);\\n                  if(front->left)q.push(front->left);\\n                  if(front->right)q.push(front->right);\\n            }\\n            if(!islefttoright){\\n                 reverse(t.begin(),t.end());\\n            }\\n            res.push_back(t);\\n            islefttoright=!islefttoright;\\n          \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if(root==NULL)return {};\\n        stack<TreeNode*>st1,st2;\\n        st1.push(root);\\n        vector<vector<int>>res;\\n        while(!st1.empty()){\\n            vector<int>t;\\n            while(!st1.empty()){\\n                 TreeNode*p=st1.top();\\n                 st1.pop();\\n                  t.push_back(p->val);\\n                  if(p->left)st2.push(p->left);\\n                  if(p->right)st2.push(p->right);\\n            }\\n            if(t.size()) res.push_back(t);\\n            t={};\\n            while(!st2.empty()){\\n                 TreeNode*p=st2.top();\\n                 st2.pop();\\n                  t.push_back(p->val);\\n                  if(p->right)st1.push(p->right);\\n                  if(p->left)st1.push(p->left);\\n            }\\n            if(t.size()) res.push_back(t);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n    if(!root) return {};\\n    queue<TreeNode*>q1; //this will use for even levels\\n    queue<TreeNode*>q2; //this will use for odd levels\\n    q1.push(root);\\n    q2.push(root);\\n    int lvl=0;\\n    vector<vector<int>>res;\\n    while(!q1.empty()){\\n       int size=q1.size();\\n       vector<int>tmp;\\n       for(int i=0;i<size;i++){\\n        TreeNode*front1=q1.front();\\n        TreeNode*front2=q2.front();\\n        q1.pop();\\n        q2.pop();\\n        if(lvl%2==0) tmp.push_back(front1->val);       \\n        \\n        else tmp.push_back(front2->val);\\n        \\n        \\n        if(front1->left)q1.push(front1->left);\\n        if(front1->right)q1.push(front1->right);\\n         //second queue is for odd levels so first we insert right child then left   \\n        if(front2->right)q2.push(front2->right);\\n        if(front2->left)q2.push(front2->left);\\n            \\n       }\\n       res.push_back(tmp);\\n          lvl++;\\n    }\\n    return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if(root==NULL)return {};\\n        //optimised one by one queue\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        vector<vector<int>>res;\\n        bool islefttoright=true;\\n        while(!q.empty()){\\n            int s=q.size();\\n            vector<int>t;\\n            for(int i=0;i<s;i++){\\n                  TreeNode*front=q.front();\\n                  q.pop();\\n                 t.push_back(front->val);\\n                  if(front->left)q.push(front->left);\\n                  if(front->right)q.push(front->right);\\n            }\\n            if(!islefttoright){\\n                 reverse(t.begin(),t.end());\\n            }\\n            res.push_back(t);\\n            islefttoright=!islefttoright;\\n          \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204172,
                "title": "python3-30ms-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing BFS level order traversal we can solve this.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- very simple approach.\\n- traverse left most node then right nodes.\\n- while traversing keep track of level.\\n- if level % 2 == 1 then we do right to left, else left to right.\\n- while traversing if we\\'re on odd level then use stack like structure, like append element at initial index.\\n- while traversing if we\\'re on even level then use queue like structure and append element at last index.\\n- that\\'s it.\\n- now return values of of dictionary we made in list form.\\n\\n# Complexity\\n- Time complexity: O(height of tree+N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        ans = dict()\\n        def bfs(curr=root, level = 0):\\n            nonlocal ans\\n            if curr != None:\\n                if level % 2 == 1: # go right to left, used stack\\n                    if level in ans.keys():\\n                        ans[level].insert(0, curr.val)\\n                    else:\\n                        ans[level] = [curr.val]\\n                else: #go left to right, used queue\\n                    if level in ans.keys():\\n                        ans[level].append(curr.val)\\n                    else:\\n                        ans[level] = [curr.val]\\n                bfs(curr.left, level + 1)\\n                bfs(curr.right, level + 1)\\n            return\\n        bfs()\\n        return ans.values()\\n```\\n# Please Like and comment below.\\n# (>\\u203F\\u25E0)\\u270C",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        ans = dict()\\n        def bfs(curr=root, level = 0):\\n            nonlocal ans\\n            if curr != None:\\n                if level % 2 == 1: # go right to left, used stack\\n                    if level in ans.keys():\\n                        ans[level].insert(0, curr.val)\\n                    else:\\n                        ans[level] = [curr.val]\\n                else: #go left to right, used queue\\n                    if level in ans.keys():\\n                        ans[level].append(curr.val)\\n                    else:\\n                        ans[level] = [curr.val]\\n                bfs(curr.left, level + 1)\\n                bfs(curr.right, level + 1)\\n            return\\n        bfs()\\n        return ans.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109302,
                "title": "using-two-stacks-optimised-solution-c-commented-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI\\'m using two stacks for this problem as it would take lesser time as each node will go inside the stack once and come out of the stack once. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will create two stacks, one stack will contain the elements in the level order transversal format i.e. left to right and another will contain in the reverse form. \\nFurther explanation is in the code itself.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> res;\\n        if(!root)\\n            return res;    // if root is empty just return empty vector\\n        stack<TreeNode*> s1,s2; // initialise two stacks\\n        s1.push(root); // put root inside the first stack\\n        vector<int> curr;  // a vector to contain the elements in the current level\\n        while(!s1.empty() || !s2.empty()){  // run loop till both of them are empty\\n            curr.resize(0);      // keep the size 0 before going and after coming from a stack\\n            while(!s1.empty()){    // run a loop till first stack is empty\\n                    TreeNode* temp=s1.top();  // create a node with the top ele. of stack1\\n                    curr.push_back(temp->val); //push the value in curr vector\\n                    s1.pop();     // remove the topmost ele.\\n                    if(temp->left)         // if it has left root push inside stack2 \\n                        s2.push(temp->left); // *notice left child is entered first if present*\\n                    if(temp->right)     // similarly for right child\\n                        s2.push(temp->right);\\n            }\\n            if(s1.empty() && curr.size()>0)  // if curr size > 0 only then push curr vector otherwise an empty array will be pushed which we don\\'t want\\n                res.push_back(curr); //push one level\\n            \\n            curr.resize(0); // this is important as we\\'ve to resize this vector to 0 for another level now\\n            while(!s2.empty()){       // loop runs exactly the same as stack1 loop \\n                    TreeNode* temp=s2.top();\\n                    curr.push_back(temp->val);\\n                    s2.pop();\\n                    if(temp->right)  // * only difference is we will push the right child first if present to maintain a zig zag order*\\n                        s1.push(temp->right);\\n                    if(temp->left)\\n                        s1.push(temp->left);\\n            }\\n            if(s2.empty() && curr.size()>0)\\n                res.push_back(curr);  // push this level\\n        }\\n        return res; // return the result vector\\n    }\\n};\\n```\\n\\n# Please upvote if you found it helpful.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> res;\\n        if(!root)\\n            return res;    // if root is empty just return empty vector\\n        stack<TreeNode*> s1,s2; // initialise two stacks\\n        s1.push(root); // put root inside the first stack\\n        vector<int> curr;  // a vector to contain the elements in the current level\\n        while(!s1.empty() || !s2.empty()){  // run loop till both of them are empty\\n            curr.resize(0);      // keep the size 0 before going and after coming from a stack\\n            while(!s1.empty()){    // run a loop till first stack is empty\\n                    TreeNode* temp=s1.top();  // create a node with the top ele. of stack1\\n                    curr.push_back(temp->val); //push the value in curr vector\\n                    s1.pop();     // remove the topmost ele.\\n                    if(temp->left)         // if it has left root push inside stack2 \\n                        s2.push(temp->left); // *notice left child is entered first if present*\\n                    if(temp->right)     // similarly for right child\\n                        s2.push(temp->right);\\n            }\\n            if(s1.empty() && curr.size()>0)  // if curr size > 0 only then push curr vector otherwise an empty array will be pushed which we don\\'t want\\n                res.push_back(curr); //push one level\\n            \\n            curr.resize(0); // this is important as we\\'ve to resize this vector to 0 for another level now\\n            while(!s2.empty()){       // loop runs exactly the same as stack1 loop \\n                    TreeNode* temp=s2.top();\\n                    curr.push_back(temp->val);\\n                    s2.pop();\\n                    if(temp->right)  // * only difference is we will push the right child first if present to maintain a zig zag order*\\n                        s1.push(temp->right);\\n                    if(temp->left)\\n                        s1.push(temp->left);\\n            }\\n            if(s2.empty() && curr.size()>0)\\n                res.push_back(curr);  // push this level\\n        }\\n        return res; // return the result vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576919,
                "title": "easy-java-solution-straight-forward-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Queue<TreeNode> q = new LinkedList<>();\\n        int j = 0;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> al = new ArrayList<>();\\n            for(int i = 0 ; i < size; i ++){\\n                TreeNode node = q.poll();\\n                al.add(node.val);\\n                if(node.left != null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    q.offer(node.right);\\n                }\\n            }\\n            if(j%2 == 1){\\n                Collections.reverse(al);\\n            }\\n            ans.add(new ArrayList<>(al));\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Queue<TreeNode> q = new LinkedList<>();\\n        int j = 0;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> al = new ArrayList<>();\\n            for(int i = 0 ; i < size; i ++){\\n                TreeNode node = q.poll();\\n                al.add(node.val);\\n                if(node.left != null){\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null){\\n                    q.offer(node.right);\\n                }\\n            }\\n            if(j%2 == 1){\\n                Collections.reverse(al);\\n            }\\n            ans.add(new ArrayList<>(al));\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603111,
                "title": "fastest-c-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n      \\n        vector<vector<int>> v;\\n        \\n        if(root==NULL)\\n            return v;\\n        queue <TreeNode *>q;\\n        q.push(root);int flag=0;\\n        while(!q.empty())\\n        {    int n=q.size();\\n             vector<int> ans;\\n             for(int i=0;i<n;i++){\\n             \\n             TreeNode *temp=q.front();\\n             q.pop();\\n         \\n             if(temp->left)q.push(temp->left);\\n             if(temp->right)q.push(temp->right);\\n             ans.push_back(temp->val);\\n         }\\n            \\n        \\n        \\n        if(flag==1)\\n        {\\n            reverse(ans.begin(),ans.end());\\n            flag=0;\\n        }\\n        else\\n         {\\n             flag=1;\\n         }\\n        v.push_back(ans);\\n        \\n        \\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n      \\n        vector<vector<int>> v;\\n        \\n        if(root==NULL)\\n            return v;\\n        queue <TreeNode *>q;\\n        q.push(root);int flag=0;\\n        while(!q.empty())\\n        {    int n=q.size();\\n             vector<int> ans;\\n             for(int i=0;i<n;i++){\\n             \\n             TreeNode *temp=q.front();\\n             q.pop();\\n         \\n             if(temp->left)q.push(temp->left);\\n             if(temp->right)q.push(temp->right);\\n             ans.push_back(temp->val);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1482965,
                "title": "my-c-0ms-faster-than-100-solution-with-simple-explanation",
                "content": "One thing to notice is that whenever we encounter a problem having something related to level order than BFS must come in our mind. Hence by using queue we can push all children level by level and do the required thing as asked in problem statement.\\n\\nHere we can see that on zero level we want ans vector to have elements from left to right , on one level we need elements from right to left and so on the pattern continues.\\n\\nSo our approach will be to store elements from left to right on even level and right to left on odd level.\\n\\nBelow is the code which will explain the above things with implementation :\\n\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root)\\n    {\\n        vector<vector<int>> ans; // Storing answer\\n        map<int, deque<int>> m; // Storing level wise elements and taking Deque to store elemets from left to right or vice versa\\n\\n        if(root == NULL) // Handling edge cases right upfront\\n            return ans;\\n\\n        queue<pair<TreeNode*, int>> q; // queue to store address and id(level) of node\\n        q.push({root, 0}); // Root node with id = 0\\n\\n        while(q.size())\\n        {\\n            TreeNode* cur = q.front().F;\\n            int id = q.front().S;\\n            q.pop();\\n\\n            if(id % 2) // if level is odd then we need elements from right to left\\n                m[id].push_front(cur->val);\\n\\n            else       // if level is even then we need elements from left to right\\n                m[id].push_back(cur->val);\\n\\n            // pushing right and left child if they are not null with incrementing id(level)\\n\\n            if(cur->left)\\n                q.push({cur->left, id + 1});\\n\\n            if(cur->right)\\n                q.push({cur->right, id + 1});\\n\\n        }\\n\\n        for(auto it = m.begin(); it != m.end(); it++)\\n        {\\n            vector<int> mid;\\n\\n            while(i->second.size()) // retrieving elements from deque\\n            {\\n                mid.P_B(i->second.front());\\n                i->second.pop_front();\\n\\n            }\\n\\n            ans.push_back(mid); // pushing into answer vector\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root)\\n    {\\n        vector<vector<int>> ans; // Storing answer\\n        map<int, deque<int>> m; // Storing level wise elements and taking Deque to store elemets from left to right or vice versa\\n\\n        if(root == NULL) // Handling edge cases right upfront\\n            return ans;\\n\\n        queue<pair<TreeNode*, int>> q; // queue to store address and id(level) of node\\n        q.push({root, 0}); // Root node with id = 0\\n\\n        while(q.size())\\n        {\\n            TreeNode* cur = q.front().F;\\n            int id = q.front().S;\\n            q.pop();\\n\\n            if(id % 2) // if level is odd then we need elements from right to left\\n                m[id].push_front(cur->val);\\n\\n            else       // if level is even then we need elements from left to right\\n                m[id].push_back(cur->val);\\n\\n            // pushing right and left child if they are not null with incrementing id(level)\\n\\n            if(cur->left)\\n                q.push({cur->left, id + 1});\\n\\n            if(cur->right)\\n                q.push({cur->right, id + 1});\\n\\n        }\\n\\n        for(auto it = m.begin(); it != m.end(); it++)\\n        {\\n            vector<int> mid;\\n\\n            while(i->second.size()) // retrieving elements from deque\\n            {\\n                mid.P_B(i->second.front());\\n                i->second.pop_front();\\n\\n            }\\n\\n            ans.push_back(mid); // pushing into answer vector\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211672,
                "title": "c-simple-solution-space-and-time-less-than-82-08-bfs",
                "content": "In this question , we again use **BFS** for level order traversal , and as we can predict from output that levels on odd layers are being reversed . So thats the technique we have used here.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode *> q;    //Initialising queue , (for bfs mostly we use queue) \\n        vector<vector<int>> ans;    //ans 2D vector\\n        int c=0;    //count variable\\n        if(!root)\\n            return ans; //To handle the edge test case i.e. if NULL tree is provided\\n        q.push(root);   //now we push the whole root node in the queue\\n        while(!q.empty())\\n        {\\n            int s = q.size();   //we take the size beforehand so that the changes made inside the loop doesnt affect , how many times it will run\\n            vector<int> vec;    //1D vector to store values \\n            c++;    //we increase count vector every time we go to one layer deep \\n            for(int i=1;i<=s;i++)\\n            {\\n                TreeNode *t = q.front();        \\n                q.pop();\\n                vec.push_back(t->val);  //we push the value of the current node to the 1D vector\\n                if(t->left)\\n                    q.push(t->left);    //if the left node of the root node is present , then push the left node in the queue\\n                if(t->right)\\n                    q.push(t->right);   //if the right node of the root node is present , then push the right node in the queue\\n            }\\n            if(c%2==0)  \\n                reverse(vec.begin(),vec.end()); //now , we took the count variable because there was a pattern in the output that the 1D vector in the 2D vector at even counts are reversed and thats how it was zigzag , so we check the condition and reverse it. \\n            ans.push_back(vec); //here we push the 1D vector in the ans.\\n        }\\n        return ans; //returning the 2D vector as our ans \\n    }\\n};\\n```\\n**IF you LIKE the solution , DO UPVOTE\\nHAPPY CODING;**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode *> q;    //Initialising queue , (for bfs mostly we use queue) \\n        vector<vector<int>> ans;    //ans 2D vector\\n        int c=0;    //count variable\\n        if(!root)\\n            return ans; //To handle the edge test case i.e. if NULL tree is provided\\n        q.push(root);   //now we push the whole root node in the queue\\n        while(!q.empty())\\n        {\\n            int s = q.size();   //we take the size beforehand so that the changes made inside the loop doesnt affect , how many times it will run\\n            vector<int> vec;    //1D vector to store values \\n            c++;    //we increase count vector every time we go to one layer deep \\n            for(int i=1;i<=s;i++)\\n            {\\n                TreeNode *t = q.front();        \\n                q.pop();\\n                vec.push_back(t->val);  //we push the value of the current node to the 1D vector\\n                if(t->left)\\n                    q.push(t->left);    //if the left node of the root node is present , then push the left node in the queue\\n                if(t->right)\\n                    q.push(t->right);   //if the right node of the root node is present , then push the right node in the queue\\n            }\\n            if(c%2==0)  \\n                reverse(vec.begin(),vec.end()); //now , we took the count variable because there was a pattern in the output that the 1D vector in the 2D vector at even counts are reversed and thats how it was zigzag , so we check the condition and reverse it. \\n            ans.push_back(vec); //here we push the 1D vector in the ans.\\n        }\\n        return ans; //returning the 2D vector as our ans \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823844,
                "title": "concise-java-solution-with-bfs",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        if (root == null)\\n            return result;\\n        \\n        boolean reversed = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while (!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            List<Integer> list = new ArrayList<>();\\n            \\n            for (int i = 0; i < size; i++)\\n            {\\n                TreeNode node = queue.poll();\\n                \\n                if (reversed)\\n                    list.add(0, node.val);\\n                else\\n                    list.add(node.val);\\n                \\n                if (node.left != null)\\n                    queue.offer(node.left);\\n                    \\n                if (node.right != null)\\n                    queue.offer(node.right);\\n            }\\n            \\n            reversed = !reversed;\\n            result.add(list);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        if (root == null)\\n            return result;\\n        \\n        boolean reversed = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while (!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            List<Integer> list = new ArrayList<>();\\n            \\n            for (int i = 0; i < size; i++)\\n            {\\n                TreeNode node = queue.poll();\\n                \\n                if (reversed)\\n                    list.add(0, node.val);\\n                else\\n                    list.add(node.val);\\n                \\n                if (node.left != null)\\n                    queue.offer(node.left);\\n                    \\n                if (node.right != null)\\n                    queue.offer(node.right);\\n            }\\n            \\n            reversed = !reversed;\\n            result.add(list);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787786,
                "title": "runtime-0-ms-faster-than-100-00-c-easy-understanding-2-stack",
                "content": "\\n      class Solution {\\n      public:\\n          vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n              if(root==NULL)\\n                  return {};\\n              stack<TreeNode*> s1;\\n              stack<TreeNode*> s2;\\n              s1.push(root);\\n              vector<vector<int>> v;\\n              bool flag= true;\\n              while(!s1.empty() || !s2.empty()){\\n                  vector<int> vec;\\n                  if(f){\\n                      while(!s1.empty()){\\n                          vec.push_back(s1.top()->val);\\n                          if(s1.top()->left!=NULL){\\n                        s2.push(s1.top()->left);\\n                          }\\n                          if(s1.top()->right!=NULL){\\n                              s2.push(s1.top()->right);\\n                          }\\n                          s1.pop();\\n                      }\\n                      flag=false;\\n                  }else{\\n                      while(!s2.empty()){\\n                          vec.push_back(s2.top()->val);\\n                    \\n                          if(s2.top()->right!=NULL){\\n                              s1.push(s2.top()->right);\\n                          }\\n                          if(s2.top()->left!=NULL){\\n                              s1.push(s2.top()->left);\\n                          }\\n                          s2.pop();\\n                      }\\n                      flag=true;\\n                 }\\n                  v.push_back(vec);\\n              }\\n              return v;\\n          }\\n      };\\n\\t  \\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n      public:\\n          vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n              if(root==NULL)\\n                  return {}",
                "codeTag": "Java"
            },
            {
                "id": 319958,
                "title": "python-with-queue",
                "content": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        res = []\\n        queue = []\\n        \\n        queue.append((root,1))\\n        while queue:\\n            n = len(queue)\\n            nodeList = []\\n            for _ in range(n):\\n                curNode, level = queue.pop(0)\\n                if level%2 == 1:\\n                    nodeList.append(curNode.val)\\n                else:\\n                    nodeList.insert(0,curNode.val)\\n                \\n                if curNode.left: queue.append((curNode.left,level+1))\\n                if curNode.right: queue.append((curNode.right,level+1))\\n            \\n            res.append(nodeList)\\n        \\n        return res\\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        res = []\\n        queue = []\\n        \\n        queue.append((root,1))\\n        while queue:\\n            n = len(queue)\\n            nodeList = []\\n            for _ in range(n):\\n                curNode, level = queue.pop(0)\\n                if level%2 == 1:\\n                    nodeList.append(curNode.val)\\n                else:\\n                    nodeList.insert(0,curNode.val)\\n                \\n                if curNode.left: queue.append((curNode.left,level+1))\\n                if curNode.right: queue.append((curNode.right,level+1))\\n            \\n            res.append(nodeList)\\n        \\n        return res\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 167512,
                "title": "javascript-clean-solution",
                "content": "```\\nvar zigzagLevelOrder = function(root) {\\n    let res = [];\\n    helper(root, 0, res);\\n    return res;\\n};\\n\\nvar helper = function(node, level, res){\\n    if(!node) return;\\n    if(!res[level]) res[level] = [];\\n    level % 2 ? res[level].unshift(node.val) : res[level].push(node.val);\\n    helper(node.left, level + 1, res);\\n    helper(node.right, level + 1, res);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar zigzagLevelOrder = function(root) {\\n    let res = [];\\n    helper(root, 0, res);\\n    return res;\\n};\\n\\nvar helper = function(node, level, res){\\n    if(!node) return;\\n    if(!res[level]) res[level] = [];\\n    level % 2 ? res[level].unshift(node.val) : res[level].push(node.val);\\n    helper(node.left, level + 1, res);\\n    helper(node.right, level + 1, res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 33925,
                "title": "c-single-stack-with-forward-flag",
                "content": "I see many solutions using a queue, but to me the stack is more appropriate as it naturally reverses the order.  The only catch is that you need to not just reverse the traversal you need to know when to push left before right and vise versa.  I use a flag to denote which direction we're traversing, other than that no reversal or insert is needed.\\n\\nYou could go one step further and omit the flag and just use the size of lists being odd or even, but I like the flag, more readable.\\n\\n```\\n    public IList<IList<int>> ZigzagLevelOrder(TreeNode root) \\n    {\\n        IList<IList<int>> lists = new List<IList<int>>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        if (root != null) stack.Push(root);\\n        bool forward = true;\\n        \\n        while (stack.Count > 0)\\n        {\\n            lists.Add(new List<int>());\\n            Stack<TreeNode> nextStack = new Stack<TreeNode>();\\n            \\n            while (stack.Count > 0)\\n            {\\n                TreeNode n = stack.Pop();\\n                lists[lists.Count - 1].Add(n.val);\\n                \\n                if (forward)\\n                {\\n                    if (n.left != null) nextStack.Push(n.left);\\n                    if (n.right != null) nextStack.Push(n.right);\\n                }\\n                else\\n                {\\n                    if (n.right != null) nextStack.Push(n.right);\\n                    if (n.left != null) nextStack.Push(n.left);\\n                }\\n            }\\n            \\n            forward = !forward;\\n            stack = nextStack;\\n        }\\n        \\n        return lists;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<IList<int>> ZigzagLevelOrder(TreeNode root) \\n    {\\n        IList<IList<int>> lists = new List<IList<int>>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        if (root != null) stack.Push(root);\\n        bool forward = true;\\n        \\n        while (stack.Count > 0)\\n        {\\n            lists.Add(new List<int>());\\n            Stack<TreeNode> nextStack = new Stack<TreeNode>();\\n            \\n            while (stack.Count > 0)\\n            {\\n                TreeNode n = stack.Pop();\\n                lists[lists.Count - 1].Add(n.val);\\n                \\n                if (forward)\\n                {\\n                    if (n.left != null) nextStack.Push(n.left);\\n                    if (n.right != null) nextStack.Push(n.right);\\n                }\\n                else\\n                {\\n                    if (n.right != null) nextStack.Push(n.right);\\n                    if (n.left != null) nextStack.Push(n.left);\\n                }\\n            }\\n            \\n            forward = !forward;\\n            stack = nextStack;\\n        }\\n        \\n        return lists;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3400623,
                "title": "simple-c-solution",
                "content": "# Approach\\nAt every alternate level we need to go from right to left instead of left to right. Apply normal bfs here but with the modification of reversing the level vector before pushing it to the answer vector. Reversing can be achieved by maintaing a counter variable/ bool flag.\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        queue<TreeNode*> level;\\n        if( !root ){\\n            return ans;\\n        }\\n        level.push(root);\\n        int cnt = 1;\\n        while( !level.empty() ){\\n            int n = level.size();\\n            vector<int> temp;\\n            \\n            for( int i = 0; i < n; i++ ){\\n                TreeNode* x = level.front();\\n                if(x->left){\\n                    level.push(x->left);\\n                }\\n                if( x->right ){\\n                    level.push(x->right);\\n                }\\n                temp.push_back(x->val);\\n                level.pop();\\n            }\\n            if( cnt % 2 == 0 ){\\n                reverse(temp.begin(),temp.end());\\n            }\\n            cnt++;\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        queue<TreeNode*> level;\\n        if( !root ){\\n            return ans;\\n        }\\n        level.push(root);\\n        int cnt = 1;\\n        while( !level.empty() ){\\n            int n = level.size();\\n            vector<int> temp;\\n            \\n            for( int i = 0; i < n; i++ ){\\n                TreeNode* x = level.front();\\n                if(x->left){\\n                    level.push(x->left);\\n                }\\n                if( x->right ){\\n                    level.push(x->right);\\n                }\\n                temp.push_back(x->val);\\n                level.pop();\\n            }\\n            if( cnt % 2 == 0 ){\\n                reverse(temp.begin(),temp.end());\\n            }\\n            cnt++;\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218289,
                "title": "best-o-n-solution",
                "content": "# Approach\\nLevel order traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if (root == NULL)\\n            return ans;\\n        queue <TreeNode* > q;\\n        q.push(root);\\n        bool flag = true;\\n        while (q.empty() != true) {\\n            int size = q.size();\\n            vector <int> level(size);\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                int index = flag ? i : size - i - 1;\\n                level[index] = curr->val;\\n                if (curr->left != NULL)\\n                    q.push(curr->left);\\n                if (curr->right != NULL)\\n                    q.push(curr->right);    \\n            }\\n            ans.push_back(level);\\n            flag = !flag; \\n        } \\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if (root == NULL)\\n            return ans;\\n        queue <TreeNode* > q;\\n        q.push(root);\\n        bool flag = true;\\n        while (q.empty() != true) {\\n            int size = q.size();\\n            vector <int> level(size);\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                int index = flag ? i : size - i - 1;\\n                level[index] = curr->val;\\n                if (curr->left != NULL)\\n                    q.push(curr->left);\\n                if (curr->right != NULL)\\n                    q.push(curr->right);    \\n            }\\n            ans.push_back(level);\\n            flag = !flag; \\n        } \\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207058,
                "title": "java-kotlin-2-simple-bfs-approaches-both-o-n-time-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Approach 1\\nJust do the classic BFS and on every odd distance reverse the iterated level. A bit slower, but quite simple.\\n\\n```kotlin []\\nclass Solution {\\n    fun zigzagLevelOrder(root: TreeNode?): List<List<Int>> {\\n        if (root == null) return listOf()\\n\\n        val queue = LinkedList<TreeNode>()\\n        val ans = arrayListOf<List<Int>>()\\n        var dist = 0\\n        queue.addLast(root)\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n            val list = arrayListOf<Int>()\\n\\n            for (i in 0 until size) {\\n                val current = queue.removeFirst()\\n                current.left?.let { queue.addLast(it) }\\n                current.right?.let { queue.addLast(it) }\\n                list.add(current.`val`)\\n            }\\n            if (dist % 2 == 1) list.reverse()\\n            ans.add(list)\\n            dist++\\n        }\\n\\n        return ans\\n    }\\n}\\n```\\n```java []\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int dist = 0;\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode current = queue.poll();\\n\\n                if (current.left != null) queue.add(current.left);\\n                if (current.right != null) queue.add(current.right);\\n                list.add(current.val);\\n            }\\n            if (list.isEmpty()) break;\\n            if (dist % 2 == 1) Collections.reverse(list);\\n            ans.add(list);\\n            dist++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n# Approach 2\\nThere goes some linked list magic. We can use different ends for even/odd levels and then just read the opposite end each time.\\n\\nSteps:\\n1. Add root to LL\\n2. Then in while loop: if the current dist is even, do the classic - remove from top, insert to last (left, then right child)\\n3. if the current dist is odd, then remove from end of list and insert to first (right, then left since we go in reverse)\\n\\n```kotlin []\\nclass Solution {\\n    fun zigzagLevelOrder(root: TreeNode?): List<List<Int>> {\\n        if (root == null) return listOf()\\n\\n        val queue = LinkedList<TreeNode>()\\n        val ans = arrayListOf<List<Int>>()\\n        var dist = 0\\n        queue.addLast(root)\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n            val list = arrayListOf<Int>()\\n\\n            for (i in 0 until size) {\\n                if (dist % 2 == 0) {\\n                    val current = queue.removeFirst()\\n\\n                    current.left?.let { queue.addLast(it) }\\n                    current.right?.let { queue.addLast(it) }\\n                    list.add(current.`val`)\\n                } else {\\n                    val current = queue.removeLast()\\n\\n                    current.right?.let { queue.addFirst(it) }\\n                    current.left?.let { queue.addFirst(it) }\\n                    list.add(current.`val`)\\n                }\\n            }\\n\\n            ans.add(list)\\n            dist++\\n        }\\n\\n        return ans\\n    }\\n}\\n```\\n```java []\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        if (root == null) return ans;\\n\\n        LinkedList<TreeNode> queue = new LinkedList<>();\\n        int dist = 0;\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int i = 0; i < size; i++) {\\n                if (dist % 2 == 0) {\\n                    TreeNode current = queue.removeFirst();\\n\\n                    if (current.left != null) queue.addLast(current.left);\\n                    if (current.right != null) queue.addLast(current.right);\\n                    list.add(current.val);\\n                } else {\\n                    TreeNode current = queue.removeLast();\\n\\n                    if (current.right != null) queue.addFirst(current.right);\\n                    if (current.left != null) queue.addFirst(current.left);\\n                    list.add(current.val);\\n                }\\n            }\\n\\n            ans.add(list);\\n            dist++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Linked List",
                    "Breadth-First Search"
                ],
                "code": "```kotlin []\\nclass Solution {\\n    fun zigzagLevelOrder(root: TreeNode?): List<List<Int>> {\\n        if (root == null) return listOf()\\n\\n        val queue = LinkedList<TreeNode>()\\n        val ans = arrayListOf<List<Int>>()\\n        var dist = 0\\n        queue.addLast(root)\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n            val list = arrayListOf<Int>()\\n\\n            for (i in 0 until size) {\\n                val current = queue.removeFirst()\\n                current.left?.let { queue.addLast(it) }\\n                current.right?.let { queue.addLast(it) }\\n                list.add(current.`val`)\\n            }\\n            if (dist % 2 == 1) list.reverse()\\n            ans.add(list)\\n            dist++\\n        }\\n\\n        return ans\\n    }\\n}\\n```\n```java []\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int dist = 0;\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode current = queue.poll();\\n\\n                if (current.left != null) queue.add(current.left);\\n                if (current.right != null) queue.add(current.right);\\n                list.add(current.val);\\n            }\\n            if (list.isEmpty()) break;\\n            if (dist % 2 == 1) Collections.reverse(list);\\n            ans.add(list);\\n            dist++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```kotlin []\\nclass Solution {\\n    fun zigzagLevelOrder(root: TreeNode?): List<List<Int>> {\\n        if (root == null) return listOf()\\n\\n        val queue = LinkedList<TreeNode>()\\n        val ans = arrayListOf<List<Int>>()\\n        var dist = 0\\n        queue.addLast(root)\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n            val list = arrayListOf<Int>()\\n\\n            for (i in 0 until size) {\\n                if (dist % 2 == 0) {\\n                    val current = queue.removeFirst()\\n\\n                    current.left?.let { queue.addLast(it) }\\n                    current.right?.let { queue.addLast(it) }\\n                    list.add(current.`val`)\\n                } else {\\n                    val current = queue.removeLast()\\n\\n                    current.right?.let { queue.addFirst(it) }\\n                    current.left?.let { queue.addFirst(it) }\\n                    list.add(current.`val`)\\n                }\\n            }\\n\\n            ans.add(list)\\n            dist++\\n        }\\n\\n        return ans\\n    }\\n}\\n```\n```java []\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        if (root == null) return ans;\\n\\n        LinkedList<TreeNode> queue = new LinkedList<>();\\n        int dist = 0;\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int i = 0; i < size; i++) {\\n                if (dist % 2 == 0) {\\n                    TreeNode current = queue.removeFirst();\\n\\n                    if (current.left != null) queue.addLast(current.left);\\n                    if (current.right != null) queue.addLast(current.right);\\n                    list.add(current.val);\\n                } else {\\n                    TreeNode current = queue.removeLast();\\n\\n                    if (current.right != null) queue.addFirst(current.right);\\n                    if (current.left != null) queue.addFirst(current.left);\\n                    list.add(current.val);\\n                }\\n            }\\n\\n            ans.add(list);\\n            dist++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204034,
                "title": "python3-26-ms-faster-than-97-08-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/3ac0be42-4841-44a1-87f0-a32a71f4b453_1676781049.3290617.png)\\n```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n\\n        queue = deque([root])\\n        result, direction = [], 1\\n\\n        while queue:\\n            level = [node.val for node in queue]\\n            if direction == -1:\\n                level.reverse()\\n            result.append(level)\\n            direction *= -1\\n\\n            for i in range(len(queue)):\\n                node = queue.popleft()\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n\\n        return result\\n```\\n\\nHere is a step-by-step description of how it works:\\n1. The input to the function is a binary tree, represented by its root node.\\n1. The function first checks if the root node is None, in which case it returns an empty list. This is a special case to handle the situation where the tree is empty.\\n1. If the root node is not None, the function initializes a queue with the root node and a list to store the final result.\\n1. The variable \"direction\" is also initialized to 1, which is used to alternate the direction of the level traversal between left-to-right and right-to-left.\\n1. The function enters a loop that continues until the queue is empty.\\n1. Inside the loop, a list \"level\" is created using a list comprehension. It contains the values of all the nodes in the current level of the tree.\\n1. If the direction is -1, the list \"level\" is reversed, to produce the zigzag traversal effect.\\n1. The list \"level\" is appended to the final result list \"result\".\\n1. The \"direction\" variable is then multiplied by -1 to alternate the direction of the level traversal in the next iteration.\\n1. A nested loop is used to iterate through all the nodes in the current level of the tree.\\n1. If a node has a left child, it is added to the queue.\\n1. If a node has a right child, it is added to the queue.\\n1. The loop continues until all the nodes in the current level have been processed.\\n1. The outer loop then repeats the above process for the next level of the tree, until the queue is empty.\\n1. The final result list, containing the zigzag level order traversal of the binary tree, is returned.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n\\n        queue = deque([root])\\n        result, direction = [], 1\\n\\n        while queue:\\n            level = [node.val for node in queue]\\n            if direction == -1:\\n                level.reverse()\\n            result.append(level)\\n            direction *= -1\\n\\n            for i in range(len(queue)):\\n                node = queue.popleft()\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203888,
                "title": "python-bfs-clean-simple",
                "content": "\\n# Code\\n``` Python [1]\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        ans = []\\n        queue = [root]\\n        cnt = 0\\n        while queue:\\n            temp = queue\\n            queue = []\\n            level = []\\n            for node in temp:\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n                level.append(node.val)\\n            cnt += 1\\n            if cnt & 1 == 1:\\n                ans.append(level)\\n            else:\\n                ans.append(level[::-1])\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python [1]\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        ans = []\\n        queue = [root]\\n        cnt = 0\\n        while queue:\\n            temp = queue\\n            queue = []\\n            level = []\\n            for node in temp:\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n                level.append(node.val)\\n            cnt += 1\\n            if cnt & 1 == 1:\\n                ans.append(level)\\n            else:\\n                ans.append(level[::-1])\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203639,
                "title": "c-bfs-reverse-easy-93-space-41-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n      vector<vector<int>> ans;\\n      if(!root) return {};\\n      queue<TreeNode *> q;\\n      q.emplace(root);\\n      while(!q.empty()){\\n        int sz = q.size();\\n        vector<int> temp;\\n        for(int i = 0; i < sz; i++){\\n          auto qf = q.front(); q.pop();\\n          temp.emplace_back(qf->val);\\n          if(qf->left) q.emplace(qf->left);\\n          if(qf->right) q.emplace(qf->right);\\n        }\\n        ans.emplace_back(temp);\\n      }\\n      for(int i = 0; i < ans.size(); i++){\\n        if(i % 2) reverse(ans[i].begin(), ans[i].end());\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n      vector<vector<int>> ans;\\n      if(!root) return {};\\n      queue<TreeNode *> q;\\n      q.emplace(root);\\n      while(!q.empty()){\\n        int sz = q.size();\\n        vector<int> temp;\\n        for(int i = 0; i < sz; i++){\\n          auto qf = q.front(); q.pop();\\n          temp.emplace_back(qf->val);\\n          if(qf->left) q.emplace(qf->left);\\n          if(qf->right) q.emplace(qf->right);\\n        }\\n        ans.emplace_back(temp);\\n      }\\n      for(int i = 0; i < ans.size(); i++){\\n        if(i % 2) reverse(ans[i].begin(), ans[i].end());\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203587,
                "title": "java-simple-code-with-explanation-bfs-queue-90-faster",
                "content": "![image.png](https://assets.leetcode.com/users/images/bdc700f3-7462-42cc-8376-267cf54cbbce_1676776051.012236.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We approach this problem as we approach the problem of a simple level order traversal.\\n- In order to traverse in a zigzag way we reverse the order of the level alternatively and our job will be done.\\n\\n- The comments in the code will help you walk through my approach in a detailed manner.\\n\\n\\n# Complexity\\n- Time complexity: `O(n * 2^h)`, n= number of nodes, h= height of the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please UPVOTE this if you find it useful!\\nLet\\'s Connect On \\u27A1\\uFE0F [LinkedIn OliFarhaan](https://www.linkedin.com/in/olifarhaan/)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n\\n        // if root is null we have to return an empty list\\n        if(root ==null) return new ArrayList<>();\\n        \\n        // for storing the resultant list of zigzag traversal\\n        List<List<Integer>> list= new ArrayList<>();\\n\\n        // for storing the nodes at a particular level \\n        Queue<TreeNode> q= new LinkedList<>();\\n\\n        // added the root to the queue so that we start the iteration\\n        q.offer(root);\\n\\n        // This is the key factor towards approaching this question\\n        // We toggle this variable from true to false & vice versa\\n        boolean isReversed=true;\\n\\n        while(!q.isEmpty()){\\n            int size= q.size();\\n            ArrayList<Integer> innerList= new ArrayList<>();\\n            \\n            // We start adding the elements at a particular level\\n            // to the innerList\\n            for(int i=0; i<size; i++){\\n                TreeNode current= q.poll();\\n                if(current.left != null) q.offer(current.left);\\n                if(current.right != null) q.offer(current.right);\\n                innerList.add(current.val);                \\n            }\\n            // This helps us to reverse the list alternatively\\n            if(!isReversed){\\n                Collections.reverse(innerList);\\n            }\\n\\n            list.add(innerList);\\n\\n            // This is to toggle the isReversed variable\\n            isReversed= !isReversed;\\n\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n\\n        // if root is null we have to return an empty list\\n        if(root ==null) return new ArrayList<>();\\n        \\n        // for storing the resultant list of zigzag traversal\\n        List<List<Integer>> list= new ArrayList<>();\\n\\n        // for storing the nodes at a particular level \\n        Queue<TreeNode> q= new LinkedList<>();\\n\\n        // added the root to the queue so that we start the iteration\\n        q.offer(root);\\n\\n        // This is the key factor towards approaching this question\\n        // We toggle this variable from true to false & vice versa\\n        boolean isReversed=true;\\n\\n        while(!q.isEmpty()){\\n            int size= q.size();\\n            ArrayList<Integer> innerList= new ArrayList<>();\\n            \\n            // We start adding the elements at a particular level\\n            // to the innerList\\n            for(int i=0; i<size; i++){\\n                TreeNode current= q.poll();\\n                if(current.left != null) q.offer(current.left);\\n                if(current.right != null) q.offer(current.right);\\n                innerList.add(current.val);                \\n            }\\n            // This helps us to reverse the list alternatively\\n            if(!isReversed){\\n                Collections.reverse(innerList);\\n            }\\n\\n            list.add(innerList);\\n\\n            // This is to toggle the isReversed variable\\n            isReversed= !isReversed;\\n\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203386,
                "title": "100-beat-0ms-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==0){\\n            return ans;\\n        }\\n        vector<int>res;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        //q.push(NULL);\\n        int ct=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode* t=q.front();\\n                q.pop();\\n                res.push_back(t->val);\\n                if(t->left!=0){\\n                    q.push(t->left);\\n                }\\n                if(t->right!=0){\\n                    q.push(t->right);\\n                }\\n            }\\n            if(ct%2==0){\\n                ans.push_back(res);\\n                res.clear();\\n            }\\n            else{\\n                reverse(res.begin(),res.end());\\n                ans.push_back(res);\\n                res.clear();\\n            }\\n            ct++;\\n        }\\n        // for(int i=0;i<ans.size();i++){\\n        //         if(i%2==1){\\n        //             reverse(ans[i].begin(),ans[i].end());\\n        //         }\\n        //     }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==0){\\n            return ans;\\n        }\\n        vector<int>res;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        //q.push(NULL);\\n        int ct=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode* t=q.front();\\n                q.pop();\\n                res.push_back(t->val);\\n                if(t->left!=0){\\n                    q.push(t->left);\\n                }\\n                if(t->right!=0){\\n                    q.push(t->right);\\n                }\\n            }\\n            if(ct%2==0){\\n                ans.push_back(res);\\n                res.clear();\\n            }\\n            else{\\n                reverse(res.begin(),res.end());\\n                ans.push_back(res);\\n                res.clear();\\n            }\\n            ct++;\\n        }\\n        // for(int i=0;i<ans.size();i++){\\n        //         if(i%2==1){\\n        //             reverse(ans[i].begin(),ans[i].end());\\n        //         }\\n        //     }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127466,
                "title": "solved-using-level-of-nodes-easy-solution",
                "content": "# Code\\n```\\nfunction zigzagLevelOrder(root: TreeNode | null): number[][] {\\n    if (!root) return []\\n\\n    const getZigZagValues = (nodes: TreeNode[], position: number): number[] => {\\n        const values = nodes.map(node => node.val)\\n\\n        if (position % 2 === 1) {\\n            values.reverse()\\n        }\\n\\n        return values\\n    }\\n\\n    const result = []\\n    let level = [root]\\n    let count = 0\\n\\n    while (level.length) {\\n        let queue = []\\n\\n        result.push(getZigZagValues(level, count))\\n\\n        level.map(node => {\\n            if (node.left) {\\n                queue.push(node.left)\\n            }\\n            if (node.right) {\\n                queue.push(node.right)\\n            }\\n        })\\n\\n        level = queue\\n        count += 1\\n    }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction zigzagLevelOrder(root: TreeNode | null): number[][] {\\n    if (!root) return []\\n\\n    const getZigZagValues = (nodes: TreeNode[], position: number): number[] => {\\n        const values = nodes.map(node => node.val)\\n\\n        if (position % 2 === 1) {\\n            values.reverse()\\n        }\\n\\n        return values\\n    }\\n\\n    const result = []\\n    let level = [root]\\n    let count = 0\\n\\n    while (level.length) {\\n        let queue = []\\n\\n        result.push(getZigZagValues(level, count))\\n\\n        level.map(node => {\\n            if (node.left) {\\n                queue.push(node.left)\\n            }\\n            if (node.right) {\\n                queue.push(node.right)\\n            }\\n        })\\n\\n        level = queue\\n        count += 1\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3120294,
                "title": "javascript-easy-and-well-explained-code",
                "content": "# Explanation:\\n\\n1. If the root is null, return an empty array.\\n1. Initialize a result array result, a queue q to store nodes and a level counter level.\\n1. While the queue q is not empty, do the following:\\n1. Get the size of the queue, and initialize an array currLevel to store the current level\\'s values.\\n1. Loop size times, dequeue the first node node from the queue, push its value to currLevel.\\n1. If node has a left child, add it to the queue q.\\n1. If node has a right child, add it to the queue q.\\n1. If the level is odd, reverse currLevel, and push it to the result array.\\n1. Increment the level counter level.\\n1. Return the result array.\\n- This solution has a time complexity of O(n) and a space complexity of O(n), where n is the number of nodes in the tree.\\n\\n\\n\\n\\n\\n# Code\\n```\\nvar zigzagLevelOrder = function(root) {\\n    if (!root) return [];\\n    \\n    let result = [], q = [root], level = 0;\\n    \\n    while (q.length) {\\n        let size = q.length, currLevel = [];\\n        for (let i = 0; i < size; i++) {\\n            let node = q.shift();\\n            currLevel.push(node.val);\\n            if (node.left) q.push(node.left);\\n            if (node.right) q.push(node.right);\\n        }\\n        if (level % 2 === 1) currLevel.reverse();\\n        result.push(currLevel);\\n        level++;\\n    }\\n    return result;\\n};\\n\\n```\\n\\nThere are several ways to optimize this solution further:\\n\\n- Reusing the same array for different levels, instead of creating a new array for each level. This will reduce the memory footprint of the solution.\\n\\n- Using a queue for the breadth-first search, instead of recursion. This will reduce the call stack size and avoid the risk of stack overflow for large trees.\\n\\n- Using a stack for reversing the order of the levels, instead of reversing the array after each level. This will reduce the time complexity and the memory usage of the solution.\\n",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar zigzagLevelOrder = function(root) {\\n    if (!root) return [];\\n    \\n    let result = [], q = [root], level = 0;\\n    \\n    while (q.length) {\\n        let size = q.length, currLevel = [];\\n        for (let i = 0; i < size; i++) {\\n            let node = q.shift();\\n            currLevel.push(node.val);\\n            if (node.left) q.push(node.left);\\n            if (node.right) q.push(node.right);\\n        }\\n        if (level % 2 === 1) currLevel.reverse();\\n        result.push(currLevel);\\n        level++;\\n    }\\n    return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3050470,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<vector<int>> ans;\\n        if(!root)\\n            return ans;\\n        vector<int> v;\\n        bool rev=false;\\n        // v.push_back(q.front)\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz; i++)\\n            {\\n                TreeNode* t=q.front();\\n                q.pop();\\n                v.push_back(t->val);\\n                if(t->left)\\n                    q.push(t->left);\\n                if(t->right)\\n                    q.push(t->right);\\n            }\\n            if(rev)\\n                reverse(v.begin(), v.end());\\n            rev=!rev;\\n            ans.push_back(v);\\n            v.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<vector<int>> ans;\\n        if(!root)\\n            return ans;\\n        vector<int> v;\\n        bool rev=false;\\n        // v.push_back(q.front)\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz; i++)\\n            {\\n                TreeNode* t=q.front();\\n                q.pop();\\n                v.push_back(t->val);\\n                if(t->left)\\n                    q.push(t->left);\\n                if(t->right)\\n                    q.push(t->right);\\n            }\\n            if(rev)\\n                reverse(v.begin(), v.end());\\n            rev=!rev;\\n            ans.push_back(v);\\n            v.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687948,
                "title": "java-100-fastest",
                "content": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        int count=0;\\n        List<List<Integer>> final_list=new ArrayList<>();\\n        if(root==null)\\n            return final_list;\\n        Queue<TreeNode> queue=new LinkedList<>();\\n        queue.add(root);\\n        boolean flag=true;\\n        while(!queue.isEmpty())\\n        {\\n            List<Integer> list=new ArrayList<>();\\n            for(int i=queue.size();i!=0;i--)\\n            {\\n                TreeNode curr=queue.poll();\\n                if(curr.left!=null)\\n                    queue.add(curr.left);\\n                if(curr.right!=null)\\n                    queue.add(curr.right);\\n                if(flag)\\n                    list.add(curr.val);\\n                else\\n                    list.add(0,curr.val);\\n            }\\n            final_list.add(list);\\n            flag=!flag;\\n        }\\n        return final_list;\\n    }\\n}\\n\\n**Kindly upvote **",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        int count=0;\\n        List<List<Integer>> final_list=new ArrayList<>();\\n        if(root==null)\\n            return final_list;\\n        Queue<TreeNode> queue=new LinkedList<>();\\n        queue.add(root);\\n        boolean flag=true;\\n        while(!queue.isEmpty())\\n        {\\n            List<Integer> list=new ArrayList<>();\\n            for(int i=queue.size();i!=0;i--)\\n            {\\n                TreeNode curr=queue.poll();\\n                if(curr.left!=null)\\n                    queue.add(curr.left);\\n                if(curr.right!=null)\\n                    queue.add(curr.right);\\n                if(flag)\\n                    list.add(curr.val);\\n                else\\n                    list.add(0,curr.val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2068140,
                "title": "c-easy-approach-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // keeping track of odd and even level with the help of count variable and using Level Order Traversal\\n    // if count is odd, then storing values in level in reverse order\\n    \\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> res;\\n        if(root == NULL) return res;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int count = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            vector<int> level(size);                                  // using to set values in reverse on odd levels\\n            for(int i = 0; i < size; i++)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(count % 2 == 0)  level[i] = node->val;\\n                else level[size - i - 1] = node->val;\\n                \\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            count++;\\n            res.push_back(level);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // keeping track of odd and even level with the help of count variable and using Level Order Traversal\\n    // if count is odd, then storing values in level in reverse order\\n    \\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> res;\\n        if(root == NULL) return res;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int count = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            vector<int> level(size);                                  // using to set values in reverse on odd levels\\n            for(int i = 0; i < size; i++)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(count % 2 == 0)  level[i] = node->val;\\n                else level[size - i - 1] = node->val;\\n                \\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            count++;\\n            res.push_back(level);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535750,
                "title": "python-simple-and-easy-to-understand-solution",
                "content": "The idea is to do a simple leven order traversal, [same as this question](https://leetcode.com/problems/binary-tree-level-order-traversal/), the only difference is before appending the list of current level we check if the current leven is even or odd and if it is even we reverse the list and then append it (considering root as level 1).\\n```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root: return []\\n        queue, res, level = collections.deque([root]), [], 1\\n        \\n        while queue:\\n            curr = []  \\n            \\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                curr.append(node.val)\\n                if node.left: queue.append(node.left)\\n                if node.right: queue.append(node.right)\\n                    \\n            curr = reversed(curr) if level % 2 == 0 else curr\\n            res.append(curr)\\n            level += 1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root: return []\\n        queue, res, level = collections.deque([root]), [], 1\\n        \\n        while queue:\\n            curr = []  \\n            \\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                curr.append(node.val)\\n                if node.left: queue.append(node.left)\\n                if node.right: queue.append(node.right)\\n                    \\n            curr = reversed(curr) if level % 2 == 0 else curr\\n            res.append(curr)\\n            level += 1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449285,
                "title": "js-easy-to-understand-bfs-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[][]}\\n */\\nvar zigzagLevelOrder = function(root) {\\n    // Edge case: when root node is empty\\n    if (!root) return [];\\n    \\n    // Initialize\\n    let result = [];\\n    let queue = [root];\\n    let level = 1;\\n    \\n    while (queue[0]) {\\n        let size = queue.length;\\n        let arr = [];\\n        \\n        while (size--) {\\n            let node = queue.shift(); // dequeue\\n            \\n            level % 2 ? arr.push(node.val) : arr.unshift(node.val);\\n            \\n            node.left && queue.push(node.left); // enqueue\\n            node.right && queue.push(node.right); // enqueue\\n        }\\n        \\n        result.push(arr);\\n        level++;\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[][]}\\n */\\nvar zigzagLevelOrder = function(root) {\\n    // Edge case: when root node is empty\\n    if (!root) return [];\\n    \\n    // Initialize\\n    let result = [];\\n    let queue = [root];\\n    let level = 1;\\n    \\n    while (queue[0]) {\\n        let size = queue.length;\\n        let arr = [];\\n        \\n        while (size--) {\\n            let node = queue.shift(); // dequeue\\n            \\n            level % 2 ? arr.push(node.val) : arr.unshift(node.val);\\n            \\n            node.left && queue.push(node.left); // enqueue\\n            node.right && queue.push(node.right); // enqueue\\n        }\\n        \\n        result.push(arr);\\n        level++;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239227,
                "title": "100-faster-java-bfs-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        getZigZag(res,root);\\n        return res;\\n        \\n    }\\n    \\n     List<List<Integer>> getZigZag(List<List<Integer>> res, TreeNode root)\\n    {\\n        if(root==null)\\n        {\\n            return res;\\n        }\\n        Queue<TreeNode> q = new LinkedList<>();\\n        \\n        q.add(root);\\n        \\n        int count = 1; \\n         \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            List<Integer> list = new ArrayList<>();\\n            for(int i=0;i<size;i++){\\n            TreeNode temp = q.poll();\\n            list.add(temp.val);\\n            if(temp.left!=null)\\n            {\\n                q.add(temp.left);\\n            }\\n            if(temp.right!=null)\\n            {\\n                q.add(temp.right);\\n            }\\n            }\\n            if(count%2 == 0)\\n            {\\n                Collections.reverse(list);\\n                res.add(list);\\n            }\\n            else\\n            {\\n                res.add(list);\\n            }\\n            count++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        getZigZag(res,root);\\n        return res;\\n        \\n    }\\n    \\n     List<List<Integer>> getZigZag(List<List<Integer>> res, TreeNode root)\\n    {\\n        if(root==null)\\n        {\\n            return res;\\n        }\\n        Queue<TreeNode> q = new LinkedList<>();\\n        \\n        q.add(root);\\n        \\n        int count = 1; \\n         \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            List<Integer> list = new ArrayList<>();\\n            for(int i=0;i<size;i++){\\n            TreeNode temp = q.poll();\\n            list.add(temp.val);\\n            if(temp.left!=null)\\n            {\\n                q.add(temp.left);\\n            }\\n            if(temp.right!=null)\\n            {\\n                q.add(temp.right);\\n            }\\n            }\\n            if(count%2 == 0)\\n            {\\n                Collections.reverse(list);\\n                res.add(list);\\n            }\\n            else\\n            {\\n                res.add(list);\\n            }\\n            count++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230517,
                "title": "faster-than-100-tree-zig-zag-level-order-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>v;\\n        if(!root)return v; \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        stack<int>s;\\n        int flip=1;\\n        while(q.size())\\n        {\\n            int count=q.size();\\n            for(int i=0;i<count;i++){\\n            TreeNode* node=q.front();\\n            s.push(node->val);\\n            q.pop();\\n            if(node->left){q.push(node->left);}\\n            if(node->right)q.push(node->right);\\n            }\\n            if(flip==-1){\\n                vector<int>a;\\n                while(s.size())\\n                {\\n                    a.push_back(s.top());\\n                    s.pop(); \\n                }\\n                v.push_back(a);\\n                flip=1;\\n            }\\n            else\\n            {\\n               vector<int>a;\\n                while(s.size())\\n                {\\n                    a.push_back(s.top());\\n                    s.pop(); \\n                }\\n                reverse(a.begin(),a.end());\\n                v.push_back(a); \\n                flip=-1;\\n            }\\n            \\n        }\\n            return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>v;\\n        if(!root)return v; \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        stack<int>s;\\n        int flip=1;\\n        while(q.size())\\n        {\\n            int count=q.size();\\n            for(int i=0;i<count;i++){\\n            TreeNode* node=q.front();\\n            s.push(node->val);\\n            q.pop();\\n            if(node->left){q.push(node->left);}\\n            if(node->right)q.push(node->right);\\n            }\\n            if(flip==-1){\\n                vector<int>a;\\n                while(s.size())\\n                {\\n                    a.push_back(s.top());\\n                    s.pop(); \\n                }\\n                v.push_back(a);\\n                flip=1;\\n            }\\n            else\\n            {\\n               vector<int>a;\\n                while(s.size())\\n                {\\n                    a.push_back(s.top());\\n                    s.pop(); \\n                }\\n                reverse(a.begin(),a.end());\\n                v.push_back(a); \\n                flip=-1;\\n            }\\n            \\n        }\\n            return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119962,
                "title": "100-faster-easy-to-understand-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxDepth(TreeNode* root){\\n        if(!root){\\n            return 0;\\n        }\\n        return 1+max(maxDepth(root->left),maxDepth(root->right));\\n    }\\n    void zzO(TreeNode* root,int c,vector<int>& sres,int i){\\n        if(!root){return;}\\n        if(c==i){\\n            sres.push_back(root->val);\\n            return;\\n        }\\n        else if(i%2==1){\\n            zzO(root->left,c+1,sres,i);\\n            zzO(root->right,c+1,sres,i);\\n        }\\n        else{\\n            zzO(root->right,c+1,sres,i);\\n            zzO(root->left,c+1,sres,i);\\n        }\\n    }                 \\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        int n=maxDepth(root);\\n        vector<vector<int>> res;\\n        for(int i=1;i<=n;i++){\\n            vector<int> sres;\\n            zzO(root,1,sres,i);\\n            res.push_back(sres);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxDepth(TreeNode* root){\\n        if(!root){\\n            return 0;\\n        }\\n        return 1+max(maxDepth(root->left),maxDepth(root->right));\\n    }\\n    void zzO(TreeNode* root,int c,vector<int>& sres,int i){\\n        if(!root){return;}\\n        if(c==i){\\n            sres.push_back(root->val);\\n            return;\\n        }\\n        else if(i%2==1){\\n            zzO(root->left,c+1,sres,i);\\n            zzO(root->right,c+1,sres,i);\\n        }\\n        else{\\n            zzO(root->right,c+1,sres,i);\\n            zzO(root->left,c+1,sres,i);\\n        }\\n    }                 \\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        int n=maxDepth(root);\\n        vector<vector<int>> res;\\n        for(int i=1;i<=n;i++){\\n            vector<int> sres;\\n            zzO(root,1,sres,i);\\n            res.push_back(sres);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749106,
                "title": "easy-c-solution-using-queues-32ms",
                "content": "```\\n  vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        \\n        vector<vector<int>> res;\\n        if(root== NULL)\\n            return vector<vector<int>>();\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int f = false;\\n        while(q.size())\\n        {\\n            int size = q.size();   //Get size of each level. (beginning with 1 for root)\\n            vector<int> level;\\n            while(size--)\\n            {\\n                TreeNode* curr = q.front();\\n                level.push_back(curr->val);   //Push prev level\\'s node into array.\\n                q.pop();\\n                if(curr->left)\\n                {\\n                    q.push(curr->left);  // Adding left node (if present) into new level.\\n                }\\n                if(curr->right)\\n                {\\n                    q.push(curr->right);  // Adding right node (if present) into new level.\\n                }\\n                    \\n            }\\n            if(f)        //Reverse every alternate level\\n             reverse(level.begin(),level.end());\\n            f=!f;   //toggling\\n            res.push_back(level);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        \\n        vector<vector<int>> res;\\n        if(root== NULL)\\n            return vector<vector<int>>();\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int f = false;\\n        while(q.size())\\n        {\\n            int size = q.size();   //Get size of each level. (beginning with 1 for root)\\n            vector<int> level;\\n            while(size--)\\n            {\\n                TreeNode* curr = q.front();\\n                level.push_back(curr->val);   //Push prev level\\'s node into array.\\n                q.pop();\\n                if(curr->left)\\n                {\\n                    q.push(curr->left);  // Adding left node (if present) into new level.\\n                }\\n                if(curr->right)\\n                {\\n                    q.push(curr->right);  // Adding right node (if present) into new level.\\n                }\\n                    \\n            }\\n            if(f)        //Reverse every alternate level\\n             reverse(level.begin(),level.end());\\n            f=!f;   //toggling\\n            res.push_back(level);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685674,
                "title": "simple-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n             \\n        List<List<Integer>> nodes = new ArrayList<>();\\n        \\n        if (root == null) return nodes;\\n        \\n        boolean left = true;\\n        Deque<TreeNode> dq = new LinkedList<>();\\n        dq.addFirst(root);\\n        \\n        while (!dq.isEmpty()) {\\n            \\n            int size = dq.size();\\n            \\n            LinkedList<Integer> result = new LinkedList<>();\\n            \\n            while (size-- > 0) {\\n                \\n                TreeNode node = dq.removeFirst();\\n                \\n                if (left) {\\n                    \\n                    result.addLast(node.val);\\n                } else {\\n                    \\n                    result.addFirst(node.val);\\n                }\\n                \\n                if (node.left != null) {\\n                    \\n                    dq.addLast(node.left);\\n                }\\n                \\n                if (node.right != null) {\\n                    \\n                   dq.addLast(node.right);\\n                }\\n            }\\n                        \\n            left = !left;\\n            nodes.add(result);\\n        }\\n        \\n        return nodes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n             \\n        List<List<Integer>> nodes = new ArrayList<>();\\n        \\n        if (root == null) return nodes;\\n        \\n        boolean left = true;\\n        Deque<TreeNode> dq = new LinkedList<>();\\n        dq.addFirst(root);\\n        \\n        while (!dq.isEmpty()) {\\n            \\n            int size = dq.size();\\n            \\n            LinkedList<Integer> result = new LinkedList<>();\\n            \\n            while (size-- > 0) {\\n                \\n                TreeNode node = dq.removeFirst();\\n                \\n                if (left) {\\n                    \\n                    result.addLast(node.val);\\n                } else {\\n                    \\n                    result.addFirst(node.val);\\n                }\\n                \\n                if (node.left != null) {\\n                    \\n                    dq.addLast(node.left);\\n                }\\n                \\n                if (node.right != null) {\\n                    \\n                   dq.addLast(node.right);\\n                }\\n            }\\n                        \\n            left = !left;\\n            nodes.add(result);\\n        }\\n        \\n        return nodes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591695,
                "title": "c-easy-solution-using-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void traverse(TreeNode *root, vector<vector<int>> &res, int level, int &max_level){\\n        if(root){\\n            if(level == max_level && res.size() == level){\\n                res.push_back(vector<int>());\\n                max_level++;   \\n            }\\n            res[level].push_back(root->val);\\n            \\n            traverse(root->left, res, level+1, max_level);\\n            traverse(root->right, res, level+1, max_level);\\n        }\\n        \\n    }\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> res;\\n        if(!root){\\n            return res;\\n        }\\n        int max_level = 0, i;\\n        traverse(root, res, 0, max_level);\\n        for(i = 1; i < res.size(); i+=2){\\n            reverse(res[i].begin(), res[i].end());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void traverse(TreeNode *root, vector<vector<int>> &res, int level, int &max_level){\\n        if(root){\\n            if(level == max_level && res.size() == level){\\n                res.push_back(vector<int>());\\n                max_level++;   \\n            }\\n            res[level].push_back(root->val);\\n            \\n            traverse(root->left, res, level+1, max_level);\\n            traverse(root->right, res, level+1, max_level);\\n        }\\n        \\n    }\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> res;\\n        if(!root){\\n            return res;\\n        }\\n        int max_level = 0, i;\\n        traverse(root, res, 0, max_level);\\n        for(i = 1; i < res.size(); i+=2){\\n            reverse(res[i].begin(), res[i].end());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542209,
                "title": "javascript-solution-97",
                "content": "```\\nvar zigzagLevelOrder = function(root) {\\n    if (!root) return [];\\n    let stackQueue = [root];\\n    let result = [];\\n    let level = 1;\\n    \\n    while (stackQueue.length > 0) {\\n        const isLtoR = level % 2 === 1;\\n        const subLength = stackQueue.length;\\n        const subList = [];\\n        for (let i = 0; i < subLength; i++) {\\n            let node;\\n            if (isLtoR) {\\n               node = stackQueue.shift();\\n                if (node.left) stackQueue.push(node.left);\\n                if (node.right) stackQueue.push(node.right);\\n            } else {\\n                node = stackQueue.pop();                \\n                if (node.right) stackQueue.unshift(node.right);\\n                if (node.left) stackQueue.unshift(node.left);\\n                \\n            }\\n            subList.push(node.val);\\n        }\\n        level++;\\n        result.push(subList);\\n    }\\n    return result;\\n};\\n```\\n\\nRuntime: 48 ms, faster than 97.36% of JavaScript online submissions for Binary Tree Zigzag Level Order Traversal.\\nMemory Usage: 34.1 MB, less than 80.00% of JavaScript online submissions for Binary Tree Zigzag Level Order Traversal.",
                "solutionTags": [],
                "code": "```\\nvar zigzagLevelOrder = function(root) {\\n    if (!root) return [];\\n    let stackQueue = [root];\\n    let result = [];\\n    let level = 1;\\n    \\n    while (stackQueue.length > 0) {\\n        const isLtoR = level % 2 === 1;\\n        const subLength = stackQueue.length;\\n        const subList = [];\\n        for (let i = 0; i < subLength; i++) {\\n            let node;\\n            if (isLtoR) {\\n               node = stackQueue.shift();\\n                if (node.left) stackQueue.push(node.left);\\n                if (node.right) stackQueue.push(node.right);\\n            } else {\\n                node = stackQueue.pop();                \\n                if (node.right) stackQueue.unshift(node.right);\\n                if (node.left) stackQueue.unshift(node.left);\\n                \\n            }\\n            subList.push(node.val);\\n        }\\n        level++;\\n        result.push(subList);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 177654,
                "title": "java-solution-without-using-queue-or-additional-data-structure",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        zigzagLevelOrder(root, result, 1);\\n        return result;\\n    }\\n        \\n    private void zigzagLevelOrder(TreeNode root, List<List<Integer>> result, int level){\\n        if(root == null) return;\\n        List<Integer> levelList;\\n        if(result.size() < level){\\n            levelList = new LinkedList<Integer>();\\n            result.add(levelList);\\n        }\\n        levelList = result.get(level-1);\\n        if(level%2 == 0 ){\\n                  levelList.add(0,root.val);  \\n            }else{\\n               levelList.add(root.val); \\n            }\\n        zigzagLevelOrder(root.left, result, level+1);\\n        zigzagLevelOrder(root.right, result, level+1);\\n        \\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        zigzagLevelOrder(root, result, 1);\\n        return result;\\n    }\\n        \\n    private void zigzagLevelOrder(TreeNode root, List<List<Integer>> result, int level){\\n        if(root == null) return;\\n        List<Integer> levelList;\\n        if(result.size() < level){\\n            levelList = new LinkedList<Integer>();\\n            result.add(levelList);\\n        }\\n        levelList = result.get(level-1);\\n        if(level%2 == 0 ){\\n                  levelList.add(0,root.val);  \\n            }else{\\n               levelList.add(root.val); \\n            }\\n        zigzagLevelOrder(root.left, result, level+1);\\n        zigzagLevelOrder(root.right, result, level+1);\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159077,
                "title": "python-3-level-order-traversal-or-bfs",
                "content": "```\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        result = []\\n        current_level = [root]\\n        count = 0\\n        while current_level:\\n            count += 1\\n            thislevel = []\\n            nextlevel = []\\n            for node in current_level:\\n                thislevel.append(node.val)\\n                if node.left:\\n                    nextlevel.append(node.left)\\n                if node.right:\\n                    nextlevel.append(node.right)\\n            if count%2==0:\\n                result.append(thislevel[::-1])\\n            else:\\n                result.append(thislevel)\\n            current_level = nextlevel\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        result = []\\n        current_level = [root]\\n        count = 0\\n        while current_level:\\n            count += 1\\n            thislevel = []\\n            nextlevel = []\\n            for node in current_level:\\n                thislevel.append(node.val)\\n                if node.left:\\n                    nextlevel.append(node.left)\\n                if node.right:\\n                    nextlevel.append(node.right)\\n            if count%2==0:\\n                result.append(thislevel[::-1])\\n            else:\\n                result.append(thislevel)\\n            current_level = nextlevel\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34018,
                "title": "c-iteration-use-two-stack",
                "content": "C# iteration use two stack. Loop each layer and push all nodes to another stack with opposite sequence\\n\\n        public IList<IList<int>> ZigzagLevelOrder(TreeNode root)\\n        {\\n            List<IList<int>> result = new List<IList<int>>();\\n\\n            if (root == null)\\n            {\\n                return result;\\n            }\\n\\n            Stack<TreeNode> s1 = new Stack<TreeNode>();\\n            Stack<TreeNode> s2 = new Stack<TreeNode>();\\n\\n            s1.Push(root);\\n\\n            while (s1.Count != 0 || s2.Count != 0)\\n            {\\n                int n1 = s1.Count;\\n                int n2 = s2.Count;\\n\\n                List<int> list = new List<int>();\\n\\n                for (int i = 0; i < n1; i++)\\n                {\\n                    root = s1.Pop();\\n                    list.Add(root.val);\\n\\n                    if (root.left != null)\\n                    {\\n                        s2.Push(root.left);\\n                    }\\n\\n                    if (root.right != null)\\n                    {\\n                        s2.Push(root.right);\\n                    }\\n                }\\n\\n                for (int i = 0; i < n2; i++)\\n                {\\n                    root = s2.Pop();\\n                    list.Add(root.val);\\n\\n                    if (root.right != null)\\n                    {\\n                        s1.Push(root.right);\\n                    }\\n\\n                    if (root.left != null)\\n                    {\\n                        s1.Push(root.left);\\n                    }\\n                }\\n\\n                result.Add(list);\\n            }\\n\\n            return result;\\n        }",
                "solutionTags": [],
                "code": "C# iteration use two stack. Loop each layer and push all nodes to another stack with opposite sequence\\n\\n        public IList<IList<int>> ZigzagLevelOrder(TreeNode root)\\n        {\\n            List<IList<int>> result = new List<IList<int>>();\\n\\n            if (root == null)\\n            {\\n                return result;\\n            }\\n\\n            Stack<TreeNode> s1 = new Stack<TreeNode>();\\n            Stack<TreeNode> s2 = new Stack<TreeNode>();\\n\\n            s1.Push(root);\\n\\n            while (s1.Count != 0 || s2.Count != 0)\\n            {\\n                int n1 = s1.Count;\\n                int n2 = s2.Count;\\n\\n                List<int> list = new List<int>();\\n\\n                for (int i = 0; i < n1; i++)\\n                {\\n                    root = s1.Pop();\\n                    list.Add(root.val);\\n\\n                    if (root.left != null)\\n                    {\\n                        s2.Push(root.left);\\n                    }\\n\\n                    if (root.right != null)\\n                    {\\n                        s2.Push(root.right);\\n                    }\\n                }\\n\\n                for (int i = 0; i < n2; i++)\\n                {\\n                    root = s2.Pop();\\n                    list.Add(root.val);\\n\\n                    if (root.right != null)\\n                    {\\n                        s1.Push(root.right);\\n                    }\\n\\n                    if (root.left != null)\\n                    {\\n                        s1.Push(root.left);\\n                    }\\n                }\\n\\n                result.Add(list);\\n            }\\n\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 34023,
                "title": "my-4ms-solution-based-on-level-order-traversal",
                "content": "    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n    \\t\\tvector<vector<int>> ret;\\n    \\t\\tif (root == NULL)\\treturn ret;\\n    \\t\\tqueue<TreeNode*> queue;\\n    \\t\\tqueue.push(root);\\n    \\t\\tint i = 0;\\n    \\n    \\t\\twhile (!queue.empty()){\\n    \\t\\t\\tvector<int> subret;\\n    \\t\\t\\tint ssize = queue.size();\\n    \\t\\t\\twhile (ssize--){\\n    \\t\\t\\t\\troot = queue.front();\\n    \\t\\t\\t\\tqueue.pop();\\n    \\t\\t\\t\\tsubret.push_back(root->val);\\n    \\t\\t\\t\\tif (root->left != NULL)\\tqueue.push(root->left);\\n    \\t\\t\\t\\tif (root->right != NULL)queue.push(root->right);\\n    \\t\\t\\t}\\n    \\t\\t\\tif (i++ % 2 == 1)\\n    \\t\\t\\t\\treverse(subret.begin(), subret.end());\\n    \\t\\t\\tret.push_back(subret);\\n    \\t\\t}\\n    \\n    \\t\\treturn ret;\\n    \\t}",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n    \\t\\tvector<vector<int>> ret;\\n    \\t\\tif (root == NULL)\\treturn ret;\\n    \\t\\tqueue<TreeNode*> queue;\\n    \\t\\tqueue.push(root);\\n    \\t\\tint i = 0;\\n    \\n    \\t\\twhile (!queue.empty()){\\n    \\t\\t\\tvector<int> subret;\\n    \\t\\t\\tint ssize = queue.size();\\n    \\t\\t\\twhile (ssize--){\\n    \\t\\t\\t\\troot = queue.front();\\n    \\t\\t\\t\\tqueue.pop();\\n    \\t\\t\\t\\tsubret.push_back(root->val);\\n    \\t\\t\\t\\tif (root->left != NULL)\\tqueue.push(root->left);\\n    \\t\\t\\t\\tif (root->right != NULL)queue.push(root->right);\\n    \\t\\t\\t}\\n    \\t\\t\\tif (i++ % 2 == 1)\\n    \\t\\t\\t\\treverse(subret.begin(), subret.end());\\n    \\t\\t\\tret.push_back(subret);\\n    \\t\\t}\\n    \\n    \\t\\treturn ret;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3953377,
                "title": "2-easy-c-solutions-with-and-without-reverse-beats-100",
                "content": "\\n\\n# Code\\n```\\n// With reverse\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<vector<int>> ans;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        int count = 1;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> res;\\n\\n            for(int i=0; i<size; i++){\\n                TreeNode *curr = q.front();\\n                q.pop();\\n                res.push_back(curr->val);\\n\\n                if(curr->left != NULL)\\n                    q.push(curr->left);\\n                if(curr->right != NULL)\\n                    q.push(curr->right);\\n            }\\n\\n            if(count%2 != 0)\\n                ans.push_back(res);\\n            else{\\n                reverse(res.begin(), res.end());\\n                ans.push_back(res);\\n            }\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Without reverse\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<vector<int>> ans;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        bool direction = true;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> res(size);\\n\\n            for(int i=0; i<size; i++){\\n                TreeNode *curr = q.front();\\n                q.pop();\\n\\n                int index = direction ? i : size-i-1;\\n                res[index] = curr->val;;\\n\\n                if(curr->left != NULL)\\n                    q.push(curr->left);\\n                if(curr->right != NULL)\\n                    q.push(curr->right);\\n            }\\n\\n            ans.push_back(res);\\n            direction = !direction;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// With reverse\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<vector<int>> ans;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        int count = 1;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> res;\\n\\n            for(int i=0; i<size; i++){\\n                TreeNode *curr = q.front();\\n                q.pop();\\n                res.push_back(curr->val);\\n\\n                if(curr->left != NULL)\\n                    q.push(curr->left);\\n                if(curr->right != NULL)\\n                    q.push(curr->right);\\n            }\\n\\n            if(count%2 != 0)\\n                ans.push_back(res);\\n            else{\\n                reverse(res.begin(), res.end());\\n                ans.push_back(res);\\n            }\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Without reverse\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<vector<int>> ans;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        bool direction = true;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int> res(size);\\n\\n            for(int i=0; i<size; i++){\\n                TreeNode *curr = q.front();\\n                q.pop();\\n\\n                int index = direction ? i : size-i-1;\\n                res[index] = curr->val;;\\n\\n                if(curr->left != NULL)\\n                    q.push(curr->left);\\n                if(curr->right != NULL)\\n                    q.push(curr->right);\\n            }\\n\\n            ans.push_back(res);\\n            direction = !direction;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804981,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(root == null) return ans;\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        boolean flag = false;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> level = new ArrayList<>();\\n            \\n            for(int i = 0; i < size; i++) {\\n                TreeNode node = queue.peek();\\n                queue.remove();\\n\\n                if(node.left != null) queue.add(node.left);\\n                if(node.right != null) queue.add(node.right);\\n                level.add(node.val);\\n            }\\n\\n            if(flag) {\\n                Collections.reverse(level);\\n                flag = false;\\n            } else {\\n                flag = true;\\n            }\\n\\n            ans.add(level);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(root == null) return ans;\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        boolean flag = false;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            List<Integer> level = new ArrayList<>();\\n            \\n            for(int i = 0; i < size; i++) {\\n                TreeNode node = queue.peek();\\n                queue.remove();\\n\\n                if(node.left != null) queue.add(node.left);\\n                if(node.right != null) queue.add(node.right);\\n                level.add(node.val);\\n            }\\n\\n            if(flag) {\\n                Collections.reverse(level);\\n                flag = false;\\n            } else {\\n                flag = true;\\n            }\\n\\n            ans.add(level);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478548,
                "title": "beginner-friendly-easy-to-understand-beats-88-53-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        if(root==null){\\n            return list;\\n        }\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> l = new ArrayList<>();\\n            for(int i=0;i<size;i++){\\n                TreeNode curr =  q.poll();\\n                l.add(curr.val);\\n                if(curr.left!=null){\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    q.add(curr.right);\\n                }\\n            }\\n            list.add(l);\\n        }\\n        for(int i=0;i<list.size();i++){\\n            if(i%2 !=0){\\n                Collections.reverse(list.get(i));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        if(root==null){\\n            return list;\\n        }\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> l = new ArrayList<>();\\n            for(int i=0;i<size;i++){\\n                TreeNode curr =  q.poll();\\n                l.add(curr.val);\\n                if(curr.left!=null){\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    q.add(curr.right);\\n                }\\n            }\\n            list.add(l);\\n        }\\n        for(int i=0;i<list.size();i++){\\n            if(i%2 !=0){\\n                Collections.reverse(list.get(i));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205411,
                "title": "java-solution-1ms-solution-bfs-easy-to-understand",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        // BFS\\n        if(root==null)  return new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        q.offer(root);\\n        boolean leftToRight = true;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> subList = new ArrayList<>();\\n            while(size-->0){\\n                TreeNode node = q.poll();\\n\\n                if(leftToRight) subList.add(node.val);\\n                else    subList.add(0,node.val);\\n\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null)    q.offer(node.right);\\n            }\\n            leftToRight = ! leftToRight;\\n            ans.add(subList);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```\\nIf you like please UpVote Solution\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        // BFS\\n        if(root==null)  return new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        q.offer(root);\\n        boolean leftToRight = true;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> subList = new ArrayList<>();\\n            while(size-->0){\\n                TreeNode node = q.poll();\\n\\n                if(leftToRight) subList.add(node.val);\\n                else    subList.add(0,node.val);\\n\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null)    q.offer(node.right);\\n            }\\n            leftToRight = ! leftToRight;\\n            ans.add(subList);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nIf you like please UpVote Solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205173,
                "title": "javascript-solution",
                "content": "# Code\\n```\\nconst zigzagLevelOrder = (root) => {\\n    if (root === null) return [];\\n\\n    let level = [root];\\n    let zigzag = [];\\n    while (level.length > 0) {\\n        zigzag.push(level.map(node => node.val));\\n        level = level.flatMap(node => [node.left, node.right]).filter(Boolean); \\n        // The flatMap() method returns a new array formed by applying a given callback function to each element of the array, and then flattening the result by one level. It is identical to a map() followed by a flat() of depth 1 (arr.map(...args).flat()), but slightly more efficient than calling those two methods separately.\\n    }\\n\\n    return zigzag.map((level, index) => index%2 === 1 ? level.reverse() : level);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst zigzagLevelOrder = (root) => {\\n    if (root === null) return [];\\n\\n    let level = [root];\\n    let zigzag = [];\\n    while (level.length > 0) {\\n        zigzag.push(level.map(node => node.val));\\n        level = level.flatMap(node => [node.left, node.right]).filter(Boolean); \\n        // The flatMap() method returns a new array formed by applying a given callback function to each element of the array, and then flattening the result by one level. It is identical to a map() followed by a flat() of depth 1 (arr.map(...args).flat()), but slightly more efficient than calling those two methods separately.\\n    }\\n\\n    return zigzag.map((level, index) => index%2 === 1 ? level.reverse() : level);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3204407,
                "title": "c-bfs",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>a;\\n        if(root==NULL)return a;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int j=1;\\n        while(q.size()){\\n           int n=q.size();\\n           vector<int>v;\\n           for(int i=0;i<n;i++){\\n               TreeNode* s =q.front();\\n               q.pop();\\n               v.push_back(s->val);\\n               if(s->left)q.push(s->left);\\n               if(s->right)q.push(s->right);\\n           }\\n           if(j%2==0)reverse(v.begin(),v.end());\\n           j++;\\n           a.push_back(v);\\n        }\\n        return a;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/f71a10cb-0738-4982-97e9-4f85dfbe5854_1676786140.9024384.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>a;\\n        if(root==NULL)return a;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int j=1;\\n        while(q.size()){\\n           int n=q.size();\\n           vector<int>v;\\n           for(int i=0;i<n;i++){\\n               TreeNode* s =q.front();\\n               q.pop();\\n               v.push_back(s->val);\\n               if(s->left)q.push(s->left);\\n               if(s->right)q.push(s->right);\\n           }\\n           if(j%2==0)reverse(v.begin(),v.end());\\n           j++;\\n           a.push_back(v);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204251,
                "title": "zigzag-traversal-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n /*\\n   Question similar to level order traversal.Just keep flag variable to check wheteher we have to go from left to right or right to left.\\n\\n  i] Store all pointers of nodes in a queue.\\n  ii] Use a flag variable to check whether we have to go from left to right or right to left.\\n\\n\\n\\n */\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        q.push(root);\\n        bool flag=1;\\n\\n        while(!q.empty())\\n        {\\n            \\n            \\n            int size=q.size();\\n           vector<int>v(size);\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* node=q.front();\\n                 q.pop();\\n                 int idx=(flag) ? i:size-i-1;\\n                 v[idx]=node->val;\\n\\n                 if(node->left)\\n                 {\\n                     q.push(node->left);\\n                 }\\n                 if(node->right)\\n                 {\\n                     q.push(node->right);\\n                 }\\n\\n\\n\\n            }\\n\\n                flag=!(flag);\\n            ans.push_back(v);\\n\\n\\n\\n\\n\\n        }\\n\\n\\n\\n\\nreturn ans;\\n        \\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n /*\\n   Question similar to level order traversal.Just keep flag variable to check wheteher we have to go from left to right or right to left.\\n\\n  i] Store all pointers of nodes in a queue.\\n  ii] Use a flag variable to check whether we have to go from left to right or right to left.\\n\\n\\n\\n */\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        q.push(root);\\n        bool flag=1;\\n\\n        while(!q.empty())\\n        {\\n            \\n            \\n            int size=q.size();\\n           vector<int>v(size);\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* node=q.front();\\n                 q.pop();\\n                 int idx=(flag) ? i:size-i-1;\\n                 v[idx]=node->val;\\n\\n                 if(node->left)\\n                 {\\n                     q.push(node->left);\\n                 }\\n                 if(node->right)\\n                 {\\n                     q.push(node->right);\\n                 }\\n\\n\\n\\n            }\\n\\n                flag=!(flag);\\n            ans.push_back(v);\\n\\n\\n\\n\\n\\n        }\\n\\n\\n\\n\\nreturn ans;\\n        \\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204158,
                "title": "beats-100-easiest-java-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     LinkedList<List<Integer>>ans=new LinkedList<>();\\n    \\n     Deque<TreeNode> deque= new LinkedList<TreeNode>();\\n\\n     if(root==null)return ans;\\n\\n     int level=0;\\n\\n     deque.push(root);\\n\\n     while(!deque.isEmpty()){\\n     int size=deque.size();\\n     List<Integer>app=new LinkedList<>();\\n     if(level%2==0){\\n      for(int i=0;i<size;i++){\\n        TreeNode temp=deque.getFirst();\\n        deque.removeFirst();   \\n        app.add(temp.val);\\n        if(temp.left!=null){\\n        deque.addLast(temp.left);\\n        }\\n        if(temp.right!=null){\\n        deque.addLast(temp.right);\\n        }\\n     }\\n     }\\n     else{\\n      for(int i=0;i<size;i++){\\n        TreeNode temp=deque.getLast();\\n        deque.removeLast();   \\n        app.add(temp.val);\\n        if(temp.right!=null){\\n        deque.addFirst(temp.right);\\n        }\\n        if(temp.left!=null){\\n        deque.addFirst(temp.left);\\n        }\\n     }\\n     }\\n     ans.add(app);\\n     level++;\\n    }\\n    return ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     LinkedList<List<Integer>>ans=new LinkedList<>();\\n    \\n     Deque<TreeNode> deque= new LinkedList<TreeNode>();\\n\\n     if(root==null)return ans;\\n\\n     int level=0;\\n\\n     deque.push(root);\\n\\n     while(!deque.isEmpty()){\\n     int size=deque.size();\\n     List<Integer>app=new LinkedList<>();\\n     if(level%2==0){\\n      for(int i=0;i<size;i++){\\n        TreeNode temp=deque.getFirst();\\n        deque.removeFirst();   \\n        app.add(temp.val);\\n        if(temp.left!=null){\\n        deque.addLast(temp.left);\\n        }\\n        if(temp.right!=null){\\n        deque.addLast(temp.right);\\n        }\\n     }\\n     }\\n     else{\\n      for(int i=0;i<size;i++){\\n        TreeNode temp=deque.getLast();\\n        deque.removeLast();   \\n        app.add(temp.val);\\n        if(temp.right!=null){\\n        deque.addFirst(temp.right);\\n        }\\n        if(temp.left!=null){\\n        deque.addFirst(temp.left);\\n        }\\n     }\\n     }\\n     ans.add(app);\\n     level++;\\n    }\\n    return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203987,
                "title": "bfs-video-explanation",
                "content": "# Intuition & Approach\\nhttps://youtu.be/F9r-7SEdpCQ\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if (!root)\\n            return {};\\n        \\n        vector<vector<int>> res;\\n        \\n        queue<TreeNode*> qu;\\n        qu.push(root);\\n\\n        bool rightToLeft = false;\\n        \\n        while (!qu.empty()) {\\n            vector<int> curLevel;\\n\\n            int sz = qu.size();\\n            for (int i = 0; i < sz; ++i) {\\n                auto node = qu.front();\\n                qu.pop();\\n                \\n                curLevel.push_back(node->val);\\n                \\n                if (node->left) qu.push(node->left);\\n                if (node->right) qu.push(node->right);\\n            }\\n\\n            if (rightToLeft)\\n                reverse(curLevel.begin(), curLevel.end());\\n            \\n            rightToLeft = !rightToLeft;\\n\\n            res.push_back(curLevel);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if (!root)\\n            return {};\\n        \\n        vector<vector<int>> res;\\n        \\n        queue<TreeNode*> qu;\\n        qu.push(root);\\n\\n        bool rightToLeft = false;\\n        \\n        while (!qu.empty()) {\\n            vector<int> curLevel;\\n\\n            int sz = qu.size();\\n            for (int i = 0; i < sz; ++i) {\\n                auto node = qu.front();\\n                qu.pop();\\n                \\n                curLevel.push_back(node->val);\\n                \\n                if (node->left) qu.push(node->left);\\n                if (node->right) qu.push(node->right);\\n            }\\n\\n            if (rightToLeft)\\n                reverse(curLevel.begin(), curLevel.end());\\n            \\n            rightToLeft = !rightToLeft;\\n\\n            res.push_back(curLevel);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203944,
                "title": "easiest-and-best-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe recursively traverse the tree first, and arrange the nodes according to their heights. Then we switch alternate vectors iteratively to produce desired result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a simple pre-order traversal technique, and also use a pointer to locate the heights of each nodes wrt the root, to arrange it in the 2-D vector.Then we run a loop to flip odd positioned vectors.\\n\\n# Complexity\\n- Time complexity: O(N+H) \\u2243 O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H) extra space for recursive implementation.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void pre(TreeNode* node,vector<vector<int>>& vv,int n) {\\n        if(!node) return;\\n        if(n<vv.size()) vv[n].push_back(node->val);\\n        else vv.push_back(vector<int>(1,node->val));\\n        pre(node->left,vv,n+1);\\n        pre(node->right,vv,n+1);\\n    }\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> vv;\\n        pre(root,vv,0);\\n        for(int i=0;i<vv.size();i++) if(i&1) reverse(vv[i].begin(),vv[i].end());\\n        return vv;\\n    }\\n};\\n```\\nUPVOTE IF EASY",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void pre(TreeNode* node,vector<vector<int>>& vv,int n) {\\n        if(!node) return;\\n        if(n<vv.size()) vv[n].push_back(node->val);\\n        else vv.push_back(vector<int>(1,node->val));\\n        pre(node->left,vv,n+1);\\n        pre(node->right,vv,n+1);\\n    }\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> vv;\\n        pre(root,vv,0);\\n        for(int i=0;i<vv.size();i++) if(i&1) reverse(vv[i].begin(),vv[i].end());\\n        return vv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203511,
                "title": "using-queue-with-two-approaches-1-ms-python",
                "content": "> ***The present is theirs; the future, for which I really worked, is mine.***\\n~ $$Nikola$$ $$Tesla$$\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the Binary Tree Zigzag Level Order Traversal is to perform a level order traversal of the binary tree while keeping track of the current level of the nodes. By using a queue to store the nodes in the current level, we can visit each node in the queue while adding its children to the queue. We also need to keep track of the current level so that we can reverse the order of the nodes when the level is odd. The final result is a list of lists, where each inner list contains the nodes of a level in the binary tree in a zigzag order.\\n\\n---\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe general approach to solve this problem is to perform a level order traversal of the binary tree while maintaining the current level of the nodes. We can use a queue to store the nodes in the current level, and visit each node in the queue while adding its children to the queue. We also need to keep track of the current level so that we can reverse the order of the nodes when the level is odd.\\n\\n**Algorithm :**\\n\\n$$Zig-Zag(root):$$\\n1. Create an empty queue to store the nodes of the binary tree.\\n2. Add the root node to the queue.\\n3. Initialize a variable called level to 1.\\n4. While the queue is not empty, repeat steps 5-8:\\n\\t4.1 Initialize an empty list called ```level_nodes```.\\n\\t4.2 For each node in the queue, add its value to ```level_nodes```.\\n\\t4.3 Add the children of each node in the queue to the queue.\\n\\t4.4 If level is odd, reverse the order of level_nodes.\\n\\t4.5 Append ```level_nodes``` to the result.\\n\\t4.6 Increment level by 1.\\n5. Return the ```result```.\\n\\n\\n---\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$, where $$N$$ is the number of nodes in the binary tree.\\n\\n- Space complexity: $$O(N)$$, where $$N$$ is the number of nodes in the binary tree.\\n\\n\\n---\\n\\n\\n\\n# Code\\n```python [Python]\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nfrom collections import deque\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:\\n            return []\\n    \\n        queue = deque([root])\\n        result = []\\n        level = 0\\n    \\n        while queue:\\n            level_nodes = []\\n            level_size = len(queue)\\n            for i in range(level_size):\\n                node = queue.popleft()\\n                if level % 2 == 0:\\n                    level_nodes.append(node.val)\\n                else:\\n                    level_nodes.insert(0, node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            result.append(level_nodes)\\n            level += 1\\n    \\n        return result\\n```\\n\\n```python [python]\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nfrom collections import deque\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:\\n            return []\\n    \\n        queue = [root]\\n        result = []\\n        level = 0\\n    \\n        while queue:\\n            level_nodes = []\\n            for _ in range(len(queue)):\\n                node = queue.pop(0)\\n                level_nodes.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            if level % 2 == 1:\\n                level_nodes.reverse()\\n            result.append(level_nodes)\\n            level += 1\\n    \\n        return result\\n```\\n\\n***UPVOTE IF YOU LIKE IT :)***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```level_nodes```\n```level_nodes```\n```level_nodes```\n```result```\n```python [Python]\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nfrom collections import deque\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:\\n            return []\\n    \\n        queue = deque([root])\\n        result = []\\n        level = 0\\n    \\n        while queue:\\n            level_nodes = []\\n            level_size = len(queue)\\n            for i in range(level_size):\\n                node = queue.popleft()\\n                if level % 2 == 0:\\n                    level_nodes.append(node.val)\\n                else:\\n                    level_nodes.insert(0, node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            result.append(level_nodes)\\n            level += 1\\n    \\n        return result\\n```\n```python [python]\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nfrom collections import deque\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not root:\\n            return []\\n    \\n        queue = [root]\\n        result = []\\n        level = 0\\n    \\n        while queue:\\n            level_nodes = []\\n            for _ in range(len(queue)):\\n                node = queue.pop(0)\\n                level_nodes.append(node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            if level % 2 == 1:\\n                level_nodes.reverse()\\n            result.append(level_nodes)\\n            level += 1\\n    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203454,
                "title": "just-do-level-order-and-reverse-the-nested-arrays-at-odd-indices-simple-implementation",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        a = []\\n\\n        def dfs(node, h):\\n            if not node: return\\n            if h == len(a): a.append([])\\n            a[h].append(node.val)\\n            dfs(node.left,h+1)\\n            dfs(node.right,h+1)\\n\\n        dfs(root,0)\\n        \\n        for i in range(len(a)):\\n            if i&1:\\n                a[i] = a[i][::-1]\\n                \\n        return a\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        a = []\\n\\n        def dfs(node, h):\\n            if not node: return\\n            if h == len(a): a.append([])\\n            a[h].append(node.val)\\n            dfs(node.left,h+1)\\n            dfs(node.right,h+1)\\n\\n        dfs(root,0)\\n        \\n        for i in range(len(a)):\\n            if i&1:\\n                a[i] = a[i][::-1]\\n                \\n        return a\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203434,
                "title": "java-bfs-simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n    var ans = new ArrayList<List<Integer>>();\\n    if (root == null) return ans;\\n\\n    var zig = true;\\n    var queue = new ArrayDeque<TreeNode>();\\n    queue.offer(root);\\n\\n    while (!queue.isEmpty()) {\\n      var level = new LinkedList<Integer>();\\n\\n      for (var i = queue.size(); i > 0; i--) {\\n        var node = queue.poll();\\n\\n        if (zig) level.add(node.val);\\n        else level.addFirst(node.val);\\n\\n        if (node.left != null) queue.offer(node.left);\\n        if (node.right != null) queue.offer(node.right);\\n      }\\n      ans.add(level);\\n      zig = !zig;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n    var ans = new ArrayList<List<Integer>>();\\n    if (root == null) return ans;\\n\\n    var zig = true;\\n    var queue = new ArrayDeque<TreeNode>();\\n    queue.offer(root);\\n\\n    while (!queue.isEmpty()) {\\n      var level = new LinkedList<Integer>();\\n\\n      for (var i = queue.size(); i > 0; i--) {\\n        var node = queue.poll();\\n\\n        if (zig) level.add(node.val);\\n        else level.addFirst(node.val);\\n\\n        if (node.left != null) queue.offer(node.left);\\n        if (node.right != null) queue.offer(node.right);\\n      }\\n      ans.add(level);\\n      zig = !zig;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203409,
                "title": "python-bfs-explained",
                "content": "level by level traverse. \\n\\nusing a deque to append the next level nodes to the end of the queue. keep tracking the level of each node. for even level node, add the value from left to right. for odd level node, add the value from right to left.\\n\\n```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        # using a queue to track each level\\n        node_queue = collections.deque()\\n        ans = []\\n        \\n        if root:\\n            node_queue.append((root, 0))\\n            prev_level, level_nodes = None, collections.deque()\\n            while node_queue:\\n                n, l = node_queue.popleft()\\n                if prev_level is not None:\\n                    if prev_level != l:\\n                        ans.append(level_nodes)\\n                        level_nodes = collections.deque()\\n                if l % 2 == 0:\\n                    level_nodes.append(n.val)\\n                else:\\n                    level_nodes.appendleft(n.val)\\n                prev_level = l\\n                \\n                if n.left:\\n                    node_queue.append((n.left, l + 1))\\n                if n.right:\\n                    node_queue.append((n.right, l + 1))\\n            \\n            if len(level_nodes):\\n                ans.append(level_nodes)\\n                \\n        return ans      \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        # using a queue to track each level\\n        node_queue = collections.deque()\\n        ans = []\\n        \\n        if root:\\n            node_queue.append((root, 0))\\n            prev_level, level_nodes = None, collections.deque()\\n            while node_queue:\\n                n, l = node_queue.popleft()\\n                if prev_level is not None:\\n                    if prev_level != l:\\n                        ans.append(level_nodes)\\n                        level_nodes = collections.deque()\\n                if l % 2 == 0:\\n                    level_nodes.append(n.val)\\n                else:\\n                    level_nodes.appendleft(n.val)\\n                prev_level = l\\n                \\n                if n.left:\\n                    node_queue.append((n.left, l + 1))\\n                if n.right:\\n                    node_queue.append((n.right, l + 1))\\n            \\n            if len(level_nodes):\\n                ans.append(level_nodes)\\n                \\n        return ans      \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191784,
                "title": "binary-tree-zigzag-level-order-traversal-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo traverse the binary tree in a zigzag manner, we can use a breadth-first search (BFS) approach. We can use a queue to store the nodes of the binary tree, and we can use a flag to indicate the direction of the zigzag traversal.\\n\\nIf the flag is set to left-to-right, we can append the node values from left to right to the current level list. Otherwise, if the flag is set to right-to-left, we can append the node values from right to left to the current level list.\\n\\nOnce we have appended all the node values for the current level, we can update the flag to switch the direction of the zigzag traversal and append the current level list to the result list.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(N), where N is the number of nodes in the binary tree, since we need to traverse all the nodes. \\n\\n- Space complexity:\\nThe space complexity of this solution is O(N), since we need to store all the nodes in the queue.\\n\\n# Code\\nHere is the Python3 code with comments explaining each step:\\n```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        # Initialize the queue with the root node\\n        queue = [root]\\n        \\n        # Initialize the flag to indicate the direction of the zigzag traversal\\n        is_left_to_right = True\\n        \\n        # Initialize the result list\\n        result = []\\n        \\n        while queue:\\n            # Initialize the current level list\\n            level = []\\n            \\n            # Get the size of the current level\\n            size = len(queue)\\n            \\n            for i in range(size):\\n                # Remove the first node from the queue\\n                node = queue.pop(0)\\n                \\n                # Append the node value to the current level list\\n                level.append(node.val)\\n                \\n                # Add the left and right children of the node to the queue\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            \\n            # Update the flag to switch the direction of the zigzag traversal\\n            if is_left_to_right:\\n                is_left_to_right = False\\n            else:\\n                is_left_to_right = True\\n                level = level[::-1]  # Reverse the current level list if the flag is set to right-to-left\\n            \\n            # Append the current level list to the result list\\n            result.append(level)\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        if not root:\\n            return []\\n        \\n        # Initialize the queue with the root node\\n        queue = [root]\\n        \\n        # Initialize the flag to indicate the direction of the zigzag traversal\\n        is_left_to_right = True\\n        \\n        # Initialize the result list\\n        result = []\\n        \\n        while queue:\\n            # Initialize the current level list\\n            level = []\\n            \\n            # Get the size of the current level\\n            size = len(queue)\\n            \\n            for i in range(size):\\n                # Remove the first node from the queue\\n                node = queue.pop(0)\\n                \\n                # Append the node value to the current level list\\n                level.append(node.val)\\n                \\n                # Add the left and right children of the node to the queue\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            \\n            # Update the flag to switch the direction of the zigzag traversal\\n            if is_left_to_right:\\n                is_left_to_right = False\\n            else:\\n                is_left_to_right = True\\n                level = level[::-1]  # Reverse the current level list if the flag is set to right-to-left\\n            \\n            # Append the current level list to the result list\\n            result.append(level)\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182699,
                "title": "go-golang-solution-using-bfs-easy",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc zigzagLevelOrder(root *TreeNode) [][]int {\\n\\tans := [][]int{}\\n    // handle base case\\n\\tif root == nil {\\n\\t\\treturn ans\\n\\t}\\n\\n\\teven := true\\n\\n\\tqueue := []*TreeNode{root}\\n\\n\\tfor len(queue) > 0 {\\n\\n\\t\\tl := len(queue)\\n\\n        // Create a subList to add to answer for each row\\n\\t\\tsubList := []int{}\\n\\n\\t\\tfor i := 0; i < l; i++ {\\n\\t\\t\\tnode := queue[i]\\n\\n            // Process left \\n\\t\\t\\tif node.Left != nil {\\n\\t\\t\\t\\tqueue = append(queue, node.Left)\\n\\t\\t\\t}\\n\\n            // Process Right \\n\\t\\t\\tif node.Right != nil {\\n\\t\\t\\t\\tqueue = append(queue, node.Right)\\n\\t\\t\\t}\\n\\n            // even, add the node value at the end of sublist\\n\\t\\t\\tif even {\\n\\t\\t\\t\\tsubList = append(subList, node.Val)\\n\\t\\t\\t} else {\\n                // odd, add the node value as the first value of sublsit\\n\\t\\t\\t\\tsubList = append([]int{node.Val}, subList...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tqueue = queue[l:]\\n        // change even to odd\\n\\t\\teven = !even\\n        // Add the sublist to final ans\\n\\t\\tans = append(ans, subList)\\n\\t}\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc zigzagLevelOrder(root *TreeNode) [][]int {\\n\\tans := [][]int{}\\n    // handle base case\\n\\tif root == nil {\\n\\t\\treturn ans\\n\\t}\\n\\n\\teven := true\\n\\n\\tqueue := []*TreeNode{root}\\n\\n\\tfor len(queue) > 0 {\\n\\n\\t\\tl := len(queue)\\n\\n        // Create a subList to add to answer for each row\\n\\t\\tsubList := []int{}\\n\\n\\t\\tfor i := 0; i < l; i++ {\\n\\t\\t\\tnode := queue[i]\\n\\n            // Process left \\n\\t\\t\\tif node.Left != nil {\\n\\t\\t\\t\\tqueue = append(queue, node.Left)\\n\\t\\t\\t}\\n\\n            // Process Right \\n\\t\\t\\tif node.Right != nil {\\n\\t\\t\\t\\tqueue = append(queue, node.Right)\\n\\t\\t\\t}\\n\\n            // even, add the node value at the end of sublist\\n\\t\\t\\tif even {\\n\\t\\t\\t\\tsubList = append(subList, node.Val)\\n\\t\\t\\t} else {\\n                // odd, add the node value as the first value of sublsit\\n\\t\\t\\t\\tsubList = append([]int{node.Val}, subList...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tqueue = queue[l:]\\n        // change even to odd\\n\\t\\teven = !even\\n        // Add the sublist to final ans\\n\\t\\tans = append(ans, subList)\\n\\t}\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109326,
                "title": "java-o-n-by-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Binary Tree",
                    "Monotonic Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075322,
                "title": "0ms-100-faster-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>>ans=new LinkedList<>();\\n        \\n        if(root==null){\\n            return ans;\\n        }\\n        boolean leftToRight=true;\\n        int index=0;\\n        Queue<TreeNode>n=new LinkedList<>();\\n        n.add(root);\\n        while(!n.isEmpty()){\\n            int count=n.size();\\n            List<Integer>l=new ArrayList<>(count);\\n            \\n            for(int i=0;i<count;i++){\\n                TreeNode cur=n.poll();\\n        \\n                if(cur.left!=null){\\n                    n.add(cur.left);\\n                }\\n                if(cur.right!=null){\\n                    n.add(cur.right);\\n                }  \\n                if(leftToRight){\\n                    l.add(cur.val);\\n                }\\n                else{\\n                    l.add(0,cur.val);\\n                    //System.out.println(l);\\n                } \\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(l);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>>ans=new LinkedList<>();\\n        \\n        if(root==null){\\n            return ans;\\n        }\\n        boolean leftToRight=true;\\n        int index=0;\\n        Queue<TreeNode>n=new LinkedList<>();\\n        n.add(root);\\n        while(!n.isEmpty()){\\n            int count=n.size();\\n            List<Integer>l=new ArrayList<>(count);\\n            \\n            for(int i=0;i<count;i++){\\n                TreeNode cur=n.poll();\\n        \\n                if(cur.left!=null){\\n                    n.add(cur.left);\\n                }\\n                if(cur.right!=null){\\n                    n.add(cur.right);\\n                }  \\n                if(leftToRight){\\n                    l.add(cur.val);\\n                }\\n                else{\\n                    l.add(0,cur.val);\\n                    //System.out.println(l);\\n                } \\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(l);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853750,
                "title": "c-easytounderstand-bfs-queue",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\\n```\\nclass Solution {\\n    public:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        int count = 1;\\n        queue<TreeNode*> pNodes;\\n        pNodes.push(root);\\n        while(!pNodes.empty()){\\n            int remNodes = pNodes.size();\\n            vector<int> nums;\\n            while(remNodes--){\\n                TreeNode * fron = pNodes.front();\\n                pNodes.pop();\\n                nums.push_back(fron->val);\\n                if(fron->left)\\n                    pNodes.push(fron->left);\\n                if(fron->right)\\n                    pNodes.push(fron->right);\\n            }\\n            if(count == 1){\\n                ans.push_back(nums);\\n                count--;\\n            }\\n            else if(count == 0){\\n                reverse(nums.begin(),nums.end());\\n                ans.push_back(nums);\\n                count++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\n```\\nclass Solution {\\n    public:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        int count = 1;\\n        queue<TreeNode*> pNodes;\\n        pNodes.push(root);\\n        while(!pNodes.empty()){\\n            int remNodes = pNodes.size();\\n            vector<int> nums;\\n            while(remNodes--){\\n                TreeNode * fron = pNodes.front();\\n                pNodes.pop();\\n                nums.push_back(fron->val);\\n                if(fron->left)\\n                    pNodes.push(fron->left);\\n                if(fron->right)\\n                    pNodes.push(fron->right);\\n            }\\n            if(count == 1){\\n                ans.push_back(nums);\\n                count--;\\n            }\\n            else if(count == 0){\\n                reverse(nums.begin(),nums.end());\\n                ans.push_back(nums);\\n                count++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811298,
                "title": "striver-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimilar as level order traversal (we use queue) but here we use flag to change whenever we have to change the direction, and then we vector<vector<int>> to store answer \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        //similar as level order traversal (we use queue) but here we use flag to change whenever we have to change the direction, and then we vector<vector<int>> to store answer  \\n        vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int flag=1;\\n        while(!q.empty()){\\n\\n            int size=q.size();//stores the size of queue\\n            vector<int>temp(size);//temp vector stores the all nodes value of particular level \\n            for(int i=0;i<size;i++){//i=0 to size\\n                //storing the front most element of queue in node\\n                TreeNode*node=q.front();\\n                //popping the front elemenet in queue\\n                q.pop();\\n\\n                if(flag==1){\\n                    //then store left to right\\n                   temp[i]=node->val;\\n                }else{\\n                    //if flag==0 then store right to left\\n                    temp[size-i-1]=node->val;\\n                }\\n                //pushing the left and right of nodes \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n            }\\n            //if flag==1 then left to right, now we change to 0 to indicate its time for right to left, similarly vice versa\\n            flag=!flag;\\n            //pusshing the temp vector\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        //similar as level order traversal (we use queue) but here we use flag to change whenever we have to change the direction, and then we vector<vector<int>> to store answer  \\n        vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int flag=1;\\n        while(!q.empty()){\\n\\n            int size=q.size();//stores the size of queue\\n            vector<int>temp(size);//temp vector stores the all nodes value of particular level \\n            for(int i=0;i<size;i++){//i=0 to size\\n                //storing the front most element of queue in node\\n                TreeNode*node=q.front();\\n                //popping the front elemenet in queue\\n                q.pop();\\n\\n                if(flag==1){\\n                    //then store left to right\\n                   temp[i]=node->val;\\n                }else{\\n                    //if flag==0 then store right to left\\n                    temp[size-i-1]=node->val;\\n                }\\n                //pushing the left and right of nodes \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n            }\\n            //if flag==1 then left to right, now we change to 0 to indicate its time for right to left, similarly vice versa\\n            flag=!flag;\\n            //pusshing the temp vector\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784042,
                "title": "java-solution-queue",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        if (root == null) {\\n            return new ArrayList<>();\\n        }\\n        List<List<Integer>> list = new ArrayList<>();\\n        int level = 1;\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while (!q.isEmpty()) {\\n            List<Integer> inner = new ArrayList<>();\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode n = q.poll();\\n                if (n != null) {\\n                    inner.add(n.val);\\n                    if (n.left != null) {\\n                         q.add(n.left);\\n                    }\\n                    if (n.right != null) {\\n                         q.add(n.right);\\n                    }\\n                   \\n                }\\n            }\\n            if (level % 2 == 0) {\\n                Collections.reverse(inner);\\n            }\\n            list.add(inner);\\n            level++;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        if (root == null) {\\n            return new ArrayList<>();\\n        }\\n        List<List<Integer>> list = new ArrayList<>();\\n        int level = 1;\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while (!q.isEmpty()) {\\n            List<Integer> inner = new ArrayList<>();\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode n = q.poll();\\n                if (n != null) {\\n                    inner.add(n.val);\\n                    if (n.left != null) {\\n                         q.add(n.left);\\n                    }\\n                    if (n.right != null) {\\n                         q.add(n.right);\\n                    }\\n                   \\n                }\\n            }\\n            if (level % 2 == 0) {\\n                Collections.reverse(inner);\\n            }\\n            list.add(inner);\\n            level++;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749136,
                "title": "easy-c-solution-100-faster-0ms-runtime",
                "content": "Here is my C++ Solution: \\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\n \\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if (root==NULL)return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool chk=0;\\n        TreeNode* node= root;\\n        while (!q.empty()){\\n            int size= q.size();\\n            vector<int> temp(size);\\n            for (int i=0; i<size; i++){\\n                TreeNode* ele= q.front();\\n                q.pop();\\n                int ind= (chk)? size-i-1: i;\\n                temp[ind]=(ele->val);\\n                if (ele->left)q.push(ele->left);\\n                if (ele->right)q.push(ele->right);\\n            }\\n            ans.push_back(temp);\\n            chk= !chk;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\n \\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if (root==NULL)return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool chk=0;\\n        TreeNode* node= root;\\n        while (!q.empty()){\\n            int size= q.size();\\n            vector<int> temp(size);\\n            for (int i=0; i<size; i++){\\n                TreeNode* ele= q.front();\\n                q.pop();\\n                int ind= (chk)? size-i-1: i;\\n                temp[ind]=(ele->val);\\n                if (ele->left)q.push(ele->left);\\n                if (ele->right)q.push(ele->right);\\n            }\\n            ans.push_back(temp);\\n            chk= !chk;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717086,
                "title": "python-bfs-easy",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root: return []\\n        ans,q,c = [],[root],1\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            if c == 1:\\n                ans.append(l)\\n            else:\\n                ans.append(l[::-1])\\n            c = 1-c\\n        return ans            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root: return []\\n        ans,q,c = [],[root],1\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            if c == 1:\\n                ans.append(l)\\n            else:\\n                ans.append(l[::-1])\\n            c = 1-c\\n        return ans            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537947,
                "title": "python-queue-bfs-easy-to-understand-approach",
                "content": "**Do consider upvoting!! if you find the solution helpful.**\\nLeave queries in the comments if you have any.\\n\\nHappy Coding \\n\\n\\n```\\nif not root:\\n            return None\\n        q = [root] # create a queueand store root inside\\n        ans = []\\n        zig = True #A variable to control alternate reversing of levels\\n        while q:\\n            l = []\\n            for i in range(len(q)): #implementing level order\\n                node = q.pop(0)\\n                l.append(node.val)\\n                if node.left:  q.append(node.left)\\n                if node.right: q.append(node.right)\\n            if not zig: #reversing every next level\\n                l.reverse()\\n            zig = not zig\\n            ans.append(l)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nif not root:\\n            return None\\n        q = [root] # create a queueand store root inside\\n        ans = []\\n        zig = True #A variable to control alternate reversing of levels\\n        while q:\\n            l = []\\n            for i in range(len(q)): #implementing level order\\n                node = q.pop(0)\\n                l.append(node.val)\\n                if node.left:  q.append(node.left)\\n                if node.right: q.append(node.right)\\n            if not zig: #reversing every next level\\n                l.reverse()\\n            zig = not zig\\n            ans.append(l)\\n        return ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402132,
                "title": "python-simple-bfs",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        level  = 0 # if even normal bfs, else reverse row\\n        queue = deque([(root)])\\n        ans = []\\n        \\n        while queue:\\n            size = len(queue)\\n            level_nodes = []\\n            for _ in range(size):\\n                curr = queue.popleft()\\n        \\n                level_nodes.append(curr.val)        \\n                \\n                if curr.left:\\n                    queue.append(curr.left)\\n                \\n                if curr.right:\\n                    queue.append(curr.right)\\n            \\n            # if odd, just reverse the level\\n            if level % 2 == 1:\\n                level_nodes.reverse()\\n                \\n            level += 1\\n            ans.append(level_nodes)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        level  = 0 # if even normal bfs, else reverse row\\n        queue = deque([(root)])\\n        ans = []\\n        \\n        while queue:\\n            size = len(queue)\\n            level_nodes = []\\n            for _ in range(size):\\n                curr = queue.popleft()\\n        \\n                level_nodes.append(curr.val)        \\n                \\n                if curr.left:\\n                    queue.append(curr.left)\\n                \\n                if curr.right:\\n                    queue.append(curr.right)\\n            \\n            # if odd, just reverse the level\\n            if level % 2 == 1:\\n                level_nodes.reverse()\\n                \\n            level += 1\\n            ans.append(level_nodes)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382062,
                "title": "c-using-queue-faster-than-100-memory-less-than-92",
                "content": "\\'\\'\\' class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>v;\\n        if(root==NULL){\\n            return v;\\n        }\\n        queue<TreeNode*>q;\\n        \\n        q.push(root);\\n        int T = 0;\\n        while(!q.empty()){\\n            vector<int>ans;\\n            int sz = q.size();\\n            for(int i = 0;i<sz;i++){\\n                TreeNode* node =q.front();\\n                q.pop();\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n                ans.push_back(node->val);\\n            }\\n            if(T==0){\\n                v.push_back(ans);\\n                T = 1;\\n            }\\n            else{\\n                reverse(ans.begin(),ans.end());\\n                v.push_back(ans);\\n                T = 0;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>v;\\n        if(root==NULL){\\n            return v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2294098,
                "title": "java-1ms-easy-understanding",
                "content": "In order to traverse the tree in zigzag order, Implement level order traversal and reverse level order traversal for alternative levels\\n\\n\\n public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n            if(root == null){\\n                return result;\\n            }\\n            Queue<TreeNode> queue = new LinkedList<>();\\n            queue.offer(root);\\n            boolean isLeftToRight = true;\\n            while(!queue.isEmpty()){\\n                int size = queue.size();\\n                List<Integer> temp = new ArrayList<>(size);\\n                for(int i=0;i<size;i++){\\n                    TreeNode node = queue.poll();\\n                    //level order traversal\\n                    if(isLeftToRight){\\n                        temp.add(node.val);\\n                    } else {\\n                    //reverse order traversal\\n                        temp.add(0,node.val);\\n                    }\\n                \\n                    if(node.left != null ){\\n                        queue.offer(node.left);\\n                    }\\n                    if(node.right != null){\\n                        queue.offer(node.right);\\n                    }\\n                }\\n                result.add(temp);\\n                isLeftToRight = !isLeftToRight;\\n            }\\n            return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "In order to traverse the tree in zigzag order, Implement level order traversal and reverse level order traversal for alternative levels\\n\\n\\n public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n            if(root == null){\\n                return result;\\n            }\\n            Queue<TreeNode> queue = new LinkedList<>();\\n            queue.offer(root);\\n            boolean isLeftToRight = true;\\n            while(!queue.isEmpty()){\\n                int size = queue.size();\\n                List<Integer> temp = new ArrayList<>(size);\\n                for(int i=0;i<size;i++){\\n                    TreeNode node = queue.poll();\\n                    //level order traversal\\n                    if(isLeftToRight){\\n                        temp.add(node.val);\\n                    } else {\\n                    //reverse order traversal\\n                        temp.add(0,node.val);\\n                    }\\n                \\n                    if(node.left != null ){\\n                        queue.offer(node.left);\\n                    }\\n                    if(node.right != null){\\n                        queue.offer(node.right);\\n                    }\\n                }\\n                result.add(temp);\\n                isLeftToRight = !isLeftToRight;\\n            }\\n            return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2287298,
                "title": "faster-than-100-without-reverse-with-explanation",
                "content": "\\uD83D\\uDD25 **Please Upvote, It is FREE from your side**\\n\\n\\u26BD\\uFE0F **Approach:-**\\n\\n*Rest of the problem is same as Level order traversal. Only catch is when to traverse in reverse direction on a particular level, For that make a variable that toogles accordingly.*\\n```\\n#define Tn TreeNode*\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if(!root){\\n            return {};\\n        }\\n        \\n        int reverseNeeded = 0;\\n        queue<TreeNode*> queue;\\n        queue.push(root);\\n        \\n        vector<vector<int>> res;\\n        \\n        while(!queue.empty()){\\n            int size = queue.size();\\n            vector<int> temp(size);\\n            \\n            int index = reverseNeeded?size-1:0;\\n            \\n            for(int i = 0; i<size; i++){\\n                Tn node = queue.front();\\n                temp[index] = node->val;\\n                index = reverseNeeded?index-1:index+1;\\n                if(node->left){\\n                    queue.push(node->left);\\n                }\\n                if(node->right){\\n                    queue.push(node->right);\\n                }\\n                queue.pop();\\n            }\\n            \\n            reverseNeeded = reverseNeeded?0:1;\\n            res.push_back(temp);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n#define Tn TreeNode*\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        if(!root){\\n            return {};\\n        }\\n        \\n        int reverseNeeded = 0;\\n        queue<TreeNode*> queue;\\n        queue.push(root);\\n        \\n        vector<vector<int>> res;\\n        \\n        while(!queue.empty()){\\n            int size = queue.size();\\n            vector<int> temp(size);\\n            \\n            int index = reverseNeeded?size-1:0;\\n            \\n            for(int i = 0; i<size; i++){\\n                Tn node = queue.front();\\n                temp[index] = node->val;\\n                index = reverseNeeded?index-1:index+1;\\n                if(node->left){\\n                    queue.push(node->left);\\n                }\\n                if(node->right){\\n                    queue.push(node->right);\\n                }\\n                queue.pop();\\n            }\\n            \\n            reverseNeeded = reverseNeeded?0:1;\\n            res.push_back(temp);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226853,
                "title": "c-100-fast-iterative-solution-using-queue-stack",
                "content": "```\\n\\n\\nclass Solution {\\n public:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        vector<vector<int>> output;\\n        bool ltor = true; //left to right\\n        if(root!=nullptr)\\n            q.push(root);\\n        while(q.size()){\\n            int s = q.size();\\n            vector<int>levelTraversal;\\n            if(ltor){\\n                while(s>0){\\n                    TreeNode* temp =  q.front();\\n                    q.pop();\\n                    levelTraversal.push_back(temp->val);\\n                    if(temp->left !=nullptr) q.push(temp->left);\\n                    if(temp->right!=nullptr) q.push(temp->right);\\n                    s--;  \\n                }\\n                output.push_back(levelTraversal);\\n                ltor = false;\\n            }\\n            else{\\n                while(s>0){\\n                    TreeNode* temp=q.front();\\n                    q.pop();\\n                    st.push(temp);\\n                    if(temp->left !=nullptr) q.push(temp->left);\\n                    if(temp->right!=nullptr) q.push(temp->right);\\n                    s--;\\n                }\\n                while(!st.empty()){\\n                    TreeNode* temp=st.top();\\n                    st.pop();\\n                    levelTraversal.push_back(temp->val);\\n                }\\n                output.push_back(levelTraversal);\\n                ltor=true;\\n            } \\n        }\\n        return output;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n public:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        vector<vector<int>> output;\\n        bool ltor = true; //left to right\\n        if(root!=nullptr)\\n            q.push(root);\\n        while(q.size()){\\n            int s = q.size();\\n            vector<int>levelTraversal;\\n            if(ltor){\\n                while(s>0){\\n                    TreeNode* temp =  q.front();\\n                    q.pop();\\n                    levelTraversal.push_back(temp->val);\\n                    if(temp->left !=nullptr) q.push(temp->left);\\n                    if(temp->right!=nullptr) q.push(temp->right);\\n                    s--;  \\n                }\\n                output.push_back(levelTraversal);\\n                ltor = false;\\n            }\\n            else{\\n                while(s>0){\\n                    TreeNode* temp=q.front();\\n                    q.pop();\\n                    st.push(temp);\\n                    if(temp->left !=nullptr) q.push(temp->left);\\n                    if(temp->right!=nullptr) q.push(temp->right);\\n                    s--;\\n                }\\n                while(!st.empty()){\\n                    TreeNode* temp=st.top();\\n                    st.pop();\\n                    levelTraversal.push_back(temp->val);\\n                }\\n                output.push_back(levelTraversal);\\n                ltor=true;\\n            } \\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051445,
                "title": "binary-tree-zigzag-level-order-traversal",
                "content": "```\\n vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n       vector<vector<int>>res;\\n        if(root==NULL)return res;\\n         \\n        queue<TreeNode *>nodes;\\n        nodes.push(root);\\n        bool left_to_right=true;\\n        while(!nodes.empty())\\n        {\\n            int size=nodes.size();\\n            vector<int>row(size);\\n            int index=-1;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode *curr=nodes.front();\\n                if(left_to_right)\\n                    index=i;\\n                else index=size-i-1;\\n                row[index]=curr->val;\\n                \\n                if(curr->left)nodes.push(curr->left);\\n                if(curr->right)nodes.push(curr->right);\\n                \\n                nodes.pop();\\n            }\\n            res.push_back(row);\\n            left_to_right=!left_to_right;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n       vector<vector<int>>res;\\n        if(root==NULL)return res;\\n         \\n        queue<TreeNode *>nodes;\\n        nodes.push(root);\\n        bool left_to_right=true;\\n        while(!nodes.empty())\\n        {\\n            int size=nodes.size();\\n            vector<int>row(size);\\n            int index=-1;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode *curr=nodes.front();\\n                if(left_to_right)\\n                    index=i;\\n                else index=size-i-1;\\n                row[index]=curr->val;\\n                \\n                if(curr->left)nodes.push(curr->left);\\n                if(curr->right)nodes.push(curr->right);\\n                \\n                nodes.pop();\\n            }\\n            res.push_back(row);\\n            left_to_right=!left_to_right;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785296,
                "title": "queue-bfs-explaination",
                "content": "C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> result;\\n        if(root == NULL) return result;\\n        \\n        queue<TreeNode*> nodesQueue;\\n        nodesQueue.push(root);\\n        bool leftToRight = true;    // true means L to R, false R to L\\n        \\n        while(!nodesQueue.empty()){\\n            //taking all the node of that levels \\n            int size = nodesQueue.size();\\n            vector<int> row(size);\\n            // Level Process\\n            for(int i=0; i<size; i++){\\n                TreeNode* node = nodesQueue.front();\\n                nodesQueue.pop();\\n                \\n                //find position to fill nodes values\\n                // if true in crct position else reverse\\n                int index = (leftToRight) ? i : (size - 1 - i);\\n                row[index] = node->val;\\n                if(node->left){\\n                    nodesQueue.push(node->left);\\n                }\\n                if(node->right){\\n                    nodesQueue.push(node->right);\\n                }\\n            }\\n            // after this level (switch over the flag) // direction change\\n            leftToRight = !leftToRight;\\n            result.push_back(row);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nNotes Link\\nhttps://github.com/rizonkumar/LeetCode-Notes/blob/main/103.pdf",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> result;\\n        if(root == NULL) return result;\\n        \\n        queue<TreeNode*> nodesQueue;\\n        nodesQueue.push(root);\\n        bool leftToRight = true;    // true means L to R, false R to L\\n        \\n        while(!nodesQueue.empty()){\\n            //taking all the node of that levels \\n            int size = nodesQueue.size();\\n            vector<int> row(size);\\n            // Level Process\\n            for(int i=0; i<size; i++){\\n                TreeNode* node = nodesQueue.front();\\n                nodesQueue.pop();\\n                \\n                //find position to fill nodes values\\n                // if true in crct position else reverse\\n                int index = (leftToRight) ? i : (size - 1 - i);\\n                row[index] = node->val;\\n                if(node->left){\\n                    nodesQueue.push(node->left);\\n                }\\n                if(node->right){\\n                    nodesQueue.push(node->right);\\n                }\\n            }\\n            // after this level (switch over the flag) // direction change\\n            leftToRight = !leftToRight;\\n            result.push_back(row);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778365,
                "title": "c-clean-easy-bfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n\\t\\t\\tvector<vector<int>> result;\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\tqueue<TreeNode*>q;\\n\\t\\t\\tq.push(root);\\n\\n\\t\\t\\tbool lefttoright = true;\\n\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\tvector<int>ans(size);\\n\\t\\t\\t\\tfor(int i=0;i<size;i++){\\n\\t\\t\\t\\t\\tTreeNode* frontnode = q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\t\\tint index = lefttoright ? i : size - i - 1;\\n\\t\\t\\t\\t\\tans[index] = frontnode -> val;\\n\\n\\t\\t\\t\\t\\tif(frontnode->left != NULL)\\n\\t\\t\\t\\t\\t\\tq.push(frontnode->left);\\n\\n\\t\\t\\t\\t\\tif(frontnode->right != NULL)\\n\\t\\t\\t\\t\\t\\tq.push(frontnode->right);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlefttoright = !lefttoright;\\n\\n\\t\\t\\t\\t\\t result.push_back(ans);\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n\\t\\t\\tvector<vector<int>> result;\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\tqueue<TreeNode*>q;\\n\\t\\t\\tq.push(root);\\n\\n\\t\\t\\tbool lefttoright = true;\\n\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\tvector<int>ans(size);\\n\\t\\t\\t\\tfor(int i=0;i<size;i++){\\n\\t\\t\\t\\t\\tTreeNode* frontnode = q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\t\\tint index = lefttoright ? i : size - i - 1;\\n\\t\\t\\t\\t\\tans[index] = frontnode -> val;\\n\\n\\t\\t\\t\\t\\tif(frontnode->left != NULL)\\n\\t\\t\\t\\t\\t\\tq.push(frontnode->left);\\n\\n\\t\\t\\t\\t\\tif(frontnode->right != NULL)\\n\\t\\t\\t\\t\\t\\tq.push(frontnode->right);\\n\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1775179,
                "title": "python-solution-bfs-easy-to-understand",
                "content": "This solution is exactly the same as` LEVEL ORDER TRAVERSAL.` We just had to make few minor changes.\\n1. Declare a `FLAG` variable.\\n\\t*. Append level according to the value of` FLAG`\\n       \\t\\t\\t\\n2. Every thing else is same.\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res=[]\\n        q=collections.deque()\\n        q.append(root)\\n        flag=0\\n        while q:\\n            level=[]\\n            qlen=len(q)\\n            for i in range(qlen):\\n                node=q.popleft()\\n                if node:\\n                    level.append(node.val)\\n                    q.append(node.left)\\n                    q.append(node.right)\\n            if level:\\n                if flag==0:\\n                    res.append(level)\\n                elif flag ==1:\\n                    res.append(level[::-1])\\n            if flag==0:\\n                flag=1\\n            elif flag==1:\\n                flag=0\\n        return res\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res=[]\\n        q=collections.deque()\\n        q.append(root)\\n        flag=0\\n        while q:\\n            level=[]\\n            qlen=len(q)\\n            for i in range(qlen):\\n                node=q.popleft()\\n                if node:\\n                    level.append(node.val)\\n                    q.append(node.left)\\n                    q.append(node.right)\\n            if level:\\n                if flag==0:\\n                    res.append(level)\\n                elif flag ==1:\\n                    res.append(level[::-1])\\n            if flag==0:\\n                flag=1\\n            elif flag==1:\\n                flag=0\\n        return res\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535797,
                "title": "c-bfs-simple-solution-using-queue-and-stack-90",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ZigzagLevelOrder(TreeNode root) {\\n        List<IList<int>> result = new List<IList<int>>();\\n\\t\\t\\n        if(root == null)\\n        {\\n            return result;\\n        }\\n        \\n        Queue<TreeNode> nodeQueue = new Queue<TreeNode>();\\n        \\n        nodeQueue.Enqueue(root);\\n        \\n        int level = 0;\\n        \\n        while(nodeQueue.Count > 0)\\n        {\\n            List<int> currentLevelVals = new List<int>();\\n            \\n            int currentLevelSize = nodeQueue.Count;\\n            \\n            Stack<TreeNode> nextLevelNodes = new Stack<TreeNode>();\\n            \\n            for(int i=0; i<currentLevelSize; i++)\\n            {\\n                TreeNode current = nodeQueue.Dequeue();\\n                \\n                currentLevelVals.Add(current.val);\\n                \\n                if(level % 2 == 1)\\n                {\\n                    if(current.right != null)\\n                    {\\n                        nextLevelNodes.Push(current.right);\\n                    }\\n                    \\n                    if(current.left != null)\\n                    {\\n                        nextLevelNodes.Push(current.left);\\n                    }\\n                }\\n                else\\n                {\\n                    if(current.left != null)\\n                    {\\n                        nextLevelNodes.Push(current.left);\\n                    }\\n                    \\n                    if(current.right != null)\\n                    {\\n                        nextLevelNodes.Push(current.right);\\n                    }\\n                }  \\n            }\\n            \\n            while(nextLevelNodes.Count > 0)\\n            {\\n                nodeQueue.Enqueue(nextLevelNodes.Pop());\\n            }\\n            \\n            level++;\\n            result.Add(currentLevelVals);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ZigzagLevelOrder(TreeNode root) {\\n        List<IList<int>> result = new List<IList<int>>();\\n\\t\\t\\n        if(root == null)\\n        {\\n            return result;\\n        }\\n        \\n        Queue<TreeNode> nodeQueue = new Queue<TreeNode>();\\n        \\n        nodeQueue.Enqueue(root);\\n        \\n        int level = 0;\\n        \\n        while(nodeQueue.Count > 0)\\n        {\\n            List<int> currentLevelVals = new List<int>();\\n            \\n            int currentLevelSize = nodeQueue.Count;\\n            \\n            Stack<TreeNode> nextLevelNodes = new Stack<TreeNode>();\\n            \\n            for(int i=0; i<currentLevelSize; i++)\\n            {\\n                TreeNode current = nodeQueue.Dequeue();\\n                \\n                currentLevelVals.Add(current.val);\\n                \\n                if(level % 2 == 1)\\n                {\\n                    if(current.right != null)\\n                    {\\n                        nextLevelNodes.Push(current.right);\\n                    }\\n                    \\n                    if(current.left != null)\\n                    {\\n                        nextLevelNodes.Push(current.left);\\n                    }\\n                }\\n                else\\n                {\\n                    if(current.left != null)\\n                    {\\n                        nextLevelNodes.Push(current.left);\\n                    }\\n                    \\n                    if(current.right != null)\\n                    {\\n                        nextLevelNodes.Push(current.right);\\n                    }\\n                }  \\n            }\\n            \\n            while(nextLevelNodes.Count > 0)\\n            {\\n                nodeQueue.Enqueue(nextLevelNodes.Pop());\\n            }\\n            \\n            level++;\\n            result.Add(currentLevelVals);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515138,
                "title": "java-easy-stack-based",
                "content": "Reverse at even levels.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        if(root==null)\\n            return res;\\n        Queue <TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int n = 1;\\n        while(!q.isEmpty())\\n        {\\n            int level = q.size();\\n            List<Integer> levelNodes = new ArrayList<>();\\n            for(int i = 0;i<level ;i++)\\n            {\\n                TreeNode cur = q.remove();\\n                levelNodes.add(cur.val);\\n                if(cur.left!=null)\\n                    q.add(cur.left);\\n                if(cur.right!=null)\\n                    q.add(cur.right);\\n                \\n            }\\n            if(n%2==0)\\n                Collections.reverse(levelNodes);\\n            res.add(levelNodes);\\n            n++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        if(root==null)\\n            return res;\\n        Queue <TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int n = 1;\\n        while(!q.isEmpty())\\n        {\\n            int level = q.size();\\n            List<Integer> levelNodes = new ArrayList<>();\\n            for(int i = 0;i<level ;i++)\\n            {\\n                TreeNode cur = q.remove();\\n                levelNodes.add(cur.val);\\n                if(cur.left!=null)\\n                    q.add(cur.left);\\n                if(cur.right!=null)\\n                    q.add(cur.right);\\n                \\n            }\\n            if(n%2==0)\\n                Collections.reverse(levelNodes);\\n            res.add(levelNodes);\\n            n++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498736,
                "title": "c-using-deque-4ms-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(root==NULL) return ans;\\n        deque<TreeNode*> dq;\\n        dq.push_back(root);\\n        int i=0;\\n        TreeNode *temp= new TreeNode();\\n        while(!dq.empty())\\n        {\\n            int s=dq.size();\\n            vector<int> ll;\\n            if(i%2==0)\\n            {\\n                while(s--)\\n                {\\n                    temp=dq.front();\\n                    dq.pop_front();\\n                    ll.push_back(temp->val);\\n                    if(temp->left!=NULL) dq.push_back(temp->left);\\n                    if(temp->right!=NULL) dq.push_back(temp->right);\\n                }\\n            }\\n            else\\n            {\\n                while(s--)\\n                {\\n                    temp=dq.back();\\n                    dq.pop_back();\\n                    ll.push_back(temp->val);\\n                    if(temp->right!=NULL) dq.push_front(temp->right);\\n                    if(temp->left!=NULL) dq.push_front(temp->left);\\n                }\\n            }\\n            ans.push_back(ll);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(root==NULL) return ans;\\n        deque<TreeNode*> dq;\\n        dq.push_back(root);\\n        int i=0;\\n        TreeNode *temp= new TreeNode();\\n        while(!dq.empty())\\n        {\\n            int s=dq.size();\\n            vector<int> ll;\\n            if(i%2==0)\\n            {\\n                while(s--)\\n                {\\n                    temp=dq.front();\\n                    dq.pop_front();\\n                    ll.push_back(temp->val);\\n                    if(temp->left!=NULL) dq.push_back(temp->left);\\n                    if(temp->right!=NULL) dq.push_back(temp->right);\\n                }\\n            }\\n            else\\n            {\\n                while(s--)\\n                {\\n                    temp=dq.back();\\n                    dq.pop_back();\\n                    ll.push_back(temp->val);\\n                    if(temp->right!=NULL) dq.push_front(temp->right);\\n                    if(temp->left!=NULL) dq.push_front(temp->left);\\n                }\\n            }\\n            ans.push_back(ll);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434043,
                "title": "c-bfs-tc-o-n-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        bool leftToRight = 1;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(q.size()){\\n            int n=q.size(); vector<int> temp(n);\\n            for(int i=0;i<n;i++){\\n                int index = leftToRight ? i : n-1-i;\\n                root=q.front(); q.pop();\\n                temp[index] = (root->val);\\n                if(root->left) q.push(root->left);\\n                if(root->right) q.push(root->right);\\n            }\\n            leftToRight = ! leftToRight;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> ans;\\n        if(!root) return ans;\\n        bool leftToRight = 1;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(q.size()){\\n            int n=q.size(); vector<int> temp(n);\\n            for(int i=0;i<n;i++){\\n                int index = leftToRight ? i : n-1-i;\\n                root=q.front(); q.pop();\\n                temp[index] = (root->val);\\n                if(root->left) q.push(root->left);\\n                if(root->right) q.push(root->right);\\n            }\\n            leftToRight = ! leftToRight;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415889,
                "title": "binary-tree-zigzag-level-order-traversal-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        zigzagOrderHelper(output, root, 0);\\n        return output;\\n    }\\n    \\n    public void zigzagOrderHelper(List<List<Integer>> output, TreeNode root, int level) {\\n        if(root == null){\\n            return;\\n        } else {\\n            if(level >= output.size()){\\n                 output.add(new ArrayList<>());\\n            }\\n            if(level % 2 == 0){\\n                output.get(level).add(root.val);\\n            } else {\\n                output.get(level).add(0, root.val);\\n            }\\n            zigzagOrderHelper(output, root.left, level + 1);\\n            zigzagOrderHelper(output, root.right, level + 1);\\n        }\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE .\\nHappy Coding and keep up the good work :)",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        zigzagOrderHelper(output, root, 0);\\n        return output;\\n    }\\n    \\n    public void zigzagOrderHelper(List<List<Integer>> output, TreeNode root, int level) {\\n        if(root == null){\\n            return;\\n        } else {\\n            if(level >= output.size()){\\n                 output.add(new ArrayList<>());\\n            }\\n            if(level % 2 == 0){\\n                output.get(level).add(root.val);\\n            } else {\\n                output.get(level).add(0, root.val);\\n            }\\n            zigzagOrderHelper(output, root.left, level + 1);\\n            zigzagOrderHelper(output, root.right, level + 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302674,
                "title": "java-simple-solution-using-queue-and-stack-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// Solution - Take a queue and a stack :\\n// Add item in queue and iterate over it until it get empty . Start at level 1. For every odd value of    level add the value in new stack and for every even level add directly to the child list . Note -      after done with setting the childs at a level we need to pop up the value in the stack and add it \\n// in the list if stack is not empty so that we could print in zig zag order .\\n\\n\\n\\n// ^ UPVOTE if like the solution \\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        if(root==null) return Collections.emptyList();\\n        List<List<Integer>> result=new ArrayList<>();\\n        Queue<TreeNode> queue=new LinkedList<>();\\n        queue.offer(root);\\n        \\n        int level=1;\\n        while(!queue.isEmpty()){\\n            int queueSize=queue.size();\\n            List<Integer> childList=new ArrayList<>();\\n            Stack<Integer> stack=new Stack<>();\\n            for(int i=0;i<queueSize;i++){\\n                TreeNode currNode=queue.poll();\\n                if(currNode!=null){\\n                    if(level%2==0) stack.add(currNode.val);\\n                    else childList.add(currNode.val);\\n                    if(currNode.left!=null) queue.add(currNode.left);\\n                    if(currNode.right!=null) queue.add(currNode.right);\\n                }\\n            }\\n            if(!stack.isEmpty()) {\\n                while(!stack.isEmpty()){\\n                    childList.add(stack.pop());\\n                }\\n            }\\n            result.add(childList);\\n            level++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// Solution - Take a queue and a stack :\\n// Add item in queue and iterate over it until it get empty . Start at level 1. For every odd value of    level add the value in new stack and for every even level add directly to the child list . Note -      after done with setting the childs at a level we need to pop up the value in the stack and add it \\n// in the list if stack is not empty so that we could print in zig zag order .\\n\\n\\n\\n// ^ UPVOTE if like the solution \\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        if(root==null) return Collections.emptyList();\\n        List<List<Integer>> result=new ArrayList<>();\\n        Queue<TreeNode> queue=new LinkedList<>();\\n        queue.offer(root);\\n        \\n        int level=1;\\n        while(!queue.isEmpty()){\\n            int queueSize=queue.size();\\n            List<Integer> childList=new ArrayList<>();\\n            Stack<Integer> stack=new Stack<>();\\n            for(int i=0;i<queueSize;i++){\\n                TreeNode currNode=queue.poll();\\n                if(currNode!=null){\\n                    if(level%2==0) stack.add(currNode.val);\\n                    else childList.add(currNode.val);\\n                    if(currNode.left!=null) queue.add(currNode.left);\\n                    if(currNode.right!=null) queue.add(currNode.right);\\n                }\\n            }\\n            if(!stack.isEmpty()) {\\n                while(!stack.isEmpty()){\\n                    childList.add(stack.pop());\\n                }\\n            }\\n            result.add(childList);\\n            level++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263714,
                "title": "bfs-easy-c-queue-takes-0ms-beats-100-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* r) {\\n        if(r == nullptr){    // if root is null\\n        return {};\\n        }\\n        vector<vector<int>> a;\\n        queue<TreeNode*> q;      //bfs\\n        q.push(r);\\n        int o=0;     // variable to check odd multiples of loop\\n        while(!q.empty()){\\n            int size = q.size();\\n            double s=size;\\n            vector<int> b;\\n            while(size--){\\n                TreeNode* t= q.front();\\n                q.pop();\\n                b.push_back(t->val);\\n                \\n                if(t->left != nullptr){\\n                    q.push(t->left);\\n                }\\n                if(t->right != nullptr) {\\n                    q.push(t->right);\\n                }\\n            }\\n            if(o%2!=0){  //check if the loop is running odd multiple time\\n                reverse(b.begin(),b.end());     // reverse the level nodes from right to left\\n            }\\n            o++;    //increment \\n            a.push_back(b);\\n        }\\n        return a;\\n    }\\n};\\n```\\n\\nDrop your query if any.",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* r) {\\n        if(r == nullptr){    // if root is null\\n        return {};\\n        }\\n        vector<vector<int>> a;\\n        queue<TreeNode*> q;      //bfs\\n        q.push(r);\\n        int o=0;     // variable to check odd multiples of loop\\n        while(!q.empty()){\\n            int size = q.size();\\n            double s=size;\\n            vector<int> b;\\n            while(size--){\\n                TreeNode* t= q.front();\\n                q.pop();\\n                b.push_back(t->val);\\n                \\n                if(t->left != nullptr){\\n                    q.push(t->left);\\n                }\\n                if(t->right != nullptr) {\\n                    q.push(t->right);\\n                }\\n            }\\n            if(o%2!=0){  //check if the loop is running odd multiple time\\n                reverse(b.begin(),b.end());     // reverse the level nodes from right to left\\n            }\\n            o++;    //increment \\n            a.push_back(b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1005886,
                "title": "java-simple-stack-implementation",
                "content": "Used 2 stacks to maintain zig zag order.\\n```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if(root == null)\\n            return result;\\n        Stack<TreeNode> st1 = new Stack<>();\\n        Stack<TreeNode> st2 = new Stack<>();\\n        st1.push(root);\\n        List<Integer> level = new ArrayList<>();\\n        \\n        while(!st1.isEmpty() || !st2.isEmpty()) {\\n            while(!st1.isEmpty()) {\\n                TreeNode node = st1.pop();\\n                level.add(node.val);\\n                \\n                if(node.left != null)\\n                    st2.push(node.left);\\n                if(node.right != null)\\n                    st2.push(node.right);\\n            }\\n            if(!level.isEmpty())\\n                result.add(new ArrayList<>(level));\\n            level.clear();\\n            \\n            while(!st2.isEmpty()) {\\n                TreeNode node = st2.pop();\\n                level.add(node.val);\\n                \\n                if(node.right != null)\\n                    st1.push(node.right);\\n                if(node.left != null)\\n                    st1.push(node.left);\\n            }\\n            if(!level.isEmpty())\\n                result.add(new ArrayList<>(level));\\n            level.clear();\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if(root == null)\\n            return result;\\n        Stack<TreeNode> st1 = new Stack<>();\\n        Stack<TreeNode> st2 = new Stack<>();\\n        st1.push(root);\\n        List<Integer> level = new ArrayList<>();\\n        \\n        while(!st1.isEmpty() || !st2.isEmpty()) {\\n            while(!st1.isEmpty()) {\\n                TreeNode node = st1.pop();\\n                level.add(node.val);\\n                \\n                if(node.left != null)\\n                    st2.push(node.left);\\n                if(node.right != null)\\n                    st2.push(node.right);\\n            }\\n            if(!level.isEmpty())\\n                result.add(new ArrayList<>(level));\\n            level.clear();\\n            \\n            while(!st2.isEmpty()) {\\n                TreeNode node = st2.pop();\\n                level.add(node.val);\\n                \\n                if(node.right != null)\\n                    st1.push(node.right);\\n                if(node.left != null)\\n                    st1.push(node.left);\\n            }\\n            if(!level.isEmpty())\\n                result.add(new ArrayList<>(level));\\n            level.clear();\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998805,
                "title": "c-0ms-faster-than-100-2-stacks-bfs-approach",
                "content": "We\\'ll maintain 2 Stacks and use BFS for achieving zig-zag traversal:\\nSinces it\\'s zig-zag traversal, in result we want that Odd levels will contain nodes from Left to Right \\nand Even levels will contain nodes from Right to Left\\n![image](https://assets.leetcode.com/users/images/59c8bee3-0c7b-4d6b-a70e-7555cc8a7002_1609977389.6869583.png)\\n\\n* Stack LtoR will be used for storing TreeNodes from Left to Right (for ODD levels)\\n* Stack RtoL will be used for storing TreeNodes from Right to Left. (for EVEN levels)\\n\\nInitially we pushed the Root Node as its the 1st level in LtoR stack.\\nThen we checked if it\\'s left and right nodes exist, if they do, we\\'ll push both of them the other stack (RtoL) because they\\'re in next level so direction should be opposite to current (zig-zag).\\nThen we\\'ll do similar processing in RtoL stack and push its children in LtoR stack and so on...\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> zigZagLevels;\\n        if(root==NULL) return zigZagLevels;\\n        vector<int> level;\\n        stack<TreeNode*> LtoR; // Left to Right\\n        stack<TreeNode*> RtoL; // Right to Left\\n        LtoR.push(root);\\n        int lvl = 1; //level Number\\n        \\n        while(!LtoR.empty() || !RtoL.empty()){\\n           \\n            if(lvl%2 != 0){\\n                while(!LtoR.empty()){\\n                    if(LtoR.top()->left != NULL) RtoL.push(LtoR.top()->left);\\n                    if(LtoR.top()->right !=NULL) RtoL.push(LtoR.top()->right);\\n                    level.push_back(LtoR.top()->val);\\n                    LtoR.pop();\\n                }\\n                zigZagLevels.push_back(level);\\n                level.clear();\\n            }\\n            else {\\n                while(!RtoL.empty()){\\n                    if(RtoL.top()->right != NULL) LtoR.push(RtoL.top()->right);\\n                    if(RtoL.top()->left != NULL) LtoR.push(RtoL.top()->left);\\n                    level.push_back(RtoL.top()->val);\\n                    RtoL.pop();\\n                }\\n                zigZagLevels.push_back(level);\\n                level.clear();\\n            }\\n            ++lvl;\\n            \\n        }\\n        return zigZagLevels;\\n    }\\n};\\n```\\nFeel free to ask anything below :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>> zigZagLevels;\\n        if(root==NULL) return zigZagLevels;\\n        vector<int> level;\\n        stack<TreeNode*> LtoR; // Left to Right\\n        stack<TreeNode*> RtoL; // Right to Left\\n        LtoR.push(root);\\n        int lvl = 1; //level Number\\n        \\n        while(!LtoR.empty() || !RtoL.empty()){\\n           \\n            if(lvl%2 != 0){\\n                while(!LtoR.empty()){\\n                    if(LtoR.top()->left != NULL) RtoL.push(LtoR.top()->left);\\n                    if(LtoR.top()->right !=NULL) RtoL.push(LtoR.top()->right);\\n                    level.push_back(LtoR.top()->val);\\n                    LtoR.pop();\\n                }\\n                zigZagLevels.push_back(level);\\n                level.clear();\\n            }\\n            else {\\n                while(!RtoL.empty()){\\n                    if(RtoL.top()->right != NULL) LtoR.push(RtoL.top()->right);\\n                    if(RtoL.top()->left != NULL) LtoR.push(RtoL.top()->left);\\n                    level.push_back(RtoL.top()->val);\\n                    RtoL.pop();\\n                }\\n                zigZagLevels.push_back(level);\\n                level.clear();\\n            }\\n            ++lvl;\\n            \\n        }\\n        return zigZagLevels;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893106,
                "title": "python-bfs-100-time",
                "content": "Intuition:\\nWe need to traverse the tree in a Zig-Zag manner.\\nIf we would traverse a tree with a normal BFS style, we would **almost** get the expected result, the only thing missing is that it isn\\'t Zig-Zagged... Well duh...\\nSo what do we do?\\n1. We have our BFS rank collection. (I call it level in the algorithm)\\n2. We have a switching variable that will decide if we want the list left->right or right-> left.\\n3. We have the output... woolah\\n\\nNote: `direction = direction ^ 1` - just flips the values between 0 and 1 continuously.\\n\\n#### Algorithm\\n\\n```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        queue = collections.deque([(root, 0)])\\n        levels = collections.defaultdict(list)\\n        result = []\\n        direction = 0 # 0 -> L / 1 -> R\\n        \\n        while queue:\\n            node, level = queue.popleft()\\n            if node:\\n                levels[level].append(node.val)\\n                if node.left:\\n                    queue.append((node.left, level + 1))\\n                if node.right:\\n                    queue.append((node.right, level + 1))\\n                \\n        \\n        for level_collection in levels.values():\\n            if direction == 0:\\n                result.append(level_collection)\\n            else:\\n                # R\\n                result.append(level_collection[::-1])\\n            \\n            direction = direction ^ 1\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\\n        queue = collections.deque([(root, 0)])\\n        levels = collections.defaultdict(list)\\n        result = []\\n        direction = 0 # 0 -> L / 1 -> R\\n        \\n        while queue:\\n            node, level = queue.popleft()\\n            if node:\\n                levels[level].append(node.val)\\n                if node.left:\\n                    queue.append((node.left, level + 1))\\n                if node.right:\\n                    queue.append((node.right, level + 1))\\n                \\n        \\n        for level_collection in levels.values():\\n            if direction == 0:\\n                result.append(level_collection)\\n            else:\\n                # R\\n                result.append(level_collection[::-1])\\n            \\n            direction = direction ^ 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800840,
                "title": "java-2-ms-simple-solution-using-bfs-traversal",
                "content": "This is very similar to Level Order Traversal.\\nA small change that needed is just maintain a variable that will take take care of alternate levels (level%2==0 or not), and add the elements in reverse order at odd levels.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Queue<TreeNode> queue = new LinkedList();\\n        \\n        if(root==null)\\n            return result;\\n        \\n        queue.offer(root);\\n        int level = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            List<Integer> currentLevel = new ArrayList<>();\\n            for(int i=0;i<size;i++){\\n                TreeNode node = queue.poll();\\n                if(node.left!=null)\\n                    queue.offer(node.left);\\n                if(node.right!=null)\\n                    queue.offer(node.right);\\n                if(level%2==0)\\n                    currentLevel.add(node.val);\\n                else\\n                    currentLevel.add(0, node.val);\\n            }\\n            result.add(currentLevel);\\n            level++;\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Queue<TreeNode> queue = new LinkedList();\\n        \\n        if(root==null)\\n            return result;\\n        \\n        queue.offer(root);\\n        int level = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            List<Integer> currentLevel = new ArrayList<>();\\n            for(int i=0;i<size;i++){\\n                TreeNode node = queue.poll();\\n                if(node.left!=null)\\n                    queue.offer(node.left);\\n                if(node.right!=null)\\n                    queue.offer(node.right);\\n                if(level%2==0)\\n                    currentLevel.add(node.val);\\n                else\\n                    currentLevel.add(0, node.val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 750361,
                "title": "0-ms-with-some-modification-of-level-order",
                "content": "```\\n   vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n vector<vector<int>> output;\\n      if(!root) return output;\\nqueue<TreeNode *> level;\\n level.push(root);\\n level.push(NULL);\\n int flag=1;\\n stack<int> st;\\n queue<int> q;\\n while(level.size()){\\n \\tTreeNode *temp=level.front();\\n \\tlevel.pop();\\n \\tvector<int> ans;\\n \\twhile(temp){\\n \\t\\tif(flag) q.push(temp->val);\\n \\t\\telse st.push(temp->val);\\n \\t\\tif(temp->left) level.push(temp->left);\\n \\t\\tif(temp->right) level.push(temp->right);\\n \\t\\ttemp=level.front();\\n \\t\\tlevel.pop();\\n \\t}\\n \\tif(level.size()) level.push(NULL);\\n \\tif(flag){\\n \\t\\twhile(q.size()){\\n \\t\\t\\tans.push_back(q.front());\\n \\t\\t\\tq.pop();\\n \\t\\t}\\n \\t}else{\\n \\t\\twhile(st.size()){\\n \\t\\t\\tans.push_back(st.top());\\n \\t\\t\\tst.pop();\\n \\t\\t}\\n \\t}\\n \\toutput.push_back(ans);\\n \\tflag^=1;\\n }\\n return output;        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n vector<vector<int>> output;\\n      if(!root) return output;\\nqueue<TreeNode *> level;\\n level.push(root);\\n level.push(NULL);\\n int flag=1;\\n stack<int> st;\\n queue<int> q;\\n while(level.size()){\\n \\tTreeNode *temp=level.front();\\n \\tlevel.pop();\\n \\tvector<int> ans;\\n \\twhile(temp){\\n \\t\\tif(flag) q.push(temp->val);\\n \\t\\telse st.push(temp->val);\\n \\t\\tif(temp->left) level.push(temp->left);\\n \\t\\tif(temp->right) level.push(temp->right);\\n \\t\\ttemp=level.front();\\n \\t\\tlevel.pop();\\n \\t}\\n \\tif(level.size()) level.push(NULL);\\n \\tif(flag){\\n \\t\\twhile(q.size()){\\n \\t\\t\\tans.push_back(q.front());\\n \\t\\t\\tq.pop();\\n \\t\\t}\\n \\t}else{\\n \\t\\twhile(st.size()){\\n \\t\\t\\tans.push_back(st.top());\\n \\t\\t\\tst.pop();\\n \\t\\t}\\n \\t}\\n \\toutput.push_back(ans);\\n \\tflag^=1;\\n }\\n return output;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748992,
                "title": "easy-to-understand-solution-0ms",
                "content": "Flag is used to check whether we want to add our answer from left to right, or from right to left.\\n\\n**Update 1**: Now the time is improved further by usage of linked List for inserting at the starting index.\\n\\nPlease ping me if u need any  clarification. Hope it helps.\\n\\n```\\n public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new LinkedList<>();\\n\\t\\t\\n        if(root==null)\\n            return ans;\\n\\t\\t\\t\\n        traverse(root,ans,true);\\n        return ans;\\n    }\\n\\t\\n    public void traverse(TreeNode root,List<List<Integer>> ans,boolean flag){\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while(!queue.isEmpty()){\\n            LinkedList<Integer> res = new LinkedList<>();\\n            int size = queue.size();\\n\\t\\t\\t\\n            while(size-->0){\\n\\t\\t\\t\\n                TreeNode temp = queue.poll();\\n                if(!flag == true){\\n                    res.addFirst(temp.val);        // Add at the 0th Index  O(1)\\n                }else{ \\n                   res.add(temp.val);              // Add at the current index. O(1)\\n                }\\n\\t\\t\\t\\t\\n                if(temp.left!=null)\\n                    queue.add(temp.left);      \\n                if(temp.right!=null)\\n                    queue.add(temp.right);\\n                \\n            }\\n            flag = !flag ;                         // Inverse the flag.\\n            ans.add(res);                          // Add the temporary result to actual answer.\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "Flag is used to check whether we want to add our answer from left to right, or from right to left.\\n\\n**Update 1**: Now the time is improved further by usage of linked List for inserting at the starting index.\\n\\nPlease ping me if u need any  clarification. Hope it helps.\\n\\n```\\n public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> ans = new LinkedList<>();\\n\\t\\t\\n        if(root==null)\\n            return ans;\\n\\t\\t\\t\\n        traverse(root,ans,true);\\n        return ans;\\n    }\\n\\t\\n    public void traverse(TreeNode root,List<List<Integer>> ans,boolean flag){\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while(!queue.isEmpty()){\\n            LinkedList<Integer> res = new LinkedList<>();\\n            int size = queue.size();\\n\\t\\t\\t\\n            while(size-->0){\\n\\t\\t\\t\\n                TreeNode temp = queue.poll();\\n                if(!flag == true){\\n                    res.addFirst(temp.val);        // Add at the 0th Index  O(1)\\n                }else{ \\n                   res.add(temp.val);              // Add at the current index. O(1)\\n                }\\n\\t\\t\\t\\t\\n                if(temp.left!=null)\\n                    queue.add(temp.left);      \\n                if(temp.right!=null)\\n                    queue.add(temp.right);\\n                \\n            }\\n            flag = !flag ;                         // Inverse the flag.\\n            ans.add(res);                          // Add the temporary result to actual answer.\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 748745,
                "title": "simple-bfs-well-explained",
                "content": "**main idea is to maintain a flag variable \"rev\" which when true we will start filling the temp vector from behind and when flag variable is false we will fill it from the front.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) \\n    {\\n        vector<vector<int>>ans;\\n        if(!root)\\n            return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool rev = false;\\n        \\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size(); \\n            vector<int>temp(n);    \\n            for(int i=0;i<n;i++)\\n            {\\n                auto it = q.front();\\n                q.pop();\\n                \\n                int ind = rev?n-i-1 : i;\\n                temp[ind] = it->val;\\n                if(it->left)\\n                {\\n                    q.push(it->left);\\n                }\\n                if(it->right)\\n                {\\n                    q.push(it->right);\\n                }\\n            }\\n                       \\n            ans.push_back(temp);\\n            rev = !rev;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) \\n    {\\n        vector<vector<int>>ans;\\n        if(!root)\\n            return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool rev = false;\\n        \\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size(); \\n            vector<int>temp(n);    \\n            for(int i=0;i<n;i++)\\n            {\\n                auto it = q.front();\\n                q.pop();\\n                \\n                int ind = rev?n-i-1 : i;\\n                temp[ind] = it->val;\\n                if(it->left)\\n                {\\n                    q.push(it->left);\\n                }\\n                if(it->right)\\n                {\\n                    q.push(it->right);\\n                }\\n            }\\n                       \\n            ans.push_back(temp);\\n            rev = !rev;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1806163,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806157,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1567192,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806174,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1571218,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806708,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806139,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1761729,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806261,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806170,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806163,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806157,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1567192,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806174,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1571218,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806708,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806139,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1761729,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806261,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1806170,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "Started this week with :**I am freaking Genius!**\\nAnd ending it with :**back to being dumb**."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "same energy"
                    },
                    {
                        "username": "santanusen",
                        "content": "Some of the traps to avoid -\nUsing a stack for BFS\nTrying to alter order in which left and right child nodes are inserted at each level.\n\nA good testcase [1,2,3,4,null,null,5]"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "this question was easy"
                    },
                    {
                        "username": "thisannie",
                        "content": "Leetcode be like*\\nEnough Trees, let\\'s give them forest now."
                    },
                    {
                        "username": "santanusen",
                        "content": "[@charonme](/charonme) The idea of continents may not apply to all planets. Most of the planets don't have life. So the tree is sparse!"
                    },
                    {
                        "username": "charonme",
                        "content": "a list of galaxies, each with a list of solar systems, each with a list of planets, each with a list of continents, each with a list of forests, each with a list of trees is still a tree ;)"
                    },
                    {
                        "username": "blursh",
                        "content": "It seems like the solution can be obtained by just manipulating the answer from the level order question."
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "It seems we should use deque instead of queue from previous question."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "exactly!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\n### BFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_BFS.png)\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_deque.png)\\n\\n### DFS\\n![](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/461703/Figures/103/103_DFS.png)"
                    },
                    {
                        "username": "n_jafr",
                        "content": "Input:\\t{1,2,3,4,#,#,5}\\nOutput:\\t[[1],[3,2],[5,4]]\\nExpected: [[1],[3,2],[4,5]]"
                    },
                    {
                        "username": "beenas1",
                        "content": "Can someone please explain how this testcase is correct"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "is this testcase correct? if yes how?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "is this testcase incorrect?\\n"
                    },
                    {
                        "username": "crusifixx",
                        "content": "Hint\n1. Its obvious that we need the regular Level Order Logic.\n2.Try thinking in terms of even odd levels.\n3.Use Linked List to store values of even levels using add() and for odd levels use addFirst() to achieve O(1) insertion in both cases\n\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "You really do not need Linked List.\\nDo not forget about Deque data structure! "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "any idea how to add the root in the final list? This is my code\\n\\n```\\n List<List<Integer>> ans= new ArrayList<>();\\n        if(root==null) return ans;\\n        int count=0;\\n        Queue<TreeNode> q= new LinkedList<>();\\n        \\n        q.add(root);\\n\\n        boolean leftToRight=true;        \\n        while(!q.isEmpty())\\n        {\\n             count= q.size();\\n             LinkedList<Integer> level= new LinkedList<>();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode curr= q.poll();\\n                level.add()\\n                if(curr.left!=null) q.add(curr.left);\\n                if(curr.right!=null) q.add(curr.right);\\n                if(leftToRight) \\n                {\\n                    \\n                    // flag true -> odd level-> children pushed to stack\\n                    if(curr.left!=null) level.addFirst(curr.left.val);\\n                    if(curr.right!=null) level.addFirst(curr.right.val);\\n                }\\n                else{\\n                    if(curr.left!=null) level.addLast(curr.left.val);\\n                    if(curr.right!=null) level.addLast(curr.right.val);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            ans.add(level);\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "raymondzheng98",
                        "content": "even the medium questions are suspiciously easy."
                    },
                    {
                        "username": "moonpatel2003",
                        "content": "it means you just got better at it . "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes bro. hahaha\\n"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "couldnot agree more\\n"
                    },
                    {
                        "username": "Praddyumn",
                        "content": "Hint: You can use a combination of stack and queue for solving this problem.\\nUnlike BFS, where we directly push the children into the queue, here we can first push them into a stack and then push all the stack elements into the queue for the next level traversal.\\n\\nAlso keep a flag pointer to just check at every level, whether you need to go from left to right or right to left. Based on this flag, you decide whether you should push the left child first or the right child first."
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@puneetripathi](/puneetripathi) why did this not occur to me. Thats a pretty great approach"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "why bother using the extra space you can just reverse the level-order vector, that would take O(n) and no extra space. Use the flag to check if the vector needs to be reversed or not,"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "ok so EASY days are over\\nbe ready"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "well BFS like usual "
                    }
                ]
            },
            {
                "id": 1571217,
                "content": [
                    {
                        "username": "Ethanlaughs",
                        "content": "I just want to know what does this mean\" The sizes of the arrays are returned as *columnSizes array.\"?\\nany ideals?"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Do they need to pay more ,if they provide some good examples"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Just do the level order traversal but at every odd level , reverse the output"
                    },
                    {
                        "username": "rajdeep_05",
                        "content": "Wonderful trick broo"
                    },
                    {
                        "username": "jahidulislamananto",
                        "content": "Given test cases are almost useless. Explanation of the problem is very poor. If the explanation was clear it can be solved easily "
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Need to include an example test case where a tree level has more than 2 nodes. So we know that each level nodes are to be included in one single list. I first wrote my code to group child nodes together rather than all the nodes in the level."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If it was simply `IEnumerable<IEnumerable<int>>`, we could have used `List<LinkedList<int>>` internally and `AddFirst()` or `AddLast()` on even/ odd levels on the linked list, and it would be a clean one pass solution with no extra space or other penalty.\\n\\nNow we have to reverse alternate levels or Insert at position 0 at lists or use two stacks alternately for left/ right order. Is there any other solution I\\'m missing that needs strictly one pass and no extra space?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        bool lefttoRight=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>level(size);\\n            for(int i=0;i<size; i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left !=NULL)\\n                    q.push(node->left);\\n                if(node->right !=NULL)\\n                    q.push(node->right);\\n                int index=lefttoRight?i:(size-i-1);\\n                level[index] = node->val;\\n            }\\n            lefttoRight=!lefttoRight;\\n            ans.push_back(level);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anshul_sankhyan",
                        "content": "why are we declaring size of level array?"
                    },
                    {
                        "username": "gurunath10",
                        "content": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List <Integer> > ans = new ArrayList<>();\\n        Queue <TreeNode > q = new LinkedList<>();\\n        if (root == null) return ans ;\\n        q.offer(root);\\n        int flag = 1; \\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> ds = new ArrayList<>();\\n            for (int i =0; i < size; i++){\\n                TreeNode cur = q.poll();\\n                if (cur.left  != null) q.offer(cur.left);\\n                if (cur.right != null ) q.offer(cur.right);\\n                \\n                if (flag == 1){\\n                ds.add(cur.val);\\n                }\\n                else {\\n                    ds.add(0,cur.val);\\n                }\\n            }\\n            flag = flag ^ 1;\\n            ans.add(ds);\\n        }return ans;\\n\\n    }"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why people are using extra space when you can just use flag and know whether to store current level in same order or reverse order "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There is a crazy difference between easy and medium questions of binary trees leetcode questions"
                    }
                ]
            },
            {
                "id": 2036913,
                "content": [
                    {
                        "username": "Ethanlaughs",
                        "content": "I just want to know what does this mean\" The sizes of the arrays are returned as *columnSizes array.\"?\\nany ideals?"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Do they need to pay more ,if they provide some good examples"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Just do the level order traversal but at every odd level , reverse the output"
                    },
                    {
                        "username": "rajdeep_05",
                        "content": "Wonderful trick broo"
                    },
                    {
                        "username": "jahidulislamananto",
                        "content": "Given test cases are almost useless. Explanation of the problem is very poor. If the explanation was clear it can be solved easily "
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Need to include an example test case where a tree level has more than 2 nodes. So we know that each level nodes are to be included in one single list. I first wrote my code to group child nodes together rather than all the nodes in the level."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If it was simply `IEnumerable<IEnumerable<int>>`, we could have used `List<LinkedList<int>>` internally and `AddFirst()` or `AddLast()` on even/ odd levels on the linked list, and it would be a clean one pass solution with no extra space or other penalty.\\n\\nNow we have to reverse alternate levels or Insert at position 0 at lists or use two stacks alternately for left/ right order. Is there any other solution I\\'m missing that needs strictly one pass and no extra space?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        bool lefttoRight=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>level(size);\\n            for(int i=0;i<size; i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left !=NULL)\\n                    q.push(node->left);\\n                if(node->right !=NULL)\\n                    q.push(node->right);\\n                int index=lefttoRight?i:(size-i-1);\\n                level[index] = node->val;\\n            }\\n            lefttoRight=!lefttoRight;\\n            ans.push_back(level);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anshul_sankhyan",
                        "content": "why are we declaring size of level array?"
                    },
                    {
                        "username": "gurunath10",
                        "content": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List <Integer> > ans = new ArrayList<>();\\n        Queue <TreeNode > q = new LinkedList<>();\\n        if (root == null) return ans ;\\n        q.offer(root);\\n        int flag = 1; \\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> ds = new ArrayList<>();\\n            for (int i =0; i < size; i++){\\n                TreeNode cur = q.poll();\\n                if (cur.left  != null) q.offer(cur.left);\\n                if (cur.right != null ) q.offer(cur.right);\\n                \\n                if (flag == 1){\\n                ds.add(cur.val);\\n                }\\n                else {\\n                    ds.add(0,cur.val);\\n                }\\n            }\\n            flag = flag ^ 1;\\n            ans.add(ds);\\n        }return ans;\\n\\n    }"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why people are using extra space when you can just use flag and know whether to store current level in same order or reverse order "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There is a crazy difference between easy and medium questions of binary trees leetcode questions"
                    }
                ]
            },
            {
                "id": 1806842,
                "content": [
                    {
                        "username": "Ethanlaughs",
                        "content": "I just want to know what does this mean\" The sizes of the arrays are returned as *columnSizes array.\"?\\nany ideals?"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Do they need to pay more ,if they provide some good examples"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Just do the level order traversal but at every odd level , reverse the output"
                    },
                    {
                        "username": "rajdeep_05",
                        "content": "Wonderful trick broo"
                    },
                    {
                        "username": "jahidulislamananto",
                        "content": "Given test cases are almost useless. Explanation of the problem is very poor. If the explanation was clear it can be solved easily "
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Need to include an example test case where a tree level has more than 2 nodes. So we know that each level nodes are to be included in one single list. I first wrote my code to group child nodes together rather than all the nodes in the level."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If it was simply `IEnumerable<IEnumerable<int>>`, we could have used `List<LinkedList<int>>` internally and `AddFirst()` or `AddLast()` on even/ odd levels on the linked list, and it would be a clean one pass solution with no extra space or other penalty.\\n\\nNow we have to reverse alternate levels or Insert at position 0 at lists or use two stacks alternately for left/ right order. Is there any other solution I\\'m missing that needs strictly one pass and no extra space?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        bool lefttoRight=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>level(size);\\n            for(int i=0;i<size; i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left !=NULL)\\n                    q.push(node->left);\\n                if(node->right !=NULL)\\n                    q.push(node->right);\\n                int index=lefttoRight?i:(size-i-1);\\n                level[index] = node->val;\\n            }\\n            lefttoRight=!lefttoRight;\\n            ans.push_back(level);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anshul_sankhyan",
                        "content": "why are we declaring size of level array?"
                    },
                    {
                        "username": "gurunath10",
                        "content": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List <Integer> > ans = new ArrayList<>();\\n        Queue <TreeNode > q = new LinkedList<>();\\n        if (root == null) return ans ;\\n        q.offer(root);\\n        int flag = 1; \\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> ds = new ArrayList<>();\\n            for (int i =0; i < size; i++){\\n                TreeNode cur = q.poll();\\n                if (cur.left  != null) q.offer(cur.left);\\n                if (cur.right != null ) q.offer(cur.right);\\n                \\n                if (flag == 1){\\n                ds.add(cur.val);\\n                }\\n                else {\\n                    ds.add(0,cur.val);\\n                }\\n            }\\n            flag = flag ^ 1;\\n            ans.add(ds);\\n        }return ans;\\n\\n    }"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why people are using extra space when you can just use flag and know whether to store current level in same order or reverse order "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There is a crazy difference between easy and medium questions of binary trees leetcode questions"
                    }
                ]
            },
            {
                "id": 1806501,
                "content": [
                    {
                        "username": "Ethanlaughs",
                        "content": "I just want to know what does this mean\" The sizes of the arrays are returned as *columnSizes array.\"?\\nany ideals?"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Do they need to pay more ,if they provide some good examples"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Just do the level order traversal but at every odd level , reverse the output"
                    },
                    {
                        "username": "rajdeep_05",
                        "content": "Wonderful trick broo"
                    },
                    {
                        "username": "jahidulislamananto",
                        "content": "Given test cases are almost useless. Explanation of the problem is very poor. If the explanation was clear it can be solved easily "
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Need to include an example test case where a tree level has more than 2 nodes. So we know that each level nodes are to be included in one single list. I first wrote my code to group child nodes together rather than all the nodes in the level."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If it was simply `IEnumerable<IEnumerable<int>>`, we could have used `List<LinkedList<int>>` internally and `AddFirst()` or `AddLast()` on even/ odd levels on the linked list, and it would be a clean one pass solution with no extra space or other penalty.\\n\\nNow we have to reverse alternate levels or Insert at position 0 at lists or use two stacks alternately for left/ right order. Is there any other solution I\\'m missing that needs strictly one pass and no extra space?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        bool lefttoRight=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>level(size);\\n            for(int i=0;i<size; i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left !=NULL)\\n                    q.push(node->left);\\n                if(node->right !=NULL)\\n                    q.push(node->right);\\n                int index=lefttoRight?i:(size-i-1);\\n                level[index] = node->val;\\n            }\\n            lefttoRight=!lefttoRight;\\n            ans.push_back(level);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anshul_sankhyan",
                        "content": "why are we declaring size of level array?"
                    },
                    {
                        "username": "gurunath10",
                        "content": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List <Integer> > ans = new ArrayList<>();\\n        Queue <TreeNode > q = new LinkedList<>();\\n        if (root == null) return ans ;\\n        q.offer(root);\\n        int flag = 1; \\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> ds = new ArrayList<>();\\n            for (int i =0; i < size; i++){\\n                TreeNode cur = q.poll();\\n                if (cur.left  != null) q.offer(cur.left);\\n                if (cur.right != null ) q.offer(cur.right);\\n                \\n                if (flag == 1){\\n                ds.add(cur.val);\\n                }\\n                else {\\n                    ds.add(0,cur.val);\\n                }\\n            }\\n            flag = flag ^ 1;\\n            ans.add(ds);\\n        }return ans;\\n\\n    }"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why people are using extra space when you can just use flag and know whether to store current level in same order or reverse order "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There is a crazy difference between easy and medium questions of binary trees leetcode questions"
                    }
                ]
            },
            {
                "id": 1784342,
                "content": [
                    {
                        "username": "Ethanlaughs",
                        "content": "I just want to know what does this mean\" The sizes of the arrays are returned as *columnSizes array.\"?\\nany ideals?"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Do they need to pay more ,if they provide some good examples"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Just do the level order traversal but at every odd level , reverse the output"
                    },
                    {
                        "username": "rajdeep_05",
                        "content": "Wonderful trick broo"
                    },
                    {
                        "username": "jahidulislamananto",
                        "content": "Given test cases are almost useless. Explanation of the problem is very poor. If the explanation was clear it can be solved easily "
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Need to include an example test case where a tree level has more than 2 nodes. So we know that each level nodes are to be included in one single list. I first wrote my code to group child nodes together rather than all the nodes in the level."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If it was simply `IEnumerable<IEnumerable<int>>`, we could have used `List<LinkedList<int>>` internally and `AddFirst()` or `AddLast()` on even/ odd levels on the linked list, and it would be a clean one pass solution with no extra space or other penalty.\\n\\nNow we have to reverse alternate levels or Insert at position 0 at lists or use two stacks alternately for left/ right order. Is there any other solution I\\'m missing that needs strictly one pass and no extra space?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        bool lefttoRight=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>level(size);\\n            for(int i=0;i<size; i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left !=NULL)\\n                    q.push(node->left);\\n                if(node->right !=NULL)\\n                    q.push(node->right);\\n                int index=lefttoRight?i:(size-i-1);\\n                level[index] = node->val;\\n            }\\n            lefttoRight=!lefttoRight;\\n            ans.push_back(level);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anshul_sankhyan",
                        "content": "why are we declaring size of level array?"
                    },
                    {
                        "username": "gurunath10",
                        "content": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List <Integer> > ans = new ArrayList<>();\\n        Queue <TreeNode > q = new LinkedList<>();\\n        if (root == null) return ans ;\\n        q.offer(root);\\n        int flag = 1; \\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> ds = new ArrayList<>();\\n            for (int i =0; i < size; i++){\\n                TreeNode cur = q.poll();\\n                if (cur.left  != null) q.offer(cur.left);\\n                if (cur.right != null ) q.offer(cur.right);\\n                \\n                if (flag == 1){\\n                ds.add(cur.val);\\n                }\\n                else {\\n                    ds.add(0,cur.val);\\n                }\\n            }\\n            flag = flag ^ 1;\\n            ans.add(ds);\\n        }return ans;\\n\\n    }"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why people are using extra space when you can just use flag and know whether to store current level in same order or reverse order "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There is a crazy difference between easy and medium questions of binary trees leetcode questions"
                    }
                ]
            },
            {
                "id": 1572151,
                "content": [
                    {
                        "username": "Ethanlaughs",
                        "content": "I just want to know what does this mean\" The sizes of the arrays are returned as *columnSizes array.\"?\\nany ideals?"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Do they need to pay more ,if they provide some good examples"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Just do the level order traversal but at every odd level , reverse the output"
                    },
                    {
                        "username": "rajdeep_05",
                        "content": "Wonderful trick broo"
                    },
                    {
                        "username": "jahidulislamananto",
                        "content": "Given test cases are almost useless. Explanation of the problem is very poor. If the explanation was clear it can be solved easily "
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Need to include an example test case where a tree level has more than 2 nodes. So we know that each level nodes are to be included in one single list. I first wrote my code to group child nodes together rather than all the nodes in the level."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If it was simply `IEnumerable<IEnumerable<int>>`, we could have used `List<LinkedList<int>>` internally and `AddFirst()` or `AddLast()` on even/ odd levels on the linked list, and it would be a clean one pass solution with no extra space or other penalty.\\n\\nNow we have to reverse alternate levels or Insert at position 0 at lists or use two stacks alternately for left/ right order. Is there any other solution I\\'m missing that needs strictly one pass and no extra space?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        bool lefttoRight=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>level(size);\\n            for(int i=0;i<size; i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left !=NULL)\\n                    q.push(node->left);\\n                if(node->right !=NULL)\\n                    q.push(node->right);\\n                int index=lefttoRight?i:(size-i-1);\\n                level[index] = node->val;\\n            }\\n            lefttoRight=!lefttoRight;\\n            ans.push_back(level);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anshul_sankhyan",
                        "content": "why are we declaring size of level array?"
                    },
                    {
                        "username": "gurunath10",
                        "content": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List <Integer> > ans = new ArrayList<>();\\n        Queue <TreeNode > q = new LinkedList<>();\\n        if (root == null) return ans ;\\n        q.offer(root);\\n        int flag = 1; \\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> ds = new ArrayList<>();\\n            for (int i =0; i < size; i++){\\n                TreeNode cur = q.poll();\\n                if (cur.left  != null) q.offer(cur.left);\\n                if (cur.right != null ) q.offer(cur.right);\\n                \\n                if (flag == 1){\\n                ds.add(cur.val);\\n                }\\n                else {\\n                    ds.add(0,cur.val);\\n                }\\n            }\\n            flag = flag ^ 1;\\n            ans.add(ds);\\n        }return ans;\\n\\n    }"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why people are using extra space when you can just use flag and know whether to store current level in same order or reverse order "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There is a crazy difference between easy and medium questions of binary trees leetcode questions"
                    }
                ]
            },
            {
                "id": 1626203,
                "content": [
                    {
                        "username": "Ethanlaughs",
                        "content": "I just want to know what does this mean\" The sizes of the arrays are returned as *columnSizes array.\"?\\nany ideals?"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Do they need to pay more ,if they provide some good examples"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Just do the level order traversal but at every odd level , reverse the output"
                    },
                    {
                        "username": "rajdeep_05",
                        "content": "Wonderful trick broo"
                    },
                    {
                        "username": "jahidulislamananto",
                        "content": "Given test cases are almost useless. Explanation of the problem is very poor. If the explanation was clear it can be solved easily "
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Need to include an example test case where a tree level has more than 2 nodes. So we know that each level nodes are to be included in one single list. I first wrote my code to group child nodes together rather than all the nodes in the level."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If it was simply `IEnumerable<IEnumerable<int>>`, we could have used `List<LinkedList<int>>` internally and `AddFirst()` or `AddLast()` on even/ odd levels on the linked list, and it would be a clean one pass solution with no extra space or other penalty.\\n\\nNow we have to reverse alternate levels or Insert at position 0 at lists or use two stacks alternately for left/ right order. Is there any other solution I\\'m missing that needs strictly one pass and no extra space?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        bool lefttoRight=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>level(size);\\n            for(int i=0;i<size; i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left !=NULL)\\n                    q.push(node->left);\\n                if(node->right !=NULL)\\n                    q.push(node->right);\\n                int index=lefttoRight?i:(size-i-1);\\n                level[index] = node->val;\\n            }\\n            lefttoRight=!lefttoRight;\\n            ans.push_back(level);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anshul_sankhyan",
                        "content": "why are we declaring size of level array?"
                    },
                    {
                        "username": "gurunath10",
                        "content": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List <Integer> > ans = new ArrayList<>();\\n        Queue <TreeNode > q = new LinkedList<>();\\n        if (root == null) return ans ;\\n        q.offer(root);\\n        int flag = 1; \\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> ds = new ArrayList<>();\\n            for (int i =0; i < size; i++){\\n                TreeNode cur = q.poll();\\n                if (cur.left  != null) q.offer(cur.left);\\n                if (cur.right != null ) q.offer(cur.right);\\n                \\n                if (flag == 1){\\n                ds.add(cur.val);\\n                }\\n                else {\\n                    ds.add(0,cur.val);\\n                }\\n            }\\n            flag = flag ^ 1;\\n            ans.add(ds);\\n        }return ans;\\n\\n    }"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why people are using extra space when you can just use flag and know whether to store current level in same order or reverse order "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There is a crazy difference between easy and medium questions of binary trees leetcode questions"
                    }
                ]
            },
            {
                "id": 2067918,
                "content": [
                    {
                        "username": "Ethanlaughs",
                        "content": "I just want to know what does this mean\" The sizes of the arrays are returned as *columnSizes array.\"?\\nany ideals?"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Do they need to pay more ,if they provide some good examples"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Just do the level order traversal but at every odd level , reverse the output"
                    },
                    {
                        "username": "rajdeep_05",
                        "content": "Wonderful trick broo"
                    },
                    {
                        "username": "jahidulislamananto",
                        "content": "Given test cases are almost useless. Explanation of the problem is very poor. If the explanation was clear it can be solved easily "
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Need to include an example test case where a tree level has more than 2 nodes. So we know that each level nodes are to be included in one single list. I first wrote my code to group child nodes together rather than all the nodes in the level."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If it was simply `IEnumerable<IEnumerable<int>>`, we could have used `List<LinkedList<int>>` internally and `AddFirst()` or `AddLast()` on even/ odd levels on the linked list, and it would be a clean one pass solution with no extra space or other penalty.\\n\\nNow we have to reverse alternate levels or Insert at position 0 at lists or use two stacks alternately for left/ right order. Is there any other solution I\\'m missing that needs strictly one pass and no extra space?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        bool lefttoRight=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>level(size);\\n            for(int i=0;i<size; i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left !=NULL)\\n                    q.push(node->left);\\n                if(node->right !=NULL)\\n                    q.push(node->right);\\n                int index=lefttoRight?i:(size-i-1);\\n                level[index] = node->val;\\n            }\\n            lefttoRight=!lefttoRight;\\n            ans.push_back(level);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anshul_sankhyan",
                        "content": "why are we declaring size of level array?"
                    },
                    {
                        "username": "gurunath10",
                        "content": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List <Integer> > ans = new ArrayList<>();\\n        Queue <TreeNode > q = new LinkedList<>();\\n        if (root == null) return ans ;\\n        q.offer(root);\\n        int flag = 1; \\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> ds = new ArrayList<>();\\n            for (int i =0; i < size; i++){\\n                TreeNode cur = q.poll();\\n                if (cur.left  != null) q.offer(cur.left);\\n                if (cur.right != null ) q.offer(cur.right);\\n                \\n                if (flag == 1){\\n                ds.add(cur.val);\\n                }\\n                else {\\n                    ds.add(0,cur.val);\\n                }\\n            }\\n            flag = flag ^ 1;\\n            ans.add(ds);\\n        }return ans;\\n\\n    }"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why people are using extra space when you can just use flag and know whether to store current level in same order or reverse order "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There is a crazy difference between easy and medium questions of binary trees leetcode questions"
                    }
                ]
            },
            {
                "id": 2036931,
                "content": [
                    {
                        "username": "Ethanlaughs",
                        "content": "I just want to know what does this mean\" The sizes of the arrays are returned as *columnSizes array.\"?\\nany ideals?"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Do they need to pay more ,if they provide some good examples"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Just do the level order traversal but at every odd level , reverse the output"
                    },
                    {
                        "username": "rajdeep_05",
                        "content": "Wonderful trick broo"
                    },
                    {
                        "username": "jahidulislamananto",
                        "content": "Given test cases are almost useless. Explanation of the problem is very poor. If the explanation was clear it can be solved easily "
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Need to include an example test case where a tree level has more than 2 nodes. So we know that each level nodes are to be included in one single list. I first wrote my code to group child nodes together rather than all the nodes in the level."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If it was simply `IEnumerable<IEnumerable<int>>`, we could have used `List<LinkedList<int>>` internally and `AddFirst()` or `AddLast()` on even/ odd levels on the linked list, and it would be a clean one pass solution with no extra space or other penalty.\\n\\nNow we have to reverse alternate levels or Insert at position 0 at lists or use two stacks alternately for left/ right order. Is there any other solution I\\'m missing that needs strictly one pass and no extra space?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        bool lefttoRight=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>level(size);\\n            for(int i=0;i<size; i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left !=NULL)\\n                    q.push(node->left);\\n                if(node->right !=NULL)\\n                    q.push(node->right);\\n                int index=lefttoRight?i:(size-i-1);\\n                level[index] = node->val;\\n            }\\n            lefttoRight=!lefttoRight;\\n            ans.push_back(level);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anshul_sankhyan",
                        "content": "why are we declaring size of level array?"
                    },
                    {
                        "username": "gurunath10",
                        "content": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List <Integer> > ans = new ArrayList<>();\\n        Queue <TreeNode > q = new LinkedList<>();\\n        if (root == null) return ans ;\\n        q.offer(root);\\n        int flag = 1; \\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> ds = new ArrayList<>();\\n            for (int i =0; i < size; i++){\\n                TreeNode cur = q.poll();\\n                if (cur.left  != null) q.offer(cur.left);\\n                if (cur.right != null ) q.offer(cur.right);\\n                \\n                if (flag == 1){\\n                ds.add(cur.val);\\n                }\\n                else {\\n                    ds.add(0,cur.val);\\n                }\\n            }\\n            flag = flag ^ 1;\\n            ans.add(ds);\\n        }return ans;\\n\\n    }"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why people are using extra space when you can just use flag and know whether to store current level in same order or reverse order "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There is a crazy difference between easy and medium questions of binary trees leetcode questions"
                    }
                ]
            },
            {
                "id": 1998511,
                "content": [
                    {
                        "username": "Ethanlaughs",
                        "content": "I just want to know what does this mean\" The sizes of the arrays are returned as *columnSizes array.\"?\\nany ideals?"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Do they need to pay more ,if they provide some good examples"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Just do the level order traversal but at every odd level , reverse the output"
                    },
                    {
                        "username": "rajdeep_05",
                        "content": "Wonderful trick broo"
                    },
                    {
                        "username": "jahidulislamananto",
                        "content": "Given test cases are almost useless. Explanation of the problem is very poor. If the explanation was clear it can be solved easily "
                    },
                    {
                        "username": "kokatekuntal",
                        "content": "Need to include an example test case where a tree level has more than 2 nodes. So we know that each level nodes are to be included in one single list. I first wrote my code to group child nodes together rather than all the nodes in the level."
                    },
                    {
                        "username": "zenzen5",
                        "content": "If it was simply `IEnumerable<IEnumerable<int>>`, we could have used `List<LinkedList<int>>` internally and `AddFirst()` or `AddLast()` on even/ odd levels on the linked list, and it would be a clean one pass solution with no extra space or other penalty.\\n\\nNow we have to reverse alternate levels or Insert at position 0 at lists or use two stacks alternately for left/ right order. Is there any other solution I\\'m missing that needs strictly one pass and no extra space?"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(root==NULL)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        bool lefttoRight=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>level(size);\\n            for(int i=0;i<size; i++){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left !=NULL)\\n                    q.push(node->left);\\n                if(node->right !=NULL)\\n                    q.push(node->right);\\n                int index=lefttoRight?i:(size-i-1);\\n                level[index] = node->val;\\n            }\\n            lefttoRight=!lefttoRight;\\n            ans.push_back(level);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "anshul_sankhyan",
                        "content": "why are we declaring size of level array?"
                    },
                    {
                        "username": "gurunath10",
                        "content": "class Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List <Integer> > ans = new ArrayList<>();\\n        Queue <TreeNode > q = new LinkedList<>();\\n        if (root == null) return ans ;\\n        q.offer(root);\\n        int flag = 1; \\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            ArrayList<Integer> ds = new ArrayList<>();\\n            for (int i =0; i < size; i++){\\n                TreeNode cur = q.poll();\\n                if (cur.left  != null) q.offer(cur.left);\\n                if (cur.right != null ) q.offer(cur.right);\\n                \\n                if (flag == 1){\\n                ds.add(cur.val);\\n                }\\n                else {\\n                    ds.add(0,cur.val);\\n                }\\n            }\\n            flag = flag ^ 1;\\n            ans.add(ds);\\n        }return ans;\\n\\n    }"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why people are using extra space when you can just use flag and know whether to store current level in same order or reverse order "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There is a crazy difference between easy and medium questions of binary trees leetcode questions"
                    }
                ]
            },
            {
                "id": 1996200,
                "content": [
                    {
                        "username": "Onkar_Wagh",
                        "content": "HINT:\\n\\nFind Level Order Traversal of the tree,\\nNow, for every alternate vector in the 2d vector just reverse the vector.\\n\\nExample 1:\\n[3,9,20,null,null,15,7]\\nLevel Order Traversal : [ [3],[9,20],[15,7] ]\\nReverse vector [9,20]\\n\\n\\nAns: [ [3],[20,9],[15,7] ]\\n\\nI hope this helps :)\\n"
                    },
                    {
                        "username": "huiellis1",
                        "content": "how to test the solution?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Level Order Traversal in Disguise"
                    },
                    {
                        "username": "JGARG",
                        "content": "[1,2,3,4,5]  in this test case output is  [[1],[3,2],[5,4]] . but expected is [[1],[3,2],[4,5]] why?"
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "Keep Track Of Left to Right and Right to Left Movement , Rest is LOT."
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Manipulating the normal level order answer is one solution but isn\\'t satisfying enough so working on the deque approach"
                    },
                    {
                        "username": "cr2017jboro999",
                        "content": "girth matters or length matters ?"
                    },
                    {
                        "username": "nurlan01",
                        "content": "First, try to solve binary tree level order traversal, and then come back to this question."
                    },
                    {
                        "username": "alexschmidt76",
                        "content": "genuinely confused as to why root.val does not exist in js? is there something im missing? "
                    },
                    {
                        "username": "developerlite19",
                        "content": "Hey I made a very simple video explaining the queue approach\nPlease check this out\nhttps://www.youtube.com/watch?v=qVO3KFOkCAU"
                    }
                ]
            },
            {
                "id": 1975416,
                "content": [
                    {
                        "username": "Onkar_Wagh",
                        "content": "HINT:\\n\\nFind Level Order Traversal of the tree,\\nNow, for every alternate vector in the 2d vector just reverse the vector.\\n\\nExample 1:\\n[3,9,20,null,null,15,7]\\nLevel Order Traversal : [ [3],[9,20],[15,7] ]\\nReverse vector [9,20]\\n\\n\\nAns: [ [3],[20,9],[15,7] ]\\n\\nI hope this helps :)\\n"
                    },
                    {
                        "username": "huiellis1",
                        "content": "how to test the solution?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Level Order Traversal in Disguise"
                    },
                    {
                        "username": "JGARG",
                        "content": "[1,2,3,4,5]  in this test case output is  [[1],[3,2],[5,4]] . but expected is [[1],[3,2],[4,5]] why?"
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "Keep Track Of Left to Right and Right to Left Movement , Rest is LOT."
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Manipulating the normal level order answer is one solution but isn\\'t satisfying enough so working on the deque approach"
                    },
                    {
                        "username": "cr2017jboro999",
                        "content": "girth matters or length matters ?"
                    },
                    {
                        "username": "nurlan01",
                        "content": "First, try to solve binary tree level order traversal, and then come back to this question."
                    },
                    {
                        "username": "alexschmidt76",
                        "content": "genuinely confused as to why root.val does not exist in js? is there something im missing? "
                    },
                    {
                        "username": "developerlite19",
                        "content": "Hey I made a very simple video explaining the queue approach\nPlease check this out\nhttps://www.youtube.com/watch?v=qVO3KFOkCAU"
                    }
                ]
            },
            {
                "id": 1974873,
                "content": [
                    {
                        "username": "Onkar_Wagh",
                        "content": "HINT:\\n\\nFind Level Order Traversal of the tree,\\nNow, for every alternate vector in the 2d vector just reverse the vector.\\n\\nExample 1:\\n[3,9,20,null,null,15,7]\\nLevel Order Traversal : [ [3],[9,20],[15,7] ]\\nReverse vector [9,20]\\n\\n\\nAns: [ [3],[20,9],[15,7] ]\\n\\nI hope this helps :)\\n"
                    },
                    {
                        "username": "huiellis1",
                        "content": "how to test the solution?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Level Order Traversal in Disguise"
                    },
                    {
                        "username": "JGARG",
                        "content": "[1,2,3,4,5]  in this test case output is  [[1],[3,2],[5,4]] . but expected is [[1],[3,2],[4,5]] why?"
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "Keep Track Of Left to Right and Right to Left Movement , Rest is LOT."
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Manipulating the normal level order answer is one solution but isn\\'t satisfying enough so working on the deque approach"
                    },
                    {
                        "username": "cr2017jboro999",
                        "content": "girth matters or length matters ?"
                    },
                    {
                        "username": "nurlan01",
                        "content": "First, try to solve binary tree level order traversal, and then come back to this question."
                    },
                    {
                        "username": "alexschmidt76",
                        "content": "genuinely confused as to why root.val does not exist in js? is there something im missing? "
                    },
                    {
                        "username": "developerlite19",
                        "content": "Hey I made a very simple video explaining the queue approach\nPlease check this out\nhttps://www.youtube.com/watch?v=qVO3KFOkCAU"
                    }
                ]
            },
            {
                "id": 1966481,
                "content": [
                    {
                        "username": "Onkar_Wagh",
                        "content": "HINT:\\n\\nFind Level Order Traversal of the tree,\\nNow, for every alternate vector in the 2d vector just reverse the vector.\\n\\nExample 1:\\n[3,9,20,null,null,15,7]\\nLevel Order Traversal : [ [3],[9,20],[15,7] ]\\nReverse vector [9,20]\\n\\n\\nAns: [ [3],[20,9],[15,7] ]\\n\\nI hope this helps :)\\n"
                    },
                    {
                        "username": "huiellis1",
                        "content": "how to test the solution?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Level Order Traversal in Disguise"
                    },
                    {
                        "username": "JGARG",
                        "content": "[1,2,3,4,5]  in this test case output is  [[1],[3,2],[5,4]] . but expected is [[1],[3,2],[4,5]] why?"
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "Keep Track Of Left to Right and Right to Left Movement , Rest is LOT."
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Manipulating the normal level order answer is one solution but isn\\'t satisfying enough so working on the deque approach"
                    },
                    {
                        "username": "cr2017jboro999",
                        "content": "girth matters or length matters ?"
                    },
                    {
                        "username": "nurlan01",
                        "content": "First, try to solve binary tree level order traversal, and then come back to this question."
                    },
                    {
                        "username": "alexschmidt76",
                        "content": "genuinely confused as to why root.val does not exist in js? is there something im missing? "
                    },
                    {
                        "username": "developerlite19",
                        "content": "Hey I made a very simple video explaining the queue approach\nPlease check this out\nhttps://www.youtube.com/watch?v=qVO3KFOkCAU"
                    }
                ]
            },
            {
                "id": 1955004,
                "content": [
                    {
                        "username": "Onkar_Wagh",
                        "content": "HINT:\\n\\nFind Level Order Traversal of the tree,\\nNow, for every alternate vector in the 2d vector just reverse the vector.\\n\\nExample 1:\\n[3,9,20,null,null,15,7]\\nLevel Order Traversal : [ [3],[9,20],[15,7] ]\\nReverse vector [9,20]\\n\\n\\nAns: [ [3],[20,9],[15,7] ]\\n\\nI hope this helps :)\\n"
                    },
                    {
                        "username": "huiellis1",
                        "content": "how to test the solution?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Level Order Traversal in Disguise"
                    },
                    {
                        "username": "JGARG",
                        "content": "[1,2,3,4,5]  in this test case output is  [[1],[3,2],[5,4]] . but expected is [[1],[3,2],[4,5]] why?"
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "Keep Track Of Left to Right and Right to Left Movement , Rest is LOT."
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Manipulating the normal level order answer is one solution but isn\\'t satisfying enough so working on the deque approach"
                    },
                    {
                        "username": "cr2017jboro999",
                        "content": "girth matters or length matters ?"
                    },
                    {
                        "username": "nurlan01",
                        "content": "First, try to solve binary tree level order traversal, and then come back to this question."
                    },
                    {
                        "username": "alexschmidt76",
                        "content": "genuinely confused as to why root.val does not exist in js? is there something im missing? "
                    },
                    {
                        "username": "developerlite19",
                        "content": "Hey I made a very simple video explaining the queue approach\nPlease check this out\nhttps://www.youtube.com/watch?v=qVO3KFOkCAU"
                    }
                ]
            },
            {
                "id": 1921290,
                "content": [
                    {
                        "username": "Onkar_Wagh",
                        "content": "HINT:\\n\\nFind Level Order Traversal of the tree,\\nNow, for every alternate vector in the 2d vector just reverse the vector.\\n\\nExample 1:\\n[3,9,20,null,null,15,7]\\nLevel Order Traversal : [ [3],[9,20],[15,7] ]\\nReverse vector [9,20]\\n\\n\\nAns: [ [3],[20,9],[15,7] ]\\n\\nI hope this helps :)\\n"
                    },
                    {
                        "username": "huiellis1",
                        "content": "how to test the solution?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Level Order Traversal in Disguise"
                    },
                    {
                        "username": "JGARG",
                        "content": "[1,2,3,4,5]  in this test case output is  [[1],[3,2],[5,4]] . but expected is [[1],[3,2],[4,5]] why?"
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "Keep Track Of Left to Right and Right to Left Movement , Rest is LOT."
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Manipulating the normal level order answer is one solution but isn\\'t satisfying enough so working on the deque approach"
                    },
                    {
                        "username": "cr2017jboro999",
                        "content": "girth matters or length matters ?"
                    },
                    {
                        "username": "nurlan01",
                        "content": "First, try to solve binary tree level order traversal, and then come back to this question."
                    },
                    {
                        "username": "alexschmidt76",
                        "content": "genuinely confused as to why root.val does not exist in js? is there something im missing? "
                    },
                    {
                        "username": "developerlite19",
                        "content": "Hey I made a very simple video explaining the queue approach\nPlease check this out\nhttps://www.youtube.com/watch?v=qVO3KFOkCAU"
                    }
                ]
            },
            {
                "id": 1865454,
                "content": [
                    {
                        "username": "Onkar_Wagh",
                        "content": "HINT:\\n\\nFind Level Order Traversal of the tree,\\nNow, for every alternate vector in the 2d vector just reverse the vector.\\n\\nExample 1:\\n[3,9,20,null,null,15,7]\\nLevel Order Traversal : [ [3],[9,20],[15,7] ]\\nReverse vector [9,20]\\n\\n\\nAns: [ [3],[20,9],[15,7] ]\\n\\nI hope this helps :)\\n"
                    },
                    {
                        "username": "huiellis1",
                        "content": "how to test the solution?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Level Order Traversal in Disguise"
                    },
                    {
                        "username": "JGARG",
                        "content": "[1,2,3,4,5]  in this test case output is  [[1],[3,2],[5,4]] . but expected is [[1],[3,2],[4,5]] why?"
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "Keep Track Of Left to Right and Right to Left Movement , Rest is LOT."
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Manipulating the normal level order answer is one solution but isn\\'t satisfying enough so working on the deque approach"
                    },
                    {
                        "username": "cr2017jboro999",
                        "content": "girth matters or length matters ?"
                    },
                    {
                        "username": "nurlan01",
                        "content": "First, try to solve binary tree level order traversal, and then come back to this question."
                    },
                    {
                        "username": "alexschmidt76",
                        "content": "genuinely confused as to why root.val does not exist in js? is there something im missing? "
                    },
                    {
                        "username": "developerlite19",
                        "content": "Hey I made a very simple video explaining the queue approach\nPlease check this out\nhttps://www.youtube.com/watch?v=qVO3KFOkCAU"
                    }
                ]
            },
            {
                "id": 1836021,
                "content": [
                    {
                        "username": "Onkar_Wagh",
                        "content": "HINT:\\n\\nFind Level Order Traversal of the tree,\\nNow, for every alternate vector in the 2d vector just reverse the vector.\\n\\nExample 1:\\n[3,9,20,null,null,15,7]\\nLevel Order Traversal : [ [3],[9,20],[15,7] ]\\nReverse vector [9,20]\\n\\n\\nAns: [ [3],[20,9],[15,7] ]\\n\\nI hope this helps :)\\n"
                    },
                    {
                        "username": "huiellis1",
                        "content": "how to test the solution?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Level Order Traversal in Disguise"
                    },
                    {
                        "username": "JGARG",
                        "content": "[1,2,3,4,5]  in this test case output is  [[1],[3,2],[5,4]] . but expected is [[1],[3,2],[4,5]] why?"
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "Keep Track Of Left to Right and Right to Left Movement , Rest is LOT."
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Manipulating the normal level order answer is one solution but isn\\'t satisfying enough so working on the deque approach"
                    },
                    {
                        "username": "cr2017jboro999",
                        "content": "girth matters or length matters ?"
                    },
                    {
                        "username": "nurlan01",
                        "content": "First, try to solve binary tree level order traversal, and then come back to this question."
                    },
                    {
                        "username": "alexschmidt76",
                        "content": "genuinely confused as to why root.val does not exist in js? is there something im missing? "
                    },
                    {
                        "username": "developerlite19",
                        "content": "Hey I made a very simple video explaining the queue approach\nPlease check this out\nhttps://www.youtube.com/watch?v=qVO3KFOkCAU"
                    }
                ]
            },
            {
                "id": 1811132,
                "content": [
                    {
                        "username": "Onkar_Wagh",
                        "content": "HINT:\\n\\nFind Level Order Traversal of the tree,\\nNow, for every alternate vector in the 2d vector just reverse the vector.\\n\\nExample 1:\\n[3,9,20,null,null,15,7]\\nLevel Order Traversal : [ [3],[9,20],[15,7] ]\\nReverse vector [9,20]\\n\\n\\nAns: [ [3],[20,9],[15,7] ]\\n\\nI hope this helps :)\\n"
                    },
                    {
                        "username": "huiellis1",
                        "content": "how to test the solution?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Level Order Traversal in Disguise"
                    },
                    {
                        "username": "JGARG",
                        "content": "[1,2,3,4,5]  in this test case output is  [[1],[3,2],[5,4]] . but expected is [[1],[3,2],[4,5]] why?"
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "Keep Track Of Left to Right and Right to Left Movement , Rest is LOT."
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Manipulating the normal level order answer is one solution but isn\\'t satisfying enough so working on the deque approach"
                    },
                    {
                        "username": "cr2017jboro999",
                        "content": "girth matters or length matters ?"
                    },
                    {
                        "username": "nurlan01",
                        "content": "First, try to solve binary tree level order traversal, and then come back to this question."
                    },
                    {
                        "username": "alexschmidt76",
                        "content": "genuinely confused as to why root.val does not exist in js? is there something im missing? "
                    },
                    {
                        "username": "developerlite19",
                        "content": "Hey I made a very simple video explaining the queue approach\nPlease check this out\nhttps://www.youtube.com/watch?v=qVO3KFOkCAU"
                    }
                ]
            },
            {
                "id": 1810975,
                "content": [
                    {
                        "username": "Onkar_Wagh",
                        "content": "HINT:\\n\\nFind Level Order Traversal of the tree,\\nNow, for every alternate vector in the 2d vector just reverse the vector.\\n\\nExample 1:\\n[3,9,20,null,null,15,7]\\nLevel Order Traversal : [ [3],[9,20],[15,7] ]\\nReverse vector [9,20]\\n\\n\\nAns: [ [3],[20,9],[15,7] ]\\n\\nI hope this helps :)\\n"
                    },
                    {
                        "username": "huiellis1",
                        "content": "how to test the solution?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Level Order Traversal in Disguise"
                    },
                    {
                        "username": "JGARG",
                        "content": "[1,2,3,4,5]  in this test case output is  [[1],[3,2],[5,4]] . but expected is [[1],[3,2],[4,5]] why?"
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "Keep Track Of Left to Right and Right to Left Movement , Rest is LOT."
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Manipulating the normal level order answer is one solution but isn\\'t satisfying enough so working on the deque approach"
                    },
                    {
                        "username": "cr2017jboro999",
                        "content": "girth matters or length matters ?"
                    },
                    {
                        "username": "nurlan01",
                        "content": "First, try to solve binary tree level order traversal, and then come back to this question."
                    },
                    {
                        "username": "alexschmidt76",
                        "content": "genuinely confused as to why root.val does not exist in js? is there something im missing? "
                    },
                    {
                        "username": "developerlite19",
                        "content": "Hey I made a very simple video explaining the queue approach\nPlease check this out\nhttps://www.youtube.com/watch?v=qVO3KFOkCAU"
                    }
                ]
            },
            {
                "id": 1808243,
                "content": [
                    {
                        "username": "fedorgoncharov",
                        "content": "Essentially BFS. Used doubly-linked list (implemented in C - 200 lines of code which in Python I guess would take 20-30) - depending on parity of the current level one needs to push / pop elements either to head or tail. \\nSort of funny exercise on mangling pointers and doing proper pop-push operations.... \\n\\nP. S. Maybe at leetcode there should be a tag for a problem with simple idea but tedious implementation?"
                    },
                    {
                        "username": "S_Basu",
                        "content": "## For each odd level, reverse the list containing the nodes of a particular level before adding to the result list.\n\n##### Note:\n> **Assuming that we count level from 0 onwards i.e. root is level 0**\n\n**[Link to my Solution](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3207579/my-easy-java-solution/)**"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "level order traversal bfs approach easily explained, just try and i am sure it will be worth your time https://youtu.be/xUEBDd_fpFg"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "It seemed so easy when I read it and I knew the answer and the DS too. But implementing it in code was a mind-fuck for me"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is an awesome problem with a great follow up challenge for those who want it. \\n\\nIt is easy solve this by reversing the levels, can you perform the same task without the additional reversals?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This was freaking easy. Who put that medium label?"
                    },
                    {
                        "username": "has_786",
                        "content": "This question is quite interesting to me."
                    },
                    {
                        "username": "pareshpvasani",
                        "content": "// Added my solution with explanation\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// 1st we need to go with Level, so need to identify the level\\n// While traversing we can define a counter named level \\n\\n// 2nd Initialize an array and sub array\\n// And we will add the sub array in main array\\n// Let\\'s take ArrayList<ArrayList<Integer>> levels // main array\\n// So while traversing and completing the sub array 3rd step comes\\n\\n// 3rd push the sub array into main array\\n// 3rd step will happen based on level(count) \\n// I am talking about traversal but I missed to tell\\n// there will be a queue which should have all child node (left and right)\\n\\n// 4th We will reverse the level value when level is odd\\n\\n// initially we can start with root\\n// then adding child to queue \\n// so that inner travalsal will be queue only\\n// let\\'s see how.. [3,9,20,null,null,15,7]\\n// queue will have root 3 \\n// Traversl the queue node 3 and remove it from queue\\n// checking that node 3 has children yes 9 and 20 adding to subarray and pushing to main array\\n// now traversal will be on 9 and 20\\n// checking the 9 has child, no then removing 9. we will not add\\n// checking the 20 has child, yes then removing 20 and adding children in to queue 15 and 7\\n// now travers the 15 and 7\\n\\n// Let\\'s understand with complext test case\\n// with this example [3,6,1,9,2,null,4,null,5,null,null,null,null,8,null,null,null]\\n// SEE SCREENSHOT\\n\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<List<Integer>>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn levels;\\n\\t\\t\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\t\\n\\t\\tint level = 0; // counter of level \\n\\t\\t\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t// start the current level\\n\\t\\t\\tlevels.add(new ArrayList<Integer>());\\n\\n\\t\\t\\t// number of elements in the current level\\n\\n\\t\\t\\tint level_length = queue.size();\\n\\t\\t\\t// on above variable -\\n\\t\\t\\t// intent behind this length taken priori is moving on next level\\n\\n\\t\\t\\t// let\\'s try to replace level_length by queue.size()\\n\\t\\t\\tfor (int i = 0; i < level_length; ++i) {\\n\\n\\t\\t\\t\\tTreeNode node = queue.remove();\\n\\n\\t\\t\\t\\t// fulfill the current level\\n\\t\\t\\t\\t// based on current level pushing/adding node value\\n\\t\\t\\t\\tlevels.get(level).add(node.val);\\n\\n\\t\\t\\t\\t// add child nodes of the current level\\n\\t\\t\\t\\t// in the queue for the next level\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t}\\n\\t\\t\\t// go to next level\\n\\t\\t\\tlevel++;\\n\\t\\t}\\n        // Levels were [3,9,20,null,null,15,7]\\n        // 1st result is [[3],[9,20],[7,15]]\\n        // 2nd result will be [[3],[20,9],[15,7]] for zigsag\\n        \\n        // 4th step for revering the Odd level Value \\n        int levelCountForReverse = 0;\\n        List<List<Integer>> finalLevels = new ArrayList<List<Integer>>();\\n        for(List<Integer> levelElements: levels){\\n            // for ZigZag reversing the level values\\n            if(levelCountForReverse %2 !=0){\\n                Collections.reverse(levelElements);\\n            } \\n            finalLevels.add(levelCountForReverse,levelElements);\\n            \\n            levelCountForReverse++;\\n        }\\n        \\n\\t\\treturn levels;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "me190003061",
                        "content": "Input `root = [3,9,20,1,99,15,7,0,99,8,100,null,null,6,8,null,null,1,null,6,10]`\\nOutput: `[[3],[20,9],[1,99],[7,15],[0,99],[100,8],[6,8],[1],[6,10]]`\\nExpected: `[[3],[20,9],[1,99,15,7],[8,6,100,8,99,0],[1,6,10]]`\\n\\nWhy are the subarray sizes arbitrary? The question seems to make some implicit assumptions, which are not articulated in the problem statement properly."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "You must take the entire level - order nodes into one vector(either from left->right or from right->left). It\\'s a BFS algorithm but we change the order of the nodes for every level.\\nFor more clarification, AlecLC has given visual description in the discussion forum on the first page."
                    },
                    {
                        "username": "adhamosorour",
                        "content": "the appropriate data structure for this question should\\'ve been a `vector<deque<int>>`  (for c++ at least)"
                    }
                ]
            },
            {
                "id": 1807607,
                "content": [
                    {
                        "username": "fedorgoncharov",
                        "content": "Essentially BFS. Used doubly-linked list (implemented in C - 200 lines of code which in Python I guess would take 20-30) - depending on parity of the current level one needs to push / pop elements either to head or tail. \\nSort of funny exercise on mangling pointers and doing proper pop-push operations.... \\n\\nP. S. Maybe at leetcode there should be a tag for a problem with simple idea but tedious implementation?"
                    },
                    {
                        "username": "S_Basu",
                        "content": "## For each odd level, reverse the list containing the nodes of a particular level before adding to the result list.\n\n##### Note:\n> **Assuming that we count level from 0 onwards i.e. root is level 0**\n\n**[Link to my Solution](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3207579/my-easy-java-solution/)**"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "level order traversal bfs approach easily explained, just try and i am sure it will be worth your time https://youtu.be/xUEBDd_fpFg"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "It seemed so easy when I read it and I knew the answer and the DS too. But implementing it in code was a mind-fuck for me"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is an awesome problem with a great follow up challenge for those who want it. \\n\\nIt is easy solve this by reversing the levels, can you perform the same task without the additional reversals?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This was freaking easy. Who put that medium label?"
                    },
                    {
                        "username": "has_786",
                        "content": "This question is quite interesting to me."
                    },
                    {
                        "username": "pareshpvasani",
                        "content": "// Added my solution with explanation\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// 1st we need to go with Level, so need to identify the level\\n// While traversing we can define a counter named level \\n\\n// 2nd Initialize an array and sub array\\n// And we will add the sub array in main array\\n// Let\\'s take ArrayList<ArrayList<Integer>> levels // main array\\n// So while traversing and completing the sub array 3rd step comes\\n\\n// 3rd push the sub array into main array\\n// 3rd step will happen based on level(count) \\n// I am talking about traversal but I missed to tell\\n// there will be a queue which should have all child node (left and right)\\n\\n// 4th We will reverse the level value when level is odd\\n\\n// initially we can start with root\\n// then adding child to queue \\n// so that inner travalsal will be queue only\\n// let\\'s see how.. [3,9,20,null,null,15,7]\\n// queue will have root 3 \\n// Traversl the queue node 3 and remove it from queue\\n// checking that node 3 has children yes 9 and 20 adding to subarray and pushing to main array\\n// now traversal will be on 9 and 20\\n// checking the 9 has child, no then removing 9. we will not add\\n// checking the 20 has child, yes then removing 20 and adding children in to queue 15 and 7\\n// now travers the 15 and 7\\n\\n// Let\\'s understand with complext test case\\n// with this example [3,6,1,9,2,null,4,null,5,null,null,null,null,8,null,null,null]\\n// SEE SCREENSHOT\\n\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<List<Integer>>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn levels;\\n\\t\\t\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\t\\n\\t\\tint level = 0; // counter of level \\n\\t\\t\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t// start the current level\\n\\t\\t\\tlevels.add(new ArrayList<Integer>());\\n\\n\\t\\t\\t// number of elements in the current level\\n\\n\\t\\t\\tint level_length = queue.size();\\n\\t\\t\\t// on above variable -\\n\\t\\t\\t// intent behind this length taken priori is moving on next level\\n\\n\\t\\t\\t// let\\'s try to replace level_length by queue.size()\\n\\t\\t\\tfor (int i = 0; i < level_length; ++i) {\\n\\n\\t\\t\\t\\tTreeNode node = queue.remove();\\n\\n\\t\\t\\t\\t// fulfill the current level\\n\\t\\t\\t\\t// based on current level pushing/adding node value\\n\\t\\t\\t\\tlevels.get(level).add(node.val);\\n\\n\\t\\t\\t\\t// add child nodes of the current level\\n\\t\\t\\t\\t// in the queue for the next level\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t}\\n\\t\\t\\t// go to next level\\n\\t\\t\\tlevel++;\\n\\t\\t}\\n        // Levels were [3,9,20,null,null,15,7]\\n        // 1st result is [[3],[9,20],[7,15]]\\n        // 2nd result will be [[3],[20,9],[15,7]] for zigsag\\n        \\n        // 4th step for revering the Odd level Value \\n        int levelCountForReverse = 0;\\n        List<List<Integer>> finalLevels = new ArrayList<List<Integer>>();\\n        for(List<Integer> levelElements: levels){\\n            // for ZigZag reversing the level values\\n            if(levelCountForReverse %2 !=0){\\n                Collections.reverse(levelElements);\\n            } \\n            finalLevels.add(levelCountForReverse,levelElements);\\n            \\n            levelCountForReverse++;\\n        }\\n        \\n\\t\\treturn levels;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "me190003061",
                        "content": "Input `root = [3,9,20,1,99,15,7,0,99,8,100,null,null,6,8,null,null,1,null,6,10]`\\nOutput: `[[3],[20,9],[1,99],[7,15],[0,99],[100,8],[6,8],[1],[6,10]]`\\nExpected: `[[3],[20,9],[1,99,15,7],[8,6,100,8,99,0],[1,6,10]]`\\n\\nWhy are the subarray sizes arbitrary? The question seems to make some implicit assumptions, which are not articulated in the problem statement properly."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "You must take the entire level - order nodes into one vector(either from left->right or from right->left). It\\'s a BFS algorithm but we change the order of the nodes for every level.\\nFor more clarification, AlecLC has given visual description in the discussion forum on the first page."
                    },
                    {
                        "username": "adhamosorour",
                        "content": "the appropriate data structure for this question should\\'ve been a `vector<deque<int>>`  (for c++ at least)"
                    }
                ]
            },
            {
                "id": 1807532,
                "content": [
                    {
                        "username": "fedorgoncharov",
                        "content": "Essentially BFS. Used doubly-linked list (implemented in C - 200 lines of code which in Python I guess would take 20-30) - depending on parity of the current level one needs to push / pop elements either to head or tail. \\nSort of funny exercise on mangling pointers and doing proper pop-push operations.... \\n\\nP. S. Maybe at leetcode there should be a tag for a problem with simple idea but tedious implementation?"
                    },
                    {
                        "username": "S_Basu",
                        "content": "## For each odd level, reverse the list containing the nodes of a particular level before adding to the result list.\n\n##### Note:\n> **Assuming that we count level from 0 onwards i.e. root is level 0**\n\n**[Link to my Solution](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3207579/my-easy-java-solution/)**"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "level order traversal bfs approach easily explained, just try and i am sure it will be worth your time https://youtu.be/xUEBDd_fpFg"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "It seemed so easy when I read it and I knew the answer and the DS too. But implementing it in code was a mind-fuck for me"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is an awesome problem with a great follow up challenge for those who want it. \\n\\nIt is easy solve this by reversing the levels, can you perform the same task without the additional reversals?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This was freaking easy. Who put that medium label?"
                    },
                    {
                        "username": "has_786",
                        "content": "This question is quite interesting to me."
                    },
                    {
                        "username": "pareshpvasani",
                        "content": "// Added my solution with explanation\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// 1st we need to go with Level, so need to identify the level\\n// While traversing we can define a counter named level \\n\\n// 2nd Initialize an array and sub array\\n// And we will add the sub array in main array\\n// Let\\'s take ArrayList<ArrayList<Integer>> levels // main array\\n// So while traversing and completing the sub array 3rd step comes\\n\\n// 3rd push the sub array into main array\\n// 3rd step will happen based on level(count) \\n// I am talking about traversal but I missed to tell\\n// there will be a queue which should have all child node (left and right)\\n\\n// 4th We will reverse the level value when level is odd\\n\\n// initially we can start with root\\n// then adding child to queue \\n// so that inner travalsal will be queue only\\n// let\\'s see how.. [3,9,20,null,null,15,7]\\n// queue will have root 3 \\n// Traversl the queue node 3 and remove it from queue\\n// checking that node 3 has children yes 9 and 20 adding to subarray and pushing to main array\\n// now traversal will be on 9 and 20\\n// checking the 9 has child, no then removing 9. we will not add\\n// checking the 20 has child, yes then removing 20 and adding children in to queue 15 and 7\\n// now travers the 15 and 7\\n\\n// Let\\'s understand with complext test case\\n// with this example [3,6,1,9,2,null,4,null,5,null,null,null,null,8,null,null,null]\\n// SEE SCREENSHOT\\n\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<List<Integer>>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn levels;\\n\\t\\t\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\t\\n\\t\\tint level = 0; // counter of level \\n\\t\\t\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t// start the current level\\n\\t\\t\\tlevels.add(new ArrayList<Integer>());\\n\\n\\t\\t\\t// number of elements in the current level\\n\\n\\t\\t\\tint level_length = queue.size();\\n\\t\\t\\t// on above variable -\\n\\t\\t\\t// intent behind this length taken priori is moving on next level\\n\\n\\t\\t\\t// let\\'s try to replace level_length by queue.size()\\n\\t\\t\\tfor (int i = 0; i < level_length; ++i) {\\n\\n\\t\\t\\t\\tTreeNode node = queue.remove();\\n\\n\\t\\t\\t\\t// fulfill the current level\\n\\t\\t\\t\\t// based on current level pushing/adding node value\\n\\t\\t\\t\\tlevels.get(level).add(node.val);\\n\\n\\t\\t\\t\\t// add child nodes of the current level\\n\\t\\t\\t\\t// in the queue for the next level\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t}\\n\\t\\t\\t// go to next level\\n\\t\\t\\tlevel++;\\n\\t\\t}\\n        // Levels were [3,9,20,null,null,15,7]\\n        // 1st result is [[3],[9,20],[7,15]]\\n        // 2nd result will be [[3],[20,9],[15,7]] for zigsag\\n        \\n        // 4th step for revering the Odd level Value \\n        int levelCountForReverse = 0;\\n        List<List<Integer>> finalLevels = new ArrayList<List<Integer>>();\\n        for(List<Integer> levelElements: levels){\\n            // for ZigZag reversing the level values\\n            if(levelCountForReverse %2 !=0){\\n                Collections.reverse(levelElements);\\n            } \\n            finalLevels.add(levelCountForReverse,levelElements);\\n            \\n            levelCountForReverse++;\\n        }\\n        \\n\\t\\treturn levels;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "me190003061",
                        "content": "Input `root = [3,9,20,1,99,15,7,0,99,8,100,null,null,6,8,null,null,1,null,6,10]`\\nOutput: `[[3],[20,9],[1,99],[7,15],[0,99],[100,8],[6,8],[1],[6,10]]`\\nExpected: `[[3],[20,9],[1,99,15,7],[8,6,100,8,99,0],[1,6,10]]`\\n\\nWhy are the subarray sizes arbitrary? The question seems to make some implicit assumptions, which are not articulated in the problem statement properly."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "You must take the entire level - order nodes into one vector(either from left->right or from right->left). It\\'s a BFS algorithm but we change the order of the nodes for every level.\\nFor more clarification, AlecLC has given visual description in the discussion forum on the first page."
                    },
                    {
                        "username": "adhamosorour",
                        "content": "the appropriate data structure for this question should\\'ve been a `vector<deque<int>>`  (for c++ at least)"
                    }
                ]
            },
            {
                "id": 1807430,
                "content": [
                    {
                        "username": "fedorgoncharov",
                        "content": "Essentially BFS. Used doubly-linked list (implemented in C - 200 lines of code which in Python I guess would take 20-30) - depending on parity of the current level one needs to push / pop elements either to head or tail. \\nSort of funny exercise on mangling pointers and doing proper pop-push operations.... \\n\\nP. S. Maybe at leetcode there should be a tag for a problem with simple idea but tedious implementation?"
                    },
                    {
                        "username": "S_Basu",
                        "content": "## For each odd level, reverse the list containing the nodes of a particular level before adding to the result list.\n\n##### Note:\n> **Assuming that we count level from 0 onwards i.e. root is level 0**\n\n**[Link to my Solution](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3207579/my-easy-java-solution/)**"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "level order traversal bfs approach easily explained, just try and i am sure it will be worth your time https://youtu.be/xUEBDd_fpFg"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "It seemed so easy when I read it and I knew the answer and the DS too. But implementing it in code was a mind-fuck for me"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is an awesome problem with a great follow up challenge for those who want it. \\n\\nIt is easy solve this by reversing the levels, can you perform the same task without the additional reversals?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This was freaking easy. Who put that medium label?"
                    },
                    {
                        "username": "has_786",
                        "content": "This question is quite interesting to me."
                    },
                    {
                        "username": "pareshpvasani",
                        "content": "// Added my solution with explanation\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// 1st we need to go with Level, so need to identify the level\\n// While traversing we can define a counter named level \\n\\n// 2nd Initialize an array and sub array\\n// And we will add the sub array in main array\\n// Let\\'s take ArrayList<ArrayList<Integer>> levels // main array\\n// So while traversing and completing the sub array 3rd step comes\\n\\n// 3rd push the sub array into main array\\n// 3rd step will happen based on level(count) \\n// I am talking about traversal but I missed to tell\\n// there will be a queue which should have all child node (left and right)\\n\\n// 4th We will reverse the level value when level is odd\\n\\n// initially we can start with root\\n// then adding child to queue \\n// so that inner travalsal will be queue only\\n// let\\'s see how.. [3,9,20,null,null,15,7]\\n// queue will have root 3 \\n// Traversl the queue node 3 and remove it from queue\\n// checking that node 3 has children yes 9 and 20 adding to subarray and pushing to main array\\n// now traversal will be on 9 and 20\\n// checking the 9 has child, no then removing 9. we will not add\\n// checking the 20 has child, yes then removing 20 and adding children in to queue 15 and 7\\n// now travers the 15 and 7\\n\\n// Let\\'s understand with complext test case\\n// with this example [3,6,1,9,2,null,4,null,5,null,null,null,null,8,null,null,null]\\n// SEE SCREENSHOT\\n\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<List<Integer>>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn levels;\\n\\t\\t\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\t\\n\\t\\tint level = 0; // counter of level \\n\\t\\t\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t// start the current level\\n\\t\\t\\tlevels.add(new ArrayList<Integer>());\\n\\n\\t\\t\\t// number of elements in the current level\\n\\n\\t\\t\\tint level_length = queue.size();\\n\\t\\t\\t// on above variable -\\n\\t\\t\\t// intent behind this length taken priori is moving on next level\\n\\n\\t\\t\\t// let\\'s try to replace level_length by queue.size()\\n\\t\\t\\tfor (int i = 0; i < level_length; ++i) {\\n\\n\\t\\t\\t\\tTreeNode node = queue.remove();\\n\\n\\t\\t\\t\\t// fulfill the current level\\n\\t\\t\\t\\t// based on current level pushing/adding node value\\n\\t\\t\\t\\tlevels.get(level).add(node.val);\\n\\n\\t\\t\\t\\t// add child nodes of the current level\\n\\t\\t\\t\\t// in the queue for the next level\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t}\\n\\t\\t\\t// go to next level\\n\\t\\t\\tlevel++;\\n\\t\\t}\\n        // Levels were [3,9,20,null,null,15,7]\\n        // 1st result is [[3],[9,20],[7,15]]\\n        // 2nd result will be [[3],[20,9],[15,7]] for zigsag\\n        \\n        // 4th step for revering the Odd level Value \\n        int levelCountForReverse = 0;\\n        List<List<Integer>> finalLevels = new ArrayList<List<Integer>>();\\n        for(List<Integer> levelElements: levels){\\n            // for ZigZag reversing the level values\\n            if(levelCountForReverse %2 !=0){\\n                Collections.reverse(levelElements);\\n            } \\n            finalLevels.add(levelCountForReverse,levelElements);\\n            \\n            levelCountForReverse++;\\n        }\\n        \\n\\t\\treturn levels;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "me190003061",
                        "content": "Input `root = [3,9,20,1,99,15,7,0,99,8,100,null,null,6,8,null,null,1,null,6,10]`\\nOutput: `[[3],[20,9],[1,99],[7,15],[0,99],[100,8],[6,8],[1],[6,10]]`\\nExpected: `[[3],[20,9],[1,99,15,7],[8,6,100,8,99,0],[1,6,10]]`\\n\\nWhy are the subarray sizes arbitrary? The question seems to make some implicit assumptions, which are not articulated in the problem statement properly."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "You must take the entire level - order nodes into one vector(either from left->right or from right->left). It\\'s a BFS algorithm but we change the order of the nodes for every level.\\nFor more clarification, AlecLC has given visual description in the discussion forum on the first page."
                    },
                    {
                        "username": "adhamosorour",
                        "content": "the appropriate data structure for this question should\\'ve been a `vector<deque<int>>`  (for c++ at least)"
                    }
                ]
            },
            {
                "id": 1807267,
                "content": [
                    {
                        "username": "fedorgoncharov",
                        "content": "Essentially BFS. Used doubly-linked list (implemented in C - 200 lines of code which in Python I guess would take 20-30) - depending on parity of the current level one needs to push / pop elements either to head or tail. \\nSort of funny exercise on mangling pointers and doing proper pop-push operations.... \\n\\nP. S. Maybe at leetcode there should be a tag for a problem with simple idea but tedious implementation?"
                    },
                    {
                        "username": "S_Basu",
                        "content": "## For each odd level, reverse the list containing the nodes of a particular level before adding to the result list.\n\n##### Note:\n> **Assuming that we count level from 0 onwards i.e. root is level 0**\n\n**[Link to my Solution](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3207579/my-easy-java-solution/)**"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "level order traversal bfs approach easily explained, just try and i am sure it will be worth your time https://youtu.be/xUEBDd_fpFg"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "It seemed so easy when I read it and I knew the answer and the DS too. But implementing it in code was a mind-fuck for me"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is an awesome problem with a great follow up challenge for those who want it. \\n\\nIt is easy solve this by reversing the levels, can you perform the same task without the additional reversals?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This was freaking easy. Who put that medium label?"
                    },
                    {
                        "username": "has_786",
                        "content": "This question is quite interesting to me."
                    },
                    {
                        "username": "pareshpvasani",
                        "content": "// Added my solution with explanation\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// 1st we need to go with Level, so need to identify the level\\n// While traversing we can define a counter named level \\n\\n// 2nd Initialize an array and sub array\\n// And we will add the sub array in main array\\n// Let\\'s take ArrayList<ArrayList<Integer>> levels // main array\\n// So while traversing and completing the sub array 3rd step comes\\n\\n// 3rd push the sub array into main array\\n// 3rd step will happen based on level(count) \\n// I am talking about traversal but I missed to tell\\n// there will be a queue which should have all child node (left and right)\\n\\n// 4th We will reverse the level value when level is odd\\n\\n// initially we can start with root\\n// then adding child to queue \\n// so that inner travalsal will be queue only\\n// let\\'s see how.. [3,9,20,null,null,15,7]\\n// queue will have root 3 \\n// Traversl the queue node 3 and remove it from queue\\n// checking that node 3 has children yes 9 and 20 adding to subarray and pushing to main array\\n// now traversal will be on 9 and 20\\n// checking the 9 has child, no then removing 9. we will not add\\n// checking the 20 has child, yes then removing 20 and adding children in to queue 15 and 7\\n// now travers the 15 and 7\\n\\n// Let\\'s understand with complext test case\\n// with this example [3,6,1,9,2,null,4,null,5,null,null,null,null,8,null,null,null]\\n// SEE SCREENSHOT\\n\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<List<Integer>>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn levels;\\n\\t\\t\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\t\\n\\t\\tint level = 0; // counter of level \\n\\t\\t\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t// start the current level\\n\\t\\t\\tlevels.add(new ArrayList<Integer>());\\n\\n\\t\\t\\t// number of elements in the current level\\n\\n\\t\\t\\tint level_length = queue.size();\\n\\t\\t\\t// on above variable -\\n\\t\\t\\t// intent behind this length taken priori is moving on next level\\n\\n\\t\\t\\t// let\\'s try to replace level_length by queue.size()\\n\\t\\t\\tfor (int i = 0; i < level_length; ++i) {\\n\\n\\t\\t\\t\\tTreeNode node = queue.remove();\\n\\n\\t\\t\\t\\t// fulfill the current level\\n\\t\\t\\t\\t// based on current level pushing/adding node value\\n\\t\\t\\t\\tlevels.get(level).add(node.val);\\n\\n\\t\\t\\t\\t// add child nodes of the current level\\n\\t\\t\\t\\t// in the queue for the next level\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t}\\n\\t\\t\\t// go to next level\\n\\t\\t\\tlevel++;\\n\\t\\t}\\n        // Levels were [3,9,20,null,null,15,7]\\n        // 1st result is [[3],[9,20],[7,15]]\\n        // 2nd result will be [[3],[20,9],[15,7]] for zigsag\\n        \\n        // 4th step for revering the Odd level Value \\n        int levelCountForReverse = 0;\\n        List<List<Integer>> finalLevels = new ArrayList<List<Integer>>();\\n        for(List<Integer> levelElements: levels){\\n            // for ZigZag reversing the level values\\n            if(levelCountForReverse %2 !=0){\\n                Collections.reverse(levelElements);\\n            } \\n            finalLevels.add(levelCountForReverse,levelElements);\\n            \\n            levelCountForReverse++;\\n        }\\n        \\n\\t\\treturn levels;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "me190003061",
                        "content": "Input `root = [3,9,20,1,99,15,7,0,99,8,100,null,null,6,8,null,null,1,null,6,10]`\\nOutput: `[[3],[20,9],[1,99],[7,15],[0,99],[100,8],[6,8],[1],[6,10]]`\\nExpected: `[[3],[20,9],[1,99,15,7],[8,6,100,8,99,0],[1,6,10]]`\\n\\nWhy are the subarray sizes arbitrary? The question seems to make some implicit assumptions, which are not articulated in the problem statement properly."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "You must take the entire level - order nodes into one vector(either from left->right or from right->left). It\\'s a BFS algorithm but we change the order of the nodes for every level.\\nFor more clarification, AlecLC has given visual description in the discussion forum on the first page."
                    },
                    {
                        "username": "adhamosorour",
                        "content": "the appropriate data structure for this question should\\'ve been a `vector<deque<int>>`  (for c++ at least)"
                    }
                ]
            },
            {
                "id": 1807217,
                "content": [
                    {
                        "username": "fedorgoncharov",
                        "content": "Essentially BFS. Used doubly-linked list (implemented in C - 200 lines of code which in Python I guess would take 20-30) - depending on parity of the current level one needs to push / pop elements either to head or tail. \\nSort of funny exercise on mangling pointers and doing proper pop-push operations.... \\n\\nP. S. Maybe at leetcode there should be a tag for a problem with simple idea but tedious implementation?"
                    },
                    {
                        "username": "S_Basu",
                        "content": "## For each odd level, reverse the list containing the nodes of a particular level before adding to the result list.\n\n##### Note:\n> **Assuming that we count level from 0 onwards i.e. root is level 0**\n\n**[Link to my Solution](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3207579/my-easy-java-solution/)**"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "level order traversal bfs approach easily explained, just try and i am sure it will be worth your time https://youtu.be/xUEBDd_fpFg"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "It seemed so easy when I read it and I knew the answer and the DS too. But implementing it in code was a mind-fuck for me"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is an awesome problem with a great follow up challenge for those who want it. \\n\\nIt is easy solve this by reversing the levels, can you perform the same task without the additional reversals?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This was freaking easy. Who put that medium label?"
                    },
                    {
                        "username": "has_786",
                        "content": "This question is quite interesting to me."
                    },
                    {
                        "username": "pareshpvasani",
                        "content": "// Added my solution with explanation\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// 1st we need to go with Level, so need to identify the level\\n// While traversing we can define a counter named level \\n\\n// 2nd Initialize an array and sub array\\n// And we will add the sub array in main array\\n// Let\\'s take ArrayList<ArrayList<Integer>> levels // main array\\n// So while traversing and completing the sub array 3rd step comes\\n\\n// 3rd push the sub array into main array\\n// 3rd step will happen based on level(count) \\n// I am talking about traversal but I missed to tell\\n// there will be a queue which should have all child node (left and right)\\n\\n// 4th We will reverse the level value when level is odd\\n\\n// initially we can start with root\\n// then adding child to queue \\n// so that inner travalsal will be queue only\\n// let\\'s see how.. [3,9,20,null,null,15,7]\\n// queue will have root 3 \\n// Traversl the queue node 3 and remove it from queue\\n// checking that node 3 has children yes 9 and 20 adding to subarray and pushing to main array\\n// now traversal will be on 9 and 20\\n// checking the 9 has child, no then removing 9. we will not add\\n// checking the 20 has child, yes then removing 20 and adding children in to queue 15 and 7\\n// now travers the 15 and 7\\n\\n// Let\\'s understand with complext test case\\n// with this example [3,6,1,9,2,null,4,null,5,null,null,null,null,8,null,null,null]\\n// SEE SCREENSHOT\\n\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<List<Integer>>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn levels;\\n\\t\\t\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\t\\n\\t\\tint level = 0; // counter of level \\n\\t\\t\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t// start the current level\\n\\t\\t\\tlevels.add(new ArrayList<Integer>());\\n\\n\\t\\t\\t// number of elements in the current level\\n\\n\\t\\t\\tint level_length = queue.size();\\n\\t\\t\\t// on above variable -\\n\\t\\t\\t// intent behind this length taken priori is moving on next level\\n\\n\\t\\t\\t// let\\'s try to replace level_length by queue.size()\\n\\t\\t\\tfor (int i = 0; i < level_length; ++i) {\\n\\n\\t\\t\\t\\tTreeNode node = queue.remove();\\n\\n\\t\\t\\t\\t// fulfill the current level\\n\\t\\t\\t\\t// based on current level pushing/adding node value\\n\\t\\t\\t\\tlevels.get(level).add(node.val);\\n\\n\\t\\t\\t\\t// add child nodes of the current level\\n\\t\\t\\t\\t// in the queue for the next level\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t}\\n\\t\\t\\t// go to next level\\n\\t\\t\\tlevel++;\\n\\t\\t}\\n        // Levels were [3,9,20,null,null,15,7]\\n        // 1st result is [[3],[9,20],[7,15]]\\n        // 2nd result will be [[3],[20,9],[15,7]] for zigsag\\n        \\n        // 4th step for revering the Odd level Value \\n        int levelCountForReverse = 0;\\n        List<List<Integer>> finalLevels = new ArrayList<List<Integer>>();\\n        for(List<Integer> levelElements: levels){\\n            // for ZigZag reversing the level values\\n            if(levelCountForReverse %2 !=0){\\n                Collections.reverse(levelElements);\\n            } \\n            finalLevels.add(levelCountForReverse,levelElements);\\n            \\n            levelCountForReverse++;\\n        }\\n        \\n\\t\\treturn levels;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "me190003061",
                        "content": "Input `root = [3,9,20,1,99,15,7,0,99,8,100,null,null,6,8,null,null,1,null,6,10]`\\nOutput: `[[3],[20,9],[1,99],[7,15],[0,99],[100,8],[6,8],[1],[6,10]]`\\nExpected: `[[3],[20,9],[1,99,15,7],[8,6,100,8,99,0],[1,6,10]]`\\n\\nWhy are the subarray sizes arbitrary? The question seems to make some implicit assumptions, which are not articulated in the problem statement properly."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "You must take the entire level - order nodes into one vector(either from left->right or from right->left). It\\'s a BFS algorithm but we change the order of the nodes for every level.\\nFor more clarification, AlecLC has given visual description in the discussion forum on the first page."
                    },
                    {
                        "username": "adhamosorour",
                        "content": "the appropriate data structure for this question should\\'ve been a `vector<deque<int>>`  (for c++ at least)"
                    }
                ]
            },
            {
                "id": 1807200,
                "content": [
                    {
                        "username": "fedorgoncharov",
                        "content": "Essentially BFS. Used doubly-linked list (implemented in C - 200 lines of code which in Python I guess would take 20-30) - depending on parity of the current level one needs to push / pop elements either to head or tail. \\nSort of funny exercise on mangling pointers and doing proper pop-push operations.... \\n\\nP. S. Maybe at leetcode there should be a tag for a problem with simple idea but tedious implementation?"
                    },
                    {
                        "username": "S_Basu",
                        "content": "## For each odd level, reverse the list containing the nodes of a particular level before adding to the result list.\n\n##### Note:\n> **Assuming that we count level from 0 onwards i.e. root is level 0**\n\n**[Link to my Solution](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3207579/my-easy-java-solution/)**"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "level order traversal bfs approach easily explained, just try and i am sure it will be worth your time https://youtu.be/xUEBDd_fpFg"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "It seemed so easy when I read it and I knew the answer and the DS too. But implementing it in code was a mind-fuck for me"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is an awesome problem with a great follow up challenge for those who want it. \\n\\nIt is easy solve this by reversing the levels, can you perform the same task without the additional reversals?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This was freaking easy. Who put that medium label?"
                    },
                    {
                        "username": "has_786",
                        "content": "This question is quite interesting to me."
                    },
                    {
                        "username": "pareshpvasani",
                        "content": "// Added my solution with explanation\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// 1st we need to go with Level, so need to identify the level\\n// While traversing we can define a counter named level \\n\\n// 2nd Initialize an array and sub array\\n// And we will add the sub array in main array\\n// Let\\'s take ArrayList<ArrayList<Integer>> levels // main array\\n// So while traversing and completing the sub array 3rd step comes\\n\\n// 3rd push the sub array into main array\\n// 3rd step will happen based on level(count) \\n// I am talking about traversal but I missed to tell\\n// there will be a queue which should have all child node (left and right)\\n\\n// 4th We will reverse the level value when level is odd\\n\\n// initially we can start with root\\n// then adding child to queue \\n// so that inner travalsal will be queue only\\n// let\\'s see how.. [3,9,20,null,null,15,7]\\n// queue will have root 3 \\n// Traversl the queue node 3 and remove it from queue\\n// checking that node 3 has children yes 9 and 20 adding to subarray and pushing to main array\\n// now traversal will be on 9 and 20\\n// checking the 9 has child, no then removing 9. we will not add\\n// checking the 20 has child, yes then removing 20 and adding children in to queue 15 and 7\\n// now travers the 15 and 7\\n\\n// Let\\'s understand with complext test case\\n// with this example [3,6,1,9,2,null,4,null,5,null,null,null,null,8,null,null,null]\\n// SEE SCREENSHOT\\n\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<List<Integer>>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn levels;\\n\\t\\t\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\t\\n\\t\\tint level = 0; // counter of level \\n\\t\\t\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t// start the current level\\n\\t\\t\\tlevels.add(new ArrayList<Integer>());\\n\\n\\t\\t\\t// number of elements in the current level\\n\\n\\t\\t\\tint level_length = queue.size();\\n\\t\\t\\t// on above variable -\\n\\t\\t\\t// intent behind this length taken priori is moving on next level\\n\\n\\t\\t\\t// let\\'s try to replace level_length by queue.size()\\n\\t\\t\\tfor (int i = 0; i < level_length; ++i) {\\n\\n\\t\\t\\t\\tTreeNode node = queue.remove();\\n\\n\\t\\t\\t\\t// fulfill the current level\\n\\t\\t\\t\\t// based on current level pushing/adding node value\\n\\t\\t\\t\\tlevels.get(level).add(node.val);\\n\\n\\t\\t\\t\\t// add child nodes of the current level\\n\\t\\t\\t\\t// in the queue for the next level\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t}\\n\\t\\t\\t// go to next level\\n\\t\\t\\tlevel++;\\n\\t\\t}\\n        // Levels were [3,9,20,null,null,15,7]\\n        // 1st result is [[3],[9,20],[7,15]]\\n        // 2nd result will be [[3],[20,9],[15,7]] for zigsag\\n        \\n        // 4th step for revering the Odd level Value \\n        int levelCountForReverse = 0;\\n        List<List<Integer>> finalLevels = new ArrayList<List<Integer>>();\\n        for(List<Integer> levelElements: levels){\\n            // for ZigZag reversing the level values\\n            if(levelCountForReverse %2 !=0){\\n                Collections.reverse(levelElements);\\n            } \\n            finalLevels.add(levelCountForReverse,levelElements);\\n            \\n            levelCountForReverse++;\\n        }\\n        \\n\\t\\treturn levels;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "me190003061",
                        "content": "Input `root = [3,9,20,1,99,15,7,0,99,8,100,null,null,6,8,null,null,1,null,6,10]`\\nOutput: `[[3],[20,9],[1,99],[7,15],[0,99],[100,8],[6,8],[1],[6,10]]`\\nExpected: `[[3],[20,9],[1,99,15,7],[8,6,100,8,99,0],[1,6,10]]`\\n\\nWhy are the subarray sizes arbitrary? The question seems to make some implicit assumptions, which are not articulated in the problem statement properly."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "You must take the entire level - order nodes into one vector(either from left->right or from right->left). It\\'s a BFS algorithm but we change the order of the nodes for every level.\\nFor more clarification, AlecLC has given visual description in the discussion forum on the first page."
                    },
                    {
                        "username": "adhamosorour",
                        "content": "the appropriate data structure for this question should\\'ve been a `vector<deque<int>>`  (for c++ at least)"
                    }
                ]
            },
            {
                "id": 1807138,
                "content": [
                    {
                        "username": "fedorgoncharov",
                        "content": "Essentially BFS. Used doubly-linked list (implemented in C - 200 lines of code which in Python I guess would take 20-30) - depending on parity of the current level one needs to push / pop elements either to head or tail. \\nSort of funny exercise on mangling pointers and doing proper pop-push operations.... \\n\\nP. S. Maybe at leetcode there should be a tag for a problem with simple idea but tedious implementation?"
                    },
                    {
                        "username": "S_Basu",
                        "content": "## For each odd level, reverse the list containing the nodes of a particular level before adding to the result list.\n\n##### Note:\n> **Assuming that we count level from 0 onwards i.e. root is level 0**\n\n**[Link to my Solution](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3207579/my-easy-java-solution/)**"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "level order traversal bfs approach easily explained, just try and i am sure it will be worth your time https://youtu.be/xUEBDd_fpFg"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "It seemed so easy when I read it and I knew the answer and the DS too. But implementing it in code was a mind-fuck for me"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is an awesome problem with a great follow up challenge for those who want it. \\n\\nIt is easy solve this by reversing the levels, can you perform the same task without the additional reversals?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This was freaking easy. Who put that medium label?"
                    },
                    {
                        "username": "has_786",
                        "content": "This question is quite interesting to me."
                    },
                    {
                        "username": "pareshpvasani",
                        "content": "// Added my solution with explanation\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// 1st we need to go with Level, so need to identify the level\\n// While traversing we can define a counter named level \\n\\n// 2nd Initialize an array and sub array\\n// And we will add the sub array in main array\\n// Let\\'s take ArrayList<ArrayList<Integer>> levels // main array\\n// So while traversing and completing the sub array 3rd step comes\\n\\n// 3rd push the sub array into main array\\n// 3rd step will happen based on level(count) \\n// I am talking about traversal but I missed to tell\\n// there will be a queue which should have all child node (left and right)\\n\\n// 4th We will reverse the level value when level is odd\\n\\n// initially we can start with root\\n// then adding child to queue \\n// so that inner travalsal will be queue only\\n// let\\'s see how.. [3,9,20,null,null,15,7]\\n// queue will have root 3 \\n// Traversl the queue node 3 and remove it from queue\\n// checking that node 3 has children yes 9 and 20 adding to subarray and pushing to main array\\n// now traversal will be on 9 and 20\\n// checking the 9 has child, no then removing 9. we will not add\\n// checking the 20 has child, yes then removing 20 and adding children in to queue 15 and 7\\n// now travers the 15 and 7\\n\\n// Let\\'s understand with complext test case\\n// with this example [3,6,1,9,2,null,4,null,5,null,null,null,null,8,null,null,null]\\n// SEE SCREENSHOT\\n\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<List<Integer>>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn levels;\\n\\t\\t\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\t\\n\\t\\tint level = 0; // counter of level \\n\\t\\t\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t// start the current level\\n\\t\\t\\tlevels.add(new ArrayList<Integer>());\\n\\n\\t\\t\\t// number of elements in the current level\\n\\n\\t\\t\\tint level_length = queue.size();\\n\\t\\t\\t// on above variable -\\n\\t\\t\\t// intent behind this length taken priori is moving on next level\\n\\n\\t\\t\\t// let\\'s try to replace level_length by queue.size()\\n\\t\\t\\tfor (int i = 0; i < level_length; ++i) {\\n\\n\\t\\t\\t\\tTreeNode node = queue.remove();\\n\\n\\t\\t\\t\\t// fulfill the current level\\n\\t\\t\\t\\t// based on current level pushing/adding node value\\n\\t\\t\\t\\tlevels.get(level).add(node.val);\\n\\n\\t\\t\\t\\t// add child nodes of the current level\\n\\t\\t\\t\\t// in the queue for the next level\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t}\\n\\t\\t\\t// go to next level\\n\\t\\t\\tlevel++;\\n\\t\\t}\\n        // Levels were [3,9,20,null,null,15,7]\\n        // 1st result is [[3],[9,20],[7,15]]\\n        // 2nd result will be [[3],[20,9],[15,7]] for zigsag\\n        \\n        // 4th step for revering the Odd level Value \\n        int levelCountForReverse = 0;\\n        List<List<Integer>> finalLevels = new ArrayList<List<Integer>>();\\n        for(List<Integer> levelElements: levels){\\n            // for ZigZag reversing the level values\\n            if(levelCountForReverse %2 !=0){\\n                Collections.reverse(levelElements);\\n            } \\n            finalLevels.add(levelCountForReverse,levelElements);\\n            \\n            levelCountForReverse++;\\n        }\\n        \\n\\t\\treturn levels;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "me190003061",
                        "content": "Input `root = [3,9,20,1,99,15,7,0,99,8,100,null,null,6,8,null,null,1,null,6,10]`\\nOutput: `[[3],[20,9],[1,99],[7,15],[0,99],[100,8],[6,8],[1],[6,10]]`\\nExpected: `[[3],[20,9],[1,99,15,7],[8,6,100,8,99,0],[1,6,10]]`\\n\\nWhy are the subarray sizes arbitrary? The question seems to make some implicit assumptions, which are not articulated in the problem statement properly."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "You must take the entire level - order nodes into one vector(either from left->right or from right->left). It\\'s a BFS algorithm but we change the order of the nodes for every level.\\nFor more clarification, AlecLC has given visual description in the discussion forum on the first page."
                    },
                    {
                        "username": "adhamosorour",
                        "content": "the appropriate data structure for this question should\\'ve been a `vector<deque<int>>`  (for c++ at least)"
                    }
                ]
            },
            {
                "id": 1807123,
                "content": [
                    {
                        "username": "fedorgoncharov",
                        "content": "Essentially BFS. Used doubly-linked list (implemented in C - 200 lines of code which in Python I guess would take 20-30) - depending on parity of the current level one needs to push / pop elements either to head or tail. \\nSort of funny exercise on mangling pointers and doing proper pop-push operations.... \\n\\nP. S. Maybe at leetcode there should be a tag for a problem with simple idea but tedious implementation?"
                    },
                    {
                        "username": "S_Basu",
                        "content": "## For each odd level, reverse the list containing the nodes of a particular level before adding to the result list.\n\n##### Note:\n> **Assuming that we count level from 0 onwards i.e. root is level 0**\n\n**[Link to my Solution](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3207579/my-easy-java-solution/)**"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "level order traversal bfs approach easily explained, just try and i am sure it will be worth your time https://youtu.be/xUEBDd_fpFg"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "It seemed so easy when I read it and I knew the answer and the DS too. But implementing it in code was a mind-fuck for me"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is an awesome problem with a great follow up challenge for those who want it. \\n\\nIt is easy solve this by reversing the levels, can you perform the same task without the additional reversals?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This was freaking easy. Who put that medium label?"
                    },
                    {
                        "username": "has_786",
                        "content": "This question is quite interesting to me."
                    },
                    {
                        "username": "pareshpvasani",
                        "content": "// Added my solution with explanation\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// 1st we need to go with Level, so need to identify the level\\n// While traversing we can define a counter named level \\n\\n// 2nd Initialize an array and sub array\\n// And we will add the sub array in main array\\n// Let\\'s take ArrayList<ArrayList<Integer>> levels // main array\\n// So while traversing and completing the sub array 3rd step comes\\n\\n// 3rd push the sub array into main array\\n// 3rd step will happen based on level(count) \\n// I am talking about traversal but I missed to tell\\n// there will be a queue which should have all child node (left and right)\\n\\n// 4th We will reverse the level value when level is odd\\n\\n// initially we can start with root\\n// then adding child to queue \\n// so that inner travalsal will be queue only\\n// let\\'s see how.. [3,9,20,null,null,15,7]\\n// queue will have root 3 \\n// Traversl the queue node 3 and remove it from queue\\n// checking that node 3 has children yes 9 and 20 adding to subarray and pushing to main array\\n// now traversal will be on 9 and 20\\n// checking the 9 has child, no then removing 9. we will not add\\n// checking the 20 has child, yes then removing 20 and adding children in to queue 15 and 7\\n// now travers the 15 and 7\\n\\n// Let\\'s understand with complext test case\\n// with this example [3,6,1,9,2,null,4,null,5,null,null,null,null,8,null,null,null]\\n// SEE SCREENSHOT\\n\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<List<Integer>>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn levels;\\n\\t\\t\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\t\\n\\t\\tint level = 0; // counter of level \\n\\t\\t\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t// start the current level\\n\\t\\t\\tlevels.add(new ArrayList<Integer>());\\n\\n\\t\\t\\t// number of elements in the current level\\n\\n\\t\\t\\tint level_length = queue.size();\\n\\t\\t\\t// on above variable -\\n\\t\\t\\t// intent behind this length taken priori is moving on next level\\n\\n\\t\\t\\t// let\\'s try to replace level_length by queue.size()\\n\\t\\t\\tfor (int i = 0; i < level_length; ++i) {\\n\\n\\t\\t\\t\\tTreeNode node = queue.remove();\\n\\n\\t\\t\\t\\t// fulfill the current level\\n\\t\\t\\t\\t// based on current level pushing/adding node value\\n\\t\\t\\t\\tlevels.get(level).add(node.val);\\n\\n\\t\\t\\t\\t// add child nodes of the current level\\n\\t\\t\\t\\t// in the queue for the next level\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t}\\n\\t\\t\\t// go to next level\\n\\t\\t\\tlevel++;\\n\\t\\t}\\n        // Levels were [3,9,20,null,null,15,7]\\n        // 1st result is [[3],[9,20],[7,15]]\\n        // 2nd result will be [[3],[20,9],[15,7]] for zigsag\\n        \\n        // 4th step for revering the Odd level Value \\n        int levelCountForReverse = 0;\\n        List<List<Integer>> finalLevels = new ArrayList<List<Integer>>();\\n        for(List<Integer> levelElements: levels){\\n            // for ZigZag reversing the level values\\n            if(levelCountForReverse %2 !=0){\\n                Collections.reverse(levelElements);\\n            } \\n            finalLevels.add(levelCountForReverse,levelElements);\\n            \\n            levelCountForReverse++;\\n        }\\n        \\n\\t\\treturn levels;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "me190003061",
                        "content": "Input `root = [3,9,20,1,99,15,7,0,99,8,100,null,null,6,8,null,null,1,null,6,10]`\\nOutput: `[[3],[20,9],[1,99],[7,15],[0,99],[100,8],[6,8],[1],[6,10]]`\\nExpected: `[[3],[20,9],[1,99,15,7],[8,6,100,8,99,0],[1,6,10]]`\\n\\nWhy are the subarray sizes arbitrary? The question seems to make some implicit assumptions, which are not articulated in the problem statement properly."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "You must take the entire level - order nodes into one vector(either from left->right or from right->left). It\\'s a BFS algorithm but we change the order of the nodes for every level.\\nFor more clarification, AlecLC has given visual description in the discussion forum on the first page."
                    },
                    {
                        "username": "adhamosorour",
                        "content": "the appropriate data structure for this question should\\'ve been a `vector<deque<int>>`  (for c++ at least)"
                    }
                ]
            },
            {
                "id": 1807114,
                "content": [
                    {
                        "username": "fedorgoncharov",
                        "content": "Essentially BFS. Used doubly-linked list (implemented in C - 200 lines of code which in Python I guess would take 20-30) - depending on parity of the current level one needs to push / pop elements either to head or tail. \\nSort of funny exercise on mangling pointers and doing proper pop-push operations.... \\n\\nP. S. Maybe at leetcode there should be a tag for a problem with simple idea but tedious implementation?"
                    },
                    {
                        "username": "S_Basu",
                        "content": "## For each odd level, reverse the list containing the nodes of a particular level before adding to the result list.\n\n##### Note:\n> **Assuming that we count level from 0 onwards i.e. root is level 0**\n\n**[Link to my Solution](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3207579/my-easy-java-solution/)**"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "level order traversal bfs approach easily explained, just try and i am sure it will be worth your time https://youtu.be/xUEBDd_fpFg"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "It seemed so easy when I read it and I knew the answer and the DS too. But implementing it in code was a mind-fuck for me"
                    },
                    {
                        "username": "ajesk",
                        "content": "This is an awesome problem with a great follow up challenge for those who want it. \\n\\nIt is easy solve this by reversing the levels, can you perform the same task without the additional reversals?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This was freaking easy. Who put that medium label?"
                    },
                    {
                        "username": "has_786",
                        "content": "This question is quite interesting to me."
                    },
                    {
                        "username": "pareshpvasani",
                        "content": "// Added my solution with explanation\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// 1st we need to go with Level, so need to identify the level\\n// While traversing we can define a counter named level \\n\\n// 2nd Initialize an array and sub array\\n// And we will add the sub array in main array\\n// Let\\'s take ArrayList<ArrayList<Integer>> levels // main array\\n// So while traversing and completing the sub array 3rd step comes\\n\\n// 3rd push the sub array into main array\\n// 3rd step will happen based on level(count) \\n// I am talking about traversal but I missed to tell\\n// there will be a queue which should have all child node (left and right)\\n\\n// 4th We will reverse the level value when level is odd\\n\\n// initially we can start with root\\n// then adding child to queue \\n// so that inner travalsal will be queue only\\n// let\\'s see how.. [3,9,20,null,null,15,7]\\n// queue will have root 3 \\n// Traversl the queue node 3 and remove it from queue\\n// checking that node 3 has children yes 9 and 20 adding to subarray and pushing to main array\\n// now traversal will be on 9 and 20\\n// checking the 9 has child, no then removing 9. we will not add\\n// checking the 20 has child, yes then removing 20 and adding children in to queue 15 and 7\\n// now travers the 15 and 7\\n\\n// Let\\'s understand with complext test case\\n// with this example [3,6,1,9,2,null,4,null,5,null,null,null,null,8,null,null,null]\\n// SEE SCREENSHOT\\n\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n        List<List<Integer>> levels = new ArrayList<List<Integer>>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn levels;\\n\\t\\t\\n\\t\\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\t\\n\\t\\tint level = 0; // counter of level \\n\\t\\t\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t// start the current level\\n\\t\\t\\tlevels.add(new ArrayList<Integer>());\\n\\n\\t\\t\\t// number of elements in the current level\\n\\n\\t\\t\\tint level_length = queue.size();\\n\\t\\t\\t// on above variable -\\n\\t\\t\\t// intent behind this length taken priori is moving on next level\\n\\n\\t\\t\\t// let\\'s try to replace level_length by queue.size()\\n\\t\\t\\tfor (int i = 0; i < level_length; ++i) {\\n\\n\\t\\t\\t\\tTreeNode node = queue.remove();\\n\\n\\t\\t\\t\\t// fulfill the current level\\n\\t\\t\\t\\t// based on current level pushing/adding node value\\n\\t\\t\\t\\tlevels.get(level).add(node.val);\\n\\n\\t\\t\\t\\t// add child nodes of the current level\\n\\t\\t\\t\\t// in the queue for the next level\\n\\t\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\t\\tqueue.add(node.left);\\n\\t\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\t\\tqueue.add(node.right);\\n\\t\\t\\t}\\n\\t\\t\\t// go to next level\\n\\t\\t\\tlevel++;\\n\\t\\t}\\n        // Levels were [3,9,20,null,null,15,7]\\n        // 1st result is [[3],[9,20],[7,15]]\\n        // 2nd result will be [[3],[20,9],[15,7]] for zigsag\\n        \\n        // 4th step for revering the Odd level Value \\n        int levelCountForReverse = 0;\\n        List<List<Integer>> finalLevels = new ArrayList<List<Integer>>();\\n        for(List<Integer> levelElements: levels){\\n            // for ZigZag reversing the level values\\n            if(levelCountForReverse %2 !=0){\\n                Collections.reverse(levelElements);\\n            } \\n            finalLevels.add(levelCountForReverse,levelElements);\\n            \\n            levelCountForReverse++;\\n        }\\n        \\n\\t\\treturn levels;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "me190003061",
                        "content": "Input `root = [3,9,20,1,99,15,7,0,99,8,100,null,null,6,8,null,null,1,null,6,10]`\\nOutput: `[[3],[20,9],[1,99],[7,15],[0,99],[100,8],[6,8],[1],[6,10]]`\\nExpected: `[[3],[20,9],[1,99,15,7],[8,6,100,8,99,0],[1,6,10]]`\\n\\nWhy are the subarray sizes arbitrary? The question seems to make some implicit assumptions, which are not articulated in the problem statement properly."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "You must take the entire level - order nodes into one vector(either from left->right or from right->left). It\\'s a BFS algorithm but we change the order of the nodes for every level.\\nFor more clarification, AlecLC has given visual description in the discussion forum on the first page."
                    },
                    {
                        "username": "adhamosorour",
                        "content": "the appropriate data structure for this question should\\'ve been a `vector<deque<int>>`  (for c++ at least)"
                    }
                ]
            },
            {
                "id": 1807077,
                "content": [
                    {
                        "username": "alehs_12",
                        "content": "Hi, I keep getting error\\nTypeError: \\'TreeNode\\' object is not iterable\\n\\nStatement\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: [[3],[20,9],[15,7]]\\nIndicates that root is of type list, however its not the case because I cant iterate through it?\\nroot also not A  List[List[int]] because ,again, I cant iterate through it.\\n\\nThank you! \\nIt is possible to convert root to list? \\n\\n"
                    },
                    {
                        "username": "Scarfsman",
                        "content": "Hi, the root is 2D linked list. It's a bit easier to see what this means if you call 'print(root)'. for the example you've given you get the below output.\n\nTreeNode{val: 3, left: TreeNode{val: 9, left: None, right: None}, right: TreeNode{val: 20, left: TreeNode{val: 15, left: None, right: None}, right: TreeNode{val: 7, left: None, right: None}}}\n\nThe input is shown as a normal list by leetcode as it just makes setting up and looking at testcases easier.\n\nTo answer your question, you can't convert the root to a list, but we can iterate  through a binary tree if we find a way of visiting every node in it. If we say that the the first layer of the tree contains only the root node, we know the second layer will be the child nodes of the root node. Then, the third layer will be the children of the nodes in the second layer, and so on until we find a layer that has no children. This approach is called a 'bredth-first search'.\n\nThat all being said, you are correct that the output needs to be a list of lists, the sub lists being the layers and the ints in them being the value of the node you have visited \n\nHope this helps!"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "What language are you using?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms c++ Easy and simple solution\\nHint : USE BFS\\n \\nMy solution Link :https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3205515/0ms-c-easy-and-simple-solution/\\n\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "prashant_23",
                        "content": "Easy enough if you do it using DFS - 100% faster and no Queue/Stack required."
                    },
                    {
                        "username": "puneetripathi",
                        "content": "Here is a simple idea for the solution:\\n1) Technically its just an level-order traversal of binary tree.\\n2) But only at the odd levels, solution differs from the level-order traversal(order is reversed)\\n3) And at each level, we have to maintain a vector that we push onto the vector of vectors\\n4) Reversal of an array using two-pointer method takes O(n) time and no extra-space.\\n5) We would need some sort of flag at each level to ensure that the current level is even or odd\\n\\nWith the above ideas, I hope you\\'ll be able to solve this problem. Cheers!"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Think of using BFS to your advantage here - that gives you a specific ordering, always left to right. At every other level, how could you store the values in a list going right to left? \\n"
                    },
                    {
                        "username": "shivam9935",
                        "content": "HINT : Look at the solution and you would see each sub list is just a BFS or level order traversal result. Only difference is alternate level are reversed."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "            \\n         class Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([(root, 0)])\\n        d = collections.defaultdict(list)\\n        while q:\\n            node, order= q.popleft()\\n            d[order] += [node.val] \\n            if node.left:\\n                q.append((node.left, order+1))\\n            if node.right:\\n                q.append((node.right, order+1))\\n        return [x[::-1] if k & 1 else x for k, x in d.items()]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "ALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp"
                    },
                    {
                        "username": "tomicz",
                        "content": "I was able to solve this solution by using a LinkedList. The LinkedList (at least in c#) has AddFirst and AddLast methods. And when you add a boolean zig = false or true, then you can select weather to add stuff from beginning or end.\\n\\nLook at my solution in the solutions section."
                    }
                ]
            },
            {
                "id": 1806983,
                "content": [
                    {
                        "username": "alehs_12",
                        "content": "Hi, I keep getting error\\nTypeError: \\'TreeNode\\' object is not iterable\\n\\nStatement\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: [[3],[20,9],[15,7]]\\nIndicates that root is of type list, however its not the case because I cant iterate through it?\\nroot also not A  List[List[int]] because ,again, I cant iterate through it.\\n\\nThank you! \\nIt is possible to convert root to list? \\n\\n"
                    },
                    {
                        "username": "Scarfsman",
                        "content": "Hi, the root is 2D linked list. It's a bit easier to see what this means if you call 'print(root)'. for the example you've given you get the below output.\n\nTreeNode{val: 3, left: TreeNode{val: 9, left: None, right: None}, right: TreeNode{val: 20, left: TreeNode{val: 15, left: None, right: None}, right: TreeNode{val: 7, left: None, right: None}}}\n\nThe input is shown as a normal list by leetcode as it just makes setting up and looking at testcases easier.\n\nTo answer your question, you can't convert the root to a list, but we can iterate  through a binary tree if we find a way of visiting every node in it. If we say that the the first layer of the tree contains only the root node, we know the second layer will be the child nodes of the root node. Then, the third layer will be the children of the nodes in the second layer, and so on until we find a layer that has no children. This approach is called a 'bredth-first search'.\n\nThat all being said, you are correct that the output needs to be a list of lists, the sub lists being the layers and the ints in them being the value of the node you have visited \n\nHope this helps!"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "What language are you using?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms c++ Easy and simple solution\\nHint : USE BFS\\n \\nMy solution Link :https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3205515/0ms-c-easy-and-simple-solution/\\n\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "prashant_23",
                        "content": "Easy enough if you do it using DFS - 100% faster and no Queue/Stack required."
                    },
                    {
                        "username": "puneetripathi",
                        "content": "Here is a simple idea for the solution:\\n1) Technically its just an level-order traversal of binary tree.\\n2) But only at the odd levels, solution differs from the level-order traversal(order is reversed)\\n3) And at each level, we have to maintain a vector that we push onto the vector of vectors\\n4) Reversal of an array using two-pointer method takes O(n) time and no extra-space.\\n5) We would need some sort of flag at each level to ensure that the current level is even or odd\\n\\nWith the above ideas, I hope you\\'ll be able to solve this problem. Cheers!"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Think of using BFS to your advantage here - that gives you a specific ordering, always left to right. At every other level, how could you store the values in a list going right to left? \\n"
                    },
                    {
                        "username": "shivam9935",
                        "content": "HINT : Look at the solution and you would see each sub list is just a BFS or level order traversal result. Only difference is alternate level are reversed."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "            \\n         class Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([(root, 0)])\\n        d = collections.defaultdict(list)\\n        while q:\\n            node, order= q.popleft()\\n            d[order] += [node.val] \\n            if node.left:\\n                q.append((node.left, order+1))\\n            if node.right:\\n                q.append((node.right, order+1))\\n        return [x[::-1] if k & 1 else x for k, x in d.items()]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "ALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp"
                    },
                    {
                        "username": "tomicz",
                        "content": "I was able to solve this solution by using a LinkedList. The LinkedList (at least in c#) has AddFirst and AddLast methods. And when you add a boolean zig = false or true, then you can select weather to add stuff from beginning or end.\\n\\nLook at my solution in the solutions section."
                    }
                ]
            },
            {
                "id": 1806975,
                "content": [
                    {
                        "username": "alehs_12",
                        "content": "Hi, I keep getting error\\nTypeError: \\'TreeNode\\' object is not iterable\\n\\nStatement\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: [[3],[20,9],[15,7]]\\nIndicates that root is of type list, however its not the case because I cant iterate through it?\\nroot also not A  List[List[int]] because ,again, I cant iterate through it.\\n\\nThank you! \\nIt is possible to convert root to list? \\n\\n"
                    },
                    {
                        "username": "Scarfsman",
                        "content": "Hi, the root is 2D linked list. It's a bit easier to see what this means if you call 'print(root)'. for the example you've given you get the below output.\n\nTreeNode{val: 3, left: TreeNode{val: 9, left: None, right: None}, right: TreeNode{val: 20, left: TreeNode{val: 15, left: None, right: None}, right: TreeNode{val: 7, left: None, right: None}}}\n\nThe input is shown as a normal list by leetcode as it just makes setting up and looking at testcases easier.\n\nTo answer your question, you can't convert the root to a list, but we can iterate  through a binary tree if we find a way of visiting every node in it. If we say that the the first layer of the tree contains only the root node, we know the second layer will be the child nodes of the root node. Then, the third layer will be the children of the nodes in the second layer, and so on until we find a layer that has no children. This approach is called a 'bredth-first search'.\n\nThat all being said, you are correct that the output needs to be a list of lists, the sub lists being the layers and the ints in them being the value of the node you have visited \n\nHope this helps!"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "What language are you using?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms c++ Easy and simple solution\\nHint : USE BFS\\n \\nMy solution Link :https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3205515/0ms-c-easy-and-simple-solution/\\n\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "prashant_23",
                        "content": "Easy enough if you do it using DFS - 100% faster and no Queue/Stack required."
                    },
                    {
                        "username": "puneetripathi",
                        "content": "Here is a simple idea for the solution:\\n1) Technically its just an level-order traversal of binary tree.\\n2) But only at the odd levels, solution differs from the level-order traversal(order is reversed)\\n3) And at each level, we have to maintain a vector that we push onto the vector of vectors\\n4) Reversal of an array using two-pointer method takes O(n) time and no extra-space.\\n5) We would need some sort of flag at each level to ensure that the current level is even or odd\\n\\nWith the above ideas, I hope you\\'ll be able to solve this problem. Cheers!"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Think of using BFS to your advantage here - that gives you a specific ordering, always left to right. At every other level, how could you store the values in a list going right to left? \\n"
                    },
                    {
                        "username": "shivam9935",
                        "content": "HINT : Look at the solution and you would see each sub list is just a BFS or level order traversal result. Only difference is alternate level are reversed."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "            \\n         class Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([(root, 0)])\\n        d = collections.defaultdict(list)\\n        while q:\\n            node, order= q.popleft()\\n            d[order] += [node.val] \\n            if node.left:\\n                q.append((node.left, order+1))\\n            if node.right:\\n                q.append((node.right, order+1))\\n        return [x[::-1] if k & 1 else x for k, x in d.items()]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "ALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp"
                    },
                    {
                        "username": "tomicz",
                        "content": "I was able to solve this solution by using a LinkedList. The LinkedList (at least in c#) has AddFirst and AddLast methods. And when you add a boolean zig = false or true, then you can select weather to add stuff from beginning or end.\\n\\nLook at my solution in the solutions section."
                    }
                ]
            },
            {
                "id": 1806967,
                "content": [
                    {
                        "username": "alehs_12",
                        "content": "Hi, I keep getting error\\nTypeError: \\'TreeNode\\' object is not iterable\\n\\nStatement\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: [[3],[20,9],[15,7]]\\nIndicates that root is of type list, however its not the case because I cant iterate through it?\\nroot also not A  List[List[int]] because ,again, I cant iterate through it.\\n\\nThank you! \\nIt is possible to convert root to list? \\n\\n"
                    },
                    {
                        "username": "Scarfsman",
                        "content": "Hi, the root is 2D linked list. It's a bit easier to see what this means if you call 'print(root)'. for the example you've given you get the below output.\n\nTreeNode{val: 3, left: TreeNode{val: 9, left: None, right: None}, right: TreeNode{val: 20, left: TreeNode{val: 15, left: None, right: None}, right: TreeNode{val: 7, left: None, right: None}}}\n\nThe input is shown as a normal list by leetcode as it just makes setting up and looking at testcases easier.\n\nTo answer your question, you can't convert the root to a list, but we can iterate  through a binary tree if we find a way of visiting every node in it. If we say that the the first layer of the tree contains only the root node, we know the second layer will be the child nodes of the root node. Then, the third layer will be the children of the nodes in the second layer, and so on until we find a layer that has no children. This approach is called a 'bredth-first search'.\n\nThat all being said, you are correct that the output needs to be a list of lists, the sub lists being the layers and the ints in them being the value of the node you have visited \n\nHope this helps!"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "What language are you using?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms c++ Easy and simple solution\\nHint : USE BFS\\n \\nMy solution Link :https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3205515/0ms-c-easy-and-simple-solution/\\n\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "prashant_23",
                        "content": "Easy enough if you do it using DFS - 100% faster and no Queue/Stack required."
                    },
                    {
                        "username": "puneetripathi",
                        "content": "Here is a simple idea for the solution:\\n1) Technically its just an level-order traversal of binary tree.\\n2) But only at the odd levels, solution differs from the level-order traversal(order is reversed)\\n3) And at each level, we have to maintain a vector that we push onto the vector of vectors\\n4) Reversal of an array using two-pointer method takes O(n) time and no extra-space.\\n5) We would need some sort of flag at each level to ensure that the current level is even or odd\\n\\nWith the above ideas, I hope you\\'ll be able to solve this problem. Cheers!"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Think of using BFS to your advantage here - that gives you a specific ordering, always left to right. At every other level, how could you store the values in a list going right to left? \\n"
                    },
                    {
                        "username": "shivam9935",
                        "content": "HINT : Look at the solution and you would see each sub list is just a BFS or level order traversal result. Only difference is alternate level are reversed."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "            \\n         class Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([(root, 0)])\\n        d = collections.defaultdict(list)\\n        while q:\\n            node, order= q.popleft()\\n            d[order] += [node.val] \\n            if node.left:\\n                q.append((node.left, order+1))\\n            if node.right:\\n                q.append((node.right, order+1))\\n        return [x[::-1] if k & 1 else x for k, x in d.items()]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "ALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp"
                    },
                    {
                        "username": "tomicz",
                        "content": "I was able to solve this solution by using a LinkedList. The LinkedList (at least in c#) has AddFirst and AddLast methods. And when you add a boolean zig = false or true, then you can select weather to add stuff from beginning or end.\\n\\nLook at my solution in the solutions section."
                    }
                ]
            },
            {
                "id": 1806892,
                "content": [
                    {
                        "username": "alehs_12",
                        "content": "Hi, I keep getting error\\nTypeError: \\'TreeNode\\' object is not iterable\\n\\nStatement\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: [[3],[20,9],[15,7]]\\nIndicates that root is of type list, however its not the case because I cant iterate through it?\\nroot also not A  List[List[int]] because ,again, I cant iterate through it.\\n\\nThank you! \\nIt is possible to convert root to list? \\n\\n"
                    },
                    {
                        "username": "Scarfsman",
                        "content": "Hi, the root is 2D linked list. It's a bit easier to see what this means if you call 'print(root)'. for the example you've given you get the below output.\n\nTreeNode{val: 3, left: TreeNode{val: 9, left: None, right: None}, right: TreeNode{val: 20, left: TreeNode{val: 15, left: None, right: None}, right: TreeNode{val: 7, left: None, right: None}}}\n\nThe input is shown as a normal list by leetcode as it just makes setting up and looking at testcases easier.\n\nTo answer your question, you can't convert the root to a list, but we can iterate  through a binary tree if we find a way of visiting every node in it. If we say that the the first layer of the tree contains only the root node, we know the second layer will be the child nodes of the root node. Then, the third layer will be the children of the nodes in the second layer, and so on until we find a layer that has no children. This approach is called a 'bredth-first search'.\n\nThat all being said, you are correct that the output needs to be a list of lists, the sub lists being the layers and the ints in them being the value of the node you have visited \n\nHope this helps!"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "What language are you using?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms c++ Easy and simple solution\\nHint : USE BFS\\n \\nMy solution Link :https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3205515/0ms-c-easy-and-simple-solution/\\n\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "prashant_23",
                        "content": "Easy enough if you do it using DFS - 100% faster and no Queue/Stack required."
                    },
                    {
                        "username": "puneetripathi",
                        "content": "Here is a simple idea for the solution:\\n1) Technically its just an level-order traversal of binary tree.\\n2) But only at the odd levels, solution differs from the level-order traversal(order is reversed)\\n3) And at each level, we have to maintain a vector that we push onto the vector of vectors\\n4) Reversal of an array using two-pointer method takes O(n) time and no extra-space.\\n5) We would need some sort of flag at each level to ensure that the current level is even or odd\\n\\nWith the above ideas, I hope you\\'ll be able to solve this problem. Cheers!"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Think of using BFS to your advantage here - that gives you a specific ordering, always left to right. At every other level, how could you store the values in a list going right to left? \\n"
                    },
                    {
                        "username": "shivam9935",
                        "content": "HINT : Look at the solution and you would see each sub list is just a BFS or level order traversal result. Only difference is alternate level are reversed."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "            \\n         class Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([(root, 0)])\\n        d = collections.defaultdict(list)\\n        while q:\\n            node, order= q.popleft()\\n            d[order] += [node.val] \\n            if node.left:\\n                q.append((node.left, order+1))\\n            if node.right:\\n                q.append((node.right, order+1))\\n        return [x[::-1] if k & 1 else x for k, x in d.items()]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "ALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp"
                    },
                    {
                        "username": "tomicz",
                        "content": "I was able to solve this solution by using a LinkedList. The LinkedList (at least in c#) has AddFirst and AddLast methods. And when you add a boolean zig = false or true, then you can select weather to add stuff from beginning or end.\\n\\nLook at my solution in the solutions section."
                    }
                ]
            },
            {
                "id": 1806821,
                "content": [
                    {
                        "username": "alehs_12",
                        "content": "Hi, I keep getting error\\nTypeError: \\'TreeNode\\' object is not iterable\\n\\nStatement\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: [[3],[20,9],[15,7]]\\nIndicates that root is of type list, however its not the case because I cant iterate through it?\\nroot also not A  List[List[int]] because ,again, I cant iterate through it.\\n\\nThank you! \\nIt is possible to convert root to list? \\n\\n"
                    },
                    {
                        "username": "Scarfsman",
                        "content": "Hi, the root is 2D linked list. It's a bit easier to see what this means if you call 'print(root)'. for the example you've given you get the below output.\n\nTreeNode{val: 3, left: TreeNode{val: 9, left: None, right: None}, right: TreeNode{val: 20, left: TreeNode{val: 15, left: None, right: None}, right: TreeNode{val: 7, left: None, right: None}}}\n\nThe input is shown as a normal list by leetcode as it just makes setting up and looking at testcases easier.\n\nTo answer your question, you can't convert the root to a list, but we can iterate  through a binary tree if we find a way of visiting every node in it. If we say that the the first layer of the tree contains only the root node, we know the second layer will be the child nodes of the root node. Then, the third layer will be the children of the nodes in the second layer, and so on until we find a layer that has no children. This approach is called a 'bredth-first search'.\n\nThat all being said, you are correct that the output needs to be a list of lists, the sub lists being the layers and the ints in them being the value of the node you have visited \n\nHope this helps!"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "What language are you using?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms c++ Easy and simple solution\\nHint : USE BFS\\n \\nMy solution Link :https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3205515/0ms-c-easy-and-simple-solution/\\n\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "prashant_23",
                        "content": "Easy enough if you do it using DFS - 100% faster and no Queue/Stack required."
                    },
                    {
                        "username": "puneetripathi",
                        "content": "Here is a simple idea for the solution:\\n1) Technically its just an level-order traversal of binary tree.\\n2) But only at the odd levels, solution differs from the level-order traversal(order is reversed)\\n3) And at each level, we have to maintain a vector that we push onto the vector of vectors\\n4) Reversal of an array using two-pointer method takes O(n) time and no extra-space.\\n5) We would need some sort of flag at each level to ensure that the current level is even or odd\\n\\nWith the above ideas, I hope you\\'ll be able to solve this problem. Cheers!"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Think of using BFS to your advantage here - that gives you a specific ordering, always left to right. At every other level, how could you store the values in a list going right to left? \\n"
                    },
                    {
                        "username": "shivam9935",
                        "content": "HINT : Look at the solution and you would see each sub list is just a BFS or level order traversal result. Only difference is alternate level are reversed."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "            \\n         class Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([(root, 0)])\\n        d = collections.defaultdict(list)\\n        while q:\\n            node, order= q.popleft()\\n            d[order] += [node.val] \\n            if node.left:\\n                q.append((node.left, order+1))\\n            if node.right:\\n                q.append((node.right, order+1))\\n        return [x[::-1] if k & 1 else x for k, x in d.items()]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "ALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp"
                    },
                    {
                        "username": "tomicz",
                        "content": "I was able to solve this solution by using a LinkedList. The LinkedList (at least in c#) has AddFirst and AddLast methods. And when you add a boolean zig = false or true, then you can select weather to add stuff from beginning or end.\\n\\nLook at my solution in the solutions section."
                    }
                ]
            },
            {
                "id": 1806724,
                "content": [
                    {
                        "username": "alehs_12",
                        "content": "Hi, I keep getting error\\nTypeError: \\'TreeNode\\' object is not iterable\\n\\nStatement\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: [[3],[20,9],[15,7]]\\nIndicates that root is of type list, however its not the case because I cant iterate through it?\\nroot also not A  List[List[int]] because ,again, I cant iterate through it.\\n\\nThank you! \\nIt is possible to convert root to list? \\n\\n"
                    },
                    {
                        "username": "Scarfsman",
                        "content": "Hi, the root is 2D linked list. It's a bit easier to see what this means if you call 'print(root)'. for the example you've given you get the below output.\n\nTreeNode{val: 3, left: TreeNode{val: 9, left: None, right: None}, right: TreeNode{val: 20, left: TreeNode{val: 15, left: None, right: None}, right: TreeNode{val: 7, left: None, right: None}}}\n\nThe input is shown as a normal list by leetcode as it just makes setting up and looking at testcases easier.\n\nTo answer your question, you can't convert the root to a list, but we can iterate  through a binary tree if we find a way of visiting every node in it. If we say that the the first layer of the tree contains only the root node, we know the second layer will be the child nodes of the root node. Then, the third layer will be the children of the nodes in the second layer, and so on until we find a layer that has no children. This approach is called a 'bredth-first search'.\n\nThat all being said, you are correct that the output needs to be a list of lists, the sub lists being the layers and the ints in them being the value of the node you have visited \n\nHope this helps!"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "What language are you using?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms c++ Easy and simple solution\\nHint : USE BFS\\n \\nMy solution Link :https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3205515/0ms-c-easy-and-simple-solution/\\n\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "prashant_23",
                        "content": "Easy enough if you do it using DFS - 100% faster and no Queue/Stack required."
                    },
                    {
                        "username": "puneetripathi",
                        "content": "Here is a simple idea for the solution:\\n1) Technically its just an level-order traversal of binary tree.\\n2) But only at the odd levels, solution differs from the level-order traversal(order is reversed)\\n3) And at each level, we have to maintain a vector that we push onto the vector of vectors\\n4) Reversal of an array using two-pointer method takes O(n) time and no extra-space.\\n5) We would need some sort of flag at each level to ensure that the current level is even or odd\\n\\nWith the above ideas, I hope you\\'ll be able to solve this problem. Cheers!"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Think of using BFS to your advantage here - that gives you a specific ordering, always left to right. At every other level, how could you store the values in a list going right to left? \\n"
                    },
                    {
                        "username": "shivam9935",
                        "content": "HINT : Look at the solution and you would see each sub list is just a BFS or level order traversal result. Only difference is alternate level are reversed."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "            \\n         class Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([(root, 0)])\\n        d = collections.defaultdict(list)\\n        while q:\\n            node, order= q.popleft()\\n            d[order] += [node.val] \\n            if node.left:\\n                q.append((node.left, order+1))\\n            if node.right:\\n                q.append((node.right, order+1))\\n        return [x[::-1] if k & 1 else x for k, x in d.items()]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "ALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp"
                    },
                    {
                        "username": "tomicz",
                        "content": "I was able to solve this solution by using a LinkedList. The LinkedList (at least in c#) has AddFirst and AddLast methods. And when you add a boolean zig = false or true, then you can select weather to add stuff from beginning or end.\\n\\nLook at my solution in the solutions section."
                    }
                ]
            },
            {
                "id": 1806685,
                "content": [
                    {
                        "username": "alehs_12",
                        "content": "Hi, I keep getting error\\nTypeError: \\'TreeNode\\' object is not iterable\\n\\nStatement\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: [[3],[20,9],[15,7]]\\nIndicates that root is of type list, however its not the case because I cant iterate through it?\\nroot also not A  List[List[int]] because ,again, I cant iterate through it.\\n\\nThank you! \\nIt is possible to convert root to list? \\n\\n"
                    },
                    {
                        "username": "Scarfsman",
                        "content": "Hi, the root is 2D linked list. It's a bit easier to see what this means if you call 'print(root)'. for the example you've given you get the below output.\n\nTreeNode{val: 3, left: TreeNode{val: 9, left: None, right: None}, right: TreeNode{val: 20, left: TreeNode{val: 15, left: None, right: None}, right: TreeNode{val: 7, left: None, right: None}}}\n\nThe input is shown as a normal list by leetcode as it just makes setting up and looking at testcases easier.\n\nTo answer your question, you can't convert the root to a list, but we can iterate  through a binary tree if we find a way of visiting every node in it. If we say that the the first layer of the tree contains only the root node, we know the second layer will be the child nodes of the root node. Then, the third layer will be the children of the nodes in the second layer, and so on until we find a layer that has no children. This approach is called a 'bredth-first search'.\n\nThat all being said, you are correct that the output needs to be a list of lists, the sub lists being the layers and the ints in them being the value of the node you have visited \n\nHope this helps!"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "What language are you using?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms c++ Easy and simple solution\\nHint : USE BFS\\n \\nMy solution Link :https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3205515/0ms-c-easy-and-simple-solution/\\n\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "prashant_23",
                        "content": "Easy enough if you do it using DFS - 100% faster and no Queue/Stack required."
                    },
                    {
                        "username": "puneetripathi",
                        "content": "Here is a simple idea for the solution:\\n1) Technically its just an level-order traversal of binary tree.\\n2) But only at the odd levels, solution differs from the level-order traversal(order is reversed)\\n3) And at each level, we have to maintain a vector that we push onto the vector of vectors\\n4) Reversal of an array using two-pointer method takes O(n) time and no extra-space.\\n5) We would need some sort of flag at each level to ensure that the current level is even or odd\\n\\nWith the above ideas, I hope you\\'ll be able to solve this problem. Cheers!"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Think of using BFS to your advantage here - that gives you a specific ordering, always left to right. At every other level, how could you store the values in a list going right to left? \\n"
                    },
                    {
                        "username": "shivam9935",
                        "content": "HINT : Look at the solution and you would see each sub list is just a BFS or level order traversal result. Only difference is alternate level are reversed."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "            \\n         class Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([(root, 0)])\\n        d = collections.defaultdict(list)\\n        while q:\\n            node, order= q.popleft()\\n            d[order] += [node.val] \\n            if node.left:\\n                q.append((node.left, order+1))\\n            if node.right:\\n                q.append((node.right, order+1))\\n        return [x[::-1] if k & 1 else x for k, x in d.items()]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "ALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp"
                    },
                    {
                        "username": "tomicz",
                        "content": "I was able to solve this solution by using a LinkedList. The LinkedList (at least in c#) has AddFirst and AddLast methods. And when you add a boolean zig = false or true, then you can select weather to add stuff from beginning or end.\\n\\nLook at my solution in the solutions section."
                    }
                ]
            },
            {
                "id": 1806674,
                "content": [
                    {
                        "username": "alehs_12",
                        "content": "Hi, I keep getting error\\nTypeError: \\'TreeNode\\' object is not iterable\\n\\nStatement\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: [[3],[20,9],[15,7]]\\nIndicates that root is of type list, however its not the case because I cant iterate through it?\\nroot also not A  List[List[int]] because ,again, I cant iterate through it.\\n\\nThank you! \\nIt is possible to convert root to list? \\n\\n"
                    },
                    {
                        "username": "Scarfsman",
                        "content": "Hi, the root is 2D linked list. It's a bit easier to see what this means if you call 'print(root)'. for the example you've given you get the below output.\n\nTreeNode{val: 3, left: TreeNode{val: 9, left: None, right: None}, right: TreeNode{val: 20, left: TreeNode{val: 15, left: None, right: None}, right: TreeNode{val: 7, left: None, right: None}}}\n\nThe input is shown as a normal list by leetcode as it just makes setting up and looking at testcases easier.\n\nTo answer your question, you can't convert the root to a list, but we can iterate  through a binary tree if we find a way of visiting every node in it. If we say that the the first layer of the tree contains only the root node, we know the second layer will be the child nodes of the root node. Then, the third layer will be the children of the nodes in the second layer, and so on until we find a layer that has no children. This approach is called a 'bredth-first search'.\n\nThat all being said, you are correct that the output needs to be a list of lists, the sub lists being the layers and the ints in them being the value of the node you have visited \n\nHope this helps!"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "What language are you using?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms c++ Easy and simple solution\\nHint : USE BFS\\n \\nMy solution Link :https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3205515/0ms-c-easy-and-simple-solution/\\n\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "prashant_23",
                        "content": "Easy enough if you do it using DFS - 100% faster and no Queue/Stack required."
                    },
                    {
                        "username": "puneetripathi",
                        "content": "Here is a simple idea for the solution:\\n1) Technically its just an level-order traversal of binary tree.\\n2) But only at the odd levels, solution differs from the level-order traversal(order is reversed)\\n3) And at each level, we have to maintain a vector that we push onto the vector of vectors\\n4) Reversal of an array using two-pointer method takes O(n) time and no extra-space.\\n5) We would need some sort of flag at each level to ensure that the current level is even or odd\\n\\nWith the above ideas, I hope you\\'ll be able to solve this problem. Cheers!"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Think of using BFS to your advantage here - that gives you a specific ordering, always left to right. At every other level, how could you store the values in a list going right to left? \\n"
                    },
                    {
                        "username": "shivam9935",
                        "content": "HINT : Look at the solution and you would see each sub list is just a BFS or level order traversal result. Only difference is alternate level are reversed."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "            \\n         class Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([(root, 0)])\\n        d = collections.defaultdict(list)\\n        while q:\\n            node, order= q.popleft()\\n            d[order] += [node.val] \\n            if node.left:\\n                q.append((node.left, order+1))\\n            if node.right:\\n                q.append((node.right, order+1))\\n        return [x[::-1] if k & 1 else x for k, x in d.items()]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "ALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp"
                    },
                    {
                        "username": "tomicz",
                        "content": "I was able to solve this solution by using a LinkedList. The LinkedList (at least in c#) has AddFirst and AddLast methods. And when you add a boolean zig = false or true, then you can select weather to add stuff from beginning or end.\\n\\nLook at my solution in the solutions section."
                    }
                ]
            },
            {
                "id": 1806649,
                "content": [
                    {
                        "username": "alehs_12",
                        "content": "Hi, I keep getting error\\nTypeError: \\'TreeNode\\' object is not iterable\\n\\nStatement\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: [[3],[20,9],[15,7]]\\nIndicates that root is of type list, however its not the case because I cant iterate through it?\\nroot also not A  List[List[int]] because ,again, I cant iterate through it.\\n\\nThank you! \\nIt is possible to convert root to list? \\n\\n"
                    },
                    {
                        "username": "Scarfsman",
                        "content": "Hi, the root is 2D linked list. It's a bit easier to see what this means if you call 'print(root)'. for the example you've given you get the below output.\n\nTreeNode{val: 3, left: TreeNode{val: 9, left: None, right: None}, right: TreeNode{val: 20, left: TreeNode{val: 15, left: None, right: None}, right: TreeNode{val: 7, left: None, right: None}}}\n\nThe input is shown as a normal list by leetcode as it just makes setting up and looking at testcases easier.\n\nTo answer your question, you can't convert the root to a list, but we can iterate  through a binary tree if we find a way of visiting every node in it. If we say that the the first layer of the tree contains only the root node, we know the second layer will be the child nodes of the root node. Then, the third layer will be the children of the nodes in the second layer, and so on until we find a layer that has no children. This approach is called a 'bredth-first search'.\n\nThat all being said, you are correct that the output needs to be a list of lists, the sub lists being the layers and the ints in them being the value of the node you have visited \n\nHope this helps!"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "What language are you using?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms c++ Easy and simple solution\\nHint : USE BFS\\n \\nMy solution Link :https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3205515/0ms-c-easy-and-simple-solution/\\n\\nDon\\'t forgot to upvote it. "
                    },
                    {
                        "username": "prashant_23",
                        "content": "Easy enough if you do it using DFS - 100% faster and no Queue/Stack required."
                    },
                    {
                        "username": "puneetripathi",
                        "content": "Here is a simple idea for the solution:\\n1) Technically its just an level-order traversal of binary tree.\\n2) But only at the odd levels, solution differs from the level-order traversal(order is reversed)\\n3) And at each level, we have to maintain a vector that we push onto the vector of vectors\\n4) Reversal of an array using two-pointer method takes O(n) time and no extra-space.\\n5) We would need some sort of flag at each level to ensure that the current level is even or odd\\n\\nWith the above ideas, I hope you\\'ll be able to solve this problem. Cheers!"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Think of using BFS to your advantage here - that gives you a specific ordering, always left to right. At every other level, how could you store the values in a list going right to left? \\n"
                    },
                    {
                        "username": "shivam9935",
                        "content": "HINT : Look at the solution and you would see each sub list is just a BFS or level order traversal result. Only difference is alternate level are reversed."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "            \\n         class Solution:\\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        if not root:\\n            return []\\n        q = collections.deque([(root, 0)])\\n        d = collections.defaultdict(list)\\n        while q:\\n            node, order= q.popleft()\\n            d[order] += [node.val] \\n            if node.left:\\n                q.append((node.left, order+1))\\n            if node.right:\\n                q.append((node.right, order+1))\\n        return [x[::-1] if k & 1 else x for k, x in d.items()]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp\\nALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "ALL LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp"
                    },
                    {
                        "username": "tomicz",
                        "content": "I was able to solve this solution by using a LinkedList. The LinkedList (at least in c#) has AddFirst and AddLast methods. And when you add a boolean zig = false or true, then you can select weather to add stuff from beginning or end.\\n\\nLook at my solution in the solutions section."
                    }
                ]
            },
            {
                "id": 1806573,
                "content": [
                    {
                        "username": "x1akshay",
                        "content": "The best, I gonna do is **level order traversal** and in each 2nd iteration reverse the elements. It will form an absolute result. \\n\\nTry it. :)"
                    },
                    {
                        "username": "patchristy",
                        "content": "We are celebrating forest week, thanks leetcode for that."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "The question is just a slight modification of the classic level order traversal. For those who may be new to this, try to understand how level order traversal works. Then simply the reverse the list of level order traversal at every alternate level. "
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Take two stack and in first stack store root and in second stact store root->left and root->right and print root->data from first stack then iterate on second stack and print top() of stack and this time push root->right in stack 1 and then push root->left in stack 1 so as to get zig-zag order of tree.\\ninstead of priniting you can store in vector and then return that vector"
                    },
                    {
                        "username": "anwendeng",
                        "content": "One way to solve this question is to use lists.\nThe node is pushed back or pushed front depending on its level (mod 2). \nFinally, these lists will be converted to the desired data structures."
                    },
                    {
                        "username": "sukiboo",
                        "content": "rip leetcode daily challenge easy streak 02/13--02/18, you will be missed"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "pretty straightforward "
                    },
                    {
                        "username": "amine_fadssi",
                        "content": "no more easy problems?"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "7 days of easy leetcode!!\\n:) Feeling lucky!"
                    },
                    {
                        "username": "chandankumarmech18",
                        "content": "\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1806561,
                "content": [
                    {
                        "username": "x1akshay",
                        "content": "The best, I gonna do is **level order traversal** and in each 2nd iteration reverse the elements. It will form an absolute result. \\n\\nTry it. :)"
                    },
                    {
                        "username": "patchristy",
                        "content": "We are celebrating forest week, thanks leetcode for that."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "The question is just a slight modification of the classic level order traversal. For those who may be new to this, try to understand how level order traversal works. Then simply the reverse the list of level order traversal at every alternate level. "
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Take two stack and in first stack store root and in second stact store root->left and root->right and print root->data from first stack then iterate on second stack and print top() of stack and this time push root->right in stack 1 and then push root->left in stack 1 so as to get zig-zag order of tree.\\ninstead of priniting you can store in vector and then return that vector"
                    },
                    {
                        "username": "anwendeng",
                        "content": "One way to solve this question is to use lists.\nThe node is pushed back or pushed front depending on its level (mod 2). \nFinally, these lists will be converted to the desired data structures."
                    },
                    {
                        "username": "sukiboo",
                        "content": "rip leetcode daily challenge easy streak 02/13--02/18, you will be missed"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "pretty straightforward "
                    },
                    {
                        "username": "amine_fadssi",
                        "content": "no more easy problems?"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "7 days of easy leetcode!!\\n:) Feeling lucky!"
                    },
                    {
                        "username": "chandankumarmech18",
                        "content": "\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1806559,
                "content": [
                    {
                        "username": "x1akshay",
                        "content": "The best, I gonna do is **level order traversal** and in each 2nd iteration reverse the elements. It will form an absolute result. \\n\\nTry it. :)"
                    },
                    {
                        "username": "patchristy",
                        "content": "We are celebrating forest week, thanks leetcode for that."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "The question is just a slight modification of the classic level order traversal. For those who may be new to this, try to understand how level order traversal works. Then simply the reverse the list of level order traversal at every alternate level. "
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Take two stack and in first stack store root and in second stact store root->left and root->right and print root->data from first stack then iterate on second stack and print top() of stack and this time push root->right in stack 1 and then push root->left in stack 1 so as to get zig-zag order of tree.\\ninstead of priniting you can store in vector and then return that vector"
                    },
                    {
                        "username": "anwendeng",
                        "content": "One way to solve this question is to use lists.\nThe node is pushed back or pushed front depending on its level (mod 2). \nFinally, these lists will be converted to the desired data structures."
                    },
                    {
                        "username": "sukiboo",
                        "content": "rip leetcode daily challenge easy streak 02/13--02/18, you will be missed"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "pretty straightforward "
                    },
                    {
                        "username": "amine_fadssi",
                        "content": "no more easy problems?"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "7 days of easy leetcode!!\\n:) Feeling lucky!"
                    },
                    {
                        "username": "chandankumarmech18",
                        "content": "\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1806468,
                "content": [
                    {
                        "username": "x1akshay",
                        "content": "The best, I gonna do is **level order traversal** and in each 2nd iteration reverse the elements. It will form an absolute result. \\n\\nTry it. :)"
                    },
                    {
                        "username": "patchristy",
                        "content": "We are celebrating forest week, thanks leetcode for that."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "The question is just a slight modification of the classic level order traversal. For those who may be new to this, try to understand how level order traversal works. Then simply the reverse the list of level order traversal at every alternate level. "
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Take two stack and in first stack store root and in second stact store root->left and root->right and print root->data from first stack then iterate on second stack and print top() of stack and this time push root->right in stack 1 and then push root->left in stack 1 so as to get zig-zag order of tree.\\ninstead of priniting you can store in vector and then return that vector"
                    },
                    {
                        "username": "anwendeng",
                        "content": "One way to solve this question is to use lists.\nThe node is pushed back or pushed front depending on its level (mod 2). \nFinally, these lists will be converted to the desired data structures."
                    },
                    {
                        "username": "sukiboo",
                        "content": "rip leetcode daily challenge easy streak 02/13--02/18, you will be missed"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "pretty straightforward "
                    },
                    {
                        "username": "amine_fadssi",
                        "content": "no more easy problems?"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "7 days of easy leetcode!!\\n:) Feeling lucky!"
                    },
                    {
                        "username": "chandankumarmech18",
                        "content": "\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1806239,
                "content": [
                    {
                        "username": "x1akshay",
                        "content": "The best, I gonna do is **level order traversal** and in each 2nd iteration reverse the elements. It will form an absolute result. \\n\\nTry it. :)"
                    },
                    {
                        "username": "patchristy",
                        "content": "We are celebrating forest week, thanks leetcode for that."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "The question is just a slight modification of the classic level order traversal. For those who may be new to this, try to understand how level order traversal works. Then simply the reverse the list of level order traversal at every alternate level. "
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Take two stack and in first stack store root and in second stact store root->left and root->right and print root->data from first stack then iterate on second stack and print top() of stack and this time push root->right in stack 1 and then push root->left in stack 1 so as to get zig-zag order of tree.\\ninstead of priniting you can store in vector and then return that vector"
                    },
                    {
                        "username": "anwendeng",
                        "content": "One way to solve this question is to use lists.\nThe node is pushed back or pushed front depending on its level (mod 2). \nFinally, these lists will be converted to the desired data structures."
                    },
                    {
                        "username": "sukiboo",
                        "content": "rip leetcode daily challenge easy streak 02/13--02/18, you will be missed"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "pretty straightforward "
                    },
                    {
                        "username": "amine_fadssi",
                        "content": "no more easy problems?"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "7 days of easy leetcode!!\\n:) Feeling lucky!"
                    },
                    {
                        "username": "chandankumarmech18",
                        "content": "\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1806191,
                "content": [
                    {
                        "username": "x1akshay",
                        "content": "The best, I gonna do is **level order traversal** and in each 2nd iteration reverse the elements. It will form an absolute result. \\n\\nTry it. :)"
                    },
                    {
                        "username": "patchristy",
                        "content": "We are celebrating forest week, thanks leetcode for that."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "The question is just a slight modification of the classic level order traversal. For those who may be new to this, try to understand how level order traversal works. Then simply the reverse the list of level order traversal at every alternate level. "
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Take two stack and in first stack store root and in second stact store root->left and root->right and print root->data from first stack then iterate on second stack and print top() of stack and this time push root->right in stack 1 and then push root->left in stack 1 so as to get zig-zag order of tree.\\ninstead of priniting you can store in vector and then return that vector"
                    },
                    {
                        "username": "anwendeng",
                        "content": "One way to solve this question is to use lists.\nThe node is pushed back or pushed front depending on its level (mod 2). \nFinally, these lists will be converted to the desired data structures."
                    },
                    {
                        "username": "sukiboo",
                        "content": "rip leetcode daily challenge easy streak 02/13--02/18, you will be missed"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "pretty straightforward "
                    },
                    {
                        "username": "amine_fadssi",
                        "content": "no more easy problems?"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "7 days of easy leetcode!!\\n:) Feeling lucky!"
                    },
                    {
                        "username": "chandankumarmech18",
                        "content": "\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1806166,
                "content": [
                    {
                        "username": "x1akshay",
                        "content": "The best, I gonna do is **level order traversal** and in each 2nd iteration reverse the elements. It will form an absolute result. \\n\\nTry it. :)"
                    },
                    {
                        "username": "patchristy",
                        "content": "We are celebrating forest week, thanks leetcode for that."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "The question is just a slight modification of the classic level order traversal. For those who may be new to this, try to understand how level order traversal works. Then simply the reverse the list of level order traversal at every alternate level. "
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Take two stack and in first stack store root and in second stact store root->left and root->right and print root->data from first stack then iterate on second stack and print top() of stack and this time push root->right in stack 1 and then push root->left in stack 1 so as to get zig-zag order of tree.\\ninstead of priniting you can store in vector and then return that vector"
                    },
                    {
                        "username": "anwendeng",
                        "content": "One way to solve this question is to use lists.\nThe node is pushed back or pushed front depending on its level (mod 2). \nFinally, these lists will be converted to the desired data structures."
                    },
                    {
                        "username": "sukiboo",
                        "content": "rip leetcode daily challenge easy streak 02/13--02/18, you will be missed"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "pretty straightforward "
                    },
                    {
                        "username": "amine_fadssi",
                        "content": "no more easy problems?"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "7 days of easy leetcode!!\\n:) Feeling lucky!"
                    },
                    {
                        "username": "chandankumarmech18",
                        "content": "\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1806154,
                "content": [
                    {
                        "username": "x1akshay",
                        "content": "The best, I gonna do is **level order traversal** and in each 2nd iteration reverse the elements. It will form an absolute result. \\n\\nTry it. :)"
                    },
                    {
                        "username": "patchristy",
                        "content": "We are celebrating forest week, thanks leetcode for that."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "The question is just a slight modification of the classic level order traversal. For those who may be new to this, try to understand how level order traversal works. Then simply the reverse the list of level order traversal at every alternate level. "
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Take two stack and in first stack store root and in second stact store root->left and root->right and print root->data from first stack then iterate on second stack and print top() of stack and this time push root->right in stack 1 and then push root->left in stack 1 so as to get zig-zag order of tree.\\ninstead of priniting you can store in vector and then return that vector"
                    },
                    {
                        "username": "anwendeng",
                        "content": "One way to solve this question is to use lists.\nThe node is pushed back or pushed front depending on its level (mod 2). \nFinally, these lists will be converted to the desired data structures."
                    },
                    {
                        "username": "sukiboo",
                        "content": "rip leetcode daily challenge easy streak 02/13--02/18, you will be missed"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "pretty straightforward "
                    },
                    {
                        "username": "amine_fadssi",
                        "content": "no more easy problems?"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "7 days of easy leetcode!!\\n:) Feeling lucky!"
                    },
                    {
                        "username": "chandankumarmech18",
                        "content": "\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1806151,
                "content": [
                    {
                        "username": "x1akshay",
                        "content": "The best, I gonna do is **level order traversal** and in each 2nd iteration reverse the elements. It will form an absolute result. \\n\\nTry it. :)"
                    },
                    {
                        "username": "patchristy",
                        "content": "We are celebrating forest week, thanks leetcode for that."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "The question is just a slight modification of the classic level order traversal. For those who may be new to this, try to understand how level order traversal works. Then simply the reverse the list of level order traversal at every alternate level. "
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Take two stack and in first stack store root and in second stact store root->left and root->right and print root->data from first stack then iterate on second stack and print top() of stack and this time push root->right in stack 1 and then push root->left in stack 1 so as to get zig-zag order of tree.\\ninstead of priniting you can store in vector and then return that vector"
                    },
                    {
                        "username": "anwendeng",
                        "content": "One way to solve this question is to use lists.\nThe node is pushed back or pushed front depending on its level (mod 2). \nFinally, these lists will be converted to the desired data structures."
                    },
                    {
                        "username": "sukiboo",
                        "content": "rip leetcode daily challenge easy streak 02/13--02/18, you will be missed"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "pretty straightforward "
                    },
                    {
                        "username": "amine_fadssi",
                        "content": "no more easy problems?"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "7 days of easy leetcode!!\\n:) Feeling lucky!"
                    },
                    {
                        "username": "chandankumarmech18",
                        "content": "\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1806135,
                "content": [
                    {
                        "username": "x1akshay",
                        "content": "The best, I gonna do is **level order traversal** and in each 2nd iteration reverse the elements. It will form an absolute result. \\n\\nTry it. :)"
                    },
                    {
                        "username": "patchristy",
                        "content": "We are celebrating forest week, thanks leetcode for that."
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "The question is just a slight modification of the classic level order traversal. For those who may be new to this, try to understand how level order traversal works. Then simply the reverse the list of level order traversal at every alternate level. "
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "Take two stack and in first stack store root and in second stact store root->left and root->right and print root->data from first stack then iterate on second stack and print top() of stack and this time push root->right in stack 1 and then push root->left in stack 1 so as to get zig-zag order of tree.\\ninstead of priniting you can store in vector and then return that vector"
                    },
                    {
                        "username": "anwendeng",
                        "content": "One way to solve this question is to use lists.\nThe node is pushed back or pushed front depending on its level (mod 2). \nFinally, these lists will be converted to the desired data structures."
                    },
                    {
                        "username": "sukiboo",
                        "content": "rip leetcode daily challenge easy streak 02/13--02/18, you will be missed"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "pretty straightforward "
                    },
                    {
                        "username": "amine_fadssi",
                        "content": "no more easy problems?"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "7 days of easy leetcode!!\\n:) Feeling lucky!"
                    },
                    {
                        "username": "chandankumarmech18",
                        "content": "\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n     \\n     \\n    \\n        ArrayList<ArrayList<Integer>>res = new ArrayList<ArrayList<Integer>>();\\n        if(root==null)return new ArrayList<>(res) ;\\n        Deque <TreeNode> q = new ArrayDeque<>();\\n        boolean isfirst = true ;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n               int size = q.size();\\n                 ArrayList<Integer>arr = new ArrayList<Integer>();\\n            if(isfirst){\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollFirst();\\n                    arr.add(node.val);\\n                    if(node.left!=null)\\n                     q.addLast(node.left);\\n                     if(node.right!=null)\\n                        q.addLast(node.right);\\n\\n                }\\n                System.out.println(arr);\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = false ;\\n\\n            }\\n            else {\\n              \\n                for(int i = 0 ;i<size;i++){\\n                    \\n                    TreeNode node = q.pollLast();\\n                    arr.add(node.val);\\n                    if(node.right!=null)\\n                     q.addFirst(node.right);\\n                     if(node.left!=null)\\n                        q.addFirst(node.left);\\n\\n                }\\n                  res.add(new ArrayList<>(arr));\\n                  isfirst = true ;\\n\\n            }\\n        }\\n        \\n        return new ArrayList<>(res);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    }
]