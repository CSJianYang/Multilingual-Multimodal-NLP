[
    {
        "title": "Bomb Enemy",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1576509,
                "content": [
                    {
                        "username": "fred042",
                        "content": "![image](https://assets.leetcode.com/users/images/288eb665-8fd1-4318-83d5-a4cbb087c375_1647334519.7002983.png)\\n"
                    },
                    {
                        "username": "tjcd",
                        "content": "There are several solutions call themselves \"DP solutions\". Actually, they are just \"straightforward solutions\", which are optimized based on brute force solution. They are still not DP though. \\nIf you think you've written a DP solution, then \\n* what is your sub-problem definition? \\n* what is the relation between sub-problem and certain polynormial number of sub-sub-problems? \\nlike dp[sub] = func(dp[sub1],dp[sub2],.....,dp[subn])? \\n\\nCan anyone solve it in a true DP way?"
                    },
                    {
                        "username": "mucle6",
                        "content": "Obviously this scenario is not real, but I still don't like being asked to maximize the effectiveness of a bomb. Anyone else feel similar?"
                    },
                    {
                        "username": "myxo945",
                        "content": "This question is so scary."
                    }
                ]
            },
            {
                "id": 1565670,
                "content": [
                    {
                        "username": "fred042",
                        "content": "![image](https://assets.leetcode.com/users/images/288eb665-8fd1-4318-83d5-a4cbb087c375_1647334519.7002983.png)\\n"
                    },
                    {
                        "username": "tjcd",
                        "content": "There are several solutions call themselves \"DP solutions\". Actually, they are just \"straightforward solutions\", which are optimized based on brute force solution. They are still not DP though. \\nIf you think you've written a DP solution, then \\n* what is your sub-problem definition? \\n* what is the relation between sub-problem and certain polynormial number of sub-sub-problems? \\nlike dp[sub] = func(dp[sub1],dp[sub2],.....,dp[subn])? \\n\\nCan anyone solve it in a true DP way?"
                    },
                    {
                        "username": "mucle6",
                        "content": "Obviously this scenario is not real, but I still don't like being asked to maximize the effectiveness of a bomb. Anyone else feel similar?"
                    },
                    {
                        "username": "myxo945",
                        "content": "This question is so scary."
                    }
                ]
            },
            {
                "id": 1565748,
                "content": [
                    {
                        "username": "fred042",
                        "content": "![image](https://assets.leetcode.com/users/images/288eb665-8fd1-4318-83d5-a4cbb087c375_1647334519.7002983.png)\\n"
                    },
                    {
                        "username": "tjcd",
                        "content": "There are several solutions call themselves \"DP solutions\". Actually, they are just \"straightforward solutions\", which are optimized based on brute force solution. They are still not DP though. \\nIf you think you've written a DP solution, then \\n* what is your sub-problem definition? \\n* what is the relation between sub-problem and certain polynormial number of sub-sub-problems? \\nlike dp[sub] = func(dp[sub1],dp[sub2],.....,dp[subn])? \\n\\nCan anyone solve it in a true DP way?"
                    },
                    {
                        "username": "mucle6",
                        "content": "Obviously this scenario is not real, but I still don't like being asked to maximize the effectiveness of a bomb. Anyone else feel similar?"
                    },
                    {
                        "username": "myxo945",
                        "content": "This question is so scary."
                    }
                ]
            },
            {
                "id": 1573407,
                "content": [
                    {
                        "username": "fred042",
                        "content": "![image](https://assets.leetcode.com/users/images/288eb665-8fd1-4318-83d5-a4cbb087c375_1647334519.7002983.png)\\n"
                    },
                    {
                        "username": "tjcd",
                        "content": "There are several solutions call themselves \"DP solutions\". Actually, they are just \"straightforward solutions\", which are optimized based on brute force solution. They are still not DP though. \\nIf you think you've written a DP solution, then \\n* what is your sub-problem definition? \\n* what is the relation between sub-problem and certain polynormial number of sub-sub-problems? \\nlike dp[sub] = func(dp[sub1],dp[sub2],.....,dp[subn])? \\n\\nCan anyone solve it in a true DP way?"
                    },
                    {
                        "username": "mucle6",
                        "content": "Obviously this scenario is not real, but I still don't like being asked to maximize the effectiveness of a bomb. Anyone else feel similar?"
                    },
                    {
                        "username": "myxo945",
                        "content": "This question is so scary."
                    }
                ]
            }
        ]
    },
    {
        "title": "Global and Local Inversions",
        "question_content": "<p>You are given an integer array <code>nums</code> of length <code>n</code> which represents a permutation of all the integers in the range <code>[0, n - 1]</code>.</p>\n\n<p>The number of <strong>global inversions</strong> is the number of the different pairs <code>(i, j)</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; n</code></li>\n\t<li><code>nums[i] &gt; nums[j]</code></li>\n</ul>\n\n<p>The number of <strong>local inversions</strong> is the number of indices <code>i</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; n - 1</code></li>\n\t<li><code>nums[i] &gt; nums[i + 1]</code></li>\n</ul>\n\n<p>Return <code>true</code> <em>if the number of <strong>global inversions</strong> is equal to the number of <strong>local inversions</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is 1 global inversion and 1 local inversion.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,0]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There are 2 global inversions and 1 local inversion.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; n</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is a permutation of all the numbers in the range <code>[0, n - 1]</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 113644,
                "title": "c-java-python-easy-and-concise-solution",
                "content": "# Explanation\\nAll local inversions are global inversions.\\nIf the number of global inversions is equal to the number of local inversions,\\nit means that all global inversions in permutations are local inversions.\\nIt also means that we can not find ```A[i] > A[j]``` with ```i+2<=j```.\\nIn other words,  ```max(A[i]) < A[i+2]```\\n\\nIn this first solution, I traverse ```A``` and keep the current biggest number ```cmax```.\\nThen I check the condition  ```cmax < A[i+2]```\\n\\nHere come this solutions\\n\\n# Solution 1\\n**C++**\\n```cpp\\nbool isIdealPermutation(vector<int>& A) {\\n        int cmax = 0, n = A.size();\\n        for (int i = 0; i < n - 2; ++i) {\\n            cmax = max(cmax, A[i]);\\n            if (cmax > A[i + 2]) return false;\\n        }\\n        return true;\\n    }\\n```\\n**Java**\\n```java\\npublic boolean isIdealPermutation(int[] A) {\\n        int cmax = 0;\\n        for (int i = 0; i < A.length - 2; ++i) {\\n            cmax = Math.max(cmax, A[i]);\\n            if (cmax > A[i + 2]) return false;\\n        }\\n        return true;\\n    }\\n```\\n**Python**\\n```py\\ndef isIdealPermutation(self, A):\\n        cmax = 0\\n        for i in range(len(A) - 2):\\n            cmax = max(cmax, A[i])\\n            if cmax > A[i + 2]:\\n                return False\\n        return True\\n```\\n<br>\\n\\n# Solution 2\\nBasic on this idea, I tried to arrange an ideal permutation. \\nThen I found that to place number `i`\\nI could only place `i` at `A[i-1]`, `A[i]` or `A[i+1]`. \\nSo it came up to me, \\nIt will be easier just to check if all `A[i] - i` equals to -1, 0 or 1.\\n\\n**C++**\\n```cpp\\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); ++i)\\n            if (abs(A[i] - i) > 1) return false;\\n        return true;\\n    }\\n```\\n**Java**\\n```java\\n    public boolean isIdealPermutation(int[] A) {\\n        for (int i = 0; i < A.length; ++i)\\n            if (Math.abs(A[i] - i) > 1) return false;\\n        return true;\\n    }\\n```\\n**Python**\\n```py\\n    def isIdealPermutation(self, A):\\n        return all(abs(i - v) <= 1 for i, v in enumerate(A))\\n```",
                "solutionTags": [],
                "code": "```A[i] > A[j]```\n```i+2<=j```\n```max(A[i]) < A[i+2]```\n```A```\n```cmax```\n```cmax < A[i+2]```\n```cpp\\nbool isIdealPermutation(vector<int>& A) {\\n        int cmax = 0, n = A.size();\\n        for (int i = 0; i < n - 2; ++i) {\\n            cmax = max(cmax, A[i]);\\n            if (cmax > A[i + 2]) return false;\\n        }\\n        return true;\\n    }\\n```\n```java\\npublic boolean isIdealPermutation(int[] A) {\\n        int cmax = 0;\\n        for (int i = 0; i < A.length - 2; ++i) {\\n            cmax = Math.max(cmax, A[i]);\\n            if (cmax > A[i + 2]) return false;\\n        }\\n        return true;\\n    }\\n```\n```py\\ndef isIdealPermutation(self, A):\\n        cmax = 0\\n        for i in range(len(A) - 2):\\n            cmax = max(cmax, A[i])\\n            if cmax > A[i + 2]:\\n                return False\\n        return True\\n```\n```cpp\\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); ++i)\\n            if (abs(A[i] - i) > 1) return false;\\n        return true;\\n    }\\n```\n```java\\n    public boolean isIdealPermutation(int[] A) {\\n        for (int i = 0; i < A.length; ++i)\\n            if (Math.abs(A[i] - i) > 1) return false;\\n        return true;\\n    }\\n```\n```py\\n    def isIdealPermutation(self, A):\\n        return all(abs(i - v) <= 1 for i, v in enumerate(A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113656,
                "title": "my-3-lines-c-solution",
                "content": "The original order should be [0, 1, 2, 3, 4...], the number i should be on the position i. We just check the offset of each number, if the absolute value is larger than 1, means the number of global inversion must be bigger than local inversion, because a local inversion is a global inversion, but a global one may not be local.\\n\\nproof:\\n\\nIf A[i] > i + 1, means at least one number that is smaller than A[i] is kicked out from first A[i] numbers, and the distance between this smaller number and A[i] is at least 2, then it is a non-local global inversion. \\nFor example, A[i] = 3, i = 1, at least one number that is smaller than 3 is kicked out from first 3 numbers, and the distance between the smaller number and 3 is at least 2.\\n\\nIf A[i] < i - 1, means at least one number that is bigger than A[i] is kicked out from last n - i numbers, and the distance between this bigger number and A[i] is at least 2, then it is a non-local global inversion. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n\\tfor (int i = 0; i < A.size(); ++i) {\\n            if (abs(A[i] - i) > 1) return false;\\n        }\\n\\treturn true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n\\tfor (int i = 0; i < A.size(); ++i) {\\n            if (abs(A[i] - i) > 1) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 150991,
                "title": "from-intuition-to-optimization",
                "content": "### Intuitive approach\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i + 2; j < A.length; j++) {\\n                if (A[j] < A[i]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nThe time complexity is O(n^2).\\n\\n### Optimization\\nIn the above appraoch, we wasted the piece of information: `We have some permutation A of [0, 1, ..., N - 1]`.\\n\\nElements to the right of A[i] must be bigger than A[i] except for A[i + 1].\\n```\\nAssuming N=4, i = 1 \\n\\nA = [0,1, 2, 3] satisfy\\n\\n// A[i] can switch with A[i + 1]\\nA = [0, 2, 1, 3] satisfy\\n\\n// A[i] can switch with A[i - 1]\\nA = [1, 0, 2, 3] satisfy\\n\\nbut A = [0, 3, 2, 1] and A = [0, 3, 1, 2] wouldn\\'t satisfy\\n```\\n\\nSo **|i - A[i]| <= 1** is an invariant.\\n\\n```\\n    public boolean isIdealPermutation(int[] A) {\\n\\n        for (int i = 0; i < A.length; i++) {\\n            if (Math.abs(i - A[i]) > 1)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n```\\n\\nThe time complexity is O(n).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i + 2; j < A.length; j++) {\\n                if (A[j] < A[i]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nAssuming N=4, i = 1 \\n\\nA = [0,1, 2, 3] satisfy\\n\\n// A[i] can switch with A[i + 1]\\nA = [0, 2, 1, 3] satisfy\\n\\n// A[i] can switch with A[i - 1]\\nA = [1, 0, 2, 3] satisfy\\n\\nbut A = [0, 3, 2, 1] and A = [0, 3, 1, 2] wouldn\\'t satisfy\\n```\n```\\n    public boolean isIdealPermutation(int[] A) {\\n\\n        for (int i = 0; i < A.length; i++) {\\n            if (Math.abs(i - A[i]) > 1)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143422,
                "title": "js-python-java-c-simple-3-line-solutions-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSo the critical thing to understand here is that *every local inversion is also, by definition, a global inversion*. Any number that represents part of a global inversion, however, could represent more than one global inversion.\\n\\nSo then we should consider that the ideal version of **A** without any inversions would be one which is **strictly increasing**, which means that for all **i**, **A[i] = i**. *Any deviation from this results in an inversion*.\\n\\nAlso, the further **A[i]** deviates from **i**, the more global inversions are ultimately triggered. In fact, *the only possible way for the number of global inversions to be equal to the number of local inversions is if each number has a maximum deviation from ideal of only **1**, meaning that it represents only a single global inversion and a single local inversion*.\\n\\nConsider the two cases:\\n\\n**Case A**) A number is more than one *higher* than the ideal; for example, **i = 3**, **A[i] = 5**.\\n\\nWhen **i** is **3**, that means we\\'ve seen **3** numbers already, yet there are **5** numbers that are less than **5**. That then means that there are **at least 2** numbers that are less than **5** that we have not yet seen, which in turn means that there are **at least 2** global inversions triggered by this one deviation.\\n\\n**Case B**) A number is more than one *lower* than the ideal; for example, **i = 3**, **A[i] = 1**.\\n\\nWhen **i** is **3**, that means we\\'ve seen **3** numbers already, yet only **1** number is less than **1**. That then means that **at least 2** of the numbers we\\'ve seen are higher than **1**, which in turn means that we\\'ve already triggered **at least 2** gobal inversions because of this one deviation.\\n\\nAny move to offset these extra global inversions with additional local inversions would only trigger at least as many more global inversions.\\n\\nSo if we iterate through **A** and find any number that deviates more than **1** from its ideal, we can immediately **return false**. If we reach the end without triggering this, we can **return true**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThis code is very basic in all languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **84ms / 42.3MB** (beats 100% / 93%).\\n```javascript\\nvar isIdealPermutation = function(A) {\\n    for (let i = 0; i < A.length; i++)\\n        if (i - A[i] > 1 || i - A[i] < -1) return false\\n    return true\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **308ms / 14.9MB** (beats 100% / 92%).\\n```python\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        for i in range(len(A)):\\n            if i - A[i] > 1 or i - A[i] < -1: return False\\n        return True\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 39.3MB** (beats 100% / 80%).\\n```java\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for (int i = 0; i < A.length; i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **36ms / 35.5MB** (beats 97% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isIdealPermutation = function(A) {\\n    for (let i = 0; i < A.length; i++)\\n        if (i - A[i] > 1 || i - A[i] < -1) return false\\n    return true\\n};\\n```\n```python\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        for i in range(len(A)):\\n            if i - A[i] > 1 or i - A[i] < -1: return False\\n        return True\\n```\n```java\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for (int i = 0; i < A.length; i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144007,
                "title": "c-3-line-code-100-fast-with-explanation",
                "content": "This question has a trick.\\n\\n* Global inversion (i<j and A[i] > A[j]) contains local inversions (A[i] > A[i+1]) because local inversions is a special case of global inversion where j = i+1.\\n* For an array to have equal number of local and global inversions it should have just the local inversions.(because global inversions = {local inversion + cases where j > i+1} and for equality cases where j > i+1 should be zero.).\\n* Now if we are given a sorted array like this {0,1,2,3,4,5} we have 0 local inversions in this as all elements are in increasing order and also note that elements index in a sorted array is element itself. i.e. A[i] = i. For creating a local inversion we will have to move a greater element at a position behind it but we cannot move more than 1 position because then we will end up creating cases where A[i] > A[j] for j > i+1 which we dont want.\\n* So to check local inversions we just need to verify if in the given array element is shifted at most 1 position from its correct position in the sorted array.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143423,
                "title": "global-and-local-inversions-js-python-java-c-simple-3-line-solutions-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSo the critical thing to understand here is that *every local inversion is also, by definition, a global inversion*. Any number that represents part of a global inversion, however, could represent more than one global inversion.\\n\\nSo then we should consider that the ideal version of **A** without any inversions would be one which is **strictly increasing**, which means that for all **i**, **A[i] = i**. *Any deviation from this results in an inversion*.\\n\\nAlso, the further **A[i]** deviates from **i**, the more global inversions are ultimately triggered. In fact, *the only possible way for the number of global inversions to be equal to the number of local inversions is if each number has a maximum deviation from ideal of only **1**, meaning that it represents only a single global inversion and a single local inversion*.\\n\\nConsider the two cases:\\n\\n**Case A**) A number is more than one *higher* than the ideal; for example, **i = 3**, **A[i] = 5**.\\n\\nWhen **i** is **3**, that means we\\'ve seen **3** numbers already, yet there are **5** numbers that are less than **5**. That then means that there are **at least 2** numbers that are less than **5** that we have not yet seen, which in turn means that there are **at least 2** global inversions triggered by this one deviation.\\n\\n**Case B**) A number is more than one *lower* than the ideal; for example, **i = 3**, **A[i] = 1**.\\n\\nWhen **i** is **3**, that means we\\'ve seen **3** numbers already, yet only **1** number is less than **1**. That then means that **at least 2** of the numbers we\\'ve seen are higher than **1**, which in turn means that we\\'ve already triggered **at least 2** gobal inversions because of this one deviation.\\n\\nAny move to offset these extra global inversions with additional local inversions would only trigger at least as many more global inversions.\\n\\nSo if we iterate through **A** and find any number that deviates more than **1** from its ideal, we can immediately **return false**. If we reach the end without triggering this, we can **return true**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThis code is very basic in all languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **84ms / 42.3MB** (beats 100% / 93%).\\n```javascript\\nvar isIdealPermutation = function(A) {\\n    for (let i = 0; i < A.length; i++)\\n        if (i - A[i] > 1 || i - A[i] < -1) return false\\n    return true\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **308ms / 14.9MB** (beats 100% / 92%).\\n```python\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        for i in range(len(A)):\\n            if i - A[i] > 1 or i - A[i] < -1: return False\\n        return True\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 39.3MB** (beats 100% / 80%).\\n```java\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for (int i = 0; i < A.length; i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **36ms / 35.5MB** (beats 97% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar isIdealPermutation = function(A) {\\n    for (let i = 0; i < A.length; i++)\\n        if (i - A[i] > 1 || i - A[i] < -1) return false\\n    return true\\n};\\n```\n```python\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        for i in range(len(A)):\\n            if i - A[i] > 1 or i - A[i] < -1: return False\\n        return True\\n```\n```java\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for (int i = 0; i < A.length; i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143477,
                "title": "short-easy-w-explanation-multiple-approaches-2-liners",
                "content": "***Solution - I (Global Inversions == Local Inversions):***\\n\\nWe can observe that **each local inversion is global inversion** (or local inversions are subset of global inversions). For both of them to be equal, **every global inversion must only be a local inversion**.\\n\\nA global inversion can be limited to be only a local inversion if for every `0 <= i < N`, **`abs(A[i] - i) <= 1`**.\\n\\n*Why?*\\nBecause, if `A[i] - i > 1`, we can have atleast 2 pairs `(i,j)` and `(i,k)` such that `A[i] > A[j] and A[i] > A[k]` but if every global inversion has to be only local inversion, we should only have gotten a single pair `(i,j)` (more specifically `(i,i+1)`) such that `A[i] > A[j]`. \\nEg. `[2,0,1]`, here `A[0]-0 = 2 > 1`, so we got two pairs of index (0,1) and (0,2) making global inversions != local inversions.\\n\\n----\\n\\n***C++***\\n```\\nbool isIdealPermutation(vector<int>& A) {        \\n\\tfor(int i = 0; i < size(A); i++) if(abs(A[i] - i) > 1) return false;\\n\\treturn true;\\n}\\n```\\n\\n***Python***\\n```\\ndef isIdealPermutation(self, A: List[int]) -> bool:\\n\\treturn not any(abs(Ai - i) > 1 for Ai, i in enumerate(A))\\n```\\n***Time Complexity :*** **`O(N)`**, where `N` is the size of given array.\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n<center>\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/71f85c39-24ba-48e3-92a5-c582f0629c22_1617622942.6370938.png />\\n</td></tr></table>\\n</center>\\n\\n----\\n----\\n\\n**Edit :**\\n\\nI had at first mentioned an approach that works but is not entirely correct. The solution was as below -\\n\\n```\\nbool isIdealPermutation(vector<int>& A) {\\n\\tint inversionDiff = 0;\\n\\t//                                                    Local Inversions  -  Global Inversions\\n\\tfor(int i = 0; i < size(A) - 1; i++) inversionDiff += (A[i] > A[i + 1]) - max(0, 2 * (A[i] - i) - 1);        \\n\\treturn !inversionDiff;\\n}\\n```\\n\\nI thought we could count global inversions using the formula  **`\\u03A3 (2*(A[i] - i) - 1)`**, for all `i`, where `A[i] > i` but it worked only for few permutations & not for all cases (Thanks @Tudor67 for bring to my attention).\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isIdealPermutation(vector<int>& A) {        \\n\\tfor(int i = 0; i < size(A); i++) if(abs(A[i] - i) > 1) return false;\\n\\treturn true;\\n}\\n```\n```\\ndef isIdealPermutation(self, A: List[int]) -> bool:\\n\\treturn not any(abs(Ai - i) > 1 for Ai, i in enumerate(A))\\n```\n```\\nbool isIdealPermutation(vector<int>& A) {\\n\\tint inversionDiff = 0;\\n\\t//                                                    Local Inversions  -  Global Inversions\\n\\tfor(int i = 0; i < size(A) - 1; i++) inversionDiff += (A[i] > A[i + 1]) - max(0, 2 * (A[i] - i) - 1);        \\n\\treturn !inversionDiff;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113652,
                "title": "check-if-we-can-sort-the-array-with-only-local-inversions",
                "content": "Key insights:\\n\\n* every local inversion is also a global inversion\\n* so \"local inversions == global inversions\" can be interpreted as \"there are only local inversions\"\\n* if there are only local inversions, the array will be sorted after making all local inversions\\n* if there are inversions that are not local, the array won't be sorted after making all local inversions\\n\\n```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        N=len(A)\\n        for i in xrange(1, N):\\n            if A[i-1]==A[i]+1:\\n                A[i], A[i-1]=A[i-1], A[i]\\n            elif A[i-1]!=i-1:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        N=len(A)\\n        for i in xrange(1, N):\\n            if A[i-1]==A[i]+1:\\n                A[i], A[i-1]=A[i-1], A[i]\\n            elif A[i-1]!=i-1:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143472,
                "title": "global-and-local-inversions-short-easy-w-explanation-2-lines",
                "content": "***Solution - I (Global Inversions == Local Inversions):***\\n\\nWe can observe that **each local inversion is global inversion** (or local inversions are subset of global inversions). For both of them to be equal, **every global inversion must only be a local inversion**.\\n\\nA global inversion can be limited to be only a local inversion if for every `0 <= i < N`, **`abs(A[i] - i) <= 1`**.\\n\\n*Why?*\\nBecause, if `A[i] - i > 1`, we can have atleast 2 pairs `(i,j)` and `(i,k)` such that `A[i] > A[j] and A[i] > A[k]` but if every global inversion has to be only local inversion, we should only have gotten a single pair `(i,j)` (more specifically `(i,i+1)`) such that `A[i] > A[j]`. \\nEg. `[2,0,1]`, here `A[0]-0 = 2 > 1`, so we got two pairs of index (0,1) and (0,2) making global inversions != local inversions.\\n\\n----\\n\\n***C++***\\n```\\nbool isIdealPermutation(vector<int>& A) {        \\n\\tfor(int i = 0; i < size(A); i++) if(abs(A[i] - i) > 1) return false;\\n\\treturn true;\\n}\\n```\\n\\n***Python***\\n```\\ndef isIdealPermutation(self, A: List[int]) -> bool:\\n\\treturn not any(abs(Ai - i) > 1 for Ai, i in enumerate(A))\\n```\\n***Time Complexity :*** **`O(N)`**, where `N` is the size of given array.\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n<center>\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/71f85c39-24ba-48e3-92a5-c582f0629c22_1617622942.6370938.png />\\n</td></tr></table>\\n</center>\\n\\n----\\n----\\n\\n**Edit :**\\n\\nI had at first mentioned an approach that works but is not entirely correct. The solution was as below -\\n\\n```\\nbool isIdealPermutation(vector<int>& A) {\\n\\tint inversionDiff = 0;\\n\\t//                                                    Local Inversions  -  Global Inversions\\n\\tfor(int i = 0; i < size(A) - 1; i++) inversionDiff += (A[i] > A[i + 1]) - max(0, 2 * (A[i] - i) - 1);        \\n\\treturn !inversionDiff;\\n}\\n```\\n\\nI thought we could count global inversions using the formula  **`\\u03A3 (2*(A[i] - i) - 1)`**, for all `i`, where `A[i] > i` but it worked only for few permutations & not for all cases (Thanks @Tudor67 for bring to my attention).\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isIdealPermutation(vector<int>& A) {        \\n\\tfor(int i = 0; i < size(A); i++) if(abs(A[i] - i) > 1) return false;\\n\\treturn true;\\n}\\n```\n```\\ndef isIdealPermutation(self, A: List[int]) -> bool:\\n\\treturn not any(abs(Ai - i) > 1 for Ai, i in enumerate(A))\\n```\n```\\nbool isIdealPermutation(vector<int>& A) {\\n\\tint inversionDiff = 0;\\n\\t//                                                    Local Inversions  -  Global Inversions\\n\\tfor(int i = 0; i < size(A) - 1; i++) inversionDiff += (A[i] > A[i + 1]) - max(0, 2 * (A[i] - i) - 1);        \\n\\treturn !inversionDiff;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 242101,
                "title": "count-inversions",
                "content": "Count global inversions while merge sorting  (approach seen from other problems)\\n\\n```\\ndef mergesort(nums):\\n\\tmergesort(1st part of nums)\\n\\tmergesort(2st part of nums)\\n\\t\\n\\t##\\n\\there do anything but dont exceed  O(n)\\n\\t##\\n\\t\\n\\t\\n\\tmerge 2 parts and return\\n\\t\\n```\\n\\nI can do anything I want that does nt exceed O(n), before the final \\'merge\\' \\nhere it\\'s counting inversed couples (u,v) where v is in the second part and u in the first \\n\\nruntime equation if n ^ 2 is the cost of the \\'anything\\' : \\n```f(n) = 2 * f(n/2) + O(n^2) ```\\nthe solution is no longer an ```O(n*log(n))```\\n\\n\\n```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        loc = sum([1 for i in range(len(A)-1) if A[i] > A[i+1]] or [0])\\n        glo = self.f(A,0,len(A) - 1)\\n        return loc == glo\\n    \\n    # count inversions while merge sorting\\n    def f(self,nums,i,j):\\n        if i >= j:\\n            return 0\\n        \\n        med = ( i + j ) >> 1\\n        count = self.f(nums,i,med) + self.f(nums,med + 1,j)\\n        \\n        ii = i\\n        for k in range(med + 1, j + 1):\\n            while(ii <= med and nums[ii] < nums[k]):\\n                ii += 1\\n            count += (med - ii + 1)\\n                \\n        nums[i:j + 1] = sorted(nums[i:j + 1])\\n        return count\\n```\\n\\nBut problem statement feels like its not wanting that count of global inversions \\n\\nwe start by assuming, the array has only local inversions\\nin plain english \\'had the array only been inversed locally then blabla\\'\\nas we go in the linear pass, if there is any incoherence, we spot it and return False\\n\\n\\n**let a[i] > a[i+1]  be an inversion , in a exclusively local inversed array**\\n1. \\tI\\'m expecting ```a[i+1] == i and a[i] == i + 1```\\n1. \\tif no return false\\n1. \\tif yes swap them\\n\\n```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        for i in range(len(A)-1):\\n            if A[i] != i:\\n                if A[i+1] == i and A[i] == i+1:\\n                    A[i], A[i+1] = A[i+1], A[i]\\n                else:\\n                    return False\\n        return True\\n```\\n\\n\\n\\nor using while\\n\\n```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        i = 0 \\n        while(i < len(A) - 1):\\n            if A[i] == i:\\n                i +=1\\n            else:\\n                if A[i + 1] == i and A[i] == i + 1:\\n                    i += 2\\n                else:\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\ndef mergesort(nums):\\n\\tmergesort(1st part of nums)\\n\\tmergesort(2st part of nums)\\n\\t\\n\\t##\\n\\there do anything but dont exceed  O(n)\\n\\t##\\n\\t\\n\\t\\n\\tmerge 2 parts and return\\n\\t\\n```\n```f(n) = 2 * f(n/2) + O(n^2) ```\n```O(n*log(n))```\n```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        loc = sum([1 for i in range(len(A)-1) if A[i] > A[i+1]] or [0])\\n        glo = self.f(A,0,len(A) - 1)\\n        return loc == glo\\n    \\n    # count inversions while merge sorting\\n    def f(self,nums,i,j):\\n        if i >= j:\\n            return 0\\n        \\n        med = ( i + j ) >> 1\\n        count = self.f(nums,i,med) + self.f(nums,med + 1,j)\\n        \\n        ii = i\\n        for k in range(med + 1, j + 1):\\n            while(ii <= med and nums[ii] < nums[k]):\\n                ii += 1\\n            count += (med - ii + 1)\\n                \\n        nums[i:j + 1] = sorted(nums[i:j + 1])\\n        return count\\n```\n```a[i+1] == i and a[i] == i + 1```\n```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        for i in range(len(A)-1):\\n            if A[i] != i:\\n                if A[i+1] == i and A[i] == i+1:\\n                    A[i], A[i+1] = A[i+1], A[i]\\n                else:\\n                    return False\\n        return True\\n```\n```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        i = 0 \\n        while(i < len(A) - 1):\\n            if A[i] == i:\\n                i +=1\\n            else:\\n                if A[i + 1] == i and A[i] == i + 1:\\n                    i += 2\\n                else:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113648,
                "title": "java-o-n-solution-with-explanation",
                "content": "Because the count of local should <= count of global, all we care is when local < global happens.\\nThe difference between local and global is global also include nonadjacent i and j, so simplify the question to for every i, find in range 0 to i-2, see if there is a element larger than A[i], if it exist, we can return false directly. and we can maintain a variable max for the linear implementation. \\n```\\npublic boolean isIdealPermutation(int[] A) {\\n         int max = -1;\\n         for(int i = 0; i < A.length-2; i++) {\\n             max = Math.max(max, A[i]);\\n             if(max > A[i+2])\\n                 return false;\\n         }\\n         return true;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\npublic boolean isIdealPermutation(int[] A) {\\n         int max = -1;\\n         for(int i = 0; i < A.length-2; i++) {\\n             max = Math.max(max, A[i]);\\n             if(max > A[i+2])\\n                 return false;\\n         }\\n         return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1143432,
                "title": "python-o-n-math-solution-explained",
                "content": "One way to solve it is to just find all number of permutations either in `O(n^2)` bruteforce  or `O(n * log n)` using merge sort or Sorted List.\\n\\nHowever here we do not need to do it and we can solve it in `O(n)` time. Let us keep `level`, this is maximum among first `i-1` values. If we consider `i+1`-th number, than it need to be greater than `level` to return True. Indeed, if it is not the case, than we have at least one inversion which is not local, with gap `2` or more. So if at any moment this condition do not hold, we return `False` and finish our program.\\n\\nFrom the other point of view, if at each step we have `A[i+1] > max(A[0], A[1], ... A[i-1])`, it means that we can not have not-local inversions: for each two indexes `j` and `k`, such that `j >= k + 2`, we get `A[j] > A[k]`, which is exaclty definition of not-local inversion.\\n\\nSo, what we checked here is that our condition is **sufficient** and **enough** to check that number of global inversions is equal to number of local inverstions.\\n\\n#### Complexity\\nTime complexity is `O(n)` as we discussed, space complexity is `O(1)`.\\n\\n#### Code\\n\\n```pyton\\nclass Solution:\\n    def isIdealPermutation(self, A):\\n        level = -float(\"inf\")\\n        n = len(A)\\n        for i in range(1, n):\\n            if A[i] < level: \\n                return False\\n            else:\\n                level = max(level, A[i-1])\\n                \\n        return True\\n```\\n\\n#### Remark\\nWe can also notice that we could only place `i` at `A[i-1], A[i]` or `A[i+1]` and check it again in `O(n)` time.\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```pyton\\nclass Solution:\\n    def isIdealPermutation(self, A):\\n        level = -float(\"inf\")\\n        n = len(A)\\n        for i in range(1, n):\\n            if A[i] < level: \\n                return False\\n            else:\\n                level = max(level, A[i-1])\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746845,
                "title": "c-easy-to-understand-solution-complexity-o-n",
                "content": "Global inversion is either the element is moved by 1 or more posititons.\\nLocal Inversion is element is moved by 1 position only.\\n\\nSo we can see all Local Inversions would be part of Global Inversions.\\n\\nThe Idea is, If a number is either not at its position or shifted by one or more place from its intended place then its a global inversion which is not a local inversion. Hence we stop the loop there and return false.\\n\\n```\\nbool isIdealPermutation(vector<int>& A) {        \\n        for (int i = 0; i < A.size(); i ++)\\n        {\\n            if ((A[i] == i + 1) || (A[i] == i - 1) || (A[i] == i))\\n                continue;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n```\\n\\n**Example:** For Size of 4 elements, perfect Array is [0,1,2,3]\\n\\nNow if we shuffle like [0,2,1,3] then its shift of one index at Index 1,2 and hence it will be true.\\nWhereas if we shuffle like [0,2,3,1] then we are sure that 1 is shifted by more than one index and hence its a global inversion which isn\\'t local.",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nbool isIdealPermutation(vector<int>& A) {        \\n        for (int i = 0; i < A.size(); i ++)\\n        {\\n            if ((A[i] == i + 1) || (A[i] == i - 1) || (A[i] == i))\\n                continue;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113661,
                "title": "generalize-to-any-integer-array-not-necessarily-a-0-n-permutation",
                "content": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        // Check if local inversion is enough to sort the array.\\n        if (A.length <= 1) return true;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i-1] > A[i]) {\\n                // Swap if you see local inversions. \\n                int tmp = A[i];\\n                A[i] = A[i-1];\\n                A[i-1] = tmp;\\n                // The recently swapped element can no longer get swapped.\\n                // Otherwise we would be doing global swaps.\\n                i = i + 1;\\n            }\\n        }\\n        \\n        // check if the array is sorted afterward. \\n        int num = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < num) return false;\\n            num = A[i];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        // Check if local inversion is enough to sort the array.\\n        if (A.length <= 1) return true;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i-1] > A[i]) {\\n                // Swap if you see local inversions. \\n                int tmp = A[i];\\n                A[i] = A[i-1];\\n                A[i-1] = tmp;\\n                // The recently swapped element can no longer get swapped.\\n                // Otherwise we would be doing global swaps.\\n                i = i + 1;\\n            }\\n        }\\n        \\n        // check if the array is sorted afterward. \\n        int num = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < num) return false;\\n            num = A[i];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859589,
                "title": "c-o-n-solution",
                "content": "Runtime: 140 ms, faster than 36.03% of C++ online submissions for Global and Local Inversions.\\nMemory Usage: 35.9 MB, less than 39.62% of C++ online submissions for Global and Local Inversions.\\n\\n```\\nGlobal Inversion : A[i] > A[j] => 0<=i<j<N\\nLocal Inversion: A[i] > A[j] => j = i+1\\n\\nSo from above definition we see that all local inversion is global inversion but not vice versa always.\\nWe need to find if global inversion == local inversion. \\n\\nWhen this happens (global inversion == local inversion)? => Only when every global inversion is a local inversion\\n\\nWhen inversion happens ? => When an element is displaced from its original position in sorted array\\n\\nWhen an element is displaced 1 distance from its original position it makes only 1 global and local inversion ([1,0,2])\\n\\twhich makes global inversion == local inversion.\\n    \\nIf an element is displaced K>1 distance from its original position then it makes 1 local inversion but K global inversions ([1,2,0])\\n    which makes global inversion != local inversion. \\n\\nSo it is sufficient to find a global inversion which is not local inversion. \\nSo we need to find if any element is displaced more than 1 distance from its original position in sorted array.\\n\\nElement Displacement distance = abs(A[i] - i)\\n```\\n.\\n.\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n \\n        int n = A.size();\\n        for(int i=0;i<n;i++)\\n            if(abs(A[i]-i)>1) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nGlobal Inversion : A[i] > A[j] => 0<=i<j<N\\nLocal Inversion: A[i] > A[j] => j = i+1\\n\\nSo from above definition we see that all local inversion is global inversion but not vice versa always.\\nWe need to find if global inversion == local inversion. \\n\\nWhen this happens (global inversion == local inversion)? => Only when every global inversion is a local inversion\\n\\nWhen inversion happens ? => When an element is displaced from its original position in sorted array\\n\\nWhen an element is displaced 1 distance from its original position it makes only 1 global and local inversion ([1,0,2])\\n\\twhich makes global inversion == local inversion.\\n    \\nIf an element is displaced K>1 distance from its original position then it makes 1 local inversion but K global inversions ([1,2,0])\\n    which makes global inversion != local inversion. \\n\\nSo it is sufficient to find a global inversion which is not local inversion. \\nSo we need to find if any element is displaced more than 1 distance from its original position in sorted array.\\n\\nElement Displacement distance = abs(A[i] - i)\\n```\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n \\n        int n = A.size();\\n        for(int i=0;i<n;i++)\\n            if(abs(A[i]-i)>1) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143413,
                "title": "java-straightforward-with-fenwick-tree-clean-concise-o-nlogn",
                "content": "**Note**\\n- There are other solutions which will take `O(N)` in time and `O(1)` in space, but it\\'s a bit tricky to understand.\\n- In this solution, we will do straightforward to find number of local and global inversions like what problem said, which will take `O(NlogN)` in time and `O(N)` in space.\\n\\n**Algorithm**\\n- For `i` in `1..N-1`:\\n\\t- If `A[i-1] > A[i]`, then number of local inversions increase by 1.\\n\\t- number of global inversions += number of elements greater than A[i] so far\\n- Since value of elements < N, we can use [Fenwick Tree](https://cp-algorithms.com/data_structures/fenwick.html) structure, to get number of elements greater than an element in our tree so far, each operations will take `O(logN)` in time complexity.\\n\\n**Complexity:**\\n- Time: `O(NlogN)`, where `N` is number of elements in array `A`\\n- Space: `O(N)`\\n\\n**Similar problem using Fenwick Tree**\\n* [1395. Count Number of Teams](https://leetcode.com/problems/count-number-of-teams/discuss/554907)\\n\\n**Java ~ 7ms**\\n```java\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        int n = A.length;\\n        int[] BIT = new int[n+1]; // Binary Indexed Tree\\n        update(BIT, A[0]+1, 1);\\n        int local = 0, global = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (A[i] < A[i - 1]) local++;\\n            global += i - getPrefixSum(BIT, A[i]+1);\\n            update(BIT, A[i]+1, 1);\\n        }\\n        return local == global;\\n    }\\n    void update(int[] BIT, int index, int val) {\\n        while (index < BIT.length) {\\n            BIT[index] += val;\\n            index += index & -index;\\n        }\\n    }\\n    int getPrefixSum(int[] BIT, int index) {\\n        int sum = 0;\\n        while (index > 0) {\\n            sum += BIT[index];\\n            index -= index & -index;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nFeel free to comment your thought in this solution, thanks.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        int n = A.length;\\n        int[] BIT = new int[n+1]; // Binary Indexed Tree\\n        update(BIT, A[0]+1, 1);\\n        int local = 0, global = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (A[i] < A[i - 1]) local++;\\n            global += i - getPrefixSum(BIT, A[i]+1);\\n            update(BIT, A[i]+1, 1);\\n        }\\n        return local == global;\\n    }\\n    void update(int[] BIT, int index, int val) {\\n        while (index < BIT.length) {\\n            BIT[index] += val;\\n            index += index & -index;\\n        }\\n    }\\n    int getPrefixSum(int[] BIT, int index) {\\n        int sum = 0;\\n        while (index > 0) {\\n            sum += BIT[index];\\n            index -= index & -index;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990981,
                "title": "java-solution-easier-to-understand-o-n-my-easy-intution",
                "content": "Logic here is \\n* Intutuion is if we find any Global Inversion which is not Local Inversion then we return ```false```;\\n* Imagine we are at index **i** we have precomputed max of all the elements behind **i** i.e. ```beforeMax```.\\n* Now we check if ```beforeMax > A[i+1]``` then the current Inversion is a Global Inversion, Hence we return ```false```.\\n* Else we return ```true```. \\n\\n```\\npublic boolean isIdealPermutation(int[] A) {\\n        int beforeMax = Integer.MIN_VALUE;\\n        for(int i = 0; i<A.length-1; i++){\\n            if(beforeMax > A[i+1])return false;\\n            beforeMax = Math.max(A[i],beforeMax);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```false```\n```beforeMax```\n```beforeMax > A[i+1]```\n```false```\n```true```\n```\\npublic boolean isIdealPermutation(int[] A) {\\n        int beforeMax = Integer.MIN_VALUE;\\n        for(int i = 0; i<A.length-1; i++){\\n            if(beforeMax > A[i+1])return false;\\n            beforeMax = Math.max(A[i],beforeMax);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144413,
                "title": "c-beginner-friendly-solution-explained",
                "content": "This problem needed more thinking than the other one. I think solving this problem is not difficult, but within the time limit is the challenge. I got TLE so many times!\\nFinally, I figured :\\nHere, local inversion is subset of global inversion. We just need to find one element that is part of global inversion, but not part of local inversion. That is easy to do. For element located at ith position, start scanning from i+2th element and find one that is smaller than ith element. That will increase global inversion count. This approach will result in TLE.\\n\\nAnother very fast approach is:\\nFor any value located at ith index, must be either i, i-1 or i+1 in order to succeed.\\nIf the value is located anywhere else, that means there must be another number that is greater than this number.\\n\\nFor example, \\n[0,2,3,1] - 0 is located at 0, 2 is located at 1 (==1+1), 3 is located at 2(==2+1), and 1 is located at 3(==3-2)\\nLast element does not satisfy the condition, so it\\'s false;\\n\\n[0,2,1,3] return true;\\n\\n```\\nbool isIdealPermutation(vector<int>& A) {\\n        int i;\\n        for(i=0; i<A.size(); i++)\\n        {\\n            if(A[i]==i)     \\n                continue;\\n            else if(A[i] == i-1)\\n                    continue;\\n            else if(A[i] == i+1)\\n                    continue;\\n                else\\n                    return false;\\n        }\\n       return true;       \\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool isIdealPermutation(vector<int>& A) {\\n        int i;\\n        for(i=0; i<A.size(); i++)\\n        {\\n            if(A[i]==i)     \\n                continue;\\n            else if(A[i] == i-1)\\n                    continue;\\n            else if(A[i] == i+1)\\n                    continue;\\n                else\\n                    return false;\\n        }\\n       return true;       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1143380,
                "title": "c-simple-easy-to-understand-explained-4-short-line-solution",
                "content": "All local inversions are also global inversions.\\nSo we have to show that we have only local inversions.\\nLocal inversion is moving an element at most one place and not more from the original order. \\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++) {\\n            if (abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++) {\\n            if (abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144553,
                "title": "java-simple-and-easy-to-understand-solution-1-ms-faster-than-96-95-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        /* Approach\\n           1. Given  0 <= A[index] = A.length, \\n           2. To check the global and local same or not,\\n              just find is there any Absolute differnce of A[index] and index, \\n              is greater than 1 or not.\\n        */\\n        \\n        for(int i = 0; i < A.length; i++){\\n            if(Math.abs(A[i] - i) > 1) return false;\\n        }\\n        \\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        /* Approach\\n           1. Given  0 <= A[index] = A.length, \\n           2. To check the global and local same or not,\\n              just find is there any Absolute differnce of A[index] and index, \\n              is greater than 1 or not.\\n        */\\n        \\n        for(int i = 0; i < A.length; i++){\\n            if(Math.abs(A[i] - i) > 1) return false;\\n        }\\n        \\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113667,
                "title": "c-3-lines-o-n-o-1",
                "content": "To satisfy the global/local inversion equality, an element in the array should be larger than all previous elements, except the one right before it: A[i] > A[0]..A[i - 2]. \\n```\\nbool isIdealPermutation(vector<int>& A) {\\n    for (auto i = 2, m = A[0]; i < A.size(); m = max(m, A[i - 1]), ++i) \\n      if (A[i] < m) return false;\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isIdealPermutation(vector<int>& A) {\\n    for (auto i = 2, m = A[0]; i < A.size(); m = max(m, A[i - 1]), ++i) \\n      if (A[i] < m) return false;\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346027,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            if abs(nums[i]-i)>1:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            if abs(nums[i]-i)>1:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179097,
                "title": "three-different-solutions-easy-understanding-c",
                "content": "**Approach 1: Naive (Two for loop for checking global inversion) => Time Complexity O(n^2)  [Not Accepted] [Time Limit Exceeded]**\\n**Approach 2: Naive (Using Merge Sort) => Time Complexity O(nlogn) [Accepted]**\\n**Approach 3: Using absolute value for comparing => Time Complexity O(n) [Accepted]**\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        \\n        \\n        // Using Two For Loop => Time Complexity O(n^2)  [Not Accepted] [Time Limit Exceeded]\\n        \\n        int global=0,local=0;\\n         for(int i=0;i<nums.size()-1;i++)\\n        {\\n            \\n                if(nums[i]>nums[i+1])local++;\\n           \\n        }\\n       /* for(int i=0;i<nums.size()-1;i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])global++;\\n            }\\n        }\\n        \\n        return global==local;*/\\n        \\n         // Using Merge Sort => Time Complexity O(nlogn) [Accepted]\\n        \\n        merge_sort(nums,0,nums.size()-1);\\n        return merge_global==local;\\n        \\n          //Using absolute value => Time Complexity O(n) [Accepted]\\n        \\n       for(int i = 0 ; i < nums.size() ; i++){\\n            if(abs(nums[i] - i) > 1)return false;        \\n        }\\n        return true;\\n    }\\n      long long merge_global = 0;\\n        void merge(vector<int>& arr, int s, int e) {\\n        int mid = s + (e-s)/2;\\n        int l1 = mid - s + 1;\\n        int l2 = e - mid;\\n        int count = 0;\\n        // creating new array;\\n        int first[l1];\\n        int second[l2];\\n\\n        //copy values\\n        int mainIndex = s;\\n        for ( int i = 0; i<l1; i++){\\n            first[i] = arr[mainIndex++];\\n        }\\n\\n        mainIndex = mid + 1;\\n        for ( int i = 0; i<l2; i++){\\n            second[i] = arr[mainIndex++];\\n        }\\n\\n        // sorting the array\\n        int index1 = 0;\\n        int index2 = 0;\\n        mainIndex = s;\\n        while(index1 < l1 && index2 < l2){\\n            if(first[index1]<=second[index2]){\\n                arr[mainIndex++] = first[index1++];\\n            }\\n            else{\\n               merge_global += (l1 - index1);\\n                arr[mainIndex++] = second[index2++];\\n            }\\n        }\\n\\n        // check individually\\n        while(index1 < l1) {\\n            arr[mainIndex++] = first[index1++];\\n        }\\n        while(index2 < l2) {\\n            arr[mainIndex++] = second[index2++];\\n        }\\n\\n\\n}\\nvoid merge_sort(vector<int>& arr, long long s, long long e) {\\n    if(s>=e)\\n        return;\\n    int mid = s + (e-s)/2;\\n    // divide for left array\\n    merge_sort(arr,s,mid);\\n\\n    //divide for right array\\n    merge_sort(arr,mid+1,e);\\n\\n    // merge array\\n    merge(arr,s,e);\\n\\n\\n}\\n};\\n```\\n**Kindly upvote, if you like the solution :)**",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        \\n        \\n        // Using Two For Loop => Time Complexity O(n^2)  [Not Accepted] [Time Limit Exceeded]\\n        \\n        int global=0,local=0;\\n         for(int i=0;i<nums.size()-1;i++)\\n        {\\n            \\n                if(nums[i]>nums[i+1])local++;\\n           \\n        }\\n       /* for(int i=0;i<nums.size()-1;i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])global++;\\n            }\\n        }\\n        \\n        return global==local;*/\\n        \\n         // Using Merge Sort => Time Complexity O(nlogn) [Accepted]\\n        \\n        merge_sort(nums,0,nums.size()-1);\\n        return merge_global==local;\\n        \\n          //Using absolute value => Time Complexity O(n) [Accepted]\\n        \\n       for(int i = 0 ; i < nums.size() ; i++){\\n            if(abs(nums[i] - i) > 1)return false;        \\n        }\\n        return true;\\n    }\\n      long long merge_global = 0;\\n        void merge(vector<int>& arr, int s, int e) {\\n        int mid = s + (e-s)/2;\\n        int l1 = mid - s + 1;\\n        int l2 = e - mid;\\n        int count = 0;\\n        // creating new array;\\n        int first[l1];\\n        int second[l2];\\n\\n        //copy values\\n        int mainIndex = s;\\n        for ( int i = 0; i<l1; i++){\\n            first[i] = arr[mainIndex++];\\n        }\\n\\n        mainIndex = mid + 1;\\n        for ( int i = 0; i<l2; i++){\\n            second[i] = arr[mainIndex++];\\n        }\\n\\n        // sorting the array\\n        int index1 = 0;\\n        int index2 = 0;\\n        mainIndex = s;\\n        while(index1 < l1 && index2 < l2){\\n            if(first[index1]<=second[index2]){\\n                arr[mainIndex++] = first[index1++];\\n            }\\n            else{\\n               merge_global += (l1 - index1);\\n                arr[mainIndex++] = second[index2++];\\n            }\\n        }\\n\\n        // check individually\\n        while(index1 < l1) {\\n            arr[mainIndex++] = first[index1++];\\n        }\\n        while(index2 < l2) {\\n            arr[mainIndex++] = second[index2++];\\n        }\\n\\n\\n}\\nvoid merge_sort(vector<int>& arr, long long s, long long e) {\\n    if(s>=e)\\n        return;\\n    int mid = s + (e-s)/2;\\n    // divide for left array\\n    merge_sort(arr,s,mid);\\n\\n    //divide for right array\\n    merge_sort(arr,mid+1,e);\\n\\n    // merge array\\n    merge(arr,s,e);\\n\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143914,
                "title": "javascript-easy-to-understand-2-solutions",
                "content": "After reading the description, the most important thing is the definition of global inversions and local inversions.\\nAccording to the definition, we could find out this easily that every local inversion must also be a global inversion.\\nSo, the key point is that could we find a global inversion that is not a local inversion, which means could we find `i` and `j` that `j - i > 1` and `A[i] < A[j]`.\\n\\n## SOLUTION 1\\n\\nWe just need to traversal the `A` and find out if there are `i` and `j` fit what we want above.\\n\\n```js\\nconst isIdealPermutation = (A) => {\\n  let max = A[0];\\n  for (let i = 1; i < A.length - 1; ++i) {\\n    if (A[i + 1] < max) return false;\\n    A[i] > max && (max = A[i]);\\n  }\\n  return true;\\n};\\n```\\n\\n## SOLUTION 2\\n\\nThis is another strategy.\\nFor this problem, the array `A` is a permutation of `[0, 1, ..., N - 1]`, which means there\\'s no duplicate numbers.\\nSo, for each number, if it\\'s been swaped to another place whose index offsets more than 1 to the origin index finally, then there must a global inversion that is not a local inversion.\\n\\nSo, we could have this code to solve it easily.\\n\\n```js\\nconst isIdealPermutation = (A) => {\\n  for (let i = 0; i < A.length; ++i) {\\n    const tmp = A[i] - i;\\n    if (tmp > 1 || tmp < -1) return false;\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst isIdealPermutation = (A) => {\\n  let max = A[0];\\n  for (let i = 1; i < A.length - 1; ++i) {\\n    if (A[i + 1] < max) return false;\\n    A[i] > max && (max = A[i]);\\n  }\\n  return true;\\n};\\n```\n```js\\nconst isIdealPermutation = (A) => {\\n  for (let i = 0; i < A.length; ++i) {\\n    const tmp = A[i] - i;\\n    if (tmp > 1 || tmp < -1) return false;\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 977479,
                "title": "c-very-simple-o-n-intuitive-code",
                "content": "The logic behind this O(N) approach is that we are asked only whether global and local inversions are equal or not. So, basically we have to check if there is any single non-adjacent inversion pair exist or not. if exists , return simply ```false``` . Otherwise return ```true``` and voila , we are done !\\n\\nHope it helps. Kindly upvote my discussion. Thanks :)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int n = A.size();\\n        for(int i=0;i<n;i++)\\n            if(abs(A[i]-i)>1) return false;\\n         return true;  \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```false```\n```true```\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int n = A.size();\\n        for(int i=0;i<n;i++)\\n            if(abs(A[i]-i)>1) return false;\\n         return true;  \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297445,
                "title": "java-2ms-common-solution-with-explanation",
                "content": "\\nApparently, the local inversion is a special case of global inversion. If we can find a global inversion which is not local inversion, then the permutation is not ideal. In other words, we need to check whether there exists i and j where **j - i > 1** and **A[i] > A[j]**. Traverse the array from left to right, record the **max** value, if max > A[i + 2] then the permutation is not ideal. \\n\\n```\\npublic boolean isIdealPermutation(int[] A) {\\n    int max = 0;\\n    for(int i = 0; i < A.length - 2; i++) {\\n        max = Math.max(A[i], max);\\n        if( A[i + 2] < max )\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isIdealPermutation(int[] A) {\\n    int max = 0;\\n    for(int i = 0; i < A.length - 2; i++) {\\n        max = Math.max(A[i], max);\\n        if( A[i + 2] < max )\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497431,
                "title": "check-this-if-you-get-tle-by-merge-sort-2-solutions-merge-sort-and-intuitive",
                "content": "**If you got TLE using merge sort, then do not worry**, most likely it is because you haven\\'t declared the vector you are using for merging (b vector in my case) globally.\\n\\n**Declare this vector/array globally**, else it will be created in every merge call which will end up increasing the time complexity, hence TLE.\\n**Also declare your global counter globally or pass it via reference to avoid TLE**\\n\\nAlso, declare the data type as **long long int** to prevent any overflow errors.\\n```\\nclass Solution{\\npublic:\\n    long long int global=0;\\n    long long int b[500000];\\n    void merge(vector <int> &arr, int l, int mid, int r)\\n    {\\n        int i=l;\\n        int j=mid+1;\\n        int k=l;\\n        \\n        while(i<=mid && j<=r)\\n        {\\n            if(arr[i]<=arr[j])\\n            {\\n                b[k]=arr[i];\\n                k++;\\n                i++;\\n            }\\n            else\\n            {\\n                b[k]=arr[j];\\n                k++;\\n                j++;\\n                global+=(mid+1-i);\\n            }\\n        }\\n        if(i>mid)\\n         {\\n             while(j<=r)\\n             {\\n                 b[k]=arr[j];\\n                 k++;\\n                 j++;\\n             }\\n         }\\n         else if(j>r)\\n         {\\n             while(i<=mid)\\n             {\\n                 b[k]=arr[i];\\n                 k++;\\n                 i++;\\n             }\\n         }\\n         \\n         for(int p=l; p<k; p++)\\n         {\\n             arr[p]=b[p];\\n         }\\n    }\\n    void mergesort(vector <int> &arr, int l, int r)\\n    {\\n        int mid=(l+r)/2;\\n        if(l<r)\\n        {\\n            mergesort(arr, l, mid);\\n            mergesort(arr, mid+1, r);\\n            merge(arr, l, mid, r);\\n        }\\n    }\\n    \\n    bool isIdealPermutation(vector<int>& nums) \\n    {        \\n        int local=0;\\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i] > nums[i + 1])\\n                local++;\\n        }\\n        \\n        mergesort(nums, 0, nums.size()-1); \\n        cout<<global<<\" \"<<local<<endl;\\n        \\n        return local==global;\\n    }\\n};\\n```\\n\\n\\n**Now let us come to the intuitive solution**\\nThe crucial thing to bserve here to build the intuition is that the elements are in the range [0, n-1]\\n\\nSo, arr[i]-i basically gives us the number of elements less than arr[i] that are to the right of arr[i] (if arr[i]-i is positive), else vice versa.\\nSo if arr[i]-i==1, then there\\'s only one elements lesser than arr[i] to it\\'s right, which is perfectly alright as we can cover it using the local inversion.\\n\\n**However, if arr[i]-i>1, then it cannot be nullified using a local inversion as a local inversion can nullify only 1 instance of a global inversion. arr[i]-i>1 means there are more than global inversions.**\\nHence, if this condition occurs, we will never be able to return a true answer.\\nThe negative case, i.e. arr[i]-i<-1 can also be explained similarly.\\n\\n**You can do it simply by:**\\n```\\nbool isIdealPermutation(vector<int> & arr)\\n{\\n\\tfor (int i = 0;  i < arr.size(); i++) \\n            if (abs(arr[i] - i) > 1) \\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    long long int global=0;\\n    long long int b[500000];\\n    void merge(vector <int> &arr, int l, int mid, int r)\\n    {\\n        int i=l;\\n        int j=mid+1;\\n        int k=l;\\n        \\n        while(i<=mid && j<=r)\\n        {\\n            if(arr[i]<=arr[j])\\n            {\\n                b[k]=arr[i];\\n                k++;\\n                i++;\\n            }\\n            else\\n            {\\n                b[k]=arr[j];\\n                k++;\\n                j++;\\n                global+=(mid+1-i);\\n            }\\n        }\\n        if(i>mid)\\n         {\\n             while(j<=r)\\n             {\\n                 b[k]=arr[j];\\n                 k++;\\n                 j++;\\n             }\\n         }\\n         else if(j>r)\\n         {\\n             while(i<=mid)\\n             {\\n                 b[k]=arr[i];\\n                 k++;\\n                 i++;\\n             }\\n         }\\n         \\n         for(int p=l; p<k; p++)\\n         {\\n             arr[p]=b[p];\\n         }\\n    }\\n    void mergesort(vector <int> &arr, int l, int r)\\n    {\\n        int mid=(l+r)/2;\\n        if(l<r)\\n        {\\n            mergesort(arr, l, mid);\\n            mergesort(arr, mid+1, r);\\n            merge(arr, l, mid, r);\\n        }\\n    }\\n    \\n    bool isIdealPermutation(vector<int>& nums) \\n    {        \\n        int local=0;\\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            if(nums[i] > nums[i + 1])\\n                local++;\\n        }\\n        \\n        mergesort(nums, 0, nums.size()-1); \\n        cout<<global<<\" \"<<local<<endl;\\n        \\n        return local==global;\\n    }\\n};\\n```\n```\\nbool isIdealPermutation(vector<int> & arr)\\n{\\n\\tfor (int i = 0;  i < arr.size(); i++) \\n            if (abs(arr[i] - i) > 1) \\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\n\\treturn true;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1975580,
                "title": "c-easy-solution-beginner-s-friendly",
                "content": "**PLEASE UPVOTE THE SOLUTION\\nDONOT JUST DOWNVOTE IT ONLY BECAUSE YOU DONOT UNDERSTAND IT.\\nUPVOTE\\'S HELP PEOPLE LIKE US TO CREATE MORE SUCH CONTENT.**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            if(i-nums[i]>1 || i-nums[i]<-1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            if(i-nums[i]>1 || i-nums[i]<-1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370931,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        for(int i=0;i<nums.length;i++)\\n            if(Math.abs(nums[i] - i) > 1) \\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        for(int i=0;i<nums.length;i++)\\n            if(Math.abs(nums[i] - i) > 1) \\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143972,
                "title": "beats-95-very-smart-solution-and-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n\\n        int flg=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(abs(A[i]-i)>=2)\\n                flg=1;\\n        }\\n        if(flg) return false;\\n        else return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n\\n        int flg=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(abs(A[i]-i)>=2)\\n                flg=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1012067,
                "title": "python-o-n-using-index-to-record-the-global-inversion-at-each-index",
                "content": "```py\\n\\'\\'\\'\\nw: it is trivial to get the number of local inversion,\\n    since we only need to compare two neighbours, the \\n    key is to find the number of global inversion.\\n\\tAGAIN, for probelm like number in a array of length N is 0,...,N-1\\n\\ta natural idea is to think about adding more meaningful things to the index, \\n\\twhich help to reduce the space\\nh: note that the number in the arr of length n is 0,1,...,n-1\\n    A key observation is:\\n    At current index,\\n      1) if num > num\\'s index: \\n          currnet global inversion = num - num\\'s index\\n          this is how many numbers after current index is smaller\\n          than the number at current index\\n      2) if num < num\\'s index\\n          current global inversion = num\\'s index - num -1\\n          this is how many numbers before current index is larger\\n          than the number at current index, the reason we subtract 1\\n          is that we have one duplicated count in 1)\\n          e.g. : [2, 1, 0] when we at index 0, we include the \\n          instance 2>0, so when at at index 2, we should not include 0<2.\\n    then everything is trivial now\\n\\t\\nO(N) in time and O(1) in space\\n\\'\\'\\'\\n\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        numLoc = 0\\n        numGlo = 0\\n\\n        for idx, num in enumerate(A):\\n            if num > idx:\\n                numGlo += (num-idx)\\n            elif num < idx:\\n                numGlo += (idx-num-1)\\n            \\n            if idx < len(A)-1 and num > A[idx+1]:\\n                numLoc += 1\\n        \\n        print(numLoc, numGlo)\\n        return numLoc == numGlo\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: it is trivial to get the number of local inversion,\\n    since we only need to compare two neighbours, the \\n    key is to find the number of global inversion.\\n\\tAGAIN, for probelm like number in a array of length N is 0,...,N-1\\n\\ta natural idea is to think about adding more meaningful things to the index, \\n\\twhich help to reduce the space\\nh: note that the number in the arr of length n is 0,1,...,n-1\\n    A key observation is:\\n    At current index,\\n      1) if num > num\\'s index: \\n          currnet global inversion = num - num\\'s index\\n          this is how many numbers after current index is smaller\\n          than the number at current index\\n      2) if num < num\\'s index\\n          current global inversion = num\\'s index - num -1\\n          this is how many numbers before current index is larger\\n          than the number at current index, the reason we subtract 1\\n          is that we have one duplicated count in 1)\\n          e.g. : [2, 1, 0] when we at index 0, we include the \\n          instance 2>0, so when at at index 2, we should not include 0<2.\\n    then everything is trivial now\\n\\t\\nO(N) in time and O(1) in space\\n\\'\\'\\'\\n\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        numLoc = 0\\n        numGlo = 0\\n\\n        for idx, num in enumerate(A):\\n            if num > idx:\\n                numGlo += (num-idx)\\n            elif num < idx:\\n                numGlo += (idx-num-1)\\n            \\n            if idx < len(A)-1 and num > A[idx+1]:\\n                numLoc += 1\\n        \\n        print(numLoc, numGlo)\\n        return numLoc == numGlo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131554,
                "title": "python-3-5-lines-easy-and-clear-solutions-84-ms-beats-94",
                "content": "Each num should be located correctly only if it\\'s located in [num -1, num+1] index range.\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A):\\n        for i, num in enumerate(A):\\n            if not (i - 1 <= num <= i + 1): return False\\n        return True\\n```\\nOr just find the first occurence of globally inversed but not locally.\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A):\\n        mx = 0\\n        for i in range(len(A) - 2):\\n            if A[i] > mx: mx = A[i]\\n            if A[i + 2] < mx: return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, A):\\n        for i, num in enumerate(A):\\n            if not (i - 1 <= num <= i + 1): return False\\n        return True\\n```\n```\\nclass Solution:\\n    def isIdealPermutation(self, A):\\n        mx = 0\\n        for i in range(len(A) - 2):\\n            if A[i] > mx: mx = A[i]\\n            if A[i + 2] < mx: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244541,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833250,
                "title": "proof-by-construction",
                "content": "**Approach (Proof by Construction)**\\nSuppose we have a ***sorted array*** where all the elements are in the range [0...n-1] and each element is distinct\\n```\\n0 1 2 3 ... n-1\\n```\\nthen we can note that each element satisfies the condition ```abs(i - a[i]) = 0; i >= 0, i < n``` \\n\\nNow, we will make modifications to the our sorted array as shown:-\\n**Note** - Both are separate modifications made to the original array.\\n\\n**Case 1** - Introducing atleast 1 non-local global inversion\\nNow, we will introduce atleast 1 non-local global inversion to this array.\\n\\nTo do this we will swap two elements a[i] and a[j] where :-\\n1. 0 <= j < i < n \\n2. i >= j + 2 \\n\\nand since the array is sorted we already know that a[i] > a[j].\\n\\n**Note -** For a simplified approach, use i = j + 2.\\n\\nOur array will tranform from \\n```\\nX X X X a[j] X X X a[i] X X X X X\\n```\\nto\\n```\\nX X X X a[i] X X X a[j] X X X X X\\n|______|    |_____|    |________|\\n   (1)        (2)          (3)\\n```\\nWe can observe the following,\\n(1)... all elements are less than both a[i] and a[j]\\n(3)... all elements are greater than both a[i] and a[j]\\n(2)... all elements are less than a[i] and greater than a[j]\\n\\nProperty (3) results in non-local global inversions combined with a[i] > a[j]\\n\\nNow, the following conditions will hold true,\\n1. |a[i] - j| >= 2 since now, a[i] is at index j\\n2. |a[j] - i| >= 2\\n\\n**Case 2** - Introducing only local inversions\\nNow, we will introduce 1 local inversion (which is also an global inversion) to the original sorted array.\\n\\nWe will swap any two adjacent elements a[i] and a[j] such that\\n1. 0 <= i < j < n and \\n2. abs(i - j) = 1 since i and j are adjacent\\n\\nOur array will tranform from \\n```\\nX X X X X X X a[i] a[j] X X X X X\\n```\\nto\\n```\\nX X X X X X X a[j] a[i] X X X X X\\n|____________|         |________|\\n     (1)                  (2)\\n```\\n(1)... all elements are less than both a[i] and a[j]\\n(2)... all elements are greater than both a[i] and a[j]\\n\\nThe properties (1) and (2) ensure that there are no non-local global inversions.\\n\\nNow, the following conditions will hold true,\\n1. |a[i] - j| = 1\\n2. |a[j] - i| = 1\\n\\nThe only inversion in this case is the pair (a[i], a[j]) which is a global inversion as well.\\n\\nAnd hence, we can conclude the following:-\\n1. If number of of local inversion and number of global inversions is equal then all the elements will hold the condition abs(a[i] - i) <= 1 true, if the array is sorted then both global inversions as well as local inversions is 0. \\n2. Otherwise, if number of of local inversion and number of global inversions is not equal then some of the elements will hold the condition abs(a[i] - i) >= 2 true.\\n\\n**Code**\\n```cpp\\nbool isIdealPermutation(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\t\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tif(abs(nums[i] - i) > 1)\\n\\t\\t\\treturn false;\\n\\t}\\n\\t\\t\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n0 1 2 3 ... n-1\\n```\n```abs(i - a[i]) = 0; i >= 0, i < n```\n```\\nX X X X a[j] X X X a[i] X X X X X\\n```\n```\\nX X X X a[i] X X X a[j] X X X X X\\n|______|    |_____|    |________|\\n   (1)        (2)          (3)\\n```\n```\\nX X X X X X X a[i] a[j] X X X X X\\n```\n```\\nX X X X X X X a[j] a[i] X X X X X\\n|____________|         |________|\\n     (1)                  (2)\\n```\n```cpp\\nbool isIdealPermutation(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\t\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tif(abs(nums[i] - i) > 1)\\n\\t\\t\\treturn false;\\n\\t}\\n\\t\\t\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1509656,
                "title": "o-n-and-o-nlogn-two-c-solutions",
                "content": "1. O(NlogN) solution would be finding both local and global inversions. Local inversions can be found in linear time. Global inversions can be found by tweaking the classic mergesort algorithm.\\n\\n```\\nint global = 0;\\n\\n    void merge(vector<int>&v, int l, int mid, int r)\\n    {\\n        vector<int> left;\\n        vector<int> right;\\n        for(int i=l;i<=mid;i++)\\n            left.push_back(v[i]);\\n        for(int i=mid+1;i<=r;i++)\\n            right.push_back(v[i]);\\n        \\n        int i=0,j=0,k=l;\\n        \\n        while(i<left.size() && j<right.size())\\n        {\\n            if(left[i] <= right[j])\\n                v[k++] = left[i++];\\n            else\\n            {\\n                global+=left.size()-i;\\n                v[k++] = right[j++];\\n            }\\n        }\\n        while(i<left.size())\\n            v[k++] = left[i++];\\n        while(j<right.size())\\n            v[k++] = right[j++];\\n    }\\n    \\n    void mergesort(vector<int> &v, int l, int r)\\n    {\\n        if(l>=r)\\n            return;\\n        int mid = l+(r-l)/2;\\n        mergesort(v,l,mid);\\n        mergesort(v,mid+1,r);\\n        merge(v,l,mid,r);\\n    }\\n    \\n    bool isIdealPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int local = 0;\\n        for(int i=0;i<n-1;i++)\\n            if(nums[i] > nums[i+1])\\n                local++;\\n        global = 0;\\n        mergesort(nums,0,n-1);\\n        cout<<global<<endl;\\n        if(global == local) return 1;\\n        return 0;\\n    }\\n```\\nThis solution doesn\\'t get accepted because we need not find the global inversions and instead we can solve the question in O(N) time complexity.\\n2. The logic is that there should only exist local inversions in the array. Global inversions apart from local inversions should be zero. That means an element at a particular position should only be at max 1 position away from it\\'s position in the sorted array. If it is 2 or more positions away from it\\'s position in the sorted array, that leads to existence of a global inversion which is not a local inversion. We should also make use of the fact that elements are in the range 0 to n-1. So abs(nums[i]-i) can be 1 at maximum, else we return 0.\\n\\n```\\nbool isIdealPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(abs(nums[i]-i) > 1)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint global = 0;\\n\\n    void merge(vector<int>&v, int l, int mid, int r)\\n    {\\n        vector<int> left;\\n        vector<int> right;\\n        for(int i=l;i<=mid;i++)\\n            left.push_back(v[i]);\\n        for(int i=mid+1;i<=r;i++)\\n            right.push_back(v[i]);\\n        \\n        int i=0,j=0,k=l;\\n        \\n        while(i<left.size() && j<right.size())\\n        {\\n            if(left[i] <= right[j])\\n                v[k++] = left[i++];\\n            else\\n            {\\n                global+=left.size()-i;\\n                v[k++] = right[j++];\\n            }\\n        }\\n        while(i<left.size())\\n            v[k++] = left[i++];\\n        while(j<right.size())\\n            v[k++] = right[j++];\\n    }\\n    \\n    void mergesort(vector<int> &v, int l, int r)\\n    {\\n        if(l>=r)\\n            return;\\n        int mid = l+(r-l)/2;\\n        mergesort(v,l,mid);\\n        mergesort(v,mid+1,r);\\n        merge(v,l,mid,r);\\n    }\\n    \\n    bool isIdealPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int local = 0;\\n        for(int i=0;i<n-1;i++)\\n            if(nums[i] > nums[i+1])\\n                local++;\\n        global = 0;\\n        mergesort(nums,0,n-1);\\n        cout<<global<<endl;\\n        if(global == local) return 1;\\n        return 0;\\n    }\\n```\n```\\nbool isIdealPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(abs(nums[i]-i) > 1)\\n                return 0;\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1155371,
                "title": "java-clean-concise-code-o-n-time-100-faster-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (Math.abs (nums[i] - i) > 1) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (Math.abs (nums[i] - i) > 1) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143366,
                "title": "global-and-local-inversions-simple-solution-3-lines-of-code-explained",
                "content": "The important point to be considered is \"**ALL LOCAL INVERSIONS ARE GLOBAL INVERSIONS BUT ALL GLOBAL INVERSIONS ARE NOT LOCAL INVERSIONS**\". \\nSo, both are equal if and only **array contains only local inversions**.\\n-> for any `i if arr[i] > arr[i+1`], we consider it as local inversion. So, we check at every index the absolute difference of `arr[i] and i`. \\n-> If `abs(arr[i]-i) > 1`, then it is not a local Inversion, So, In this case Global Inversions are more than local Inversions. so we direcly `return false`.\\n\\n**Do Upvote** if you like the explanation!!\\n```\\nbool isIdealPermutation(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++)\\n            if(abs(arr[i]-i)>1) return false;\\n        return true;\\n    }\\n```\\nAny other ways to solve ?? Thoughts?? Comment down below !!",
                "solutionTags": [],
                "code": "```\\nbool isIdealPermutation(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++)\\n            if(abs(arr[i]-i)>1) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698493,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        /*All local inversions are global inversions but vice versa is not true\\n        thus if difference between idx & value at idx (i.e. A[idx]) is greater than 1\\n        then its global inversion which is not local */\\n        \\n        for(int i=0;i<A.length;i++){\\n            if(Math.abs(i-A[i])>1)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        /*All local inversions are global inversions but vice versa is not true\\n        thus if difference between idx & value at idx (i.e. A[idx]) is greater than 1\\n        then its global inversion which is not local */\\n        \\n        for(int i=0;i<A.length;i++){\\n            if(Math.abs(i-A[i])>1)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564900,
                "title": "c-98-time-100-memory-with-description",
                "content": "```\\nclass Solution {\\npublic:    \\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++)\\n            if (abs(A[i] - i) > 1)\\n                return false;\\n        return true;\\n    }\\n};\\n```\\nThe idea is that if we move any number to distance more than 1 from its original position, we increase local inversions by one and global inversions by more than one, breaking the balance.\\nHence, we get ideal permutation only by swapping adjacent elements from original permutation (e. g. 0 1 2 3 4 ... n)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++)\\n            if (abs(A[i] - i) > 1)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488894,
                "title": "java-o-n-solution-5-lines-beats-100-1ms-detailed-explanation",
                "content": "### Array One Pass - O(n)\\n![image](https://assets.leetcode.com/users/thisisnsh/image_1579853304.png)\\n\\n\\n```\\npublic boolean isIdealPermutation(int[] A) {\\n        for(int i=0;i<A.length;i++) {\\n            if (i-A[i]>1 || i-A[i]<-1) \\n                return false;\\n        }\\n        return true;\\n    }\\n```\\n\\n**Basic Approach**\\nLet the basic permutation be: `0 1 2 3 4 5`\\n\\n* Local is Global but Global is not local. \\n* So check if there exist a global which is not a local. That is find an element such that `A[i]>A[j]` and `j>i+1`. Why this? because if `j>=i+1` then for `j=i+1` we will get a local. But we want to look for a global which is not a local. \\n* Lets take `i=2` so `A[2]=2` in basic permutation.\\n* Shift `A[2]` by 1 position to left so we can get `0 2 1 3 4 5` or `1 2 0 3 4 5`   **(#1 Check Updates)**\\n* Shift `A[2]` by 1 position to right so we can get `0 1 3 2 4 5` or `0 1 4 2 3 5` ..... or more.  **(#2 Check Updates)**   \\n* There is no chance we can can get a global which not a local, as we shift the position by 1 only and global==local. (Try Yourself!)\\n* If we shift `A[2]` by 2 positions to left or right we can get `0 1 3 4 2 5` etc. so `3>2` and is global but is not local. \\n* So having this same approach, we solve the problem.  \\n\\n**Explanation Line by Line**\\n1. Loop from `i=0` to `i=A.length-1`\\n2. If the current element `A[i]` is shifted by 2 positions to left or right return false.\\n3. Return True.\\n\\n**Updates**\\nSuggested by varunarora1687\\n1. `1 2 0 3 4 5` is a wrong example I took, as A[0]==0 has moved 2 places to the right.\\n2. `0 1 4 2 3 5` is a wrong example I took, as A[4]==4 has moved 2 places to the left.\\n\\nThanks for reading. Feedback & doubts are welcomed.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isIdealPermutation(int[] A) {\\n        for(int i=0;i<A.length;i++) {\\n            if (i-A[i]>1 || i-A[i]<-1) \\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3473298,
                "title": "priorityqueue-space-optimized-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```\\nGlobal Inversion : 0 <= i < j < n   and   nums[i] > nums[j]\\nLocal Inversion : 0 <= i < n - 1    ans   nums[i] > nums[i + 1]\\n```\\n\\nIt means that, if there exist any element at left of current index which is greater than ```nums[i + 1]```, then Global inversion will be greater than Local Inversion. \\n\\nTherefore, \\n```\\nGlobalInversion != LocalInversion\\n```\\nElse  \\n```\\nGlobalInversion == LocalInversion\\n```\\nSo, we will store elements in PriorityQueue in decreasing order and traverse linearly while comparing to peek() element of PriorityQueue.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> (b - a));\\n        for (int i = 0; i < n - 1; i++) {\\n            int cur = nums[i];\\n            int next = nums[i + 1];\\n            if (!pq.isEmpty()) {\\n                //If there exist any element at left which is greater than next then GlobalInversion > LocalInversion\\n                if (pq.peek() > next)\\n                    return false;\\n            }\\n            pq.add(cur);\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# Without Using Extra Space\\n*Space Optimized Code*\\n\\nInstead of storing elements in priorityQueue, we will keep track of the maximum element at left of ith index of the array.\\n\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int n = nums.length;\\n        int max = -1;\\n        for (int i = 0; i < n - 1; i++) {\\n            int cur = nums[i];\\n            int next = nums[i + 1];\\n            if (max > next)\\n                return false;\\n            max = Math.max(max, cur);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nGlobal Inversion : 0 <= i < j < n   and   nums[i] > nums[j]\\nLocal Inversion : 0 <= i < n - 1    ans   nums[i] > nums[i + 1]\\n```\n```nums[i + 1]```\n```\\nGlobalInversion != LocalInversion\\n```\n```\\nGlobalInversion == LocalInversion\\n```\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> (b - a));\\n        for (int i = 0; i < n - 1; i++) {\\n            int cur = nums[i];\\n            int next = nums[i + 1];\\n            if (!pq.isEmpty()) {\\n                //If there exist any element at left which is greater than next then GlobalInversion > LocalInversion\\n                if (pq.peek() > next)\\n                    return false;\\n            }\\n            pq.add(cur);\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int n = nums.length;\\n        int max = -1;\\n        for (int i = 0; i < n - 1; i++) {\\n            int cur = nums[i];\\n            int next = nums[i + 1];\\n            if (max > next)\\n                return false;\\n            max = Math.max(max, cur);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806640,
                "title": "java-mergesort",
                "content": "```\\nclass Solution {\\n    int global = 0;\\n    public boolean isIdealPermutation(int[] nums) {\\n        int local = localInversions(nums);\\n        mergeSort(nums,0,nums.length-1);\\n        return local==global;\\n    }\\n    private int localInversions(int nums[]){\\n        int local = 0;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]>nums[i+1]){\\n                local++;\\n            }\\n        }\\n        return local;\\n    }\\n    private void mergeSort(int[] nums,int start,int end){\\n        if(start>=end) return;\\n        int mid = start + (end-start)/2;\\n        mergeSort(nums,start,mid);\\n        mergeSort(nums,mid+1,end);\\n        merge(nums,start,mid,end);\\n    }\\n    private void merge(int nums[],int start,int mid,int end){\\n        int ans[] = new int[end-start+1];\\n        int s1 = start;\\n        int s2 = mid+1;\\n        int index = 0;\\n        while(s1<=mid && s2<=end){\\n            if(nums[s1]<nums[s2]){\\n                ans[index++] = nums[s1];\\n                s1++;\\n            }else{\\n                ans[index++] = nums[s2];\\n                global += mid-s1+1;\\n                s2++;\\n            }\\n        }\\n        while(s1<=mid){\\n            ans[index++] = nums[s1];\\n            s1++;\\n        }\\n        while(s2<=end){\\n            ans[index++] = nums[s2];\\n            s2++;\\n        }\\n        for(int i=0;i<ans.length;i++){\\n            nums[i+start] = ans[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    int global = 0;\\n    public boolean isIdealPermutation(int[] nums) {\\n        int local = localInversions(nums);\\n        mergeSort(nums,0,nums.length-1);\\n        return local==global;\\n    }\\n    private int localInversions(int nums[]){\\n        int local = 0;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]>nums[i+1]){\\n                local++;\\n            }\\n        }\\n        return local;\\n    }\\n    private void mergeSort(int[] nums,int start,int end){\\n        if(start>=end) return;\\n        int mid = start + (end-start)/2;\\n        mergeSort(nums,start,mid);\\n        mergeSort(nums,mid+1,end);\\n        merge(nums,start,mid,end);\\n    }\\n    private void merge(int nums[],int start,int mid,int end){\\n        int ans[] = new int[end-start+1];\\n        int s1 = start;\\n        int s2 = mid+1;\\n        int index = 0;\\n        while(s1<=mid && s2<=end){\\n            if(nums[s1]<nums[s2]){\\n                ans[index++] = nums[s1];\\n                s1++;\\n            }else{\\n                ans[index++] = nums[s2];\\n                global += mid-s1+1;\\n                s2++;\\n            }\\n        }\\n        while(s1<=mid){\\n            ans[index++] = nums[s1];\\n            s1++;\\n        }\\n        while(s2<=end){\\n            ans[index++] = nums[s2];\\n            s2++;\\n        }\\n        for(int i=0;i<ans.length;i++){\\n            nums[i+start] = ans[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659832,
                "title": "c-o-n-simple-maths-10-line-solution",
                "content": "```\\n//  Local inversion is equal to Global inversion when all local inversions are same as global inversion\\n//  So if any Global inversion found which is not local then return false;\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        for(int i=0; i<nums.size(); i++){\\n            if((nums[i] == i) || (i>=1 && i==nums[i-1]) || (i<nums.size()-1 && i==nums[i+1]))\\n                continue;\\n            else return false;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n//  Local inversion is equal to Global inversion when all local inversions are same as global inversion\\n//  So if any Global inversion found which is not local then return false;\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        for(int i=0; i<nums.size(); i++){\\n            if((nums[i] == i) || (i>=1 && i==nums[i-1]) || (i<nums.size()-1 && i==nums[i+1]))\\n                continue;\\n            else return false;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149877,
                "title": "simple-3-line-o-n-java-solution",
                "content": "Whenever the positive different between an element and the index where the element is located is more than 1, then there will be more global inversions than local inversions\\n\\n```\\npublic boolean isIdealPermutation1(int[] A) {\\n        for(int i=0; i<A.length; i++)\\n            if(Math.abs(A[i] - i) > 1)return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isIdealPermutation1(int[] A) {\\n        for(int i=0; i<A.length; i++)\\n            if(Math.abs(A[i] - i) > 1)return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1143753,
                "title": "intuitive-and-easy-to-understand-java-o-n-solution-with-detailed-explanation",
                "content": "An inversion basically suggests that two elements are not in their natural ordering. \\n\\nIntuition: Given two indices i and j in an array A, A[i] & A[j] is said to be an inversion if and only if i<j, but A[i]>A[j].\\nAny element at index j that occurs after element index i (i.e., Any j>=i+1) and follows the inversion property mentioned above is said to be a global inversion. \\n\\nNow, if j == i+1, which means that when A[i] and A[j] are adjacent elements in an array, and an inversion is found, it is said to be a local inversion. \\n\\nThus, local inversions are a subset of global inversions, with a special property of being adjacent to each other, i.e., all local inversions are also global inversions. \\nSo, to prove that the number of global inversions is equal to the number of local inversions, we only need to prove that there a global inversion, which is not a local inversion. \\nIf we are unable to find such a global inversion, it would mean that the number of local inversions is the same as the numnber of global inversions, and we can return true. \\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        int max = -1;\\n        \\n        for(int i=0;i<A.length-2;i++){\\n            max = Math.max(max, A[i]);\\n            if(max > A[i+2]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        int max = -1;\\n        \\n        for(int i=0;i<A.length-2;i++){\\n            max = Math.max(max, A[i]);\\n            if(max > A[i+2]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143663,
                "title": "c-o-n-algo-simple-to-understand",
                "content": "The idea is if there are any 2 numbers after index i smaller than the number at index i, then it will not be an ideal permutation(bcoz global > local). \\nSo, we just check A[i]-i>1 for every i, which implies that if A[i]-i > 1, then there must exist 2 numbers which are smaller than A[i], which inturns makes the permutation non-ideal.\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int n = A.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;                \\n    }\\n};\\n```\\nUpvote otherwise maata raani paap lgayegi :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int n = A.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143388,
                "title": "c-java-simple-solution-with-intuition",
                "content": "Used an approach kinda similar to  Kadane\\'s algorithm.\\n\\nIntuition - If any inversion is local then it must be global also. But if there exists any inversion which is not local then it is not desired permutation => **Only local inversions are allowed** \\n\\n\\n```\\nSaying in mathematical terms :\\n\\tIf (A[i]>A[j] && i<j)  then j must be equal to i+1 only.\\n```\\n\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int n=A.size();\\n        if(n<3) //Corner cases handled\\n            return true;\\n        \\n        int VAL = A[0]; //max allowed value at current position\\n        \\n        for(int i=2;i<n;i++){\\n            if(A[i]<VAL)\\n                return false;\\n            VAL=max(VAL,A[i-1]);\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**JAVA :**\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        int n=A.length;\\n        \\n        if(n<3)\\n            return true;\\n        int VAL=A[0];\\n        for(int i=2;i<n;i++){\\n            if(A[i]<VAL)\\n                return false;\\n            VAL=Math.max(VAL,A[i-1]);\\n        }\\n        return true;\\n    }\\n}\\n```\\n**Time Complexity - O(n)**\\n**Space Complexity - O(1)**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nSaying in mathematical terms :\\n\\tIf (A[i]>A[j] && i<j)  then j must be equal to i+1 only.\\n```\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int n=A.size();\\n        if(n<3) //Corner cases handled\\n            return true;\\n        \\n        int VAL = A[0]; //max allowed value at current position\\n        \\n        for(int i=2;i<n;i++){\\n            if(A[i]<VAL)\\n                return false;\\n            VAL=max(VAL,A[i-1]);\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        int n=A.length;\\n        \\n        if(n<3)\\n            return true;\\n        int VAL=A[0];\\n        for(int i=2;i<n;i++){\\n            if(A[i]<VAL)\\n                return false;\\n            VAL=Math.max(VAL,A[i-1]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084172,
                "title": "optimal-solution-thinking-process-explained-in-more-detail-than-you-d-ever-want",
                "content": "If you don\\'t need the most basic explanation possible, skip to the **[TLDR]**, which is still somewhat long.\\n\\nAfter reading the description, we might first imagine two (extreme) examples to try and get a handle on the problem.\\n\\n(1) [0, 1, 2, 3]\\n(2) [3, 2, 1, 0]\\n\\nIn example (1), we see there are neither local nor global inversions, because the listed is sorted in ascending order.\\n\\nIn example (2), we first tackle the local inversions: since each element is (by definition) less than the preceding element, there are (abstractly, *n - 1* inversions, but specific to our case) three inversions. Proceeding to the global inversions, we notice that for the first element, 3, in addition to the immediately subsequent element, all the remaining elements are less than 3. This of course is true for every element, and anyway, the number of global inversions are (*(n-1) + (n-2) + ... + (n-n)*) five in total.\\n\\nAt this point we could try the na\\xEFve solution: find all local inversions, find all global inversions, then compare the two for equality. However, we decide to think a little further about the problem.\\n\\nWe notice that the cases of local and global inversions overlap; a local inversion is always part of the count of global inversions. Since our problem asks only to detect when the counts differ, we should try and formulate examples where global inversions occur other than the local inversion. (At the very least, this might help us optimize the na\\xEFve solution by not having not having to count twice).\\n\\nAnyway, we think of the following example, which is just our first example but with odd- and even-numbered elements swapped:\\n\\n(3) [1, 0, 3, 2]\\n\\nWe notice that every other element is a local inversion, yet does not provide a global inversion for any other element.\\n\\nAt this point we may get excited and say to ourselves, \"Well that\\'s all we have to do, is split the list in two according to the parity of the index, and check that each is sorted in ascending order (that way, we can be sure no element that is greater in value will occur after a preceeding element (other than its immediate neighbor), ensuring it is not a global inversion)!\" This is of course wrong. While it is true that if a list\\'s local inversions equal global inversions, then this property is satisfied, the converse is false, so we cannot use this relation to solve our problem. As a counter-example that demonstrates this, consider the following:\\n\\n(4) [2, 0, 3, 1]\\n\\n1 is less than both 2 and 0. At this point we might resign ourselves to the fact that we\\'ll just have to do a standard stack approach, which we often resort to when we need to solve problems that require traversal through list \"with memory\" (in this case, does more than one element subsequently occur that is greater in value then a given element).\\n\\n# **[TLDR]**\\nFinally, however, we think back to what was right about our intuition from our third example, we restate the property we\\'re trying to test (namely that there can be only one element greater than a given element occuring later in the list), and **crucially**, we reconsider the limited domain space of our problem\\u2014specifically, that our input is going to be a permutation of some continuous subset of the Natural Numbers.\\n\\nIf our input could be lists of any variety, then no doubt we\\'d have to approach this as a stack problem, like we said. However, our domain is limited to sequences, among the elements of which there are no duplicates, and there are no gaps.\\n\\nWe realize that if we see an element *e* in the list, then there **must** exist all elements in the range [0, *e*) somewhere else in the list. If, for example, we see the element 2 occupying the 0th index, then it stands to reason that because elements 0 and 1 **must** exist, and there are no indices preceeding the 0th, then 0 and 1 occurr after 2, meaning there is at the very least one more global inversion than local.\\n\\nWhat indices is the element 2 allowed to occupy then? Well, clearly it can occupy the index 2; that is its position were the list sorted in ascending order. We know also however that 2 could be swapped with its neighbor and still satisfy that no global inversions exists other than ones that are also local; it could occur at index 2 plus or minus 1. Hence, all our algorithm has to do to confirm correctness is check that each element is in one of three possible indices. The *Python3* code is simply as follows:\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        for i, a in enumerate(A):\\n            if (abs(a - i) > 1):\\n                return False\\n        \\n        return True\\n```\\nThis reasoning still might leave you suspicious. Understand however that if any one element is in position, other elements could of course be out of position while still occupying a valid index. Checking this ostensibly out-of-position element then would confirm however if it was indeed in-place. Therefore by checking every element we know we have a correct answer.\\n\\n[This (Check if We Can Sort the Array)](https://leetcode.com/problems/global-and-local-inversions/discuss/113652/check-if-we-can-sort-the-array-with-only-local-inversions) is another solution that is very good conceptually. Restatements and implications are good habits of mathematical thinking, in my belief. In a way, solving a problem is trivial if you describe it properly.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        for i, a in enumerate(A):\\n            if (abs(a - i) > 1):\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045170,
                "title": "c-o-n-time-o-1-space-solution",
                "content": "Gist : \\n* Local inverstion is also counted as global inversion. (By definition of problem).\\n* Hence for case when global inversion == local inversion, means there are only local inversions & no global inversions.\\n* Hence problem reduces to : \\n```\\nif(hasGlobalInversion)\\n\\treturn false;\\nelse\\n\\treturn true;\\n```\\n\\n* If any digit is misplaced by more than 1 position, which means it has global inversion. (All elements are permutations fro 0 - n -1)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for(int i = 0; i < A.size(); ++i){\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "```\\nif(hasGlobalInversion)\\n\\treturn false;\\nelse\\n\\treturn true;\\n```\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for(int i = 0; i < A.size(); ++i){\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859083,
                "title": "my-2-line-java-solution-accepted-with-explanation-beats-100",
                "content": "**Basic Idea**\\n\\t1. Every Local Inversion is a global inversion, so if a LI is encountered LI will still be equal to GI. But if a new GI is encountered then return false.\\n\\t2. How to find GI..?, think of how can a GI be generated? It can be generated if you swap and make a value jump more than 1 times in the array. Here is the answer. \\n\\t3.  Note, Originally the array was sorted from 0 to n-1. \\n\\t\\n\\n\\tfor(int i=0;i<A.length;i++) if(Math.abs(i-A[i])>1) return false; // Implying this number or A[i] was jumped/swaped more than 1 times to come here at i! \\n\\treturn true;\\n\\t\\n\\t// Still confused? Well remember this A[i] was at A[i]th index or to put it simply..\\n\\t// 0 was at 0 index orignally but if it is now found at 2 then how many swaps would have been made? \\n\\t// Here you are, answer is two. \\n\\t\\n    \\n\\t \\n\\nWithout using any inbuilt functions :- **[ Beats 100% ]**\\n\\n\\tfor(int i=0;i<A.length;i++) if(i-A[i]>1 || i-A[i]<-1) return false;\\n    return true;\\n\\t\\n**TL;DR;** If it took more than 1 swap to bring a number at an index well here it is a GI, so return false;\\n\\nPS: \\nLI = Local Inversion\\nGI = Global Inversion\\n\\n\\nHappy Coding :)",
                "solutionTags": [],
                "code": "**Basic Idea**\\n\\t1. Every Local Inversion is a global inversion, so if a LI is encountered LI will still be equal to GI. But if a new GI is encountered then return false.\\n\\t2. How to find GI..?, think of how can a GI be generated? It can be generated if you swap and make a value jump more than 1 times in the array. Here is the answer. \\n\\t3.  Note, Originally the array was sorted from 0 to n-1. \\n\\t\\n\\n\\tfor(int i=0;i<A.length;i++) if(Math.abs(i-A[i])>1) return false; // Implying this number or A[i] was jumped/swaped more than 1 times to come here at i! \\n\\treturn true;\\n\\t\\n\\t// Still confused? Well remember this A[i] was at A[i]th index or to put it simply..\\n\\t// 0 was at 0 index orignally but if it is now found at 2 then how many swaps would have been made? \\n\\t// Here you are, answer is two. \\n\\t\\n    \\n\\t \\n\\nWithout using any inbuilt functions :- **[ Beats 100% ]**\\n\\n\\tfor(int i=0;i<A.length;i++) if(i-A[i]>1 || i-A[i]<-1) return false;\\n    return true;\\n\\t\\n**TL;DR;** If it took more than 1 swap to bring a number at an index well here it is a GI, so return false;\\n\\nPS: \\nLI = Local Inversion\\nGI = Global Inversion\\n\\n\\nHappy Coding :)",
                "codeTag": "Unknown"
            },
            {
                "id": 430435,
                "title": "java-idea-same-with-merge-sort",
                "content": "The idea is same with merge-sort or divide-and-conquer, \\njust divide the array until there are two numbers, \\nand find the inversions. then back to four... \\n```\\n\\tint global = 0;\\n    int local = 0;\\n    public boolean isIdealPermutation(int[] A) {\\n        // \\u5206\\u6CBB\\u6CD5\\uFF0C\\u5148\\u6C42global\\uFF0C\\u518D\\u5224\\u65AD\\u662F\\u5426\\u6709local\\n        divide(A, 0, A.length-1);\\n        return global == local;\\n    }\\n    private void divide(int[] a, int lo, int hi) {\\n        if (lo >= hi) {\\n            return;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        divide(a, lo, mid);\\n        divide(a, mid+1, hi);\\n        merge(a, lo, mid, hi);\\n    }\\n    private void merge(int[] a, int lo, int mid, int hi) {\\n        int i = lo;\\n\\t\\t// find global inversion\\n        while (i <= mid) {\\n            for (int j = mid + 1; j <= hi; j++) {\\n                if (a[i] > a[j]) {\\n                    global++;\\n                }\\n            }\\n            i++;\\n        }\\n\\t\\t// find local inversion\\n        if (a[mid] > a[mid + 1]) {\\n            local++;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint global = 0;\\n    int local = 0;\\n    public boolean isIdealPermutation(int[] A) {\\n        // \\u5206\\u6CBB\\u6CD5\\uFF0C\\u5148\\u6C42global\\uFF0C\\u518D\\u5224\\u65AD\\u662F\\u5426\\u6709local\\n        divide(A, 0, A.length-1);\\n        return global == local;\\n    }\\n    private void divide(int[] a, int lo, int hi) {\\n        if (lo >= hi) {\\n            return;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        divide(a, lo, mid);\\n        divide(a, mid+1, hi);\\n        merge(a, lo, mid, hi);\\n    }\\n    private void merge(int[] a, int lo, int mid, int hi) {\\n        int i = lo;\\n\\t\\t// find global inversion\\n        while (i <= mid) {\\n            for (int j = mid + 1; j <= hi; j++) {\\n                if (a[i] > a[j]) {\\n                    global++;\\n                }\\n            }\\n            i++;\\n        }\\n\\t\\t// find local inversion\\n        if (a[mid] > a[mid + 1]) {\\n            local++;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189416,
                "title": "share-my-simple-o-n-solution-without-math-or-hard-thinking",
                "content": "```\nclass Solution {\n    public boolean isIdealPermutation(int[] A) {\n        // Observations:\n        // Local Inversion is Global Inversion\n        // For any i, only i + 1 can be less than i\n        // A[i] < A[i+2:]\n        \n        if (A.length < 3) {\n            return true;\n        }\n        \n        int min = A[A.length - 1];\n        for (int i = A.length - 3; i >= 0; i--) {\n            if (A[i] > min) {\n                return false;\n            }\n            min = Math.min(min, A[i + 1]);\n        }\n        \n        return true;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public boolean isIdealPermutation(int[] A) {\n        // Observations:\n        // Local Inversion is Global Inversion\n        // For any i, only i + 1 can be less than i\n        // A[i] < A[i+2:]\n        \n        if (A.length < 3) {\n            return true;\n        }\n        \n        int min = A[A.length - 1];\n        for (int i = A.length - 3; i >= 0; i--) {\n            if (A[i] > min) {\n                return false;\n            }\n            min = Math.min(min, A[i + 1]);\n        }\n        \n        return true;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716674,
                "title": "merge-sort-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> temp; // to avoid TLE Declare here\\n    // So it\\'s not intialized for every merge call\\n\\n    long long merge(int s, int m, int e, vector<int>& nums){\\n        temp.clear();\\n        long long ctr = 0;\\n\\n        int left = s;\\n        int right = m+1;\\n\\n        while(left <= m && right <= e){\\n            if(nums[left] <= nums[right]){\\n                temp.push_back(nums[left]);\\n                left++;\\n            }\\n            else{\\n                ctr += (m-left+1); // m+1 len of arr, left is the pos\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        while(left <= m){\\n            temp.push_back(nums[left]);\\n            left++;\\n        }\\n        while(right <= e){\\n            temp.push_back(nums[right]);\\n            right++;\\n        }\\n\\n        for(int i=s; i<=e; i++){\\n            nums[i] = temp[i-s];\\n        }\\n\\n        return ctr;\\n\\n    }\\n    long long ms(int s, int e, vector<int>& nums){\\n        long long ctr = 0;\\n\\n        if(s>=e) return 0;\\n        int mid = s + (e-s)/2;\\n        ctr += ms(s, mid, nums);\\n        ctr += ms(mid+1, e, nums);\\n        //here is where 2 broken sorted arrays are there\\n        //s...mid , mid+1...e\\n        ctr += merge(s,mid,e, nums);\\n        return ctr;\\n    }\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<int> vec(nums.begin(), nums.end());\\n        long long glb_ctr = ms(0, N-1, vec);\\n        \\n        long long loc_ctr = 0;\\n\\n        for(int i=0; i<N-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                loc_ctr++;\\n            }\\n        }\\n\\n        //cout<<glb_ctr<<\" \"<<loc_ctr<<\"\\\\n\";\\n\\n        return loc_ctr == glb_ctr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Divide and Conquer",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> temp; // to avoid TLE Declare here\\n    // So it\\'s not intialized for every merge call\\n\\n    long long merge(int s, int m, int e, vector<int>& nums){\\n        temp.clear();\\n        long long ctr = 0;\\n\\n        int left = s;\\n        int right = m+1;\\n\\n        while(left <= m && right <= e){\\n            if(nums[left] <= nums[right]){\\n                temp.push_back(nums[left]);\\n                left++;\\n            }\\n            else{\\n                ctr += (m-left+1); // m+1 len of arr, left is the pos\\n                temp.push_back(nums[right]);\\n                right++;\\n            }\\n        }\\n        while(left <= m){\\n            temp.push_back(nums[left]);\\n            left++;\\n        }\\n        while(right <= e){\\n            temp.push_back(nums[right]);\\n            right++;\\n        }\\n\\n        for(int i=s; i<=e; i++){\\n            nums[i] = temp[i-s];\\n        }\\n\\n        return ctr;\\n\\n    }\\n    long long ms(int s, int e, vector<int>& nums){\\n        long long ctr = 0;\\n\\n        if(s>=e) return 0;\\n        int mid = s + (e-s)/2;\\n        ctr += ms(s, mid, nums);\\n        ctr += ms(mid+1, e, nums);\\n        //here is where 2 broken sorted arrays are there\\n        //s...mid , mid+1...e\\n        ctr += merge(s,mid,e, nums);\\n        return ctr;\\n    }\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<int> vec(nums.begin(), nums.end());\\n        long long glb_ctr = ms(0, N-1, vec);\\n        \\n        long long loc_ctr = 0;\\n\\n        for(int i=0; i<N-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                loc_ctr++;\\n            }\\n        }\\n\\n        //cout<<glb_ctr<<\" \"<<loc_ctr<<\"\\\\n\";\\n\\n        return loc_ctr == glb_ctr;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3657781,
                "title": "java-0ms-100-3-liner-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n       for(int i = 0; i < nums.length; i ++) \\n           if(i - nums[i] > 1 || i - nums[i] < - 1) return false;\\n           return true;\\n    }\\n}\\n```\\n# PLESE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n       for(int i = 0; i < nums.length; i ++) \\n           if(i - nums[i] > 1 || i - nums[i] < - 1) return false;\\n           return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462890,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i]-i)>1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        return all(abs(ind - num) <= 1 for ind, num in enumerate(nums))\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for (int i = 0; i < A.length; i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i]-i)>1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        return all(abs(ind - num) <= 1 for ind, num in enumerate(nums))\\n```\n```Java []\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for (int i = 0; i < A.length; i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3398162,
                "title": "merge-sort-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n   {\\n    public boolean isIdealPermutation(int[] nums)\\n    {\\n        int n=nums.length;\\n        int temp[]=new int[n];\\n        int global=0,local=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n               local++;\\n        }\\n        global=mergesort(nums,temp,0,n-1);  \\n        if(local==global)\\n        return true;\\n        return false;\\n       }\\n       public int mergesort(int arr[],int temp[],int l,int r)\\n       {\\n           int mid=0,inv=0;\\n           if(r>l)\\n           {\\n               mid=(l+r)/2;\\n               inv+=mergesort(arr,temp,l,mid);\\n               inv+=mergesort(arr,temp,mid+1,r);\\n               inv+=merge(arr,temp,l,mid+1,r);\\n           }\\n           return inv;\\n       }\\n       public int merge(int arr[],int temp[],int l,int mid,int r)\\n       {\\n           int i=l,j=mid,k=l,inv=0;\\n           while(i<=mid-1&&j<=r)\\n           {\\n               if(arr[i]<=arr[j])\\n               {\\n                   temp[k++]=arr[i++];\\n\\n               }\\n               else\\n               {\\n                   temp[k++]=arr[j++];\\n                   inv+=mid-i;\\n          }\\n           }\\n           while(i<=mid-1)\\n           temp[k++]=arr[i++];\\n           while(j<=r)\\n           temp[k++]=arr[j++];\\n           for(i=l;i<=r;i++)\\n           arr[i]=temp[i];\\n           return inv;\\n       }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n   {\\n    public boolean isIdealPermutation(int[] nums)\\n    {\\n        int n=nums.length;\\n        int temp[]=new int[n];\\n        int global=0,local=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n               local++;\\n        }\\n        global=mergesort(nums,temp,0,n-1);  \\n        if(local==global)\\n        return true;\\n        return false;\\n       }\\n       public int mergesort(int arr[],int temp[],int l,int r)\\n       {\\n           int mid=0,inv=0;\\n           if(r>l)\\n           {\\n               mid=(l+r)/2;\\n               inv+=mergesort(arr,temp,l,mid);\\n               inv+=mergesort(arr,temp,mid+1,r);\\n               inv+=merge(arr,temp,l,mid+1,r);\\n           }\\n           return inv;\\n       }\\n       public int merge(int arr[],int temp[],int l,int mid,int r)\\n       {\\n           int i=l,j=mid,k=l,inv=0;\\n           while(i<=mid-1&&j<=r)\\n           {\\n               if(arr[i]<=arr[j])\\n               {\\n                   temp[k++]=arr[i++];\\n\\n               }\\n               else\\n               {\\n                   temp[k++]=arr[j++];\\n                   inv+=mid-i;\\n          }\\n           }\\n           while(i<=mid-1)\\n           temp[k++]=arr[i++];\\n           while(j<=r)\\n           temp[k++]=arr[j++];\\n           for(i=l;i<=r;i++)\\n           arr[i]=temp[i];\\n           return inv;\\n       }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215159,
                "title": "small-c-solutions-with-explanation-o-n",
                "content": "Important observation: **all local inversions are global inversions at the same time.**\\n* So you just need to **find one global inversion that isn\\'t local inversion at the same time**, then **(local != global)** anymore.\\n\\n* If you find a ```(nums[index] != index)``` then it cause ```x``` number of global inversion and at least x =  ```abs(nums[index] - index)``` global inversion.\\n*  Don\\'t forget that it may has one local inversion too, so check that ```x > 1```.\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int n = (int) nums.size();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // the least number of Global inversion this number make.\\n            int x = (int) abs(nums[i] - i); \\n            \\n            // To make sure that there is one global that is not local at the same time\\n            if(x > 1) return false;  // Condition fails\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```(nums[index] != index)```\n```x```\n```abs(nums[index] - index)```\n```x > 1```\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int n = (int) nums.size();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // the least number of Global inversion this number make.\\n            int x = (int) abs(nums[i] - i); \\n            \\n            // To make sure that there is one global that is not local at the same time\\n            if(x > 1) return false;  // Condition fails\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043330,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is that this problem can be solved by iterating through the array and comparing the value of each element to its index, and checking if the difference between them is greater than 1.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use a for loop to iterate through the input array, and for each element, compare its value to its index using the built-in abs() function. If the difference is greater than 1, the function returns False indicating that the permutation is not ideal. If the for loop completes without returning False, the function returns True indicating that the permutation is ideal.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            if abs(nums[i] - i) > 1:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            if abs(nums[i] - i) > 1:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826061,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for (int i = 0; i < A.size(); i++)\\n            if (i - A[i] > 1 || i - A[i] < -1) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526097,
                "title": "2-line-code-o-n-detailed-explanation-3-approaches",
                "content": "**Approach #1: [accepted]**\\n\\n I worked out for certain examples and saw a pattern:\\n *\"If there is difference of more than 1 between index and the value present at index, global inversion will be more than local inversion...\"*\\n \\nThis pattern exploits the following conditions: \\n```\\n\\n* 0 <= nums[i] < n\\n* All the integers of nums are unique.\\n\\n```\\n\\n\\n**Let\\'s workout some example:**\\n\\n*\\u201CIf there is at least one global inversion that is not a local inversion, then the total global inversions will never be equal to the local inversions\\u201D.*\\nAlso, any index can have at most one local inversion. So, if we find an index that is part of more than one global inversion, we should return \\u2018False\\u2019 as the answer.\\n\\nConsider, `ARR = [0, 1, 2, 3, 4, 5, 6]`, i.e., in sorted order. We try to place the integer 3 at different locations:\\n\\n* **Shift \\u20183\\u2019 to the left by one position,**\\n```\\nARR = [0, 1, 3, 2, 4, 5, 6]\\n```\\nIf we fix the position of 3 and no matter how we rearrange the other integers, there will always be an integer between index [3, 6] that is smaller than 3. Thus, 3 will always have at least one global inversion.\\n\\n* **Shift \\u20183\\u2019 to the left by two positions,**\\n```\\nARR = [0, 3, 1, 2, 4, 5, 6]\\n```\\nSimilarly, no matter what positions the other integers have, there will always be two integers between index [2, 6] that will be smaller than \\u20183\\u2019. Thus, \\u20183\\u2019 will always have at least two global inversions.\\n \\n\\nWe can generalize these for the right shifts. \\n* Let\\u2019s `DIST[i]` be the distance of `ARR[i]` from its position in the sorted order. So, for every `i`, `ARR[i]` will be part of at least \\u2018DIST[i]\\u2019 global inversions.\\n\\n* As per the question, the array `ARR` is a permutation of the integers from `[0, N - 1]`. So, the position of `ARR[i]` in sorted order is `ARR[i]`. \\n \\n* We have `DIST[i] = abs(ARR[i] - i)`, where abs(X) is the absolute value of \\'X\\'.\\n \\n* As per our previous analysis, if `DIST[i] > 1`, we should return `false`. Also, if for every `i` we have `DIST[i] <= 1`, then no integer has moved more than one distance from its sorted position, so every inversion has to be a local inversion.\\n\\n**Algorithm:**\\n1. Run a loop where `i` ranges from `0 to N - 2`:\\n2. If `abs(ARR[i] - i) > 1`, then there is at least one extra global inversion:\\n\\ta. Return `false` as the answer.\\n4. Return `true` as the answer.\\n\\n**Solution:**  \\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(Math.abs(nums[i]-i)>1) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n---\\n\\n**Approach #2: [Accepted]**\\n\\nObserve that all the local inversions are also global inversions. So, we can greedily check if there exists at least one global inversion that is not a local inversion. In such a scenario, the local inversions will never be equal to global inversions.\\n\\nStore the maximum value in `ARR` up to `i` (including \\u2018i\\u2019), let\\u2019s say `CUR_MAX`. If `CUR_MAX` is greater than `ARR[i + 2]` (as `i + 1` is a local inversion), then there exists at least one global inversion, which is not a local inversion. If `CUR_MAX` is smaller than `ARR[i + 2]`, then all the values before `i + 1` are also smaller, so we will always find that extra global inversion if it exists.\\n\\n**Algorithm:**\\n1. Set `CUR_MAX`. Use it to store the maximum value up to the current index.\\n1. Run a loop where `i` ranges from `0 to N - 3`:\\n\\t1. CUR_MAX = max(CUR_MAX, ARR[i])\\u2019. Update CUR_MAX.\\n\\t1. If `CUR_MAX > ARR[i + 2]`, then there is an extra global inversion:\\n\\t\\t1. Return \\u2018False\\u2019 as the answer.\\n1. Return \\u2018True\\u2019 as the answer.\\n\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        \\n        if(nums.length < 2)\\n            return true;\\n\\t\\t\\n        int curr_max = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < nums.length - 2; i++){\\n            curr_max = Math.max(curr_max, nums[i]);\\n\\t\\t\\t\\n            if(curr_max > nums[i+2])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n---\\n\\n**Approach #3: [TLE]**\\n\\n**Idea:**\\nRemember Bubble Sort and consider the inversions/swaps as global inversions and local inversions. \\n\\nHere the approach would be to use two nested loops to count the number of global inversions and a single loop to count the number of local inversions.\\n\\n**Solutions:**\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int len = nums.length, local = 0, global = 0;\\n        \\n        for( int i = 0; i < len-1; i++){\\n            for(int j = i+1; j < len; j++){\\n                if( nums[i] > nums[j])\\n                    global++;\\n            }\\n            if(nums[i] > nums[i+1])\\n                local++;\\n        }\\n        return (local == global);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n* 0 <= nums[i] < n\\n* All the integers of nums are unique.\\n\\n```\n```\\nARR = [0, 1, 3, 2, 4, 5, 6]\\n```\n```\\nARR = [0, 3, 1, 2, 4, 5, 6]\\n```\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(Math.abs(nums[i]-i)>1) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        \\n        if(nums.length < 2)\\n            return true;\\n\\t\\t\\n        int curr_max = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < nums.length - 2; i++){\\n            curr_max = Math.max(curr_max, nums[i]);\\n\\t\\t\\t\\n            if(curr_max > nums[i+2])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int len = nums.length, local = 0, global = 0;\\n        \\n        for( int i = 0; i < len-1; i++){\\n            for(int j = i+1; j < len; j++){\\n                if( nums[i] > nums[j])\\n                    global++;\\n            }\\n            if(nums[i] > nums[i+1])\\n                local++;\\n        }\\n        return (local == global);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280151,
                "title": "c-short-concise-o-n",
                "content": "**Brute force O(N^2) - gives TLE**\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int globalInversions = 0;\\n        int localInversions = 0;\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n-1; ++i){\\n            for(int j=i+1; j<n; ++j){\\n                \\n                if(nums[i]>nums[j]){\\n                    globalInversions++;\\n                    if(i+1 == j){\\n                        localInversions++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return localInversions==globalInversions;\\n    }\\n};\\n```\\n\\n**O(N) solution**\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        // all local inversions are global inversions\\n        // but the all global is not necessary a local inversion\\n        // so if we can find atleast one extra global inversion we can directly return false\\n        \\n        int maxNum = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n-2; ++i){\\n            maxNum = max(maxNum, nums[i]);// we keep track of max number we found so far\\n            // because it can generate global inversion with smaller element\\n            if(maxNum > nums[i+2]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int globalInversions = 0;\\n        int localInversions = 0;\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n-1; ++i){\\n            for(int j=i+1; j<n; ++j){\\n                \\n                if(nums[i]>nums[j]){\\n                    globalInversions++;\\n                    if(i+1 == j){\\n                        localInversions++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return localInversions==globalInversions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146754,
                "title": "c-easy-observation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(abs(nums[i]-i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/514092ad-3cff-4717-8b7d-53934b83432a_1655117060.534257.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(abs(nums[i]-i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106795,
                "title": "easy-solution-faster-than-others-4-lines-code-beats-85",
                "content": "```\\nclass Solution {\\npublic:\\n    //in case of decresing array answer is always false\\n    //in case of increasing array answer is always true (0 local 0 global)\\n    // so if global=local+where j>i+1 for this equation being equal global=local means there would be only local inversions i>i+1 case always\\n    //so in sorted array index-arr[i]=0 so for checking local index should be replaced with 1 to get (i+1) case\\n    bool isIdealPermutation(vector<int>& A) {\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    //in case of decresing array answer is always false\\n    //in case of increasing array answer is always true (0 local 0 global)\\n    // so if global=local+where j>i+1 for this equation being equal global=local means there would be only local inversions i>i+1 case always\\n    //so in sorted array index-arr[i]=0 so for checking local index should be replaced with 1 to get (i+1) case\\n    bool isIdealPermutation(vector<int>& A) {\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1782313,
                "title": "c-math",
                "content": "if we can find i j that j>i+1 and num[i] > num[j] that the fuction return false otherwise return true\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1 || n==2) {return true;}\\n        else {\\n            int m1 = nums[n-1];\\n            int index = n-3, i = n-2;\\n            while(index >= 0) {\\n                if(nums[index] > m1) {return false;}\\n                index-=1;\\n                m1 = min(m1, nums[i]);\\n                i-=1;\\n            }\\n            return true;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1 || n==2) {return true;}",
                "codeTag": "Java"
            },
            {
                "id": 1554495,
                "title": "python3-implementation-with-explanation",
                "content": "Idea is since local inversion is also global inversion, so to have them equal we should\\'nt have extra global inversion.\\nso either nums is increasing or only swapped with neighbours then no extra global.\\nso if swapped with neighbour we swap back and at the end if is now sorted in increasing order.\\n```\\nclass Solution:\\n    \\n    def check_sorted(self, nums):\\n        \\n        i = 0\\n        while i < len(nums)-1:\\n            if nums[i] > nums[i+1]:\\n                return False\\n            i += 1\\n        return True\\n    \\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        \\n        i = 0\\n        while i < len(nums)-1:\\n            if nums[i] < nums[i+1]:\\n                i += 1\\n            else:\\n                nums[i], nums[i+1] = nums[i+1], nums[i]\\n                i += 2\\n                \\n        return self.check_sorted(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def check_sorted(self, nums):\\n        \\n        i = 0\\n        while i < len(nums)-1:\\n            if nums[i] > nums[i+1]:\\n                return False\\n            i += 1\\n        return True\\n    \\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        \\n        i = 0\\n        while i < len(nums)-1:\\n            if nums[i] < nums[i+1]:\\n                i += 1\\n            else:\\n                nums[i], nums[i+1] = nums[i+1], nums[i]\\n                i += 2\\n                \\n        return self.check_sorted(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302305,
                "title": "simple-java-soln-explained",
                "content": "As per the rules we see that \" All local inversions are global inversions\" but all \"Global Inversions are NOT local inversions\"\\nWe see that global inversions are\\'t consecutive where as local inversions need to be consecutive.\\nHence we are trying to get 1 such global inversion which isnt a local inversion and hence return false. \\n\\nExample : [1,0,2]\\nthe local inversions are 0,2 --- (1)\\nthe global inversions are\\n1. (0,2) which is a local inversion \\n2. (1,2) which is not a local inversion.\\nMax variable keeps a cound of the highest seen number and compares is with nums[i+2] to see if there is any such cases where it is a global inversion but not a local inversion. :)\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            if(max>nums[i+2])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            if(max>nums[i+2])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260200,
                "title": "detailed-explanation-c",
                "content": "The idea is every global inversion is local inversion. Let\\'s take an example \\n3 2 1 0\\n^ ^\\n(3,2)\\n3 2 1 0\\n^     ^\\n(3,1)\\nsimilarly (3,0),(2,1),(2,0),(1,0) ----> 6 global inversions\\nwhat are local inversions---> a[i+1]<a[i];\\nso (3,2), (2,1), (1,0) ------> local inversions in this case global inversions are not equal to local inversions \\nbut what if we had an array like 0 1 2 3 ----> local -->0, global--->0 (return true)\\nbut guess in case of 1 0 3 2---> ans will be true;\\nso approach to this problem will be that if we find a global inversion apart from i , i+1 we will return false\\nSimilarly we will exclude i+2, i+3 and check from i+4 and so on\\nbut we will not check from last values we will take the max of previously encountered values which means if max(i,i+1...)>(i+2,....) return false\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int mx = 0, n = nums.size();\\n        for (int i = 0; i < n - 2; i++) {\\n            mx = max(mx, nums[i]);\\n            if (mx > nums[i + 2]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int mx = 0, n = nums.size();\\n        for (int i = 0; i < n - 2; i++) {\\n            mx = max(mx, nums[i]);\\n            if (mx > nums[i + 2]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204536,
                "title": "java-divide-and-conquer-merge-sort-easy",
                "content": "```\\nclass Solution {\\n   int global=0;\\n    public boolean isIdealPermutation(int[] arr) {\\n       int local=0;\\n        for(int i=0;i<arr.length-1;i++){\\n          if(arr[i]>arr[i+1]) local++;\\n        }\\n      mergeSort(arr,0,arr.length-1);\\n      System.out.println(local);\\n      System.out.println(global);\\n      return local==global;\\n    }\\n   public int[] mergeSort(int arr[],int l,int h){\\n        if(l==h){\\n            return new int[]{arr[l]};\\n        }\\n        int mid=l+(h-l)/2;\\n        int lsh[] = mergeSort(arr,l,mid);\\n        int rsh[] = mergeSort(arr,mid+1,h);\\n        int fsh[] = merger(lsh,rsh);\\n        return fsh;\\n    }\\n    public int[] merger(int left[], int right[]){\\n        int arr[] = new int[left.length+ right.length];\\n        int idx=0;\\n        int i=0;\\n        int j=0;\\n        while(i<left.length && j<right.length){\\n            if(left[i]<=right[j]){\\n                arr[idx]=left[i];\\n                i++;\\n                idx++;\\n                \\n            }\\n            else{\\n               global+=(left.length-i);\\n                arr[idx]=right[j];\\n                idx++;\\n                j++;\\n            }\\n        }\\n        while(i<left.length){\\n            arr[idx++]=left[i++];\\n        }\\n            while(j<right.length){\\n            arr[idx++]=right[j++];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   int global=0;\\n    public boolean isIdealPermutation(int[] arr) {\\n       int local=0;\\n        for(int i=0;i<arr.length-1;i++){\\n          if(arr[i]>arr[i+1]) local++;\\n        }\\n      mergeSort(arr,0,arr.length-1);\\n      System.out.println(local);\\n      System.out.println(global);\\n      return local==global;\\n    }\\n   public int[] mergeSort(int arr[],int l,int h){\\n        if(l==h){\\n            return new int[]{arr[l]};\\n        }\\n        int mid=l+(h-l)/2;\\n        int lsh[] = mergeSort(arr,l,mid);\\n        int rsh[] = mergeSort(arr,mid+1,h);\\n        int fsh[] = merger(lsh,rsh);\\n        return fsh;\\n    }\\n    public int[] merger(int left[], int right[]){\\n        int arr[] = new int[left.length+ right.length];\\n        int idx=0;\\n        int i=0;\\n        int j=0;\\n        while(i<left.length && j<right.length){\\n            if(left[i]<=right[j]){\\n                arr[idx]=left[i];\\n                i++;\\n                idx++;\\n                \\n            }\\n            else{\\n               global+=(left.length-i);\\n                arr[idx]=right[j];\\n                idx++;\\n                j++;\\n            }\\n        }\\n        while(i<left.length){\\n            arr[idx++]=left[i++];\\n        }\\n            while(j<right.length){\\n            arr[idx++]=right[j++];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167123,
                "title": "c-1-iteration-with-constant-space",
                "content": "* Since num_of_global_inv == num_of_local_inv, there must not exist (i, j) where i + 2 <= j && nums[i] > nums[j], aka for each index i, all elements since index i + 2 must be >= nums[i]. \\nSo we maintain the minimum element from the last, at each index i compare the minimum value with nums[i - 2]. If min_element < nums[i - 2] then global inversion > local inversion, return false. Otherwise return true.\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int size = nums.size(), minVal = INT_MAX;\\n        for (int i = size - 1; i >= 2; --i)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if (nums[i - 2] > minVal)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int size = nums.size(), minVal = INT_MAX;\\n        for (int i = size - 1; i >= 2; --i)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if (nums[i - 2] > minVal)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151071,
                "title": "java-2ms-o-n",
                "content": "\\t\\n\\nAPPROACH 1\\n\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\tpublic boolean isIdealPermutation(int[] nums) {\\n\\t\\t\\t\\t\\t\\tint gi=0,li=0;\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<nums.length-1;i++){\\n\\t\\t\\t\\t\\t\\t\\tif(nums[i]>nums[i+1])\\n\\t\\t\\t\\t\\t\\t\\t\\tli++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tint max=-1;\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\t\\t\\t\\tif(max<nums[i])\\n\\t\\t\\t\\t\\t\\t\\t\\tmax=nums[i];\\n\\t\\t\\t\\t\\t\\t\\tif(max>i)\\n\\t\\t\\t\\t\\t\\t\\t\\tgi+=max-i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn gi==li;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\n\\t\\tAPPROACH 2\\n\\t\\tLOGIC: GI will always be greater then or equal to LI (think how??) so we need to check if a LI element also\\n\\t\\tforms a GI then answer will always be false because GI will definitely exceed. for an element to form LI \\n\\t\\twithout\\n\\t\\textra GI check if only 1 element is misplaced from left subarray to right and also next element is that one\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\tpublic boolean isIdealPermutation(int[] nums) {\\n\\t\\t\\tint max=-1;\\n\\t\\t\\tfor(int i=0;i<nums.length-1;i++){\\n\\t\\t\\t\\tif(max<nums[i])\\n\\t\\t\\t\\t\\tmax=nums[i];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tint diff=max-i;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(diff>1 ||(diff==1 && nums[i+1]!=i))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\t\\t\\tpublic boolean isIdealPermutation(int[] nums) {\\n\\t\\t\\t\\t\\t\\tint gi=0,li=0;\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<nums.length-1;i++){\\n\\t\\t\\t\\t\\t\\t\\tif(nums[i]>nums[i+1])\\n\\t\\t\\t\\t\\t\\t\\t\\tli++;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1144033,
                "title": "explanation-cpp-code-deceptively-easy-less-than-4-lines-solution-o-n",
                "content": "There is a catch in the question which  I missed and that is why I spent a lot of time on the question. \\nActually its clear in the first line itself that you are given a **permutation [0, 1, 2 . . . N-1]**.\\n\\n* So array value **a[i] - i** checks whether permutation is right or not.\\n    -> **a[i] - i** == 0, means no inversion\\n\\t-> **a[i] - i**==1, one inversion, local as well as global\\n\\t-> **a[i] - i**==2,  two inversion, its one local as well as two global inversion \\n\\t\\n* Now all the local inversions are actualy part of global inversions with difference 1, so if we found an inversion with difference more than 1 even once then that means we actually have a **global inversion which is not a local inversion**. \\n\\n```\\nbool isIdealPermutation(vector<int>& v) {\\n        for(int i=0; i<v.size(); i++)\\n            if(abs(v[i]-i)>1)\\n                return false;\\n        return true;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nbool isIdealPermutation(vector<int>& v) {\\n        for(int i=0; i<v.size(); i++)\\n            if(abs(v[i]-i)>1)\\n                return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1143800,
                "title": "c-merge-sort-time-o-nlogn-space-o-n",
                "content": "```cpp\\nclass Solution {\\npublic:\\n//     Merge function\\n    int merge(vector<int>& A, vector<int>& temp, int left, int mid, int right){\\n        \\n        int i = left;\\n        int j = mid;\\n        int k = left;\\n        int inv_count = 0;\\n        while ((i <= mid - 1) && (j <= right)) {\\n            if (A[i] <= A[j]) {\\n                temp[k++] = A[i++];\\n            }\\n            else {\\n                temp[k++] = A[j++];\\n                \\n                inv_count = inv_count + (mid - i);\\n            }\\n        }\\n        \\n         while (i <= mid - 1)\\n        temp[k++] = A[i++];\\n \\n   \\n        while (j <= right)\\n                temp[k++] = A[j++];\\n \\n        for (i = left; i <= right; i++)\\n             A[i] = temp[i];\\n        \\n        return inv_count;\\n    }\\n    \\n    int globalInvCount(vector<int>& A, vector<int>& temp, int left, int right){\\n        \\n        int mid, inv_count= 0;\\n        \\n        if(left < right){\\n            \\n            mid = (left + right)/2;\\n            \\n//             left\\n            inv_count += globalInvCount(A, temp, left, mid);\\n\\n//             right\\n            inv_count += globalInvCount(A, temp, mid+1, right);\\n\\n//             merge\\n            inv_count += merge(A, temp, left, mid + 1, right);\\n        }\\n        \\n        return inv_count;\\n        \\n    }\\n    \\n    \\n    int localInvCount(vector<int> A){\\n        \\n        int inv_count = 0;\\n        int n = A.size();\\n        for(int i=0; i<n-1; i++){\\n            \\n            if(A[i] > A[i+1])\\n                inv_count++;\\n        }\\n        \\n        return inv_count;\\n    }    \\n    bool isIdealPermutation(vector<int>& A) {\\n        int n = A.size();\\n        vector<int> temp(n);\\n        int local_inv = localInvCount(A);\\n        \\n        int global_inv = globalInvCount(A, temp, 0, n - 1);\\n     \\n        return global_inv == local_inv;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n//     Merge function\\n    int merge(vector<int>& A, vector<int>& temp, int left, int mid, int right){\\n        \\n        int i = left;\\n        int j = mid;\\n        int k = left;\\n        int inv_count = 0;\\n        while ((i <= mid - 1) && (j <= right)) {\\n            if (A[i] <= A[j]) {\\n                temp[k++] = A[i++];\\n            }\\n            else {\\n                temp[k++] = A[j++];\\n                \\n                inv_count = inv_count + (mid - i);\\n            }\\n        }\\n        \\n         while (i <= mid - 1)\\n        temp[k++] = A[i++];\\n \\n   \\n        while (j <= right)\\n                temp[k++] = A[j++];\\n \\n        for (i = left; i <= right; i++)\\n             A[i] = temp[i];\\n        \\n        return inv_count;\\n    }\\n    \\n    int globalInvCount(vector<int>& A, vector<int>& temp, int left, int right){\\n        \\n        int mid, inv_count= 0;\\n        \\n        if(left < right){\\n            \\n            mid = (left + right)/2;\\n            \\n//             left\\n            inv_count += globalInvCount(A, temp, left, mid);\\n\\n//             right\\n            inv_count += globalInvCount(A, temp, mid+1, right);\\n\\n//             merge\\n            inv_count += merge(A, temp, left, mid + 1, right);\\n        }\\n        \\n        return inv_count;\\n        \\n    }\\n    \\n    \\n    int localInvCount(vector<int> A){\\n        \\n        int inv_count = 0;\\n        int n = A.size();\\n        for(int i=0; i<n-1; i++){\\n            \\n            if(A[i] > A[i+1])\\n                inv_count++;\\n        }\\n        \\n        return inv_count;\\n    }    \\n    bool isIdealPermutation(vector<int>& A) {\\n        int n = A.size();\\n        vector<int> temp(n);\\n        int local_inv = localInvCount(A);\\n        \\n        int global_inv = globalInvCount(A, temp, 0, n - 1);\\n     \\n        return global_inv == local_inv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143683,
                "title": "python-one-line-explanation",
                "content": "```python\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        return all([(i-1<=a<=i+1) for i,a in enumerate(A)])\\n```\\n\\nLet\\'s say arr=[0,1,2,3]\\n\\nif number `0` is not located at either 0 or 1 (eg. at 2)\\n\\npossible `A` is\\n> [1,2,0,3]\\n> [1,3,0,2]\\n> [2,1,0,3]\\n> [2,3,0,1]\\n> [3,1,0,2]\\n> [3,2,0,1]\\n> \\nthey all have more than one number greater than `0` on left-side of `0` , which makes \\n`cnt(Global) == cnt(Local)` impossible\\n\\nfor `cnt(Global) == cnt(Local)` , there should be only one j that satisfies\\n`A[i]>A[j] , i<j` and that j should be i+1\\n\\nalso, note that `zero number of j that satisfy the condition above for all i` is also answer.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        return all([(i-1<=a<=i+1) for i,a in enumerate(A)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143430,
                "title": "python-go-o-n-by-iteration-w-comment",
                "content": "Python/Go O(n) by iteration\\n\\n---\\n\\n**Implementation** by iteration in Python\\n\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        \\n        global_inversion, local_inversion = 0, 0\\n        \\n        size = len(A)\\n        \\n        for cur_idx, cur_num in enumerate(A):\\n            \\n            ## for global inversion\\n            if cur_num > cur_idx:\\n                \\n                # current number is too big, update with the count of mismatch on smaller elements\\n                global_inversion += cur_num - cur_idx\\n                \\n            elif cur_num < cur_idx:\\n                \\n                # current number is too small, update with the count of mismatch on larger elements\\n                global_inversion += cur_idx - cur_num - 1\\n                \\n            \\n            ## for local inversion\\n            if (cur_idx < size-1) and (A[cur_idx] > A[cur_idx+1]):\\n                \\n                # current number is out of order, update with current mismatch pair\\n                local_inversion += 1\\n        \\n        \\n        return global_inversion == local_inversion\\n```\\n\\n---\\n\\n**Implementation** by iteration in Go\\n\\n```\\nfunc isIdealPermutation(A []int) bool {\\n    \\n    globalInversion, localInversion := 0, 0\\n    \\n    size := len(A)\\n    \\n    for curIdx, curNum := range A{\\n        \\n        // for global inversion\\n        if curNum > curIdx{\\n            \\n            // current number is too big, update with the count with mismatch on smaller elements\\n            globalInversion += ( curNum - curIdx)\\n            \\n        }else if curNum < curIdx{\\n            \\n            // current number is too small, update with the count with mismatch on larger elements\\n            globalInversion += ( curIdx - curNum - 1)\\n            \\n        }\\n        \\n        // for local inversion\\n        if (curIdx < (size-1)) && (A[curIdx] > A[curIdx+1]){\\n            \\n            // current number is out-of-order, update with current mismatch pair\\n            localInversion += 1\\n        }\\n        \\n    }\\n    \\n    return globalInversion == localInversion\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        \\n        global_inversion, local_inversion = 0, 0\\n        \\n        size = len(A)\\n        \\n        for cur_idx, cur_num in enumerate(A):\\n            \\n            ## for global inversion\\n            if cur_num > cur_idx:\\n                \\n                # current number is too big, update with the count of mismatch on smaller elements\\n                global_inversion += cur_num - cur_idx\\n                \\n            elif cur_num < cur_idx:\\n                \\n                # current number is too small, update with the count of mismatch on larger elements\\n                global_inversion += cur_idx - cur_num - 1\\n                \\n            \\n            ## for local inversion\\n            if (cur_idx < size-1) and (A[cur_idx] > A[cur_idx+1]):\\n                \\n                # current number is out of order, update with current mismatch pair\\n                local_inversion += 1\\n        \\n        \\n        return global_inversion == local_inversion\\n```\n```\\nfunc isIdealPermutation(A []int) bool {\\n    \\n    globalInversion, localInversion := 0, 0\\n    \\n    size := len(A)\\n    \\n    for curIdx, curNum := range A{\\n        \\n        // for global inversion\\n        if curNum > curIdx{\\n            \\n            // current number is too big, update with the count with mismatch on smaller elements\\n            globalInversion += ( curNum - curIdx)\\n            \\n        }else if curNum < curIdx{\\n            \\n            // current number is too small, update with the count with mismatch on larger elements\\n            globalInversion += ( curIdx - curNum - 1)\\n            \\n        }\\n        \\n        // for local inversion\\n        if (curIdx < (size-1)) && (A[curIdx] > A[curIdx+1]){\\n            \\n            // current number is out-of-order, update with current mismatch pair\\n            localInversion += 1\\n        }\\n        \\n    }\\n    \\n    return globalInversion == localInversion\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143408,
                "title": "easy-cpp-solution-with-explanation-beats-96-88-submissions-o-n-o-1",
                "content": "If all the inversions were local, then swapping all the adjacent elements which cause the local inversion(essentially removing the local inversions) should result in a sorted array. \\n\\nWe can do precisely this. Run a loop to check for any local inversions. If present, remove it by swapping the elements. If the resultant array is sorted, all the inversions were local and return true. Else, return false.\\n\\nHere is the code for the same\\n\\n```\\nbool isIdealPermutation(vector<int>& A) {\\n        int s = A.size();\\n        int i = 0;\\n        while(i < s - 1){\\n            if(A[i] > A[i+1]){\\n                swap(A[i], A[i + 1]);\\n                i++;\\n            }\\n            i++;\\n        }\\n        \\n        i= 0;\\n        while(i < s - 1)\\n        {\\n            if(A[i] > A[i + 1]){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n```\\n\\nPlease upvote if you found my solution helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isIdealPermutation(vector<int>& A) {\\n        int s = A.size();\\n        int i = 0;\\n        while(i < s - 1){\\n            if(A[i] > A[i+1]){\\n                swap(A[i], A[i + 1]);\\n                i++;\\n            }\\n            i++;\\n        }\\n        \\n        i= 0;\\n        while(i < s - 1)\\n        {\\n            if(A[i] > A[i + 1]){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124643,
                "title": "4-line-python-solution",
                "content": "```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(len(A)):\\n            if abs(A[i] - i) > 1:\\n                return False\\n        return True",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(len(A)):\\n            if abs(A[i] - i) > 1:\\n                return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 931839,
                "title": "simple-concise-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& a) {\\n     \\n        for(int i=0 ; i< a.size() ; i++){\\n            bool f = 0 ;\\n             if(a[i] ==i+1 || a[i]==i || a[i]==i-1) {  \\n               f = 1 ;\\n             }\\n            if(f==0) {  \\n               return 0 ; \\n            }\\n        }\\n        return 1 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& a) {\\n     \\n        for(int i=0 ; i< a.size() ; i++){\\n            bool f = 0 ;\\n             if(a[i] ==i+1 || a[i]==i || a[i]==i-1) {  \\n               f = 1 ;\\n             }\\n            if(f==0) {  \\n               return 0 ; \\n            }\\n        }\\n        return 1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903433,
                "title": "python-simple-o-n-solution",
                "content": "```html5\\n<b>Time Complexity: O(n)\\nSpace Complexity: O(1)</b>\\n```\\n\\n**Intuition:**\\nThe key observation here is that **all local inversions are global inversions**,  but **not all global inversions are local inversions.**\\nSo if any global inversion exists that is not a local inversion, then the answer is False.  \\n\\n**Solution:**\\nA global inversion **that is not also a local inversion** happens whenever there is a value greater than A[i] in A[:i-1].  \\nSo all we need to keep track of is the largest value in A[:i-1] and if this value is ever greater than A[i], return False.  \\n\\n```python\\ndef isIdealPermutation(self, A: List[int]) -> bool:\\n\\n\\tleft = A[0]\\n\\tfor i in range(2, len(A)):\\n\\t\\tif left > A[i]:\\n\\t\\t\\treturn False\\n\\t\\tleft = max(left, A[i-1])\\n\\n\\treturn True\\n```",
                "solutionTags": [],
                "code": "```html5\\n<b>Time Complexity: O(n)\\nSpace Complexity: O(1)</b>\\n```\n```python\\ndef isIdealPermutation(self, A: List[int]) -> bool:\\n\\n\\tleft = A[0]\\n\\tfor i in range(2, len(A)):\\n\\t\\tif left > A[i]:\\n\\t\\t\\treturn False\\n\\t\\tleft = max(left, A[i-1])\\n\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 900430,
                "title": "python-straightforward-with-explanation",
                "content": "The only True case is that, the adjacent two numbers are swapped, all other cases are False. That being said, we loop over A, if A[i]!=i, we check if it is because that it is swapped with its next elements, if yes, then i += 2; else False.\\n\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        i = 0\\n        while i < len(A):\\n            if A[i] == i:\\n                i+=1\\n            elif A[i] == i+1 and i+1 < len(A) and A[i+1] == i:\\n                i+=2\\n            else:\\n                return False\\n        return True",
                "solutionTags": [],
                "code": "The only True case is that, the adjacent two numbers are swapped, all other cases are False. That being said, we loop over A, if A[i]!=i, we check if it is because that it is swapped with its next elements, if yes, then i += 2; else False.\\n\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        i = 0\\n        while i < len(A):\\n            if A[i] == i:\\n                i+=1\\n            elif A[i] == i+1 and i+1 < len(A) and A[i+1] == i:\\n                i+=2\\n            else:\\n                return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 680070,
                "title": "well-explained-easiest-o-n-time-c-solution",
                "content": "**Basic Idea/ Algo :**\\nIn the given question, every local inversion is a global inversion but reverse is not true.\\nThat means, if any number at place j is greater than place i and j - i > 1 then its a global inversion and false should be returned.\\nBy taking advantage of 0 to N - 1 numbers.....if a number is at an index where difference of itself with that index is greater than 1 means there is a global inversion (which is not local inversion).\\n**Intuition :**\\nFor the explained algorithm, the intuition is that if  *\"difference of itself with that index is greater than 1 means there is a global inversion (which is not local inversion)\"* is that if this is so, then either the number is greater than index by 2 or more ....or less than index by 2 or more...which means if out number is greater than index then number equal to that index is somewhere at the right of our number which means a global inversion, and if our number is smaller then number  equal to that index is somwhere at the left of present number which means a global inversion.\\n```\\nbool isIdealPermutation(vector<int>& A) {\\n\\tfor (int i = 0, size = A.size(); i < size; i++) {\\n\\t\\tif (abs(A[i] - i) > 1)  return false;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isIdealPermutation(vector<int>& A) {\\n\\tfor (int i = 0, size = A.size(); i < size; i++) {\\n\\t\\tif (abs(A[i] - i) > 1)  return false;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 407433,
                "title": "c-simple-o-n-solution",
                "content": "Since all **local** inversions are also **global** inversions, we have to check if there are any global inversions that are **NOT** local inversions.\\nThis occurs exactly when **A[i] < max(A[0 , .. , A[i - 2])** for some valid index **i**.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int n = A.size();\\n        int mx = A[0];\\n        \\n        for(int i = 2; i < n; ++i) {\\n            if(A[i] < mx)\\n                return false;\\n            mx = max(mx, A[i - 1]);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int n = A.size();\\n        int mx = A[0];\\n        \\n        for(int i = 2; i < n; ++i) {\\n            if(A[i] < mx)\\n                return false;\\n            mx = max(mx, A[i - 1]);\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113651,
                "title": "python-easy-understanding-solution",
                "content": "Global >= Local. The \"=\" occurs only when each number i is at i-1, i, or i + 1\\n\\n```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i in xrange(len(A)):\\n            if abs(A[i] - i) >= 2: return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isIdealPermutation(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i in xrange(len(A)):\\n            if abs(A[i] - i) >= 2: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874173,
                "title": "python-100-faster-two-approaches",
                "content": "**Brute Forece Appoach: O(nlogn) Time Complexity It will give TLE**\\n\\n```\\nclass Solution:\\n    def isIdealPermutation(self, arr: List[int]) -> bool:\\n        n=len(arr)\\n        l=0\\n        for i in range(n-1):\\n            if arr[i]>arr[i+1]:\\n                l+=1\\n                if l>1:\\n                    return False\\n        g=self.mergeSort(arr,0,n-1)\\n        return g==l\\n    \\n    def merge(self,arr,l,m,r):\\n        left=l\\n        right=m+1\\n        temp=[]\\n        c=0\\n        while left<=m and right<=r:\\n            if arr[left]<=arr[right]:\\n                temp.append(arr[left])\\n                left+=1\\n            else:\\n                temp.append(arr[right])\\n                c+=m-left+1\\n                right+=1\\n        while left<=m:\\n            temp.append(arr[left])\\n            left+=1\\n        while right<=r:\\n            temp.append(arr[right])\\n            right+=1\\n        for i in range(l,r+1):\\n            arr[i]=temp[i-l]\\n        return c\\n            \\n    def mergeSort(self,arr,l,r):\\n        c=0\\n        if l>=r:\\n            return c\\n        m=(l+r)>>1\\n        c+=self.mergeSort(arr,l,m)\\n        c+=self.mergeSort(arr,m+1,r)\\n        c+=self.merge(arr,l,m,r)\\n        return c\\n```\\n\\n**Optimized Approach: O(n) Time Complexity**\\n\\n**The algorithm iterates through each element of the input array arr using the enumerate function. For each element, it calculates the absolute difference between its index and its value: abs(ind - val).**\\n\\n**If this absolute difference is greater than 1, it means that the element is not in its correct position according to the \"ideal permutation\" definition, because it is either more than one position ahead or behind its actual index. In other words, this element would contribute to both a global inversion and a local inversion, which would make the permutation not ideal.**\\n\\n**Therefore, if the absolute difference abs(ind - val) is greater than 1 for any element in the array, the function immediately returns False, indicating that the given permutation is not an ideal permutation.**\\n\\n**If the loop completes without finding any violations (i.e., all elements have an absolute difference of at most 1 between their index and value), the function returns True, indicating that the permutation is an ideal permutation.**\\n\\n**In essence, this approach checks for violations of the \"ideal permutation\" condition by comparing each element\\'s index to its value, and if any element is more than one position away from its correct index, the permutation is not ideal.**\\n\\n**While this approach is simpler and shorter than the previous ones, it is still a valid way to determine whether a permutation is an ideal permutation.**\\n\\n```\\nclass Solution:\\n    def isIdealPermutation(self, arr: List[int]) -> bool:\\n        for ind,val in enumerate(arr):\\n            if abs(ind-val)>1:\\n                return False\\n        return True\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, arr: List[int]) -> bool:\\n        n=len(arr)\\n        l=0\\n        for i in range(n-1):\\n            if arr[i]>arr[i+1]:\\n                l+=1\\n                if l>1:\\n                    return False\\n        g=self.mergeSort(arr,0,n-1)\\n        return g==l\\n    \\n    def merge(self,arr,l,m,r):\\n        left=l\\n        right=m+1\\n        temp=[]\\n        c=0\\n        while left<=m and right<=r:\\n            if arr[left]<=arr[right]:\\n                temp.append(arr[left])\\n                left+=1\\n            else:\\n                temp.append(arr[right])\\n                c+=m-left+1\\n                right+=1\\n        while left<=m:\\n            temp.append(arr[left])\\n            left+=1\\n        while right<=r:\\n            temp.append(arr[right])\\n            right+=1\\n        for i in range(l,r+1):\\n            arr[i]=temp[i-l]\\n        return c\\n            \\n    def mergeSort(self,arr,l,r):\\n        c=0\\n        if l>=r:\\n            return c\\n        m=(l+r)>>1\\n        c+=self.mergeSort(arr,l,m)\\n        c+=self.mergeSort(arr,m+1,r)\\n        c+=self.merge(arr,l,m,r)\\n        return c\\n```\n```\\nclass Solution:\\n    def isIdealPermutation(self, arr: List[int]) -> bool:\\n        for ind,val in enumerate(arr):\\n            if abs(ind-val)>1:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649941,
                "title": "to-avoid-tle-declare-temp-vector-as-globally",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> temp; // to avoid TLE Declare here. So it\\'s not intialized for every merge call\\n\\n    ll cnt = 0;\\n    void merge(vector<int>& v, ll low, ll mid, ll high)\\n    {\\n        temp.clear();\\n        \\n        ll left = low;\\n        ll right = mid+1;\\n        \\n        while(left <= mid and right <= high)\\n        {\\n            if(v[left] <= v[right])\\n            {\\n                temp.push_back(v[left]);\\n                left++;\\n            }\\n            else\\n            {\\n                temp.push_back(v[right]);\\n                cnt += (mid - left + 1);\\n                right++;\\n            }\\n        }\\n        \\n        while(left <= mid)\\n        {\\n            temp.push_back(v[left]);\\n            left++;\\n        }\\n        \\n        while(right <= high)\\n        {\\n            temp.push_back(v[right]);\\n            right++;\\n        }\\n        \\n        for(int i=low; i<=high; i++)\\n        {\\n            v[i] =  temp[i-low];\\n        }\\n    }\\n    \\n    void mergeSort(vector<int>& v, ll low, ll high)\\n    {        \\n        if(low<high)\\n        {\\n            ll mid = low + (high - low)/2;\\n            \\n            mergeSort(v, low, mid);\\n            mergeSort(v,mid+1, high);\\n            \\n            merge(v, low, mid, high);\\n        }\\n        \\n    }\\n    bool isIdealPermutation(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        int n2 = 0; // Number of local inversions\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(nums[i] > nums[i+1])\\n                n2++;\\n        }\\n\\n        mergeSort(nums, 0, n-1);        \\n        int n1 = cnt; // Number of global inversions\\n\\n        cout<<n1<< \" \"<< n2<<endl;\\n        return n1 == n2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> temp; // to avoid TLE Declare here. So it\\'s not intialized for every merge call\\n\\n    ll cnt = 0;\\n    void merge(vector<int>& v, ll low, ll mid, ll high)\\n    {\\n        temp.clear();\\n        \\n        ll left = low;\\n        ll right = mid+1;\\n        \\n        while(left <= mid and right <= high)\\n        {\\n            if(v[left] <= v[right])\\n            {\\n                temp.push_back(v[left]);\\n                left++;\\n            }\\n            else\\n            {\\n                temp.push_back(v[right]);\\n                cnt += (mid - left + 1);\\n                right++;\\n            }\\n        }\\n        \\n        while(left <= mid)\\n        {\\n            temp.push_back(v[left]);\\n            left++;\\n        }\\n        \\n        while(right <= high)\\n        {\\n            temp.push_back(v[right]);\\n            right++;\\n        }\\n        \\n        for(int i=low; i<=high; i++)\\n        {\\n            v[i] =  temp[i-low];\\n        }\\n    }\\n    \\n    void mergeSort(vector<int>& v, ll low, ll high)\\n    {        \\n        if(low<high)\\n        {\\n            ll mid = low + (high - low)/2;\\n            \\n            mergeSort(v, low, mid);\\n            mergeSort(v,mid+1, high);\\n            \\n            merge(v, low, mid, high);\\n        }\\n        \\n    }\\n    bool isIdealPermutation(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        int n2 = 0; // Number of local inversions\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(nums[i] > nums[i+1])\\n                n2++;\\n        }\\n\\n        mergeSort(nums, 0, n-1);        \\n        int n1 = cnt; // Number of global inversions\\n\\n        cout<<n1<< \" \"<< n2<<endl;\\n        return n1 == n2;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3209676,
                "title": "easy-java-solution-using-merge-sort",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int n= nums.length;\\n\\n        //  Counting local inversions\\n        int li= 0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                li++;\\n            }\\n        }\\n\\n        //  Counting the global inversions (Using merge sort)\\n        int gi= mergeSort(nums, 0, n-1);\\n\\n        if(gi == li){\\n            return true;\\n        } \\n        else{\\n            return false;\\n        }\\n    }\\n\\n    public int mergeSort(int[] nums, int left, int right){\\n        if(left>= right){\\n            return 0;\\n        }\\n        int ans= 0;\\n\\n        int middle= (left+right)/2;\\n        ans+= mergeSort(nums, left, middle);\\n        ans+= mergeSort(nums, middle+1, right);\\n\\n        ans+= merge(nums, left, middle, right);\\n\\n        return ans;\\n    }\\n\\n    public int merge(int[] nums, int left, int middle, int right){\\n        int tempAns= 0;\\n\\n        int[] temp1= Arrays.copyOfRange(nums, left, middle+1);\\n        int[] temp2= Arrays.copyOfRange(nums, middle+1, right+1);\\n\\n        //  Merging the two arrays\\n        int n1= temp1.length;\\n        int n2= temp2.length;\\n        int p1= 0;\\n        int p2= 0;\\n        int originalPointer= left;\\n\\n        while(p1<n1 && p2<n2){\\n            if(temp1[p1] <= temp2[p2]){\\n                nums[originalPointer] = temp1[p1];\\n                p1++;\\n                originalPointer++;\\n            }\\n            else{\\n                tempAns+= (n1-p1);\\n                nums[originalPointer]= temp2[p2];\\n                p2++;\\n                originalPointer++;\\n            }\\n        }\\n\\n        while(p1<n1){\\n            nums[originalPointer]= temp1[p1];\\n            p1++;\\n            originalPointer++;\\n        }\\n\\n        while(p2<n2){\\n            nums[originalPointer]= temp2[p2];\\n            p2++;\\n            originalPointer++;\\n        }\\n\\n        return tempAns;\\n    }\\n}\\n```\\n![please-upvote.jpg](https://assets.leetcode.com/users/images/4a553c1c-910e-41d1-8594-eabdc1b48da6_1676892520.206923.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int n= nums.length;\\n\\n        //  Counting local inversions\\n        int li= 0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                li++;\\n            }\\n        }\\n\\n        //  Counting the global inversions (Using merge sort)\\n        int gi= mergeSort(nums, 0, n-1);\\n\\n        if(gi == li){\\n            return true;\\n        } \\n        else{\\n            return false;\\n        }\\n    }\\n\\n    public int mergeSort(int[] nums, int left, int right){\\n        if(left>= right){\\n            return 0;\\n        }\\n        int ans= 0;\\n\\n        int middle= (left+right)/2;\\n        ans+= mergeSort(nums, left, middle);\\n        ans+= mergeSort(nums, middle+1, right);\\n\\n        ans+= merge(nums, left, middle, right);\\n\\n        return ans;\\n    }\\n\\n    public int merge(int[] nums, int left, int middle, int right){\\n        int tempAns= 0;\\n\\n        int[] temp1= Arrays.copyOfRange(nums, left, middle+1);\\n        int[] temp2= Arrays.copyOfRange(nums, middle+1, right+1);\\n\\n        //  Merging the two arrays\\n        int n1= temp1.length;\\n        int n2= temp2.length;\\n        int p1= 0;\\n        int p2= 0;\\n        int originalPointer= left;\\n\\n        while(p1<n1 && p2<n2){\\n            if(temp1[p1] <= temp2[p2]){\\n                nums[originalPointer] = temp1[p1];\\n                p1++;\\n                originalPointer++;\\n            }\\n            else{\\n                tempAns+= (n1-p1);\\n                nums[originalPointer]= temp2[p2];\\n                p2++;\\n                originalPointer++;\\n            }\\n        }\\n\\n        while(p1<n1){\\n            nums[originalPointer]= temp1[p1];\\n            p1++;\\n            originalPointer++;\\n        }\\n\\n        while(p2<n2){\\n            nums[originalPointer]= temp2[p2];\\n            p2++;\\n            originalPointer++;\\n        }\\n\\n        return tempAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101101,
                "title": "mergesort-approach-java-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n * logn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    static int ans;\\n    private static void merge(int arr[], int start, int mid, int end) {\\n        int temp[] = new int[end - start + 1];\\n        int k = 0;\\n        int l = start, r = mid + 1;\\n        for (;l <= mid && r <= end;) {\\n            if (arr[l] <= arr[r])\\n                temp[k++] = arr[l++];\\n            else{\\n                ans += mid - l + 1;   \\n                temp[k++] = arr[r++];\\n            }\\n        }\\n\\n        for (;l <= mid;)\\n            temp[k++] = arr[l++];\\n\\n        for (;r <= end;)\\n            temp[k++] = arr[r++];\\n\\n        for (int i = start, j = 0; i <= end; ++i, ++j) {\\n            arr[i] = temp[j];\\n        }\\n    }\\n\\n    public static void mergeSort(int arr[], int start, int end) {\\n        if (start >= end)\\n            return;\\n        int mid = (start + end) / 2;\\n\\n        mergeSort(arr, start, mid);\\n        mergeSort(arr, mid + 1, end);\\n\\n        merge(arr, start, mid, end);\\n    }\\n\\n    public static int countInversions(int arr[]){\\n        ans = 0;\\n        mergeSort(arr, 0, arr.length - 1);\\n        return ans;\\n    }\\n\\n    int localInversions(int arr[]){\\n        int cnt = 0;\\n        for(int i = 0;i < arr.length - 1;i++){\\n            if(arr[i] > arr[i + 1]) cnt++;\\n        }\\n        return cnt;\\n    }\\n    public boolean isIdealPermutation(int[] nums) {\\n        return localInversions(nums) == countInversions(nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    static int ans;\\n    private static void merge(int arr[], int start, int mid, int end) {\\n        int temp[] = new int[end - start + 1];\\n        int k = 0;\\n        int l = start, r = mid + 1;\\n        for (;l <= mid && r <= end;) {\\n            if (arr[l] <= arr[r])\\n                temp[k++] = arr[l++];\\n            else{\\n                ans += mid - l + 1;   \\n                temp[k++] = arr[r++];\\n            }\\n        }\\n\\n        for (;l <= mid;)\\n            temp[k++] = arr[l++];\\n\\n        for (;r <= end;)\\n            temp[k++] = arr[r++];\\n\\n        for (int i = start, j = 0; i <= end; ++i, ++j) {\\n            arr[i] = temp[j];\\n        }\\n    }\\n\\n    public static void mergeSort(int arr[], int start, int end) {\\n        if (start >= end)\\n            return;\\n        int mid = (start + end) / 2;\\n\\n        mergeSort(arr, start, mid);\\n        mergeSort(arr, mid + 1, end);\\n\\n        merge(arr, start, mid, end);\\n    }\\n\\n    public static int countInversions(int arr[]){\\n        ans = 0;\\n        mergeSort(arr, 0, arr.length - 1);\\n        return ans;\\n    }\\n\\n    int localInversions(int arr[]){\\n        int cnt = 0;\\n        for(int i = 0;i < arr.length - 1;i++){\\n            if(arr[i] > arr[i + 1]) cnt++;\\n        }\\n        return cnt;\\n    }\\n    public boolean isIdealPermutation(int[] nums) {\\n        return localInversions(nums) == countInversions(nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356060,
                "title": "c-tc-o-n-4-line-of-code",
                "content": "```\\n/*\\nApproach :-> Given nums are from 0 to n-1 so to make local and global count equal  it must have swapping \\nbetween adjacent element in sorted array so for any element at index if it is either swapped with i or i+1 or i-1 this is\\nonly condition when both are equal else it got swapped with j > i+1 or j<i-1 then global count become greater \\nthan local count\\n*/\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==i || nums[i]==i-1 || nums[i]==i+1) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\nApproach :-> Given nums are from 0 to n-1 so to make local and global count equal  it must have swapping \\nbetween adjacent element in sorted array so for any element at index if it is either swapped with i or i+1 or i-1 this is\\nonly condition when both are equal else it got swapped with j > i+1 or j<i-1 then global count become greater \\nthan local count\\n*/\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==i || nums[i]==i-1 || nums[i]==i+1) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273118,
                "title": "if-someone-is-interested-in-merge-sort-and-making-a-medium-ques-hard-lol",
                "content": "\\n\\t\\tclass Solution {\\n\\tpublic:\\n    \\n    //1 2 3  // 0 1 2\\n\\n    long long  merge(vector<int>&nums,vector<int>&temp,int low,int mid,int high){\\n        \\n        if(low>=high)\\n            return 0;\\n        \\n        \\n        long long res=0;\\n        long long j=mid;\\n        long long k=low;\\n        long long i=low;\\n        while(j<=high && i<mid){\\n            \\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }\\n            else{\\n                temp[k++]=nums[j++];\\n                res+=(mid-i);\\n            }\\n        }\\n        \\n        while(i<mid){\\n            temp[k++]=nums[i++];\\n        }\\n        \\n        while(j<=high){\\n            temp[k++]=nums[j++];\\n        }\\n        \\n        \\n        for (int m = low; m <= high; m++)\\n\\t\\tnums[m] = temp[m];\\n        \\n        \\n        return res;\\n    }\\n    \\n    long long mergeSort(vector<int>&nums,vector<int>&temp,int low,int high){\\n        \\n        if(low>=high)\\n            return 0;\\n        \\n        long long mid=low+(high-low)/2;\\n        \\n        long long left=mergeSort(nums,temp,low,mid);\\n        long long  right=mergeSort(nums,temp,mid+1,high);\\n        \\n        return left+right+merge(nums,temp,low,mid+1,high);\\n        \\n    }\\n    \\n    int countInversion(vector<int>&nums){\\n        \\n        vector<int>temp(nums.size());\\n        return mergeSort(nums,temp,0,nums.size()-1);\\n        \\n    }\\n    \\n    bool isIdealPermutation(vector<int>& nums) {\\n     \\n        int LI=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            if(nums[i]>nums[i+1])\\n                LI++;\\n            \\n        }\\n        \\n        int GI=countInversion(nums);\\n        return GI==LI;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    //1 2 3  // 0 1 2\\n\\n    long long  merge(vector<int>&nums,vector<int>&temp,int low,int mid,int high){\\n        \\n        if(low>=high)\\n            return 0;\\n        \\n        \\n        long long res=0;\\n        long long j=mid;\\n        long long k=low;\\n        long long i=low;\\n        while(j<=high && i<mid){\\n            \\n            if(nums[i]<=nums[j]){\\n                temp[k++]=nums[i++];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2128215,
                "title": "java-1ms-few-lines",
                "content": "~~~\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int max = nums[0];\\n        for(int i = 2; i < nums.length; ++i){\\n            max = Math.max(max, nums[i-2]);\\n            if(max>nums[i]) return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        int max = nums[0];\\n        for(int i = 2; i < nums.length; ++i){\\n            max = Math.max(max, nums[i-2]);\\n            if(max>nums[i]) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2122704,
                "title": "broken-test-cases-with-python",
                "content": "The O(N) solution TLE, both official solution and solution from lee215.",
                "solutionTags": [],
                "code": "The O(N) solution TLE, both official solution and solution from lee215.",
                "codeTag": "Unknown"
            },
            {
                "id": 2012451,
                "title": "java-easy-to-understand",
                "content": "class Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        for(int i =0 ;i < nums.length; i++){\\n            if(Math.abs(nums[i]-i)>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        for(int i =0 ;i < nums.length; i++){\\n            if(Math.abs(nums[i]-i)>1){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2004334,
                "title": "c-easy-to-understand-maths",
                "content": "APPROACH 1: ex:A[1,20,5,3,4] -GI = 5>3>4 && local inversion is not satifying the condition A[i] > A[i + 1] - 5>3 but 3 not greater than 4 .\\n\\n\\n```\\n  class Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n       \\n       \\n        int n = nums.size();\\n        int maxi= INT_MIN;\\n        for(int i=0;i<n-2;i++){\\n            maxi=max(maxi,nums[i]);\\n            if(maxi > nums[i+2]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\t\\t}\\n\\t\\t}\\n       \\n```\\n    APPROACH 2: \\nGlobal Inversion : A[i] > A[j] => 0<=i<j<N\\nLocal Inversion: A[i] > A[j] => j = i+1\\n\\nSo from above definition we see that all local inversion is global inversion but not vice versa always.\\nWe need to find if global inversion == local inversion. \\n\\nWhen this happens (global inversion == local inversion)? => Only when every global inversion is a local inversion\\n\\nWhen inversion happens ? => When an element is displaced from its original position in sorted array\\n\\nWhen an element is displaced 1 distance from its original position it makes only 1 global and local inversion ([1,0,2])\\n\\twhich makes global inversion == local inversion.\\n    \\nIf an element is displaced K>1 distance from its original position then it makes 1 local inversion but K global inversions ([1,2,0])\\n    which makes global inversion != local inversion. \\n\\nSo it is sufficient to find a global inversion which is not local inversion. \\nSo we need to find if any element is displaced more than 1 distance from its original position in sorted array.\\n\\nElement Displacement distance = abs(A[i] - i).\\n```\\n  class Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n\\t    int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(abs(nums[i]-i)>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "```\\n  class Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n       \\n       \\n        int n = nums.size();\\n        int maxi= INT_MIN;\\n        for(int i=0;i<n-2;i++){\\n            maxi=max(maxi,nums[i]);\\n            if(maxi > nums[i+2]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\t\\t}\\n\\t\\t}\\n       \\n```\n```\\n  class Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n\\t    int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(abs(nums[i]-i)>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889872,
                "title": "tle",
                "content": "I have submitted 4 solutions all are O(n), but only the final one works (better than 5%). Is there a more optimal solution Im missing, is there a reason that last one works and the other 3 dont?\\n\\nSolution 1:\\n\\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        currMax = float(\\'-inf\\')\\n        willBeNextMax = float(\\'-inf\\')\\n        for num in nums:\\n            if num < currMax:\\n                return False\\n            else:\\n                currMax = willBeNextMax\\n                willBeNextMax = max(willBeNextMax, num)\\n        return True\\n```\\n\\nSolution 2:\\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] != i:\\n                if nums[i+1] != i or nums[i] != i+1:\\n                    return False\\n                else:\\n                    i+=1\\n            i+=1\\n                \\n        return True\\n```\\n\\nSolution 3:\\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        for i, a in enumerate(nums):\\n            if (abs(a - i) > 1):\\n                return False\\n        \\n        return True\\n```\\n\\nFinal Working Solution (basically just iterated backwards instead of forwards):\\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[i]-i) > 1:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        currMax = float(\\'-inf\\')\\n        willBeNextMax = float(\\'-inf\\')\\n        for num in nums:\\n            if num < currMax:\\n                return False\\n            else:\\n                currMax = willBeNextMax\\n                willBeNextMax = max(willBeNextMax, num)\\n        return True\\n```\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] != i:\\n                if nums[i+1] != i or nums[i] != i+1:\\n                    return False\\n                else:\\n                    i+=1\\n            i+=1\\n                \\n        return True\\n```\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        for i, a in enumerate(nums):\\n            if (abs(a - i) > 1):\\n                return False\\n        \\n        return True\\n```\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[i]-i) > 1:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789212,
                "title": "java-short-and-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        for(int i =0 ;i < nums.length; i++){\\n            if(Math.abs(nums[i]-i)>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nConsidering the array is a permutaion and that every local inversion is also a global inversion we can try to find if there is at least one global inversion that is not a local one.\\nlets try to understand how a local inversion only permutation looks like.\\nfor the i\\'th number there are i-1 numbers smaller than it and the rest are bigger if the i\\'th number is in the i\\'th posion that means that all the numbers before him are smaller than it except for one at most, the same logic applays for the case that the i\\'th number is in the i-1 position and the i+1 position.\\nif the i\\'th number is in any different position, say the i-2, thet means that at least two numbers smaller than it are located after him wich means we have at least one global inversion.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        for(int i =0 ;i < nums.length; i++){\\n            if(Math.abs(nums[i]-i)>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752847,
                "title": "best-solution-for-this-question-using-set-in-c-very-simple-approach",
                "content": "class Solution {\\npublic:\\n\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int local = 0 , global = 0;\\n        int n = nums.size();\\n        for(int i=0 ; i<n-1 ; i++){\\n            if(nums[i] > nums[i+1])local++;\\n        }\\n        set<int>st;\\n        for(int i=n-1 ; i>=0 ; i--){\\n            st.insert(nums[i]);\\n            auto it = st.find(nums[i]);\\n            int ct=0;\\n            for( ; it != st.begin() ; it--){\\n                ct++;\\n            }\\n            global += ct;\\n            if(global > local)return false;\\n        }\\n        return global == local;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isIdealPermutation(vector<int>& nums) {\\n        int local = 0 , global = 0;\\n        int n = nums.size();\\n        for(int i=0 ; i<n-1 ; i++){\\n            if(nums[i] > nums[i+1])local++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1618568,
                "title": "my-python-solution",
                "content": "**Brute force solution**\\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        g=0\\n        l=0\\n        for i in range(len(nums) ) :\\n            for j in range(i+1, len(nums))  :\\n                if nums[i]>nums[j]:\\n                    g+=1\\n        for i in range(len(nums)-1):\\n            if nums[i]>nums[i+1]:\\n                l+=1\\n        return g==l\\n\\n```\\n**Optimized solution**\\n\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        cmax = 0\\n        for i in range(len(A) - 2):\\n            cmax = max(cmax, A[i])\\n            if cmax > A[i + 2]:\\n                return False\\n        return True\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        g=0\\n        l=0\\n        for i in range(len(nums) ) :\\n            for j in range(i+1, len(nums))  :\\n                if nums[i]>nums[j]:\\n                    g+=1\\n        for i in range(len(nums)-1):\\n            if nums[i]>nums[i+1]:\\n                l+=1\\n        return g==l\\n\\n```\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        cmax = 0\\n        for i in range(len(A) - 2):\\n            cmax = max(cmax, A[i])\\n            if cmax > A[i + 2]:\\n                return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602891,
                "title": "failing-on-0-2-3-1-c",
                "content": "```\\nclass Solution {\\n    int merge(vector<int> &arr,int left,int mid,int right)\\n    {\\n    int i = left, j = mid, k = 0;\\n    int invCount = 0;\\n    vector<int> temp(right - left + 1);\\n\\n    while ((i < mid) && (j <= right)){\\n        if (arr[i] <= arr[j]){\\n            temp[k] = arr[i];\\n            ++k;\\n            ++i;\\n        }\\n        else{\\n            temp[k] = arr[j];\\n            invCount += (mid - i);\\n            ++k;\\n            ++j;\\n        }\\n    }\\n\\n    while (i < mid){\\n        temp[k] = arr[i];\\n        ++k;\\n        ++i;\\n    }\\n\\n    while (j <= right){\\n        temp[k] = arr[j];\\n        ++k;\\n        ++j;\\n    }\\n\\n    for (i = left, k = 0; i <= right; i++, k++){\\n        arr[i] = temp[k];\\n    }\\n\\n    return invCount;\\n    }\\n    int mergeSort(vector<int> arr,int low,int high)\\n    {\\n        int inversions=0;\\n        if(high>low)\\n        {\\n            int mid=low + (high - low) / 2;\\n            inversions=mergeSort(arr,low,mid)+mergeSort(arr,mid+1,high);\\n            \\n            inversions+=merge(arr,low,mid+1,high);\\n            \\n        }\\n        return inversions;\\n    }\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        int ginversions=mergeSort(nums,0,nums.size()-1);\\n        int linversions=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n                linversions+=1;\\n        }\\n        cout<<ginversions<<\" \"<<linversions;\\n        return ginversions==linversions;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int merge(vector<int> &arr,int left,int mid,int right)\\n    {\\n    int i = left, j = mid, k = 0;\\n    int invCount = 0;\\n    vector<int> temp(right - left + 1);\\n\\n    while ((i < mid) && (j <= right)){\\n        if (arr[i] <= arr[j]){\\n            temp[k] = arr[i];\\n            ++k;\\n            ++i;\\n        }\\n        else{\\n            temp[k] = arr[j];\\n            invCount += (mid - i);\\n            ++k;\\n            ++j;\\n        }\\n    }\\n\\n    while (i < mid){\\n        temp[k] = arr[i];\\n        ++k;\\n        ++i;\\n    }\\n\\n    while (j <= right){\\n        temp[k] = arr[j];\\n        ++k;\\n        ++j;\\n    }\\n\\n    for (i = left, k = 0; i <= right; i++, k++){\\n        arr[i] = temp[k];\\n    }\\n\\n    return invCount;\\n    }\\n    int mergeSort(vector<int> arr,int low,int high)\\n    {\\n        int inversions=0;\\n        if(high>low)\\n        {\\n            int mid=low + (high - low) / 2;\\n            inversions=mergeSort(arr,low,mid)+mergeSort(arr,mid+1,high);\\n            \\n            inversions+=merge(arr,low,mid+1,high);\\n            \\n        }\\n        return inversions;\\n    }\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        int ginversions=mergeSort(nums,0,nums.size()-1);\\n        int linversions=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n                linversions+=1;\\n        }\\n        cout<<ginversions<<\" \"<<linversions;\\n        return ginversions==linversions;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1493701,
                "title": "o-n-java-solution-that-beats-100-by-1ms-explanation-given",
                "content": "Intuition: Every local inversion is also a global inversion. All we need to find is a global inversion that is not a local inversion.\\n\\nSo we keep a array dp where:\\ndp[i] = max element in array from arr[0] to arr[i]\\n\\nNow just check if a global inversion is possible which is not a local inversion i.e.\\n\\tdp[i-2] > arr[i]\\n\\t\\nPlease upvote if helpful!\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] arr) {\\n        \\n        //If only one element in array both inversions are impossible\\n        if(arr.length==1)\\n            return true;\\n        \\n        int n = arr.length;\\n        \\n        //dp[i] stores the max element from arr[0] to arr[i]\\n        int[] dp = new int[n];\\n        dp[0] = arr[0];\\n        \\n        for(int i=1;i<n;i++){\\n            dp[i] = Math.max(dp[i-1], arr[i]);\\n            \\n            //checking if it is possible to have atleast one global inversion\\n            //from arr[i] and any element from arr[0] to arr[i-2]\\n            if(i-2>=0 && dp[i-2] > arr[i])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] arr) {\\n        \\n        //If only one element in array both inversions are impossible\\n        if(arr.length==1)\\n            return true;\\n        \\n        int n = arr.length;\\n        \\n        //dp[i] stores the max element from arr[0] to arr[i]\\n        int[] dp = new int[n];\\n        dp[0] = arr[0];\\n        \\n        for(int i=1;i<n;i++){\\n            dp[i] = Math.max(dp[i-1], arr[i]);\\n            \\n            //checking if it is possible to have atleast one global inversion\\n            //from arr[i] and any element from arr[0] to arr[i-2]\\n            if(i-2>=0 && dp[i-2] > arr[i])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447617,
                "title": "segment-tree-o-nlogn-approach",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll query(ll st[],ll ind,ll tl,ll tr,ll ql,ll qr){\\n        if(tl>tr || ql>tr || qr<tl)\\n            return 0;\\n        if(tl>=ql && qr>=tr)\\n            return st[ind];\\n        ll m=(tl+tr)/2;\\n        ll l=ind<<1;\\n        return query(st,l,tl,m,ql,qr)+query(st,l+1,m+1,tr,ql,qr);\\n    }\\n    \\n    void update(ll st[],ll tind,ll tl,ll tr,ll ind){\\n        if(tl>tr)\\n            return;\\n        if(tl==tr){\\n            st[tind]++;\\n            return;\\n        }\\n        ll m=(tl+tr)/2;\\n        ll l=tind<<1;\\n        if(ind<=m)\\n            update(st,l,tl,m,ind);\\n        else\\n            update(st,l+1,m+1,tr,ind);\\n        st[tind]=st[l]+st[l+1];\\n    }\\n    \\n    bool isIdealPermutation(vector<int>& a) {\\n        ll i,n=a.size();\\n        ll loc=0,st[4*n+10],glob=0;\\n        memset(st,0,sizeof(st));\\n        for(i=0;i<n;i++){\\n            if(i+1<n && a[i]>a[i+1])\\n                loc++;\\n            ll q=query(st,1,1,n,a[i]+1,n);\\n            glob+=q;\\n            update(st,1,1,n,a[i]+1);\\n        }\\n        return glob==loc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll query(ll st[],ll ind,ll tl,ll tr,ll ql,ll qr){\\n        if(tl>tr || ql>tr || qr<tl)\\n            return 0;\\n        if(tl>=ql && qr>=tr)\\n            return st[ind];\\n        ll m=(tl+tr)/2;\\n        ll l=ind<<1;\\n        return query(st,l,tl,m,ql,qr)+query(st,l+1,m+1,tr,ql,qr);\\n    }\\n    \\n    void update(ll st[],ll tind,ll tl,ll tr,ll ind){\\n        if(tl>tr)\\n            return;\\n        if(tl==tr){\\n            st[tind]++;\\n            return;\\n        }\\n        ll m=(tl+tr)/2;\\n        ll l=tind<<1;\\n        if(ind<=m)\\n            update(st,l,tl,m,ind);\\n        else\\n            update(st,l+1,m+1,tr,ind);\\n        st[tind]=st[l]+st[l+1];\\n    }\\n    \\n    bool isIdealPermutation(vector<int>& a) {\\n        ll i,n=a.size();\\n        ll loc=0,st[4*n+10],glob=0;\\n        memset(st,0,sizeof(st));\\n        for(i=0;i<n;i++){\\n            if(i+1<n && a[i]>a[i+1])\\n                loc++;\\n            ll q=query(st,1,1,n,a[i]+1,n);\\n            glob+=q;\\n            update(st,1,1,n,a[i]+1);\\n        }\\n        return glob==loc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429760,
                "title": "short-easy-explanation-c",
                "content": "The idea here is simple:\\nEvery local inversion is a global inversion but every global inversion is not always a local inversion:\\n[1,2,0] in this case:\\nlocal inversion is: (2,0)\\nglobal inversion are (1,0) && (2,0)\\nso when are these two not equal when we find a global inversion that is not a local inversion.\\nlets say we are iterating the arr and we find A[i] which is smaller than max(A[0],A[1],A[2],A[3],...A[i-2]) in this case we can be sure that we found an inversion that is global but not local becuase local always follows the relationship strictly--> A[i-1]>A[i]. \\n\\nbool isIdealPermutation(vector<int>& nums) {\\n        \\n\\t\\tint maxi=INT_MIN;\\n        for(int i=2;i<nums.size();++i)\\n        {\\n            if( nums[i-2]>maxi)\\n            {\\n                maxi=nums[i-2];\\n            }\\n            if(maxi>nums[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "The idea here is simple:\\nEvery local inversion is a global inversion but every global inversion is not always a local inversion:\\n[1,2,0] in this case:\\nlocal inversion is: (2,0)\\nglobal inversion are (1,0) && (2,0)\\nso when are these two not equal when we find a global inversion that is not a local inversion.\\nlets say we are iterating the arr and we find A[i] which is smaller than max(A[0],A[1],A[2],A[3],...A[i-2]) in this case we can be sure that we found an inversion that is global but not local becuase local always follows the relationship strictly--> A[i-1]>A[i]. \\n\\nbool isIdealPermutation(vector<int>& nums) {\\n        \\n\\t\\tint maxi=INT_MIN;\\n        for(int i=2;i<nums.size();++i)\\n        {\\n            if( nums[i-2]>maxi)\\n            {\\n                maxi=nums[i-2];\\n            }\\n            if(maxi>nums[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1420154,
                "title": "accepted-c-trie-solution-in-o-n",
                "content": "Trie based solution works in O(Nx32)=O(N) \\n\\nThere is another very shorter solution for this specific question  but that solution works for if numbers are permutation (1 to n-1) ( as mentioned in this question).\\n\\nBut  this Trie based solution  works  even if number are random  in vector or array and i have tested this solution on SPOJ (inversion count) problem.\\n\\n```\\n\\nstruct TrieNode {\\n\\n    TrieNode *left;\\n    TrieNode *right;\\n    int cnt;\\n\\n    TrieNode()\\n    {\\n        left = NULL;\\n        right = NULL;\\n        cnt = 0;\\n    }\\n\\n};\\n\\n\\n\\n\\n\\nclass Trie {\\n\\nprivate:\\n    TrieNode * root;\\n\\npublic:\\n\\n    Trie() {\\n\\n        root = new TrieNode();\\n    }\\n\\n\\n\\n    void insert(int n) {\\n\\n        TrieNode *curr = root;\\n\\n        for (int i = 31; i >= 0; --i)\\n        {\\n\\n            int bit = (n >> i) & 1;\\n\\n            if (bit == 1)\\n            {\\n                if (curr->right == NULL)\\n                    curr->right = new TrieNode();\\n\\n                curr = curr->right;\\n            }\\n            else\\n            {\\n                if (curr->left == NULL)\\n                    curr->left = new TrieNode();\\n\\n                curr = curr->left;\\n            }\\n\\n            curr->cnt++;\\n\\n        }\\n\\n\\n    }\\n\\n\\n\\n    int no_of_smaller_element(int n) {\\n\\n        TrieNode *curr = root;\\n\\n        int answer = 0;\\n\\n        for (int i = 31; i >= 0; --i)\\n        {\\n\\n            int bit = (n >> i) & 1;\\n\\n            if (bit == 1) {\\n\\n                /* add all the definetly smaller numbers */\\n\\n                if (curr->left != NULL)\\n                    answer += curr->left->cnt;\\n\\n                /* Check  further weather it is smaller or not  */\\n\\n                if (curr->right != NULL)\\n                    curr = curr->right;\\n\\n            }\\n            else\\n            {\\n                if (curr->left != NULL)\\n                    curr = curr->left ;\\n\\n            }\\n\\n        }\\n\\n        answer += curr->cnt;\\n\\n        return answer;\\n    }\\n\\n};\\n\\n\\n\\n\\n\\nclass Solution {   \\npublic:\\n    \\n    \\n    bool isIdealPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        long long localInversions=0;\\n        \\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (nums[i]>nums[i+1])\\n                  localInversions++;\\n        }\\n        \\n        \\n        Trie *trie = new Trie();\\n\\n        int left, right;\\n\\n        long long globalInversions = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n\\n            trie->insert(nums[i]);\\n\\n            left = trie->no_of_smaller_element(nums[i]) - 1;\\n            right = i - left;\\n            globalInversions += right;\\n            \\n        }\\n        \\n        delete trie;\\n        \\n       \\n        return localInversions==globalInversions;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\n\\nstruct TrieNode {\\n\\n    TrieNode *left;\\n    TrieNode *right;\\n    int cnt;\\n\\n    TrieNode()\\n    {\\n        left = NULL;\\n        right = NULL;\\n        cnt = 0;\\n    }\\n\\n};\\n\\n\\n\\n\\n\\nclass Trie {\\n\\nprivate:\\n    TrieNode * root;\\n\\npublic:\\n\\n    Trie() {\\n\\n        root = new TrieNode();\\n    }\\n\\n\\n\\n    void insert(int n) {\\n\\n        TrieNode *curr = root;\\n\\n        for (int i = 31; i >= 0; --i)\\n        {\\n\\n            int bit = (n >> i) & 1;\\n\\n            if (bit == 1)\\n            {\\n                if (curr->right == NULL)\\n                    curr->right = new TrieNode();\\n\\n                curr = curr->right;\\n            }\\n            else\\n            {\\n                if (curr->left == NULL)\\n                    curr->left = new TrieNode();\\n\\n                curr = curr->left;\\n            }\\n\\n            curr->cnt++;\\n\\n        }\\n\\n\\n    }\\n\\n\\n\\n    int no_of_smaller_element(int n) {\\n\\n        TrieNode *curr = root;\\n\\n        int answer = 0;\\n\\n        for (int i = 31; i >= 0; --i)\\n        {\\n\\n            int bit = (n >> i) & 1;\\n\\n            if (bit == 1) {\\n\\n                /* add all the definetly smaller numbers */\\n\\n                if (curr->left != NULL)\\n                    answer += curr->left->cnt;\\n\\n                /* Check  further weather it is smaller or not  */\\n\\n                if (curr->right != NULL)\\n                    curr = curr->right;\\n\\n            }\\n            else\\n            {\\n                if (curr->left != NULL)\\n                    curr = curr->left ;\\n\\n            }\\n\\n        }\\n\\n        answer += curr->cnt;\\n\\n        return answer;\\n    }\\n\\n};\\n\\n\\n\\n\\n\\nclass Solution {   \\npublic:\\n    \\n    \\n    bool isIdealPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        long long localInversions=0;\\n        \\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (nums[i]>nums[i+1])\\n                  localInversions++;\\n        }\\n        \\n        \\n        Trie *trie = new Trie();\\n\\n        int left, right;\\n\\n        long long globalInversions = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n\\n            trie->insert(nums[i]);\\n\\n            left = trie->no_of_smaller_element(nums[i]) - 1;\\n            right = i - left;\\n            globalInversions += right;\\n            \\n        }\\n        \\n        delete trie;\\n        \\n       \\n        return localInversions==globalInversions;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368593,
                "title": "merge-sort-c-template",
                "content": "Gives TLE for this question.\\n\\n\\t// While merging [ 1 7 8 11 ] and [ 8 9 10 17 ]\\n\\t//                       |            |\\n\\t//                       i            j\\n\\t// Despite of i < j, nums[i]>nums[j] : \\n\\t// So whenever smaller element is from 2nd array, add [arr1.size()-i] to ans;\\n    \\n    long long countInversions(vector<int> &nums, int s, int e){\\n        \\n        if(s>=e) return 0;\\n        \\n        long long mid = s + (e-s)/2;\\n        long long lans = countInversions(nums, s, mid);\\n        long long rans = countInversions(nums, mid+1, e);\\n        \\n        vector<int> ans(e-s+1, 0);\\n        \\n        long long i = s, j = mid+1, k = 0, inv = 0;\\n        while(i<=mid||j<=e){\\n            if(i<=mid&&(j>e||nums[i]<nums[j])){ ans[k++] = nums[i++]; }\\n            else{ ans[k++] = nums[j++]; inv += mid+1-i; }\\n        }\\n        \\n        for(int i=s;i<=e;i++) nums[i] = ans[i-s];\\n        \\n        return lans + rans + inv;\\n        \\n    }\\n    \\n    bool isIdealPermutation(vector<int>& nums){\\n        \\n        long long localInv = 0;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n            localInv += (nums[i]>nums[i+1]?1:0);\\n        \\n        long long globalInv = countInversions(nums, 0, nums.size()-1);\\n    \\n        return localInv==globalInv;\\n        \\n    }",
                "solutionTags": [],
                "code": "Gives TLE for this question.\\n\\n\\t// While merging [ 1 7 8 11 ] and [ 8 9 10 17 ]\\n\\t//                       |            |\\n\\t//                       i            j\\n\\t// Despite of i < j, nums[i]>nums[j] : \\n\\t// So whenever smaller element is from 2nd array, add [arr1.size()-i] to ans;\\n    \\n    long long countInversions(vector<int> &nums, int s, int e){\\n        \\n        if(s>=e) return 0;\\n        \\n        long long mid = s + (e-s)/2;\\n        long long lans = countInversions(nums, s, mid);\\n        long long rans = countInversions(nums, mid+1, e);\\n        \\n        vector<int> ans(e-s+1, 0);\\n        \\n        long long i = s, j = mid+1, k = 0, inv = 0;\\n        while(i<=mid||j<=e){\\n            if(i<=mid&&(j>e||nums[i]<nums[j])){ ans[k++] = nums[i++]; }\\n            else{ ans[k++] = nums[j++]; inv += mid+1-i; }\\n        }\\n        \\n        for(int i=s;i<=e;i++) nums[i] = ans[i-s];\\n        \\n        return lans + rans + inv;\\n        \\n    }\\n    \\n    bool isIdealPermutation(vector<int>& nums){\\n        \\n        long long localInv = 0;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n            localInv += (nums[i]>nums[i+1]?1:0);\\n        \\n        long long globalInv = countInversions(nums, 0, nums.size()-1);\\n    \\n        return localInv==globalInv;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1366625,
                "title": "c-1-line-soln-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++) if(abs(i-nums[i])>1) return false; return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++) if(abs(i-nums[i])>1) return false; return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322966,
                "title": "c-o-n-solution",
                "content": "```\\nMajor insight here is that if local inv==global inv then by just changing local ones we can get a sorted array which in this case would be just range(0,n)\\n```\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int n=A.size();\\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (A[i]>A[i+1])\\n            {\\n                swap(A[i],A[i+1]);\\n                i++;\\n            }\\n        }\\n        \\n        for (int i=0;i<n;i++)\\n            if (A[i]!=i)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nMajor insight here is that if local inv==global inv then by just changing local ones we can get a sorted array which in this case would be just range(0,n)\\n```\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int n=A.size();\\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (A[i]>A[i+1])\\n            {\\n                swap(A[i],A[i+1]);\\n                i++;\\n            }\\n        }\\n        \\n        for (int i=0;i<n;i++)\\n            if (A[i]!=i)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317162,
                "title": "easy-4-line-c-solution-with-the-logic",
                "content": "We check the position by which the number is shifted. Since the array contains [0,n-1] numbers, if a number is shifted by more than one position, the number of global inversions will increase and it wont be equal to the number of local inversions.\\n```\\nbool isIdealPermutation(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==i+1 || nums[i]==i-1 || nums[i]==i) c++;\\n        }\\n        return c==nums.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isIdealPermutation(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==i+1 || nums[i]==i-1 || nums[i]==i) c++;\\n        }\\n        return c==nums.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1282779,
                "title": "java-fast-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        //find one global inversion whichh is not a local inversion \\n        //if found retun false else true;\\n        //note: each local inversion is a global inversion\\n        int max=-1;\\n        for(int i=0;i<nums.length-2;i++){\\n                max=Math.max(max,nums[i]);\\n                if(max>nums[i+2]) //its a global inversion and not local due to the fact that we are comparing max at index i with value at index i+2 to be sure that we get the excess global inversion\\n                        return false;\\n            }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] nums) {\\n        //find one global inversion whichh is not a local inversion \\n        //if found retun false else true;\\n        //note: each local inversion is a global inversion\\n        int max=-1;\\n        for(int i=0;i<nums.length-2;i++){\\n                max=Math.max(max,nums[i]);\\n                if(max>nums[i+2]) //its a global inversion and not local due to the fact that we are comparing max at index i with value at index i+2 to be sure that we get the excess global inversion\\n                        return false;\\n            }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154183,
                "title": "java-simple-soln-with-explanation",
                "content": "\\n\\tclass Solution {\\n    public boolean isIdealPermutation(int[] arr) {\\n        for(int i=0;i<arr.length;i++) {\\n            if(Math.abs(i- arr[i])>1) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n// every local inversion is a global inversion with j= i+1.\\n// so for any index i if it has more than one value for j which satisfies conditions\\n// for global inversion that means the no of local!= global.\\n\\n// but for some reason we have a permutation of [0, n-1] and not just random nos.\\n// .........................we can still complete the func in O(N) resonable time \\n// without caring about the permutation though.\\n\\n// OBSERVATIONS: \\n//      1. for any no all elements ahead of him should be greater than it except for no just ahead of him.\\n//      2. for any no all element behind him should be smaller except for the no just behind him.\\n// using these observations if you try to make a ideal permutation then u will see a number lets say x can be at index x, x+1 or x-1 \\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isIdealPermutation(int[] arr) {\\n        for(int i=0;i<arr.length;i++) {\\n            if(Math.abs(i- arr[i])>1) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1144735,
                "title": "simple-c-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        //We can observe that each local inversion is global inversion (or local inversions are subset of global inversions). For both of them to be equal, every global inversion must only be a local inversion.\\n        \\n        //KEY  : //So, if we find any global inversion which is not local inversion, we return false\\n        \\n        //Hint : 0 can be placed in either 0th position or 1st position\\n        //Because if we put it anywhere else we will have more global inversions\\n        //Similarly, any element can be placed in either i , i-1 or i+1 index only\\n        \\n        //For example : 0 1 2 3 -> 1 0 3 2\\n        //So, abs(A[i]-i) should always be smaller than or equal to 1\\n        int n = A.size();\\n        for(int i = 0; i<n; i++) {\\n            if(abs(A[i]-i) > 1)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        //We can observe that each local inversion is global inversion (or local inversions are subset of global inversions). For both of them to be equal, every global inversion must only be a local inversion.\\n        \\n        //KEY  : //So, if we find any global inversion which is not local inversion, we return false\\n        \\n        //Hint : 0 can be placed in either 0th position or 1st position\\n        //Because if we put it anywhere else we will have more global inversions\\n        //Similarly, any element can be placed in either i , i-1 or i+1 index only\\n        \\n        //For example : 0 1 2 3 -> 1 0 3 2\\n        //So, abs(A[i]-i) should always be smaller than or equal to 1\\n        int n = A.size();\\n        for(int i = 0; i<n; i++) {\\n            if(abs(A[i]-i) > 1)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144215,
                "title": "python-simple-solution",
                "content": "```\\n\\'\\'\\'\\nEvery local inversion is also a Global inversion\\nSo we only have to check whether there are any other global inversions i.e.The inversion separated by more than one index\\nSo we track the maximum value seen before the previous value of the current element i.e.max_before_prev=max(max_before_prev,A[i-1])\\nIf this max_before_prev is greater than the current element then it means that we have a global inversion separated by more than one index and hence return False\\n\\'\\'\\'\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        max_before_prev=-1\\n        for i in range(1,len(A)):\\n            if A[i]<max_before_prev:\\n                return False\\n            max_before_prev=max(max_before_prev,A[i-1])\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\'\\'\\'\\nEvery local inversion is also a Global inversion\\nSo we only have to check whether there are any other global inversions i.e.The inversion separated by more than one index\\nSo we track the maximum value seen before the previous value of the current element i.e.max_before_prev=max(max_before_prev,A[i-1])\\nIf this max_before_prev is greater than the current element then it means that we have a global inversion separated by more than one index and hence return False\\n\\'\\'\\'\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        max_before_prev=-1\\n        for i in range(1,len(A)):\\n            if A[i]<max_before_prev:\\n                return False\\n            max_before_prev=max(max_before_prev,A[i-1])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144190,
                "title": "global-and-local-inversions-javascript-brute-force-solution",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {boolean}\\n */\\nvar isIdealPermutation = function(A) {\\nlet globalCount = 0;\\n   let localCount =0;\\n    \\n    \\n //global inversion => count  i<j  with 0 <= i < j < N and A[i] > A[j].\\n    \\n //local inversions => count i with 0 <= i < N and A[i] > A[i+1].\\n    \\n    //global\\n    for(let i=0; i<A.length; i++){\\n        for(let j = A.length; j>i; j--){\\n            if(A[i] > A[j]){\\n                globalCount++;\\n            }}}\\n        \\n    //local \\n    for(let k = 0; k<A.length; k++){\\n    \\n         if(A[k] > A[k+1]){\\n            localCount++;\\n    }}\\n        \\n    \\n    if(globalCount == localCount){\\n        return true;\\n    }\\n    else{\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {boolean}\\n */\\nvar isIdealPermutation = function(A) {\\nlet globalCount = 0;\\n   let localCount =0;\\n    \\n    \\n //global inversion => count  i<j  with 0 <= i < j < N and A[i] > A[j].\\n    \\n //local inversions => count i with 0 <= i < N and A[i] > A[i+1].\\n    \\n    //global\\n    for(let i=0; i<A.length; i++){\\n        for(let j = A.length; j>i; j--){\\n            if(A[i] > A[j]){\\n                globalCount++;\\n            }}}\\n        \\n    //local \\n    for(let k = 0; k<A.length; k++){\\n    \\n         if(A[k] > A[k+1]){\\n            localCount++;\\n    }}\\n        \\n    \\n    if(globalCount == localCount){\\n        return true;\\n    }\\n    else{\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144117,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) \\n    {\\n        for(int i = 0 ; i < A.size() ; i++)\\n        {\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) \\n    {\\n        for(int i = 0 ; i < A.size() ; i++)\\n        {\\n            if(abs(A[i] - i) > 1)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1144107,
                "title": "one-liner-c",
                "content": "A number can have three positions in order to make local inversions and global inversions equal\\ni) its correct position\\nii) wrong position to the left by one\\niii) wrong postion to the right by one\\n\\nany other position will tend to increase global inversions\\n\\n\\n``` for(int i=0;i<A.size();i++){\\n            if(!(A[i]==i || A[i]==i-1 || A[i]==i+1))\\n                return false;\\n        }\\n\\t\\t\\treturn true;\\n\\nJUST AN OBSERVATION(TRICK) BASED QUESTION",
                "solutionTags": [],
                "code": "A number can have three positions in order to make local inversions and global inversions equal\\ni) its correct position\\nii) wrong position to the left by one\\niii) wrong postion to the right by one\\n\\nany other position will tend to increase global inversions\\n\\n\\n``` for(int i=0;i<A.size();i++){\\n            if(!(A[i]==i || A[i]==i-1 || A[i]==i+1))\\n                return false;\\n        }\\n\\t\\t\\treturn true;\\n\\nJUST AN OBSERVATION(TRICK) BASED QUESTION",
                "codeTag": "Unknown"
            },
            {
                "id": 1143923,
                "title": "c-set",
                "content": "Count all `local` and `global` inversions, then return `true` if and only if the inversion counts are equal.\\n\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = set<int>;\\n    bool isIdealPermutation(VI& A, Set S = {}, int last = -1, int local = 0, int global = 0) {\\n        for (auto x: A) {\\n            if (x < last)\\n                ++local;\\n            global += distance(S.upper_bound(x), S.end());\\n            S.insert(x);\\n            last = x;\\n        }\\n        return local == global;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = set<int>;\\n    bool isIdealPermutation(VI& A, Set S = {}, int last = -1, int local = 0, int global = 0) {\\n        for (auto x: A) {\\n            if (x < last)\\n                ++local;\\n            global += distance(S.upper_bound(x), S.end());\\n            S.insert(x);\\n            last = x;\\n        }\\n        return local == global;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143897,
                "title": "kotlin-a-simple-functional-solution",
                "content": "```\\nclass Solution {\\n    fun isIdealPermutation(A: IntArray): Boolean = \\n        A.foldIndexed(true) { index, acc, num -> \\n            acc && num - 1 <= index && index <= num + 1\\n        }\\n}\\n```\\nTime complexity: O(n)\\nSpace complexity: O(1)\\nExplanation: each number (num) can only be in the position (index) within [num - 1, num + 1]",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun isIdealPermutation(A: IntArray): Boolean = \\n        A.foldIndexed(true) { index, acc, num -> \\n            acc && num - 1 <= index && index <= num + 1\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143684,
                "title": "c-solution-using-merge-sort-technique-o-nlogn",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\n\\t  // FOR FINDING LOCAL INVERSION\\n\\t\\tint getLocal(vector<int> &arr) {\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfor(int i=1;i<arr.size();i++) if(arr[i-1]>arr[i]) c++;\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\n\\t\\tint countInv(int i1,int j1,int i2,int j2,vector<int> &arr) {\\n\\t\\t\\tint i=i1,c=0;\\n\\t\\t\\tvector<int> v;\\n\\t\\t\\twhile(i1<=j1 && i2<=j2) {\\n\\t\\t\\t\\tif(arr[i1]<arr[i2]) v.push_back(arr[i1++]);\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tv.push_back(arr[i2++]);\\n\\t\\t\\t\\t\\tc+= j1-i1+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile(i1<=j1) v.push_back(arr[i1++]);\\n\\t\\t\\twhile(i2<=j2) v.push_back(arr[i2++]);\\n\\t\\t\\tfor(int x: v) arr[i++]=x;\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\n\\t\\tint getGloInv(int i,int j,vector<int> &arr) {\\n\\t\\t\\tif(i==j) return 0;\\n\\t\\t\\tint mid= (i+j)/2;\\n\\t\\t\\tint x= getGloInv(i,mid,arr)+ getGloInv(mid+1,j,arr);\\n\\t\\t\\tint y= countInv(i,mid,mid+1,j,arr); \\n\\t\\t\\treturn x+y;\\n\\t\\t}\\n\\t \\n\\t   // FOR FIINDING GLOBAL INVERSIONS\\n\\t\\tint getGlobal(vector<int> arr) {\\n\\t\\t\\tint i=0,j=arr.size()-1;\\n\\t\\t\\treturn getGloInv(i,j,arr);\\n\\t\\t}\\n\\n\\t\\tbool isIdealPermutation(vector<int>& A) {\\n\\t\\t\\tint x= getLocal(A);\\n\\t\\t\\tint y= getGlobal(A);\\n\\t\\t\\t// cout<<x<<\" \"<<y;\\n\\t\\t\\treturn x==y;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Merge Sort"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\n\\t  // FOR FINDING LOCAL INVERSION\\n\\t\\tint getLocal(vector<int> &arr) {\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfor(int i=1;i<arr.size();i++) if(arr[i-1]>arr[i]) c++;\\n\\t\\t\\treturn c;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1143675,
                "title": "swift-short-easy-simple-3-line-solution-w-explanation",
                "content": "The fact that given array is just a permutation from `[0, ..., N]` makes the problem much simpler.\\n\\n**Local Inversions** \\u2014 These are easy to count. Just iterate over the array and increment count if `A[i] > A[i+1]`\\n**Global Inversions** \\u2014 These constitute all the pairs `(i,j)` where `i < j && A[i] > A[j]`.\\nThe total global inversions can be found from the formula : `\\u03A3 (2*(A[i] - i) - 1)`, for all `i`, where `A[i] > i`\\n\\n**Time Complexity:** `O(N)`, where `N` is the size of given array\\n**Space Complexity:**` O(1)`\\n\\n```\\nclass Solution {\\n    func isIdealPermutation(_ A: [Int]) -> Bool {\\n        var inversionDiff = 0\\n        for i in 0..<A.count-1 {\\n            inversionDiff += (A[i] > A[i + 1] ? 1 : 0) - max(0, 2 * (A[i] - i) - 1)\\n        }\\n        return inversionDiff == 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func isIdealPermutation(_ A: [Int]) -> Bool {\\n        var inversionDiff = 0\\n        for i in 0..<A.count-1 {\\n            inversionDiff += (A[i] > A[i + 1] ? 1 : 0) - max(0, 2 * (A[i] - i) - 1)\\n        }\\n        return inversionDiff == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143633,
                "title": "100-faster-explained-o-n-soln",
                "content": "```\\npublic class Solution {\\n    // Time O(n) || Space O(1)\\n    public bool IsIdealPermutation(int[] A) {\\n        /* local count is only subset of global count, all we need to focus is on when local < global.\\n         * The difference between local and global is global also include nonadjacent i and j,\\n         * i.e. for each index i, we need to find a larger number than A[i] in range 0 to i-2.\\n         * if it exist, we return false directly without checking further.\\n         */\\n        int max = -1;\\n        for (int i = 0; i < A.Length - 2; i++)\\n        {\\n            max = Math.Max(max, A[i]);\\n            if (max > A[i + 2])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/32ee17c8-bf6f-4aeb-b3e5-4f2c22703aa9_1617620791.633655.png)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // Time O(n) || Space O(1)\\n    public bool IsIdealPermutation(int[] A) {\\n        /* local count is only subset of global count, all we need to focus is on when local < global.\\n         * The difference between local and global is global also include nonadjacent i and j,\\n         * i.e. for each index i, we need to find a larger number than A[i] in range 0 to i-2.\\n         * if it exist, we return false directly without checking further.\\n         */\\n        int max = -1;\\n        for (int i = 0; i < A.Length - 2; i++)\\n        {\\n            max = Math.Max(max, A[i]);\\n            if (max > A[i + 2])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143627,
                "title": "python-scan",
                "content": "# Idea\\nLet\\'s reformulate the problem: If a number is smaller than any preceding number which is not its immediate predecessor, we have more global inversions than local. Therefore, the only thing we need to keep track of as we iterate over the array is the max number we have encountered up to 2 indices before the current idx.\\n# Complexity\\nTime: O(N)\\nSpace: O(1)\\n```\\ndef isIdealPermutation(self, A: List[int]) -> bool:\\n\\tmax_prior = A[0]\\n\\tfor i in range(2, len(A)):\\n\\t\\tif A[i] < max_prior: return False\\n\\t\\tmax_prior = max(max_prior, A[i-1])\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isIdealPermutation(self, A: List[int]) -> bool:\\n\\tmax_prior = A[0]\\n\\tfor i in range(2, len(A)):\\n\\t\\tif A[i] < max_prior: return False\\n\\t\\tmax_prior = max(max_prior, A[i-1])\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1143523,
                "title": "java-1-ms-remove-non-intersecting-local-inversions",
                "content": "All local inversions are also global inversions.\\nIf the number of local and global inversions are equal,\\nThen after removing all non-intersecing local inversions,\\nThe total number of inversions must be zero, i.e. the array must be sorted.\\n```\\nclass Solution\\n{\\n    public boolean isIdealPermutation(int[] A)\\n    {\\n        for(int i=0; i<A.length-1; i++)\\n        {\\n            if(A[i]>A[i+1])\\n            {\\n                int t = A[i];\\n                A[i] = A[i+1];\\n                A[i+1] = t;\\n                i++;\\n            }\\n        }\\n        for(int i=0; i<A.length-1; i++)\\n        {\\n            if(A[i]>A[i+1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public boolean isIdealPermutation(int[] A)\\n    {\\n        for(int i=0; i<A.length-1; i++)\\n        {\\n            if(A[i]>A[i+1])\\n            {\\n                int t = A[i];\\n                A[i] = A[i+1];\\n                A[i+1] = t;\\n                i++;\\n            }\\n        }\\n        for(int i=0; i<A.length-1; i++)\\n        {\\n            if(A[i]>A[i+1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143486,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn is_ideal_permutation(a: Vec<i32>) -> bool {\\n        a.iter()\\n            .enumerate()\\n            .all(|(i, &n)| (n - i as i32).abs() <= 1)\\n    }\\n}\\n```\\n\\n```rust\\nimpl Solution {\\n    pub fn is_ideal_permutation(a: Vec<i32>) -> bool {\\n        a.windows(3).all(|w| {\\n            (w[0] < w[1] && w[1] < w[2])\\n                || (w[0] - w[1] == 1 && w[1] < w[2])\\n                || (w[0] < w[1] && w[1] - w[2] == 1)\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_ideal_permutation(a: Vec<i32>) -> bool {\\n        a.iter()\\n            .enumerate()\\n            .all(|(i, &n)| (n - i as i32).abs() <= 1)\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn is_ideal_permutation(a: Vec<i32>) -> bool {\\n        a.windows(3).all(|w| {\\n            (w[0] < w[1] && w[1] < w[2])\\n                || (w[0] - w[1] == 1 && w[1] < w[2])\\n                || (w[0] < w[1] && w[1] - w[2] == 1)\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1143446,
                "title": "simple-solution-in-java-with-a-brief-explanation",
                "content": "Pointers:\\n* Every local inversion is a global inversion but other way is not true\\n* For local inversion, we need to move in a fashion similar to bubble sort and hence can be done in O(n)\\n* For global inversion, we need to move in a selection sort fashion and hence O(n ** 2)\\n* Since numbers are in the range of `[0 .. n]`, we can leverage this to find the offset from ideal position when the local and global inversions could be same\\n* This ideal position would be either sorted or reverse sorted. Going with sorted is a simpler idea\\n* If the permuation were sorted, A[i] would be equal to i. ie) `A[i] == i`. But now we can find what the actual value is, ie. the difference of `A[i] - i` could give us the offset. If this offset is == 0, array is sorted. If offset == 1, it is not sorted but it has a local inversion and since every local inversion is a global one, it has both. Stands by our case.\\n* But if, `A[i] - i` is >= 2, this means that it is off by 2 positions or more, which gives lead to a chance of global inversion but not local and we can stop the iteration and return `false` here.\\n\\nJava code - \\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        int n = A.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            int j = A[i];\\n            if(Math.abs(j - i) >= 2){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        int n = A.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            int j = A[i];\\n            if(Math.abs(j - i) >= 2){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143409,
                "title": "binary-indexed-tree-c-bit",
                "content": "```\\nclass Solution {\\npublic:\\n    int c[5001];\\n    bool isIdealPermutation(vector<int>& A) {\\n        update(A[0] + 1);\\n        int local = 0, global = 0;\\n        for (int i = 1; i < A.size(); i++) {\\n            if (A[i] < A[i - 1]) local++;\\n            global += i - get(A[i] + 1);\\n            update(A[i] + 1);\\n        }\\n        return local == global;\\n    }\\n    void update(int x) {\\n        while (x < 5001) {\\n            c[x]++;\\n            x += x & -x;\\n        }\\n    }\\n    int get(int x) {\\n        int res = 0;\\n        while (x) {\\n            res += c[x];\\n            x -= x & -x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c[5001];\\n    bool isIdealPermutation(vector<int>& A) {\\n        update(A[0] + 1);\\n        int local = 0, global = 0;\\n        for (int i = 1; i < A.size(); i++) {\\n            if (A[i] < A[i - 1]) local++;\\n            global += i - get(A[i] + 1);\\n            update(A[i] + 1);\\n        }\\n        return local == global;\\n    }\\n    void update(int x) {\\n        while (x < 5001) {\\n            c[x]++;\\n            x += x & -x;\\n        }\\n    }\\n    int get(int x) {\\n        int res = 0;\\n        while (x) {\\n            res += c[x];\\n            x -= x & -x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143389,
                "title": "easy-java-solution",
                "content": "Two important observations:\\n1.  every local conversion is subset of global conversion\\n2.  if there is any global conversion pair which is not local conversion return false i.e. just check any global conversion having distance more than one\\n\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] arr) {\\n        \\n        int len = arr.length;\\n        \\n        if(len < 3) return true;\\n        \\n        int j = len - 1;\\n        int i = len - 3;\\n        int min = arr[j];\\n        \\n        while( i >= 0 ) {\\n            if(arr[i] > min) return false;\\n             j--;\\n             i--;\\n             min = Math.min(arr[j], min);\\n        }\\n        \\n        return true;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] arr) {\\n        \\n        int len = arr.length;\\n        \\n        if(len < 3) return true;\\n        \\n        int j = len - 1;\\n        int i = len - 3;\\n        int min = arr[j];\\n        \\n        while( i >= 0 ) {\\n            if(arr[i] > min) return false;\\n             j--;\\n             i--;\\n             min = Math.min(arr[j], min);\\n        }\\n        \\n        return true;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056150,
                "title": "super-easy-java-solution-with-explanation",
                "content": "It\\'s kind of like all squares are rectangles, but not all rectangles are squares.  All local inversions are global inversions, but not all global inversions are local.  So we just need to find one time when a global inversion would not be a local inversion and we know to return false.\\n\\nThe ideal array is 0,1,2,3,4,5...A.length.  This would mean that every number at index i would equal i.  For example at index 5 the value is 5.\\n\\nIf a number is in the wrong place by 2 or more spots, we know that will cause 2 global inversions, but only 1 local inversion. See example below:\\n\\n[0,1,4,2,3]\\n\\nGoing through this array we would get to 4 before the logic was triggered.  At index 2, we have 4.  What does this mean?  This means up until this point every number is where it was supposed to be.  Since 4 is at least 2 spots from where it was supposed to be, that means that its ahead of at least 2 numbers that should have come before it.  This means, that 4 will cause a global inversion on every number it is ahead of.  So 2 and 3 are both less than 4, so 2 global inversions are created from number 4.  4>2 but 2 <3 so only one local inversion can be created with the same numbers.\\n\\nSince the number of global is now greater than local they will not be equal at the end so we can return false now.\\n\\n*The reason we dont check just 1 position different is because that will result in one global and one local inversion which keeps it balanced. \\n\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for(int i = 0; i<A.length; i++){\\n            if(Math.abs(A[i]-i) >= 2) return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for(int i = 0; i<A.length; i++){\\n            if(Math.abs(A[i]-i) >= 2) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1016410,
                "title": "7-lines-python-solution-with-explanation",
                "content": "* The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j].\\n* The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1].\\n* If the the number of global inversions is equal to the number of local inversions, it means  for a certain number n, at most one number is larger than n and also  is in front of it.  If exits, this \"larger number\" must be n+1. \\n* To make it more intuitive, lets say we have A =  [0,1,2,3,4]. It\\'s not hard to find that A[0] can be occupied by 0 or 1, A[1] can be occupied by 0,1,2, A[2] can be occupied by 1,2,3, A[3] can be occupied by 2,3,4, A[4] can be occupied by 3,4. Think about it, if we put 4 in A[2], no matter what permutation we have, there are two numbers lower than 4 and will be put in A[3] and A[4].\\n* What we can derive from the rules above? Except the first and last position, every index has three options.\\n\\n\\nclass Solution:\\n\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        A_length = len(A)\\n        if (A[0]!=0 and A[0]!=1) or (A[-1]!=A_length-1 and A[-1]!=A_length-2):\\n            return False  #check the first and last position\\n        for i in range(1,A_length-1):\\n            if A[i]!=i and A[i]!=i-1 and A[i]!=i+1: #check the others \\n                return False\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "* The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j].\\n* The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1].\\n* If the the number of global inversions is equal to the number of local inversions, it means  for a certain number n, at most one number is larger than n and also  is in front of it.  If exits, this \"larger number\" must be n+1. \\n* To make it more intuitive, lets say we have A =  [0,1,2,3,4]. It\\'s not hard to find that A[0] can be occupied by 0 or 1, A[1] can be occupied by 0,1,2, A[2] can be occupied by 1,2,3, A[3] can be occupied by 2,3,4, A[4] can be occupied by 3,4. Think about it, if we put 4 in A[2], no matter what permutation we have, there are two numbers lower than 4 and will be put in A[3] and A[4].\\n* What we can derive from the rules above? Except the first and last position, every index has three options.\\n\\n\\nclass Solution:\\n\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        A_length = len(A)\\n        if (A[0]!=0 and A[0]!=1) or (A[-1]!=A_length-1 and A[-1]!=A_length-2):\\n            return False  #check the first and last position\\n        for i in range(1,A_length-1):\\n            if A[i]!=i and A[i]!=i-1 and A[i]!=i+1: #check the others \\n                return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1013065,
                "title": "c-the-basic-concept-100-faster",
                "content": "```\\nbool isIdealPermutation(vector<int>& v) {\\n        int n = v.size();\\n        int diff = 0,g = 0,l=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i] == i && diff >1){\\n                diff--;\\n                g += diff;\\n            }\\n            else if(v[i] > i){\\n                diff = v[i]-i;\\n                g += diff;\\n            }\\n            if(i != n-1 && v[i]>v[i+1]){\\n                l += 1;\\n            }\\n        }\\n        return (g == l);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isIdealPermutation(vector<int>& v) {\\n        int n = v.size();\\n        int diff = 0,g = 0,l=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i] == i && diff >1){\\n                diff--;\\n                g += diff;\\n            }\\n            else if(v[i] > i){\\n                diff = v[i]-i;\\n                g += diff;\\n            }\\n            if(i != n-1 && v[i]>v[i+1]){\\n                l += 1;\\n            }\\n        }\\n        return (g == l);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1005205,
                "title": "java-o-n-log-n-mergesort-solution",
                "content": "Well, this is definitely garbage compare to @lee215\\'s solution...\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        int local = 0;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] > A[i + 1]) {\\n                local++;\\n            }\\n        }\\n        int global = mergesort(A, 0, A.length - 1);\\n        return local == global;\\n    }\\n    \\n    private int mergesort(int[] A, int start, int end) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n        int mid = start + (end - start) / 2;\\n        int cnt = 0;\\n        cnt += mergesort(A, start, mid);\\n        cnt += mergesort(A, mid + 1, end);\\n        cnt += merge(A, start, mid, mid + 1, end);\\n        return cnt;\\n    }\\n    \\n    private int merge(int[] A, int start1, int end1, int start2, int end2) {\\n        List<Integer> temp = new ArrayList<>();\\n        int i = start1;\\n        int j = start2;\\n        int cnt = 0;\\n        while (i <= end1 && j <= end2) {\\n            if (A[i] < A[j]) {\\n                temp.add(A[i]);\\n                i++;\\n            }\\n            else {\\n                cnt += end1 - i + 1;\\n                temp.add(A[j]);\\n                j++;\\n            }\\n        }\\n        while (i <= end1) {\\n            temp.add(A[i]);\\n            i++;\\n        }\\n        while (j <= end2) {\\n            temp.add(A[j]);\\n            j++;\\n        }\\n        for (int k = start1, l = 0; k <= end2; k++, l++) {\\n            A[k] = temp.get(l);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        int local = 0;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] > A[i + 1]) {\\n                local++;\\n            }\\n        }\\n        int global = mergesort(A, 0, A.length - 1);\\n        return local == global;\\n    }\\n    \\n    private int mergesort(int[] A, int start, int end) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n        int mid = start + (end - start) / 2;\\n        int cnt = 0;\\n        cnt += mergesort(A, start, mid);\\n        cnt += mergesort(A, mid + 1, end);\\n        cnt += merge(A, start, mid, mid + 1, end);\\n        return cnt;\\n    }\\n    \\n    private int merge(int[] A, int start1, int end1, int start2, int end2) {\\n        List<Integer> temp = new ArrayList<>();\\n        int i = start1;\\n        int j = start2;\\n        int cnt = 0;\\n        while (i <= end1 && j <= end2) {\\n            if (A[i] < A[j]) {\\n                temp.add(A[i]);\\n                i++;\\n            }\\n            else {\\n                cnt += end1 - i + 1;\\n                temp.add(A[j]);\\n                j++;\\n            }\\n        }\\n        while (i <= end1) {\\n            temp.add(A[i]);\\n            i++;\\n        }\\n        while (j <= end2) {\\n            temp.add(A[j]);\\n            j++;\\n        }\\n        for (int k = start1, l = 0; k <= end2; k++, l++) {\\n            A[k] = temp.get(l);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972980,
                "title": "o-n-how-i-come-cross-the-idea",
                "content": "def isIdealPermutation(self, A: List[int]) -> bool:\\n        \\n        for i in range(len(A)):\\n\\n            if abs(A[i]-i)>1:\\n                return False\\n        return True\\n\\t\\t\\nAt first I think about calculate global and local. But I come across that I only need to decide whether global == local instead of finding the exact value.\\n\\nSo how is the local different from global. The answer is, once there is a non-adjacent inversion pair, global will not be equal to local.\\n\\nAgain that in this problem. if abs(A[i] - i)>1, there will exist non-adjacent inversion pair.",
                "solutionTags": [],
                "code": "def isIdealPermutation(self, A: List[int]) -> bool:\\n        \\n        for i in range(len(A)):\\n\\n            if abs(A[i]-i)>1:\\n                return False\\n        return True\\n\\t\\t\\nAt first I think about calculate global and local. But I come across that I only need to decide whether global == local instead of finding the exact value.\\n\\nSo how is the local different from global. The answer is, once there is a non-adjacent inversion pair, global will not be equal to local.\\n\\nAgain that in this problem. if abs(A[i] - i)>1, there will exist non-adjacent inversion pair.",
                "codeTag": "Python3"
            },
            {
                "id": 972159,
                "title": "o-n-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        const int n=A.size();\\n        int mn=INT_MAX;\\n        for(int i=n-3;i>=0;i--){\\n            mn=min(mn,A[i+2]);\\n            if(A[i]>mn) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n/*\\nbasically if a element, has a smaller element to its right other than the next element its false s, just keep track of the minimum element upto the current index -2, i.e other than its immediate neighbour\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        const int n=A.size();\\n        int mn=INT_MAX;\\n        for(int i=n-3;i>=0;i--){\\n            mn=min(mn,A[i+2]);\\n            if(A[i]>mn) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n/*\\nbasically if a element, has a smaller element to its right other than the next element its false s, just keep track of the minimum element upto the current index -2, i.e other than its immediate neighbour\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967007,
                "title": "java-easy-constant-space-linear-time",
                "content": "**Basic Idea**\\nif count of global inversions == count local inversions, \\nthen it means all the global inversions are local inversions.\\n\\nthat is why we are trying to find an global inversion which is not local inversion(A[i] > A[i+2])\\nwhere A[i] is the maximum element till i.\\n\\n..if found such inversion return false\\n\\n\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        \\n    int max = -1;\\n    for(int i = 0 ; i < A.length-2; i++){\\n        max = Math.max(max, A[i]);\\n        if(max > A[i+2]){\\n            return false;\\n        }\\n    }\\n    return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        \\n    int max = -1;\\n    for(int i = 0 ; i < A.length-2; i++){\\n        max = Math.max(max, A[i]);\\n        if(max > A[i+2]){\\n            return false;\\n        }\\n    }\\n    return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924636,
                "title": "python3-linear-sweep",
                "content": "\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        for i, x in enumerate(A):\\n            if abs(i - x) > 1: return False \\n        return True \\n```\\n\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        return all(abs(i-x) <= 1 for i, x in enumerate(A))\\n```\\n\\nBtw, local inversions can be counted in `O(N)` time and global inversion can be counted in `O(NlogN)` time but this problem doesn\\'t allow `O(NlogN)` algo. \\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        cnt = sum(nums[i] > nums[i+1] for i in range(len(nums)-1))\\n        aux = nums.copy() # auxiliary array \\n        \\n        def fn(nums, aux, lo, hi): \\n            \"\"\"Return count of global inversions of nums[lo:hi].\"\"\"\\n            if lo + 1 >= hi: return 0 \\n            mid = lo + hi >> 1\\n            left = fn(aux, nums, lo, mid) \\n            right = fn(aux, nums, mid, hi)\\n            split = 0 \\n            i, j = lo, mid\\n            for k in range(lo, hi): \\n                if j >= hi or i < mid and aux[i] < aux[j]: \\n                    nums[k] = aux[i]\\n                    i += 1\\n                else: \\n                    nums[k] = aux[j]\\n                    j += 1\\n                    split += mid - i # split inversions \\n            return left + split + right \\n        \\n        return cnt == fn(nums, aux, 0, len(nums))\\n```\\n\\nRelated problems \\n[315. Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        for i, x in enumerate(A):\\n            if abs(i - x) > 1: return False \\n        return True \\n```\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        return all(abs(i-x) <= 1 for i, x in enumerate(A))\\n```\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        cnt = sum(nums[i] > nums[i+1] for i in range(len(nums)-1))\\n        aux = nums.copy() # auxiliary array \\n        \\n        def fn(nums, aux, lo, hi): \\n            \"\"\"Return count of global inversions of nums[lo:hi].\"\"\"\\n            if lo + 1 >= hi: return 0 \\n            mid = lo + hi >> 1\\n            left = fn(aux, nums, lo, mid) \\n            right = fn(aux, nums, mid, hi)\\n            split = 0 \\n            i, j = lo, mid\\n            for k in range(lo, hi): \\n                if j >= hi or i < mid and aux[i] < aux[j]: \\n                    nums[k] = aux[i]\\n                    i += 1\\n                else: \\n                    nums[k] = aux[j]\\n                    j += 1\\n                    split += mid - i # split inversions \\n            return left + split + right \\n        \\n        return cnt == fn(nums, aux, 0, len(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857414,
                "title": "c-o-n-solution-works-on-any-vectors-besides-permutation-of-n",
                "content": "Since every local inversion is a global inversion. We just need to check if there is any global inversion for subarray A[0,....,i] is not a local inversion, i.e. their index differencen is not greater than 1.\\n```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int maxVal=INT_MIN;\\n        for (int i=2;i<A.size();i++) {\\n            maxVal=max(maxVal,A[i-2]);\\n            if (A[i]<maxVal) return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int maxVal=INT_MIN;\\n        for (int i=2;i<A.size();i++) {\\n            maxVal=max(maxVal,A[i-2]);\\n            if (A[i]<maxVal) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 851420,
                "title": "simple-python-code",
                "content": "```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        if len(A) == 0 or len(A) == 1 or (len(A) == 2 and A[0] < A[1]):\\n            return True\\n        tmp = A[0]\\n        for i in range(2, len(A)):\\n            if tmp > A[i] :\\n                return False\\n            tmp = max(tmp, A[i-1])\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        if len(A) == 0 or len(A) == 1 or (len(A) == 2 and A[0] < A[1]):\\n            return True\\n        tmp = A[0]\\n        for i in range(2, len(A)):\\n            if tmp > A[i] :\\n                return False\\n            tmp = max(tmp, A[i-1])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838358,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        if(A.size()<3)\\n            return true;\\n        int maxm=A[0];\\n        for(int i=2;i<A.size();i++)\\n        {\\n            if(maxm>A[i])\\n                return false;\\n            maxm=max(maxm,A[i-1]);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        if(A.size()<3)\\n            return true;\\n        int maxm=A[0];\\n        for(int i=2;i<A.size();i++)\\n        {\\n            if(maxm>A[i])\\n                return false;\\n            maxm=max(maxm,A[i-1]);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812216,
                "title": "99-9-intuitive-solution-python",
                "content": "Quickly got down to merge sort solution, as I previosly solved similar question of finding inversions in array.\\n\\n```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        self.glob_inv, self.local_inv = 0, 0\\n\\n        for i in range(len(nums)-1):\\n            if nums[i] > nums[i+1]:\\n                self.local_inv += 1\\n\\n        def merge(arr, left, right):\\n            i, j, k = 0, 0, 0\\n            while i<len(left) and j<len(right):\\n                if left[i] < right[j]:\\n                    arr[k] = left[i]\\n                    i += 1\\n                else:\\n                    self.glob_inv += (len(left)-i)\\n                    arr[k] = right[j]\\n                    j += 1\\n                k += 1\\n            while i < len(left):\\n                arr[k] = left[i]\\n                i += 1\\n                k += 1\\n            while j < len(right):\\n                arr[k] = right[j]\\n                j += 1\\n                k += 1\\n\\n        def merge_sort(arr):\\n            if len(arr)>1:\\n                mid = len(arr)//2\\n                left = arr[:mid]\\n                right = arr[mid:]\\n                merge_sort(left)\\n                merge_sort(right)\\n                merge(arr, left, right)\\n                \\n        merge_sort(nums)\\n        return self.local_inv == self.glob_inv\\n```\\n\\nSo, the second approach. \\n\\nOk, without much over complicating it. The solution is simple.\\n\\nNote: Range of elements in array is between [0, N-1]\\n\\nLocal inversions: misplaced by one position.\\nGlobal inversions: misplaced by one or more positions.\\n\\nSo, for local inversion to be equal to global inversion, the element must be at i\\'th position or i+1\\'th or i-1\\'th position. Otherwise, our number of global inversions increase right?\\n\\n```\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            if nums[i]!=i-1 and nums[i]!=i+1 and nums[i]!=i:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        self.glob_inv, self.local_inv = 0, 0\\n\\n        for i in range(len(nums)-1):\\n            if nums[i] > nums[i+1]:\\n                self.local_inv += 1\\n\\n        def merge(arr, left, right):\\n            i, j, k = 0, 0, 0\\n            while i<len(left) and j<len(right):\\n                if left[i] < right[j]:\\n                    arr[k] = left[i]\\n                    i += 1\\n                else:\\n                    self.glob_inv += (len(left)-i)\\n                    arr[k] = right[j]\\n                    j += 1\\n                k += 1\\n            while i < len(left):\\n                arr[k] = left[i]\\n                i += 1\\n                k += 1\\n            while j < len(right):\\n                arr[k] = right[j]\\n                j += 1\\n                k += 1\\n\\n        def merge_sort(arr):\\n            if len(arr)>1:\\n                mid = len(arr)//2\\n                left = arr[:mid]\\n                right = arr[mid:]\\n                merge_sort(left)\\n                merge_sort(right)\\n                merge(arr, left, right)\\n                \\n        merge_sort(nums)\\n        return self.local_inv == self.glob_inv\\n```\n```\\n    def isIdealPermutation(self, nums: List[int]) -> bool:\\n        for i in range(len(nums)):\\n            if nums[i]!=i-1 and nums[i]!=i+1 and nums[i]!=i:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738305,
                "title": "javascript-two-pointer",
                "content": "```\\nconst isIdealPermutation = (A) => {\\n    let local = 0;\\n    let global = 0;\\n    for (let i = 1; i < A.length; i++) {\\n        if (A[i - 1] > A[i]) local++;\\n    }\\n    for (let i = 0; i < A.length; i++) {\\n        for (let j = i + 1; j < A.length; j++) {\\n            if (A[i] > A[j]) global++;\\n        }\\n    }\\n    if (global == local) return true;\\n    return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst isIdealPermutation = (A) => {\\n    let local = 0;\\n    let global = 0;\\n    for (let i = 1; i < A.length; i++) {\\n        if (A[i - 1] > A[i]) local++;\\n    }\\n    for (let i = 0; i < A.length; i++) {\\n        for (let j = i + 1; j < A.length; j++) {\\n            if (A[i] > A[j]) global++;\\n        }\\n    }\\n    if (global == local) return true;\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 701757,
                "title": "python-3-faster-99-very-concice",
                "content": "As the local and gloable inversion are depent on the diviation of the index, and the number are in range[0, N-1], then this can be written as:\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        if not A: return\\n        for i, x in enumerate(A):\\n            if abs(x-i) > 1:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        if not A: return\\n        for i, x in enumerate(A):\\n            if abs(x-i) > 1:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689633,
                "title": "python-o-n-simple-solution-with-explanation",
                "content": "Before jumping to the solution, let\\'s consider where the maixmum value of an ideal permutation can be placed.\\n\\nIf the maximum value ```N``` is placed at the end ```[..., N]```, there are no inversions caused by ```N```, which means it becomes ```check(N - 1)```.\\n\\nIf the maximum value N is placed at the second rightmost location ```[..., N, X]```, what value can ```X``` be?\\n```X``` can only be ```N - 1```. If ```X``` is smaller than ```N - 1```, then ```N - 1``` must be placed at the left side of ```X```, which will produce one more global inversion. In this case, it becomes ```check(N - 2)```.\\n\\n```N``` Cannot be placed at other locations.\\n\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        maxi = len(A) - 1\\n        \\n        while len(A) > 2:\\n            last = A.pop()\\n            if last == maxi:\\n                maxi -= 1\\n            elif last == maxi - 1 and A[-1] == maxi:\\n                A.pop()\\n                maxi -= 2\\n            else:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```N```\n```[..., N]```\n```N```\n```check(N - 1)```\n```[..., N, X]```\n```X```\n```X```\n```N - 1```\n```X```\n```N - 1```\n```N - 1```\n```X```\n```check(N - 2)```\n```N```\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        maxi = len(A) - 1\\n        \\n        while len(A) > 2:\\n            last = A.pop()\\n            if last == maxi:\\n                maxi -= 1\\n            elif last == maxi - 1 and A[-1] == maxi:\\n                A.pop()\\n                maxi -= 2\\n            else:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681770,
                "title": "simple-c-solution-and-easy-to-understand-explanation",
                "content": "```\\n/*\\n1. Given: All local inversions are global inversions.\\n2. Lets look at problem statement closely, we should identify whether global inversions == local inversions or not?  \\n3. This means, there should not be any other global inversions except a local inversion for a particular index i. So we just ignore i+1 why? \\n\\tBecause if it is a local inversion it is part of global inversion as well. So we don\\'t have to really count i+1.\\n\\tIt adds 1 either to both global and local count, or it adds 0 to both global and local count, so we dont care about it.\\n4. What we have to check? are there any other global inversions starting from i+2 till end.\\n5. This means we just have to check if there is a value in right [i+2, n) that is less than A[i] then return false. \\n*/\\n\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int minVal = INT_MAX;\\n        \\n        for(int i = A.size()-3; i >= 0; i--) {\\n            minVal = min(minVal, A[i+2]);\\n            if(A[i] > minVal)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n1. Given: All local inversions are global inversions.\\n2. Lets look at problem statement closely, we should identify whether global inversions == local inversions or not?  \\n3. This means, there should not be any other global inversions except a local inversion for a particular index i. So we just ignore i+1 why? \\n\\tBecause if it is a local inversion it is part of global inversion as well. So we don\\'t have to really count i+1.\\n\\tIt adds 1 either to both global and local count, or it adds 0 to both global and local count, so we dont care about it.\\n4. What we have to check? are there any other global inversions starting from i+2 till end.\\n5. This means we just have to check if there is a value in right [i+2, n) that is less than A[i] then return false. \\n*/\\n\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        int minVal = INT_MAX;\\n        \\n        for(int i = A.size()-3; i >= 0; i--) {\\n            minVal = min(minVal, A[i+2]);\\n            if(A[i] > minVal)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654588,
                "title": "detailed-explanation-o-n-solution",
                "content": "Number of local inversion = Number of global inversion if and only if the following condition holds:\\n\\nA[i + 2]...A[n - 1] > A[i] where n = length of array\\n\\nwhich means that min(A[i + 2]...A[n - 1]) should be greater than A[i]\\n\\nWe need to only find 1 violation of this condition and we can return false else true.\\n\\nAlso note that we don\\'t care about indices n - 1(this is trivial) & n - 2(because global and local inversion is the same for this index). \\n\\n```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) { \\n        int min = A[A.length - 1];\\n        for(int i = A.length - 3;i >= 0;i--) {\\n            if(min < A[i]) {\\n                return false;\\n            }\\n            min = Math.min(min, A[i + 1]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) { \\n        int min = A[A.length - 1];\\n        for(int i = A.length - 3;i >= 0;i--) {\\n            if(min < A[i]) {\\n                return false;\\n            }\\n            min = Math.min(min, A[i + 1]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632490,
                "title": "monostack-o-n-solution-similar-to-962",
                "content": "Idea is to create a monotonic increasing stack. We iterate from the back and check if any global inversions exist that aren\\'t local inversions.\\n\\n```\\ndef isIdealPermutation(self, A: List[int]) -> bool:\\n\\tn = len(A)\\n\\tstack = []\\n\\tfor i in range(n):\\n\\t\\tif not stack or A[i] > A[stack[-1]]:\\n\\t\\t\\tstack.append(i)\\n\\n\\tfor i in range(n-1, -1, -1):\\n\\t\\twhile stack and A[stack[-1]] > A[i]:\\n\\t\\t\\tj = stack.pop()\\n\\t\\t\\tif i - j > 1:\\n\\t\\t\\t\\treturn False\\n\\treturn True\\n```",
                "solutionTags": [],
                "code": "```\\ndef isIdealPermutation(self, A: List[int]) -> bool:\\n\\tn = len(A)\\n\\tstack = []\\n\\tfor i in range(n):\\n\\t\\tif not stack or A[i] > A[stack[-1]]:\\n\\t\\t\\tstack.append(i)\\n\\n\\tfor i in range(n-1, -1, -1):\\n\\t\\twhile stack and A[stack[-1]] > A[i]:\\n\\t\\t\\tj = stack.pop()\\n\\t\\t\\tif i - j > 1:\\n\\t\\t\\t\\treturn False\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 573372,
                "title": "java-easiest",
                "content": "note that the array is in \"permutation\"\\n```\\nclass Solution {\\n    public static boolean isIdealPermutation(int[] A) {\\n        for(int i = 0; i < A.length; i++){\\n            if(Math.abs(i - A[i]) > 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static boolean isIdealPermutation(int[] A) {\\n        for(int i = 0; i < A.length; i++){\\n            if(Math.abs(i - A[i]) > 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516833,
                "title": "python3-87-44-360-ms-100-00-13-3-mb-o-n-time-o-1-space-single-while-loop",
                "content": "```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        index = 0\\n        \\n        \\n        while(index < len(A)):\\n            if (A[index] == index):\\n                pass\\n            elif (A[index] == index + 1 and A[index + 1] == index):\\n                index += 1\\n            else:\\n                return False\\n            \\n            index += 1\\n            \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        index = 0\\n        \\n        \\n        while(index < len(A)):\\n            if (A[index] == index):\\n                pass\\n            elif (A[index] == index + 1 and A[index + 1] == index):\\n                index += 1\\n            else:\\n                return False\\n            \\n            index += 1\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441166,
                "title": "time-complexity-o-n-easy-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for(int i=1;i<A.size();i++){\\n            if((A[i-1]>A[i] && A[i]==i-1 && A[i-1]==i) || (A[i-1]<A[i]))continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isIdealPermutation(vector<int>& A) {\\n        for(int i=1;i<A.size();i++){\\n            if((A[i-1]>A[i] && A[i]==i-1 && A[i-1]==i) || (A[i-1]<A[i]))continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397244,
                "title": "python-solution-explained",
                "content": "Note:\\n1. A local inversion is at the same time a global inversion\\n2. Hence, we only need to check if there exists a global inversion that is not the same time a local inversion\\n3. Since local inversion are always occuring between neighboring elements, we skip the immediate neighbor and check for the global inversion\\n4. We move a 3-element window, we can safely ignore the second element, because regardless if it can form a local inversion with the last element, it does not matter (refer to point 1.)\\n6.  We maintain a \\'largest\\' variable with the first element (some solution maintain another variable for the second largest, but it is actually unnecessary)\\n7.  Whenever there is a inversion between the \\'largest\\' and the 3rd element, there is a global inversion and not the same time a local inversion -> return False\\n \\n\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        if len(A) < 3:\\n            return True\\n        \\n        largest = -math.inf\\n        for i in range(2, len(A)):            \\n            \\n\\t\\t\\t# update largest\\n            if A[i-2] > largest:\\n                largest = A[i-2]\\n\\t\\t\\t\\t\\n\\t\\t\\t# check non-local inversion\\n            if largest > A[i]:\\n                return False\\n                \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, A: List[int]) -> bool:\\n        if len(A) < 3:\\n            return True\\n        \\n        largest = -math.inf\\n        for i in range(2, len(A)):            \\n            \\n\\t\\t\\t# update largest\\n            if A[i-2] > largest:\\n                largest = A[i-2]\\n\\t\\t\\t\\t\\n\\t\\t\\t# check non-local inversion\\n            if largest > A[i]:\\n                return False\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301612,
                "title": "c-7-lines-beat-95",
                "content": "```\\nbool isIdealPermutation(vector<int>& A) {\\n\\tint max_v = 0;\\n\\tfor(int i = 0 ; i < A.size()-1 ; i++){\\n\\t\\tif(max_v > A[i+1])\\n\\t\\t\\treturn false;\\n\\t\\tmax_v = max(max_v,A[i]);\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isIdealPermutation(vector<int>& A) {\\n\\tint max_v = 0;\\n\\tfor(int i = 0 ; i < A.size()-1 ; i++){\\n\\t\\tif(max_v > A[i+1])\\n\\t\\t\\treturn false;\\n\\t\\tmax_v = max(max_v,A[i]);\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249517,
                "title": "c-simple-answer-with-just-one-line",
                "content": "```\\nbool isIdealPermutation(vector<int>& A) {\\n        int len = A.size();\\n        for (int i = 0; i < len; i++)\\n        {\\n            if (abs(A[i] - i) > 1) return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isIdealPermutation(vector<int>& A) {\\n        int len = A.size();\\n        for (int i = 0; i < len; i++)\\n        {\\n            if (abs(A[i] - i) > 1) return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244807,
                "title": "js-divide-conquer-n-log-n-solution",
                "content": "I know, it\\'s not the most optimal solution...\\n\\n```\\nconst mergeSort = (arr, left, mid, right) => {\\n\\tlet res = [], l = left, r = mid;\\n\\n\\twhile (l < mid && r < right) {\\n\\t\\tif (arr[l] <= arr[r]) { res.push(arr[l++]); }\\n\\t\\telse { res.push(arr[r++]); }\\n\\t}\\n\\n\\twhile (l < mid) { res.push(arr[l++]); }\\n\\twhile (r < right) { res.push(arr[r++]); }\\n\\tfor (let i = left; i < right; i++) { arr[i] = res[i - left]; }\\n}\\n\\nconst cntInversions = (arr, left, mid) => {\\n    let i = left, j = mid - 1, cnt = 0;\\n\\n\\twhile (i < mid) {\\n\\t\\twhile (arr[j + 1] <= arr[i]) { j++; }\\n\\t\\tif (arr[i] > arr[j]) { cnt += (j - mid) + 1; }\\n\\t\\ti++;\\n\\t}\\n    return cnt;\\n}\\n\\nconst globalInversions = (arr, left, right) => {\\n\\tif (right === left + 1) { return 0; }\\n\\n\\tlet mid = Math.floor((left + right) / 2);\\n\\n\\tlet lcnt = globalInversions(arr, left, mid);\\n\\tlet rcnt = globalInversions(arr, mid, right);\\n\\t\\n    let cnt = cntInversions(arr, left, mid);\\n    mergeSort(arr, left, mid, right);\\n\\n\\treturn lcnt + rcnt + cnt;\\n}\\n\\nconst localInversions = A => {\\n    let cnt = 0;\\n    for (let i = 0; i < A.length - 1; i++) { if (A[i] > A[i + 1]) { cnt++; } }\\n    return cnt;\\n}\\n\\nconst isIdealPermutation = A => localInversions(A) === globalInversions(A, 0, A.length);\\n```",
                "solutionTags": [],
                "code": "```\\nconst mergeSort = (arr, left, mid, right) => {\\n\\tlet res = [], l = left, r = mid;\\n\\n\\twhile (l < mid && r < right) {\\n\\t\\tif (arr[l] <= arr[r]) { res.push(arr[l++]); }\\n\\t\\telse { res.push(arr[r++]); }\\n\\t}\\n\\n\\twhile (l < mid) { res.push(arr[l++]); }\\n\\twhile (r < right) { res.push(arr[r++]); }\\n\\tfor (let i = left; i < right; i++) { arr[i] = res[i - left]; }\\n}\\n\\nconst cntInversions = (arr, left, mid) => {\\n    let i = left, j = mid - 1, cnt = 0;\\n\\n\\twhile (i < mid) {\\n\\t\\twhile (arr[j + 1] <= arr[i]) { j++; }\\n\\t\\tif (arr[i] > arr[j]) { cnt += (j - mid) + 1; }\\n\\t\\ti++;\\n\\t}\\n    return cnt;\\n}\\n\\nconst globalInversions = (arr, left, right) => {\\n\\tif (right === left + 1) { return 0; }\\n\\n\\tlet mid = Math.floor((left + right) / 2);\\n\\n\\tlet lcnt = globalInversions(arr, left, mid);\\n\\tlet rcnt = globalInversions(arr, mid, right);\\n\\t\\n    let cnt = cntInversions(arr, left, mid);\\n    mergeSort(arr, left, mid, right);\\n\\n\\treturn lcnt + rcnt + cnt;\\n}\\n\\nconst localInversions = A => {\\n    let cnt = 0;\\n    for (let i = 0; i < A.length - 1; i++) { if (A[i] > A[i + 1]) { cnt++; } }\\n    return cnt;\\n}\\n\\nconst isIdealPermutation = A => localInversions(A) === globalInversions(A, 0, A.length);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 233816,
                "title": "java-beats-100-super-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for(int i = 0; i < A.length; i++){\\n            if(A[i] - i < -1 || A[i] - i > 1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isIdealPermutation(int[] A) {\\n        for(int i = 0; i < A.length; i++){\\n            if(A[i] - i < -1 || A[i] - i > 1){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 204927,
                "title": "python-linear-scan-time-o-n-space-o-1",
                "content": "For every number n, there are n numbers smaller than it. \\n\\nIf its poistion i is larger than n more than 1 (i-n >= 2), then there must be at least one number before i-1 larger than n. Return False.\\n\\nIf i-n == 1, then there is only one number larger than n before i. If it is not at i-1, then it must be before i-1. Return False.\\n\\nOtherwise, return True.\\n```\\nclass Solution:\\n    def isIdealPermutation(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i, n in enumerate(A):\\n            if i - n >= 2 or (i - n == 1 and A[i-1] < A[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isIdealPermutation(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i, n in enumerate(A):\\n            if i - n >= 2 or (i - n == 1 and A[i-1] < A[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1670270,
                "content": [
                    {
                        "username": "kuntalviv",
                        "content": "Getting TLE for O(n logn) solution. :/"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@rakeshks7](/rakeshks7) It\\'s late but it can be O(n)... I hate these kinda questions where they just get a question then twist it to make it confusing...."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "same lol :/"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "final submission results coming out weird.. I have an O(n) solutions still its get TLE , sometimes their is no test case shown for the failed submission and that too on the 226/226 test case...very weird behavior"
                    },
                    {
                        "username": "EricWiener",
                        "content": "I was also seeing this issue. I optimized the case for counting global inversions for just 2 elements and then I was able to pass"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "this thing happens with python.. i resubmitted in java it got AC."
                    },
                    {
                        "username": "francolai",
                        "content": "more of a logic puzzle"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I just looked at the solution and can\\'t believe it is so simple. I over-engineered my solution smh. Think simply!\\n\\nThink about this: Would a local inversion also be a global inversion? What about the other way around?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "It should accept nlogn solution\\nbu it is giving TLE."
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a tricky one"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "You are thinking too hard"
                    }
                ]
            },
            {
                "id": 1645365,
                "content": [
                    {
                        "username": "kuntalviv",
                        "content": "Getting TLE for O(n logn) solution. :/"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@rakeshks7](/rakeshks7) It\\'s late but it can be O(n)... I hate these kinda questions where they just get a question then twist it to make it confusing...."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "same lol :/"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "final submission results coming out weird.. I have an O(n) solutions still its get TLE , sometimes their is no test case shown for the failed submission and that too on the 226/226 test case...very weird behavior"
                    },
                    {
                        "username": "EricWiener",
                        "content": "I was also seeing this issue. I optimized the case for counting global inversions for just 2 elements and then I was able to pass"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "this thing happens with python.. i resubmitted in java it got AC."
                    },
                    {
                        "username": "francolai",
                        "content": "more of a logic puzzle"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I just looked at the solution and can\\'t believe it is so simple. I over-engineered my solution smh. Think simply!\\n\\nThink about this: Would a local inversion also be a global inversion? What about the other way around?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "It should accept nlogn solution\\nbu it is giving TLE."
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a tricky one"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "You are thinking too hard"
                    }
                ]
            },
            {
                "id": 2027079,
                "content": [
                    {
                        "username": "kuntalviv",
                        "content": "Getting TLE for O(n logn) solution. :/"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@rakeshks7](/rakeshks7) It\\'s late but it can be O(n)... I hate these kinda questions where they just get a question then twist it to make it confusing...."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "same lol :/"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "final submission results coming out weird.. I have an O(n) solutions still its get TLE , sometimes their is no test case shown for the failed submission and that too on the 226/226 test case...very weird behavior"
                    },
                    {
                        "username": "EricWiener",
                        "content": "I was also seeing this issue. I optimized the case for counting global inversions for just 2 elements and then I was able to pass"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "this thing happens with python.. i resubmitted in java it got AC."
                    },
                    {
                        "username": "francolai",
                        "content": "more of a logic puzzle"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I just looked at the solution and can\\'t believe it is so simple. I over-engineered my solution smh. Think simply!\\n\\nThink about this: Would a local inversion also be a global inversion? What about the other way around?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "It should accept nlogn solution\\nbu it is giving TLE."
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a tricky one"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "You are thinking too hard"
                    }
                ]
            },
            {
                "id": 1933343,
                "content": [
                    {
                        "username": "kuntalviv",
                        "content": "Getting TLE for O(n logn) solution. :/"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@rakeshks7](/rakeshks7) It\\'s late but it can be O(n)... I hate these kinda questions where they just get a question then twist it to make it confusing...."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "same lol :/"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "final submission results coming out weird.. I have an O(n) solutions still its get TLE , sometimes their is no test case shown for the failed submission and that too on the 226/226 test case...very weird behavior"
                    },
                    {
                        "username": "EricWiener",
                        "content": "I was also seeing this issue. I optimized the case for counting global inversions for just 2 elements and then I was able to pass"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "this thing happens with python.. i resubmitted in java it got AC."
                    },
                    {
                        "username": "francolai",
                        "content": "more of a logic puzzle"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I just looked at the solution and can\\'t believe it is so simple. I over-engineered my solution smh. Think simply!\\n\\nThink about this: Would a local inversion also be a global inversion? What about the other way around?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "It should accept nlogn solution\\nbu it is giving TLE."
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a tricky one"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "You are thinking too hard"
                    }
                ]
            },
            {
                "id": 2046383,
                "content": [
                    {
                        "username": "kuntalviv",
                        "content": "Getting TLE for O(n logn) solution. :/"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@rakeshks7](/rakeshks7) It\\'s late but it can be O(n)... I hate these kinda questions where they just get a question then twist it to make it confusing...."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "same lol :/"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "final submission results coming out weird.. I have an O(n) solutions still its get TLE , sometimes their is no test case shown for the failed submission and that too on the 226/226 test case...very weird behavior"
                    },
                    {
                        "username": "EricWiener",
                        "content": "I was also seeing this issue. I optimized the case for counting global inversions for just 2 elements and then I was able to pass"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "this thing happens with python.. i resubmitted in java it got AC."
                    },
                    {
                        "username": "francolai",
                        "content": "more of a logic puzzle"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I just looked at the solution and can\\'t believe it is so simple. I over-engineered my solution smh. Think simply!\\n\\nThink about this: Would a local inversion also be a global inversion? What about the other way around?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "It should accept nlogn solution\\nbu it is giving TLE."
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a tricky one"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "You are thinking too hard"
                    }
                ]
            },
            {
                "id": 1991399,
                "content": [
                    {
                        "username": "kuntalviv",
                        "content": "Getting TLE for O(n logn) solution. :/"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@rakeshks7](/rakeshks7) It\\'s late but it can be O(n)... I hate these kinda questions where they just get a question then twist it to make it confusing...."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "same lol :/"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "final submission results coming out weird.. I have an O(n) solutions still its get TLE , sometimes their is no test case shown for the failed submission and that too on the 226/226 test case...very weird behavior"
                    },
                    {
                        "username": "EricWiener",
                        "content": "I was also seeing this issue. I optimized the case for counting global inversions for just 2 elements and then I was able to pass"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "this thing happens with python.. i resubmitted in java it got AC."
                    },
                    {
                        "username": "francolai",
                        "content": "more of a logic puzzle"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I just looked at the solution and can\\'t believe it is so simple. I over-engineered my solution smh. Think simply!\\n\\nThink about this: Would a local inversion also be a global inversion? What about the other way around?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "It should accept nlogn solution\\nbu it is giving TLE."
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a tricky one"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "You are thinking too hard"
                    }
                ]
            },
            {
                "id": 1907278,
                "content": [
                    {
                        "username": "kuntalviv",
                        "content": "Getting TLE for O(n logn) solution. :/"
                    },
                    {
                        "username": "feng3245",
                        "content": "[@rakeshks7](/rakeshks7) It\\'s late but it can be O(n)... I hate these kinda questions where they just get a question then twist it to make it confusing...."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "same lol :/"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "final submission results coming out weird.. I have an O(n) solutions still its get TLE , sometimes their is no test case shown for the failed submission and that too on the 226/226 test case...very weird behavior"
                    },
                    {
                        "username": "EricWiener",
                        "content": "I was also seeing this issue. I optimized the case for counting global inversions for just 2 elements and then I was able to pass"
                    },
                    {
                        "username": "shadowfax_1024",
                        "content": "this thing happens with python.. i resubmitted in java it got AC."
                    },
                    {
                        "username": "francolai",
                        "content": "more of a logic puzzle"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I just looked at the solution and can\\'t believe it is so simple. I over-engineered my solution smh. Think simply!\\n\\nThink about this: Would a local inversion also be a global inversion? What about the other way around?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "It should accept nlogn solution\\nbu it is giving TLE."
                    },
                    {
                        "username": "coder_sd",
                        "content": "Its a tricky one"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "You are thinking too hard"
                    }
                ]
            }
        ]
    }
]