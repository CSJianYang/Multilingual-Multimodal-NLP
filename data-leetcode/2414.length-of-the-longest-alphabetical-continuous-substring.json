[
    {
        "title": "Length of the Longest Alphabetical Continuous Substring",
        "question_content": "An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string \"abcdefghijklmnopqrstuvwxyz\".\n\n\tFor example, \"abc\" is an alphabetical continuous string, while \"acb\" and \"za\" are not.\n\nGiven a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring.\n&nbsp;\nExample 1:\n\nInput: s = \"abacaba\"\nOutput: 2\nExplanation: There are 4 distinct continuous substrings: \"a\", \"b\", \"c\" and \"ab\".\n\"ab\" is the longest continuous substring.\n\nExample 2:\n\nInput: s = \"abcde\"\nOutput: 5\nExplanation: \"abcde\" is the longest continuous substring.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts consists of only English lowercase letters.",
        "solutions": [
            {
                "id": 2590074,
                "title": "python3-o-n-with-line-by-line-comments",
                "content": "At each position, it either belongs to previous continues substring or it is the beginning of a new substring.\\n\\n\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        cur = 1 ### We are currently at 0 position, so the length is 1.\\n        res = 1 ### At least the string should contain 1 letter.\\n        for i in range(1,len(s)):\\n        \\t### If the ith letter is continued from the previous letter, \\n        \\t### update the curLength and store the maximum length to res\\n            if ord(s[i])-ord(s[i-1])==1:\\n                cur = cur+1\\n                res = max(cur,res)\\n            ### This is the start of a new substring with length 1.\\n            else:\\n                cur = 1\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        cur = 1 ### We are currently at 0 position, so the length is 1.\\n        res = 1 ### At least the string should contain 1 letter.\\n        for i in range(1,len(s)):\\n        \\t### If the ith letter is continued from the previous letter, \\n        \\t### update the curLength and store the maximum length to res\\n            if ord(s[i])-ord(s[i-1])==1:\\n                cur = cur+1\\n                res = max(cur,res)\\n            ### This is the start of a new substring with length 1.\\n            else:\\n                cur = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590079,
                "title": "two-pointers",
                "content": "Here, `i` is the current character, and `j` marks the start of the aplhabetical string.\\n\\nIn an aplhabetical string starting at `j`, `s[i] - s[j] == i - j` would be true for each `i <= j`.\\n\\n**Java**\\n```java\\npublic int longestContinuousSubstring(String s) {\\n    int j = 0, res = 1;\\n    for (int i = 1; i < s.length(); ++i) {\\n        if (s.charAt(i) != s.charAt(j) + i - j)\\n            j = i;\\n        res = Math.max(res, i - j + 1);\\n    }\\n    return res;\\n}\\n```\\n**C++**\\n```cpp\\nint longestContinuousSubstring(string s) {\\n    int j = 0, res = 1;\\n    for (int i = 1; i < s.size(); ++i) {\\n        if (s[i] != s[j] + i - j)\\n            j = i;\\n        res = max(res, i - j + 1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int longestContinuousSubstring(String s) {\\n    int j = 0, res = 1;\\n    for (int i = 1; i < s.length(); ++i) {\\n        if (s.charAt(i) != s.charAt(j) + i - j)\\n            j = i;\\n        res = Math.max(res, i - j + 1);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint longestContinuousSubstring(string s) {\\n    int j = 0, res = 1;\\n    for (int i = 1; i < s.size(); ++i) {\\n        if (s[i] != s[j] + i - j)\\n            j = i;\\n        res = max(res, i - j + 1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590113,
                "title": "add-to-length-or-restart-java",
                "content": "**Code:**\\n\\n    public int longestContinuousSubstring(String s) {\\n        int x = 0, len = 0, res = 0;\\n        for(char ch : s.toCharArray()) {\\n            len = ch-\\'a\\'-x==1 ? len+1 : 1;  // add to len or restart\\n            res = Math.max(res, len);\\n            x = ch-\\'a\\';\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Code:**\\n\\n    public int longestContinuousSubstring(String s) {\\n        int x = 0, len = 0, res = 0;\\n        for(char ch : s.toCharArray()) {\\n            len = ch-\\'a\\'-x==1 ? len+1 : 1;  // add to len or restart\\n            res = Math.max(res, len);\\n            x = ch-\\'a\\';\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2590098,
                "title": "c-easy-and-efficient-approach",
                "content": "```\\n//Please upvote if it helps :)\\nclass Solution \\n{\\npublic:\\n    int longestContinuousSubstring(string s) \\n    {\\n        int cnt=1, maxi=1, n=s.size(); \\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(s[i]+1 == s[i+1]) cnt++;\\n            else cnt=1;\\n            maxi = max(maxi, cnt);   \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Counting Sort"
                ],
                "code": "```\\n//Please upvote if it helps :)\\nclass Solution \\n{\\npublic:\\n    int longestContinuousSubstring(string s) \\n    {\\n        int cnt=1, maxi=1, n=s.size(); \\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(s[i]+1 == s[i+1]) cnt++;\\n            else cnt=1;\\n            maxi = max(maxi, cnt);   \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591028,
                "title": "java-simplest-o-n-solution-intuition-explained",
                "content": "**INTUITION -** \\n**1. Traverse the whole string**\\n**2. If difference between current character and previous character is 1, increase count**\\n**3. If it is not equal to 1, reset count = 1**\\n**4. Store the max of count at each step**\\n\\n```java\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int ans = 1;\\n\\t\\tint count = 1;\\n\\t\\tfor (int i = 1; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) - s.charAt(i-1) == 1) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tans = Math.max(ans, count);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int ans = 1;\\n\\t\\tint count = 1;\\n\\t\\tfor (int i = 1; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) - s.charAt(i-1) == 1) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tans = Math.max(ans, count);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590211,
                "title": "python-one-pass",
                "content": "```\\n    def longestContinuousSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1 for _ in range(len(s))]\\n        for i in range(1, len(s)):\\n            if ord(s[i]) == ord(s[i - 1]) + 1:\\n                dp[i] = dp[i - 1] + 1\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\n    def longestContinuousSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1 for _ in range(len(s))]\\n        for i in range(1, len(s)):\\n            if ord(s[i]) == ord(s[i - 1]) + 1:\\n                dp[i] = dp[i - 1] + 1\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2590032,
                "title": "c-one-pass",
                "content": "**a = a\\nb = a+1\\nc = b+1\\nd = c+1\\nso on......\\nminimum answer will be 1\\nrest is simple comparison**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = INT_MIN , maxi = 1;\\n        for(int i = 1; i < s.size(); i++){\\n            if(s[i-1]+1 == s[i])    maxi++;\\n            else{\\n                ans = max(ans,maxi);\\n                maxi = 1;\\n            }\\n        }\\n        return max(ans,maxi);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = INT_MIN , maxi = 1;\\n        for(int i = 1; i < s.size(); i++){\\n            if(s[i-1]+1 == s[i])    maxi++;\\n            else{\\n                ans = max(ans,maxi);\\n                maxi = 1;\\n            }\\n        }\\n        return max(ans,maxi);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606647,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem asks us to find the length of the longest alphabetical continuous substring in a given string. To solve this, we can iterate through the string and keep track of the current count of consecutive alphabetical characters. Whenever we encounter a character that breaks the alphabetical sequence, we update the maximum count found so far. Finally, we return the maximum count as the result.\\n\\n\\n# Approach\\n1.\\tInitialize variables: We start by initializing a count variable to keep track of the current count of consecutive alphabetical characters and a result variable to store the maximum count found so far. We also set the index variable \\'i\\' to 1, representing the current index in the string.\\n2.\\tIteration: We iterate through the string starting from the second character (index 1) until the end.\\n3.\\tChecking alphabetical sequence: For each character, we compare its ASCII value with the ASCII value of the previous character. If the ASCII value of the current character is one more than the previous character, it means the alphabetical sequence is continuing. In that case, we increment the count by 1.\\n4.\\tBreaking the sequence: If the ASCII value of the current character does not satisfy the condition mentioned above, it means the alphabetical sequence is broken. We update the result by taking the maximum of the current count and the previous result. Additionally, we reset the count to 1, as we start counting a new alphabetical sequence.\\n5.\\tIncrement index: After each iteration, we increment the index variable \\'i\\' by 1 to move to the next character in the string.\\n6.\\tFinalizing the result: After the loop ends, we update the result one final time by taking the maximum of the last count and the previous result, as there might be a valid alphabetical sequence ending at the last character.\\n7.\\tReturn the result: Finally, we return the result as the length of the longest alphabetical continuous substring in the given string.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe algorithm iterates through the input string once, resulting in a linear time complexity of O(n), where n is the length of the string.\\n\\n\\n- Space complexity:\\nThe algorithm uses a constant amount of extra space to store variables, resulting in a space complexity of O(1).\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        count=1\\n        i=1\\n        res=1\\n        while i<len(s):\\n            if ord(s[i-1])+1==ord(s[i]):\\n                count+=1\\n            else:\\n                res=max(res,count)\\n                count=1\\n            i+=1\\n        res=max(res,count)\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        count=1\\n        i=1\\n        res=1\\n        while i<len(s):\\n            if ord(s[i-1])+1==ord(s[i]):\\n                count+=1\\n            else:\\n                res=max(res,count)\\n                count=1\\n            i+=1\\n        res=max(res,count)\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590789,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n)**\\n**Python**\\n```\\nclass Solution(object):\\n    def longestContinuousSubstring(self, s):\\n        max_len = 1\\n        for i in range(1, len(s)):\\n            count = 1\\n            while i < len(s) and ord(s[i-1]) + 1 == ord(s[i]):\\n                count += 1\\n                i += 1\\n            max_len = max(max_len, count)\\n        return max_len\\n```\\n**JavaScript**\\n```\\nvar longestContinuousSubstring = function(s) {\\n    let max_len = 1\\n    for(let i=1; i<s.length; i++){\\n        let count = 1\\n        while(i < s.length && s.charCodeAt(i-1) + 1 == s.charCodeAt(i)){\\n            count++\\n            i++;\\n        }\\n        max_len = Math.max(max_len, count)\\n    }     \\n    return max_len\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max_len = 1;\\n        for(int i=1; i<s.length(); i++){\\n            int count = 1;\\n            while(i < s.length() && s.charAt(i-1) + 1 == s.charAt(i)){\\n                count++;\\n                i++;\\n            }\\n            max_len = Math.max(max_len, count);\\n        }     \\n        return max_len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestContinuousSubstring(self, s):\\n        max_len = 1\\n        for i in range(1, len(s)):\\n            count = 1\\n            while i < len(s) and ord(s[i-1]) + 1 == ord(s[i]):\\n                count += 1\\n                i += 1\\n            max_len = max(max_len, count)\\n        return max_len\\n```\n```\\nvar longestContinuousSubstring = function(s) {\\n    let max_len = 1\\n    for(let i=1; i<s.length; i++){\\n        let count = 1\\n        while(i < s.length && s.charCodeAt(i-1) + 1 == s.charCodeAt(i)){\\n            count++\\n            i++;\\n        }\\n        max_len = Math.max(max_len, count)\\n    }     \\n    return max_len\\n};\\n```\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max_len = 1;\\n        for(int i=1; i<s.length(); i++){\\n            int count = 1;\\n            while(i < s.length() && s.charAt(i-1) + 1 == s.charAt(i)){\\n                count++;\\n                i++;\\n            }\\n            max_len = Math.max(max_len, count);\\n        }     \\n        return max_len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590210,
                "title": "c-o-n-frequency-map",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int longestContinuousSubstring(string s) {\\n        int n=s.length();\\n        \\n        map<char,int> mp; // frequency map for each character \\n        int c=0; // count of unique characters in current sub-string\\n        int i=0;\\n        int prev=-1; // ASCII index for previous character included in sub-string \\n        \\n        int ans=0;\\n        while(i<n){\\n            char ch=s[i];\\n            mp[ch]++;\\n            c++;\\n            \\n            if(prev!=-1){\\n                int cur=ch-\\'a\\';\\n                // if not continuous or repetition of character, need to start new sub-string\\n                if((cur != prev+1) || c>mp.size()){\\n                    mp.clear();\\n                    mp[ch]++;\\n                    c=1;\\n                }\\n            }\\n            prev=ch-\\'a\\';\\n            ans=max(ans,c);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int longestContinuousSubstring(string s) {\\n        int n=s.length();\\n        \\n        map<char,int> mp; // frequency map for each character \\n        int c=0; // count of unique characters in current sub-string\\n        int i=0;\\n        int prev=-1; // ASCII index for previous character included in sub-string \\n        \\n        int ans=0;\\n        while(i<n){\\n            char ch=s[i];\\n            mp[ch]++;\\n            c++;\\n            \\n            if(prev!=-1){\\n                int cur=ch-\\'a\\';\\n                // if not continuous or repetition of character, need to start new sub-string\\n                if((cur != prev+1) || c>mp.size()){\\n                    mp.clear();\\n                    mp[ch]++;\\n                    c=1;\\n                }\\n            }\\n            prev=ch-\\'a\\';\\n            ans=max(ans,c);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590976,
                "title": "python-one-pass-solution",
                "content": "Create a mapping of character to next alphabetical character.\\n\\nWhen you iterate over the given string, check whether the next character is consecutive. If it is increase your current sequence length, otherwise reset to 1\\n\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:    \\n        next_letters = {}\\n        for n in range(26):\\n            cur_letter = chr(n + ord(\\'a\\'))\\n            next_letter = chr(n + ord(\\'a\\') + 1)\\n            next_letters[cur_letter] = next_letter\\n        \\n\\t\\tlongest = 1\\n        cur_streak = 1\\n        for i in range(len(s) - 1):\\n            if next_letters[s[i]] == s[i+1]:\\n                cur_streak += 1\\n                longest = max(longest, cur_streak)\\n            else:\\n                cur_streak = 1\\n         \\n        return longest\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:    \\n        next_letters = {}\\n        for n in range(26):\\n            cur_letter = chr(n + ord(\\'a\\'))\\n            next_letter = chr(n + ord(\\'a\\') + 1)\\n            next_letters[cur_letter] = next_letter\\n        \\n\\t\\tlongest = 1\\n        cur_streak = 1\\n        for i in range(len(s) - 1):\\n            if next_letters[s[i]] == s[i+1]:\\n                cur_streak += 1\\n                longest = max(longest, cur_streak)\\n            else:\\n                cur_streak = 1\\n         \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590657,
                "title": "iterative-method-explained-python-c",
                "content": "* We can iterate ove the string and just count consecutive characters and update `ans` every time the sequence breaks.\\n---------------\\n**Python**\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        mxl = 0\\n        count = 0\\n        for i in range(1, len(s)):\\n            if ord(s[i]) == ord(s[i-1])+1:\\n                count += 1\\n            else:\\n                mxl = max(mxl, count+1)\\n                count = 0\\n        mxl = max(mxl, count+1)\\n        return mxl\\n```\\n-------------------\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int mxl = 0;\\n        int count = 0;\\n        for (int i=1; i<s.size(); i++){\\n            if(s[i-1]+1 == s[i]){\\n                count += 1;\\n            }else{\\n                mxl = max(mxl, count+1);\\n                count = 0;\\n            }\\n        }\\n        mxl = max(mxl, count+1);\\n        return mxl;\\n    }\\n};\\n\\n```\\n---------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        mxl = 0\\n        count = 0\\n        for i in range(1, len(s)):\\n            if ord(s[i]) == ord(s[i-1])+1:\\n                count += 1\\n            else:\\n                mxl = max(mxl, count+1)\\n                count = 0\\n        mxl = max(mxl, count+1)\\n        return mxl\\n```\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int mxl = 0;\\n        int count = 0;\\n        for (int i=1; i<s.size(); i++){\\n            if(s[i-1]+1 == s[i]){\\n                count += 1;\\n            }else{\\n                mxl = max(mxl, count+1);\\n                count = 0;\\n            }\\n        }\\n        mxl = max(mxl, count+1);\\n        return mxl;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590651,
                "title": "c-easy-to-understand-solution",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint longestContinuousSubstring(string s) {\\n\\t\\t\\t\\tint maxu = 1;\\n\\t\\t\\t\\tint ans = 1;\\n\\t\\t\\t\\tfor(int i = 1; i < s.length(); i++){\\n\\t\\t\\t\\t\\tif(s[i] == s[i-1]+1){\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tmaxu = max(ans,maxu);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tans = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxu = max(maxu,ans);\\n\\t\\t\\t\\treturn maxu;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint longestContinuousSubstring(string s) {\\n\\t\\t\\t\\tint maxu = 1;\\n\\t\\t\\t\\tint ans = 1;\\n\\t\\t\\t\\tfor(int i = 1; i < s.length(); i++){\\n\\t\\t\\t\\t\\tif(s[i] == s[i-1]+1){\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tmaxu = max(ans,maxu);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2590364,
                "title": "keep-check-of-previous-element-easy-c-code",
                "content": "```\\nint longestContinuousSubstring(string s) {\\n        int n=s.length(), res = 1, cnt = 1;\\n        for(int i=1; i<n; i++){\\n            if((s[i]-\\'a\\') == (s[i-1]-\\'a\\')+1){\\n                cnt++;\\n                res = max(res, cnt);\\n            }\\n            else cnt = 1;\\n        }\\n        return res;\\n    }\\n```\\n***Upvote if this helped***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestContinuousSubstring(string s) {\\n        int n=s.length(), res = 1, cnt = 1;\\n        for(int i=1; i<n; i++){\\n            if((s[i]-\\'a\\') == (s[i-1]-\\'a\\')+1){\\n                cnt++;\\n                res = max(res, cnt);\\n            }\\n            else cnt = 1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590261,
                "title": "c-sliding-window",
                "content": "Using sliding window methord we just need to look at the size of the subarray if the next element is 1 more than the previous\\nelse just reset the pointers\\n\\nPlease upvote if you find this helpful :)\\n\\n```\\nclass Solution {\\nprivate:\\n    int ans=1;\\n    \\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int i=0, j=0, n=s.length();\\n        while(j<n){\\n            if(s[j+1]-s[j]==1){\\n                j++;\\n                ans=max(ans,j-i+1);\\n            }\\n            else{\\n                j++;\\n                i=j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int ans=1;\\n    \\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int i=0, j=0, n=s.length();\\n        while(j<n){\\n            if(s[j+1]-s[j]==1){\\n                j++;\\n                ans=max(ans,j-i+1);\\n            }\\n            else{\\n                j++;\\n                i=j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408770,
                "title": "c-time-o-n-space-1-short-sweet-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = 1;//minimum possible value of ans is 1\\n\\t\\tint sum=1;\\n        for(int i = 0; i < s.length()-1; i++){\\n            if(s[i+1]-s[i]==1){\\n                sum++;//if next char = previous char +1 than increment in temp ans\\n            }else{\\n                sum = 1;//else tempans = 1\\n            }\\n            ans = max(ans,sum);// ans = max value of ans,tempans\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = 1;//minimum possible value of ans is 1\\n\\t\\tint sum=1;\\n        for(int i = 0; i < s.length()-1; i++){\\n            if(s[i+1]-s[i]==1){\\n                sum++;//if next char = previous char +1 than increment in temp ans\\n            }else{\\n                sum = 1;//else tempans = 1\\n            }\\n            ans = max(ans,sum);// ans = max value of ans,tempans\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325045,
                "title": "easy-python-solution-using-ord-runtime-90",
                "content": "![image.png](https://assets.leetcode.com/users/images/195113d1-caf1-4fc8-96d4-fe8631698d3b_1679411331.0546842.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def longestContinuousSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mx=0\\n        v=\"\"\\n        for i in range(1,len(s)):\\n            if ord(s[i])==ord(s[i-1])+1:\\n                v+=s[i]\\n            else:\\n                if v:\\n                    mx=max(len(v)+1,mx)\\n                v=\"\"\\n        return max(mx,len(v)+1)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestContinuousSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mx=0\\n        v=\"\"\\n        for i in range(1,len(s)):\\n            if ord(s[i])==ord(s[i-1])+1:\\n                v+=s[i]\\n            else:\\n                if v:\\n                    mx=max(len(v)+1,mx)\\n                v=\"\"\\n        return max(mx,len(v)+1)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594370,
                "title": "python3-str-join-split-2-lines-t-m-375ms-15-7-mb",
                "content": "Something different, just for fun...\\n\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n\\n        arr = \\'\\'.join([\\'1\\' if ord(s[i])-ord(s[i-1]) == 1 \\n                       else \\' \\' for i in range(1,len(s))]).split()\\n                       \\n        return max((len(ones)+1 for ones in arr), default = 1)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Something different, just for fun...\\n\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n\\n        arr = \\'\\'.join([\\'1\\' if ord(s[i])-ord(s[i-1]) == 1 \\n                       else \\' \\' for i in range(1,len(s))]).split()\\n                       \\n        return max((len(ones)+1 for ones in arr), default = 1)",
                "codeTag": "Java"
            },
            {
                "id": 2590474,
                "title": "java-solution",
                "content": "class Solution {\\n    public int longestContinuousSubstring(String s) {\\n     \\n        int ans=1;\\n        \\n        \\n        int count=1;\\n        \\n        \\n        for(int i=1;i<s.length();i++){\\n            \\n            if(s.charAt(i)-s.charAt(i-1)==1){\\n                count++;\\n                \\n            }\\n            else{\\n                count=1;\\n            }\\n            \\n            ans=Math.max(ans,count);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestContinuousSubstring(String s) {\\n     \\n        int ans=1;\\n        \\n        \\n        int count=1;\\n        \\n        \\n        for(int i=1;i<s.length();i++){\\n            \\n            if(s.charAt(i)-s.charAt(i-1)==1){\\n                count++;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2590309,
                "title": "java-single-pass-explained",
                "content": "```\\n/*\\n    Count the length of substring until chain breaks, and then start the chain from next character\\n*/\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        int i=0, res=0;\\n        \\n        // Move till the last character\\n        while(i<n){\\n            \\n            // start from first\\n            char first = arr[i];\\n            int count = 1;\\n            // count characters until chain breaks\\n            while(true){\\n                first++;\\n                i++;\\n                \\n                // break when found incorrect character\\n                if(i==n || first!=arr[i]){\\n                    res = Math.max(res,count);\\n                    break;\\n                }\\n                count++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    Count the length of substring until chain breaks, and then start the chain from next character\\n*/\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        int i=0, res=0;\\n        \\n        // Move till the last character\\n        while(i<n){\\n            \\n            // start from first\\n            char first = arr[i];\\n            int count = 1;\\n            // count characters until chain breaks\\n            while(true){\\n                first++;\\n                i++;\\n                \\n                // break when found incorrect character\\n                if(i==n || first!=arr[i]){\\n                    res = Math.max(res,count);\\n                    break;\\n                }\\n                count++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590082,
                "title": "c-easily-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) \\n    {\\n        int count=1;\\n        int mx = 1;\\n        int n = s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]+1 == s[i+1]) count++;                    // checking the sequentional Alphabetical Continuous Substring\\n            else count = 1;\\n            \\n            mx = max(mx,count);                              // each time find max of count and mx\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) \\n    {\\n        int count=1;\\n        int mx = 1;\\n        int n = s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]+1 == s[i+1]) count++;                    // checking the sequentional Alphabetical Continuous Substring\\n            else count = 1;\\n            \\n            mx = max(mx,count);                              // each time find max of count and mx\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491849,
                "title": "simple-fast-solution-in-o-n-time",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize the variables lastChar, start, and res to the first character of the string, the start index of the current substring, and the longest substring seen so far (which is 0 to start with), respectively. Also, convert the input string into an array of characters.\\n\\nLoop through each character of the string, starting from the second character.\\n\\nIf the current character is one more than the previous character in ASCII order, set lastChar to the current character and continue iterating.\\n\\nOtherwise, reset the start index to the current index i, update res to the maximum of its current value and the length of the previous substring (which can be calculated as i - start, and set lastChar to the current character.\\n\\nAfter the loop is finished, handle the case where the longest substring is at the end of the string by updating res to the maximum of its current value and the length of the final substring (which can be calculated as chars.length - start).\\n\\nReturn res, which is the length of the longest continuous substring where the characters are consecutive in ASCII order.\\n\\nPlease upvote if you find it useful\\uD83D\\uDE09.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        // initialize variables\\n        char lastChar = s.charAt(0);\\n        int start = 0;\\n        int res = 0;\\n        char [] chars = s.toCharArray();\\n        \\n        // loop through each character of the string\\n        for(int i = 1; i < chars.length; i++){\\n            // if current character is one more than the previous character in ASCII order\\n            if(chars[i] == lastChar + 1){\\n                lastChar = chars[i];\\n            }\\n            // otherwise, reset the start index and update the longest length seen so far\\n            else{\\n                res = Math.max(res, i - start);\\n                lastChar = chars[i];\\n                start = i;\\n            }\\n        }\\n        // handle the case where the longest substring is at the end of the string\\n        res = Math.max(res, chars.length - start);\\n        // return the longest length seen\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        // initialize variables\\n        char lastChar = s.charAt(0);\\n        int start = 0;\\n        int res = 0;\\n        char [] chars = s.toCharArray();\\n        \\n        // loop through each character of the string\\n        for(int i = 1; i < chars.length; i++){\\n            // if current character is one more than the previous character in ASCII order\\n            if(chars[i] == lastChar + 1){\\n                lastChar = chars[i];\\n            }\\n            // otherwise, reset the start index and update the longest length seen so far\\n            else{\\n                res = Math.max(res, i - start);\\n                lastChar = chars[i];\\n                start = i;\\n            }\\n        }\\n        // handle the case where the longest substring is at the end of the string\\n        res = Math.max(res, chars.length - start);\\n        // return the longest length seen\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736980,
                "title": "java-string-manipulation",
                "content": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int maxLength = 1, currentLength = 1;\\n        for(int i = 1;i<s.length();i++){\\n            currentLength = (int)(s.charAt(i) - \\'a\\') - (int)(s.charAt(i-1) - \\'a\\') == 1?currentLength+1:1;\\n            maxLength = Math.max(maxLength, currentLength); // Atleast if the condition never matches, the minimum length would be 1(\"Single alphabet strings\")\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int maxLength = 1, currentLength = 1;\\n        for(int i = 1;i<s.length();i++){\\n            currentLength = (int)(s.charAt(i) - \\'a\\') - (int)(s.charAt(i-1) - \\'a\\') == 1?currentLength+1:1;\\n            maxLength = Math.max(maxLength, currentLength); // Atleast if the condition never matches, the minimum length would be 1(\"Single alphabet strings\")\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664465,
                "title": "o-n",
                "content": "##### Java\\n```java\\npublic int longestContinuousSubstring(String s) {\\n        int longest = 1, current = 1;\\n        for (int i = 1; i < s.length(); ++i) {\\n            if (s.charAt(i) - s.charAt(i - 1) == 1)\\n                current++;\\n            else\\n                current = 1;\\n\\n            longest = Math.max(current, longest);\\n        }\\n\\n        return longest;\\n    }\\n```\\n\\n##### C++\\n```c++\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int longest = 1, current = 1;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (s[i] - s[i - 1] == 1)\\n                current++;\\n            else\\n                current = 1;\\n\\n            longest = max(longest, current);\\n        }\\n\\n        return longest;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int longestContinuousSubstring(String s) {\\n        int longest = 1, current = 1;\\n        for (int i = 1; i < s.length(); ++i) {\\n            if (s.charAt(i) - s.charAt(i - 1) == 1)\\n                current++;\\n            else\\n                current = 1;\\n\\n            longest = Math.max(current, longest);\\n        }\\n\\n        return longest;\\n    }\\n```\n```c++\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int longest = 1, current = 1;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (s[i] - s[i - 1] == 1)\\n                current++;\\n            else\\n                current = 1;\\n\\n            longest = max(longest, current);\\n        }\\n\\n        return longest;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2608036,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        global_max, local_max, prev = 0, 0, 0\\n        \\n        for cur in map(ord, s):\\n            if cur - prev == 1:\\n                local_max += 1\\n            else:\\n                local_max = 1\\n            \\n            global_max, prev = max(global_max, local_max), cur\\n            \\n        return global_max\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        global_max, local_max, prev = 0, 0, 0\\n        \\n        for cur in map(ord, s):\\n            if cur - prev == 1:\\n                local_max += 1\\n            else:\\n                local_max = 1\\n            \\n            global_max, prev = max(global_max, local_max), cur\\n            \\n        return global_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597916,
                "title": "c-o-26-m",
                "content": "```\\nstring ss = \"abcdefghijklmnopqrstuvwxyz\";\\n        int n = ss.length();\\n        int m = s.length();\\n        int res=0;\\n        \\n        int t[n+1][m+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j = 0;j<=m;j++){\\n                if(i==0 || j==0){\\n                    t[i][j] = 0;\\n                }\\n                else if(ss[i-1]==s[j-1]){\\n                    t[i][j] = t[i-1][j-1]+1;\\n                    res = max(res,t[i][j]);\\n                }\\n                else{\\n                    t[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        \\n        return res;\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nstring ss = \"abcdefghijklmnopqrstuvwxyz\";\\n        int n = ss.length();\\n        int m = s.length();\\n        int res=0;\\n        \\n        int t[n+1][m+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j = 0;j<=m;j++){\\n                if(i==0 || j==0){\\n                    t[i][j] = 0;\\n                }\\n                else if(ss[i-1]==s[j-1]){\\n                    t[i][j] = t[i-1][j-1]+1;\\n                    res = max(res,t[i][j]);\\n                }\\n                else{\\n                    t[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        \\n        return res;\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2592847,
                "title": "c-optimal-count-consecutive-return-max",
                "content": "**C++**\\n       \\n\\t    int longestContinuousSubstring(string s) {\\n        if(s.size()==1)return 1;\\n        int ans=0,mx=-9521;\\n        for(int i=1;i<s.size();i++){\\n            if((s[i]-s[i-1])==1)ans++;\\n            else\\n                ans=0;\\n                               //     cout<<ans<<\" \";\\n           mx=max(ans,mx);\\n        }\\n        return mx+1;\\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "**C++**\\n       \\n\\t    int longestContinuousSubstring(string s) {\\n        if(s.size()==1)return 1;\\n        int ans=0,mx=-9521;\\n        for(int i=1;i<s.size();i++){\\n            if((s[i]-s[i-1])==1)ans++;\\n            else\\n                ans=0;\\n                               //     cout<<ans<<\" \";\\n           mx=max(ans,mx);\\n        }\\n        return mx+1;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2590468,
                "title": "easy-for-loop",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string &s) {\\n        int mx = INT_MIN, len = 1;\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i] - s[i-1] == 1) {\\n                len++;\\n                mx = max(len, mx);\\n            } else {\\n                len = 1;\\n            }\\n        }\\n        mx = max(mx, len);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string &s) {\\n        int mx = INT_MIN, len = 1;\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i] - s[i-1] == 1) {\\n                len++;\\n                mx = max(len, mx);\\n            } else {\\n                len = 1;\\n            }\\n        }\\n        mx = max(mx, len);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590371,
                "title": "rust-dp-with-comments",
                "content": "EDIT 2022-09-18: With 20-20 hindsight, this is the clean functional-style solution that I would have wanted to come up with at 4:30 AM during the contest :D :\\n\\n```\\nimpl Solution {\\n    pub fn longest_continuous_substring(s: String) -> i32 {\\n        s.bytes()\\n            .fold((1, 0, 0), |(max, len, prev), curr| {\\n                if curr == prev + 1 {\\n                    (max.max(len + 1), len + 1, curr)\\n                } else {\\n                    (max, 1, curr)\\n                }\\n            })\\n            .0\\n    }\\n}\\n```\\n\\n**Original Post**\\n\\nThis is my unrevised submission for the 2022-09-18 Weekly Contest 311. We extend a window as long as possible. If the previous character comes before the current in the alphabet, we can extend the window by one. If not, we reset the window to one, since single letters are a substring of length one.\\n\\nComment: I knew I should reset the window to one, but did the typo to reset it to zero anyway when I submitted, and couldn\\'t understand what I had missed. \\xAF\\\\_(\\u30C4)_/\\xAF\\n\\n```rust\\nimpl Solution {\\n    pub fn longest_continuous_substring(s: String) -> i32 {\\n        let mut max = 1;\\n        let mut curr = 1;\\n        let s = s.as_bytes();\\n        for i in 1..s.len() {\\n            if s[i] == s[i-1] + 1 {\\n                curr += 1;\\n            } else {\\n                curr = 1;\\n            }\\n            max = max.max(curr);\\n        }\\n        max as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_continuous_substring(s: String) -> i32 {\\n        s.bytes()\\n            .fold((1, 0, 0), |(max, len, prev), curr| {\\n                if curr == prev + 1 {\\n                    (max.max(len + 1), len + 1, curr)\\n                } else {\\n                    (max, 1, curr)\\n                }\\n            })\\n            .0\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn longest_continuous_substring(s: String) -> i32 {\\n        let mut max = 1;\\n        let mut curr = 1;\\n        let s = s.as_bytes();\\n        for i in 1..s.len() {\\n            if s[i] == s[i-1] + 1 {\\n                curr += 1;\\n            } else {\\n                curr = 1;\\n            }\\n            max = max.max(curr);\\n        }\\n        max as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590279,
                "title": "easy-java-solution",
                "content": "**Length of the Longest Alphabetical Continuous Substring**\\n**Easy Java Solution**\\n\\n**Approach:**\\n1.) Iterate over the String\\n2.) Keep track of previous character value(ascii)\\n3.) If current character value is just 1 greater then previous character then it is part of continous substring and now we update current character as previous character andd increment len by 1\\n4.) Else current character is now the previous character and length is 1\\n\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        //Stores the ans, maximum longest continous subarray\\n        int ans=0;\\n        int len=0;\\n        //Stores the value of previous character in integer form(ascii)\\n        int prev=-1;\\n        for(int i=0;i<s.length();i++){\\n            //If prev==-1 means we are at the first character of the string\\n            if(prev==-1){\\n                len++;\\n                prev=s.charAt(i)-\\'a\\';\\n            }\\n            else{\\n                //If current character value is just 1 greater then previous character then it is part of continous substring and now we update current character as previous character andd increment len by 1\\n                if(s.charAt(i)-\\'a\\'==prev+1){\\n                    len++;\\n                    prev=s.charAt(i)-\\'a\\';\\n                }\\n                //Else current character is now the previous character and length is 1\\n                else{\\n                    len=1;\\n                    prev=s.charAt(i)-\\'a\\';\\n                }\\n            }\\n            ans=Math.max(ans,len);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        //Stores the ans, maximum longest continous subarray\\n        int ans=0;\\n        int len=0;\\n        //Stores the value of previous character in integer form(ascii)\\n        int prev=-1;\\n        for(int i=0;i<s.length();i++){\\n            //If prev==-1 means we are at the first character of the string\\n            if(prev==-1){\\n                len++;\\n                prev=s.charAt(i)-\\'a\\';\\n            }\\n            else{\\n                //If current character value is just 1 greater then previous character then it is part of continous substring and now we update current character as previous character andd increment len by 1\\n                if(s.charAt(i)-\\'a\\'==prev+1){\\n                    len++;\\n                    prev=s.charAt(i)-\\'a\\';\\n                }\\n                //Else current character is now the previous character and length is 1\\n                else{\\n                    len=1;\\n                    prev=s.charAt(i)-\\'a\\';\\n                }\\n            }\\n            ans=Math.max(ans,len);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590193,
                "title": "using-concept-of-longest-common-substring-dp-c",
                "content": "```c++\\nint longestContinuousSubstring(string s1) {\\n        string s2=\"abcdefghijklmnopqrstuvwxyz\";\\n        int m=s1.length(),n=s2.length(),sol=0;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(s1[i-1]==s2[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                    sol=max(sol,dp[i][j]);\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c++\\nint longestContinuousSubstring(string s1) {\\n        string s2=\"abcdefghijklmnopqrstuvwxyz\";\\n        int m=s1.length(),n=s2.length(),sol=0;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(s1[i-1]==s2[j-1])\\n                {\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                    sol=max(sol,dp[i][j]);\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590046,
                "title": "python-o-n-time-o-1-space-7-lines",
                "content": "Check two consecutive chars - if they are consecutive in the alphabet, the difference will be 1.\\n\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        res, currLen = 1, 1\\n        for i in range(1, len(s)):\\n            currLen = currLen + 1 if ord(s[i]) - ord(s[i - 1]) == 1 else 1\\n            res = max(res, currLen)\\n        return res\\n```\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        res, currLen = 1, 1\\n        for i in range(1, len(s)):\\n            currLen = currLen + 1 if ord(s[i]) - ord(s[i - 1]) == 1 else 1\\n            res = max(res, currLen)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819944,
                "title": "beats-90-cpp-sol-o-n-time-and-o-1-space",
                "content": "\\n# Pls Upvote Me if it Helps \\uD83D\\uDE07\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int front = 0;\\n        int back = 0;\\n        int ans = 0;\\n\\n        while(front < s.size()){\\n            if(front+1 < s.size() && s[front] == s[front+1]-1){\\n                front++;\\n            }\\n            else{\\n                front++;\\n                back = front;\\n            }\\n            ans = max(ans, front-back+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int front = 0;\\n        int back = 0;\\n        int ans = 0;\\n\\n        while(front < s.size()){\\n            if(front+1 < s.size() && s[front] == s[front+1]-1){\\n                front++;\\n            }\\n            else{\\n                front++;\\n                back = front;\\n            }\\n            ans = max(ans, front-back+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488820,
                "title": "easy-python-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        lst=[]\\n        for i in range(len(s)-1):\\n            lst.append(ord(s[i+1])-ord(s[i]))\\n        print(lst)\\n        i=0\\n        bst=[]\\n        c=1\\n        l=1\\n        while i<len(lst):\\n            \\n            if lst[i]==1:\\n                c+=1\\n\\n                i+=1\\n                l=max(l,c)\\n            else:\\n                c=1\\n                i+=1\\n        return l\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        lst=[]\\n        for i in range(len(s)-1):\\n            lst.append(ord(s[i+1])-ord(s[i]))\\n        print(lst)\\n        i=0\\n        bst=[]\\n        c=1\\n        l=1\\n        while i<len(lst):\\n            \\n            if lst[i]==1:\\n                c+=1\\n\\n                i+=1\\n                l=max(l,c)\\n            else:\\n                c=1\\n                i+=1\\n        return l\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426887,
                "title": "easy-to-understand-c-soltuion-string-sliding-window",
                "content": "if u like the solution upvote plss\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans=1, x=1;\\n        for(int i=1;i<s.size();i++)\\n        {\\n           if((s[i]-\\'0\\') -(s[i-1]-\\'0\\')==1)\\n           {\\n               x++;\\n               ans= max(ans,x);\\n           }\\n            else\\n            {\\n                x=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans=1, x=1;\\n        for(int i=1;i<s.size();i++)\\n        {\\n           if((s[i]-\\'0\\') -(s[i-1]-\\'0\\')==1)\\n           {\\n               x++;\\n               ans= max(ans,x);\\n           }\\n            else\\n            {\\n                x=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322728,
                "title": "c-one-pass-90-faster-concise",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int local = 1, res = 1;\\n    for (int i = 1; i < s.size(); i++) {\\n        // Check if the difference between the current character and the previous character is equal to 1.\\n        // If it is, increment `local` by 1, otherwise reset `local` to 1.\\n        local = s[i] - s[i-1] == 1 ? local + 1: 1;\\n        res = max(res, local);\\n    }\\n    return res;\\n}\\n```\\n\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int local = 1, res = 1;\\n    for (int i = 1; i < s.size(); i++) {\\n        // Check if the difference between the current character and the previous character is equal to 1.\\n        // If it is, increment `local` by 1, otherwise reset `local` to 1.\\n        local = s[i] - s[i-1] == 1 ? local + 1: 1;\\n        res = max(res, local);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322170,
                "title": "c-python-simple-code-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n\\n        int N = s.size();\\n        vector<int>dp(N+1, 1);\\n\\n        for(int i = 0; i < N - 1; i++){\\n            if((int)s[i] + 1 == (int)s[i+1]){\\n                dp[i+1] = dp[i] + 1;\\n            }\\n        }\\n\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n\\n        dp = [1 for _ in range(len(s) + 1)]\\n\\n        for i in range(len(s)-1):\\n            if ord(s[i]) + 1 == ord(s[i+1]):\\n                dp[i+1] = dp[i] + 1\\n\\n        return max(dp)        \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n\\n        int N = s.size();\\n        vector<int>dp(N+1, 1);\\n\\n        for(int i = 0; i < N - 1; i++){\\n            if((int)s[i] + 1 == (int)s[i+1]){\\n                dp[i+1] = dp[i] + 1;\\n            }\\n        }\\n\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n\\n        dp = [1 for _ in range(len(s) + 1)]\\n\\n        for i in range(len(s)-1):\\n            if ord(s[i]) + 1 == ord(s[i+1]):\\n                dp[i+1] = dp[i] + 1\\n\\n        return max(dp)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239439,
                "title": "c-simple-clear-and-concise-one-pass-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = INT_MIN;\\n        int n = s.size();\\n        int i = 0;\\n        char curr = s[i];\\n        int currlen = 1;\\n        i = 1;\\n        ans = 1;\\n        while (i < n) {\\n            if (curr+1 != s[i]) {\\n                ans = max(ans, currlen);\\n                currlen = 0;\\n            }\\n            curr = s[i];\\n            currlen++;\\n            i++;\\n        }\\n        ans = max(ans, currlen);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = INT_MIN;\\n        int n = s.size();\\n        int i = 0;\\n        char curr = s[i];\\n        int currlen = 1;\\n        i = 1;\\n        ans = 1;\\n        while (i < n) {\\n            if (curr+1 != s[i]) {\\n                ans = max(ans, currlen);\\n                currlen = 0;\\n            }\\n            curr = s[i];\\n            currlen++;\\n            i++;\\n        }\\n        ans = max(ans, currlen);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232012,
                "title": "easy-c-solution-beaten-81-t-c",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int count = 1;\\n        int maxi = -1;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i+1]-s[i]==1)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                maxi = max(maxi,count);\\n                count=1;\\n            }\\n        }\\n        return max(maxi,count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int count = 1;\\n        int maxi = -1;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i+1]-s[i]==1)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                maxi = max(maxi,count);\\n                count=1;\\n            }\\n        }\\n        return max(maxi,count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160092,
                "title": "java-simple-approach",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int len = 1;\\n        int max = 1;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s.charAt(i) - 1 == s.charAt(i - 1)){\\n                len++;\\n            }else{\\n                max = Math.max(max, len);\\n                len = 1;\\n            }\\n        }\\n        return Math.max(max, len);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int len = 1;\\n        int max = 1;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s.charAt(i) - 1 == s.charAt(i - 1)){\\n                len++;\\n            }else{\\n                max = Math.max(max, len);\\n                len = 1;\\n            }\\n        }\\n        return Math.max(max, len);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028460,
                "title": "python3-two-pointer",
                "content": "\\n# Approach\\nInitialize i with index 0 and j with index 1.\\nFix the pointer \\'i\\' and keep on moving pointer \\'j\\' until the difference between ascii value of s[j] and s[j-1] equals 1. Keep updating the answer with max length obtained till the current step. once the difference between ascii value of s[j] and s[j-1] not equals 1, i.e s[j] and s[j-1] are not consecutive update the pointer \\'i\\' to pointer \\'j\\' and pointer \\'j\\' to j+1. Here updation indicates that we are trying to find the possible solutions starting at index \\'i\\'.\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        i = 0\\n        j = 1\\n        n = len(s)\\n        ans = 1\\n        while j<n:\\n            while j<n and ord(s[j])-ord(s[j-1])==1:\\n                ans = max(ans,j-i+1)\\n                j+=1\\n            if j<n and ord(s[j])-ord(s[j-1])!=1:\\n                i = j\\n                j+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        i = 0\\n        j = 1\\n        n = len(s)\\n        ans = 1\\n        while j<n:\\n            while j<n and ord(s[j])-ord(s[j-1])==1:\\n                ans = max(ans,j-i+1)\\n                j+=1\\n            if j<n and ord(s[j])-ord(s[j-1])!=1:\\n                i = j\\n                j+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983933,
                "title": "c-explained-in-detail-fastser-than-89-simple-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding window \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate once over the string and find all continous substring which is alphabetical keep maximum of size of all such substring and return at the end \\n\\\\\\n![image.png](https://assets.leetcode.com/users/images/587d205d-8fbb-42bc-8f2d-483f5938e787_1672641404.194256.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int mexi=1;\\n        for(int i=0;i<s.size();i++){\\n            int cnt=0;\\n            if(s[i+1]-s[i]==1){\\n                while(s[i+1]-s[i]==1&&i<s.size()){\\n                    cnt++;\\n                    i++;\\n                }\\n                mexi=max(mexi,cnt+1);\\n            }\\n        }\\n        return mexi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Greedy",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int mexi=1;\\n        for(int i=0;i<s.size();i++){\\n            int cnt=0;\\n            if(s[i+1]-s[i]==1){\\n                while(s[i+1]-s[i]==1&&i<s.size()){\\n                    cnt++;\\n                    i++;\\n                }\\n                mexi=max(mexi,cnt+1);\\n            }\\n        }\\n        return mexi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854511,
                "title": "c-o-n-and-o-1-space-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = INT_MIN, count = 1;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if((s[i + 1] - \\'a\\') - (s[i] - \\'a\\') == 1)\\n                count++;\\n            else\\n            {\\n                ans = max(ans, count);\\n                count = 1;\\n            }\\n        }\\n        return max(ans, count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = INT_MIN, count = 1;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if((s[i + 1] - \\'a\\') - (s[i] - \\'a\\') == 1)\\n                count++;\\n            else\\n            {\\n                ans = max(ans, count);\\n                count = 1;\\n            }\\n        }\\n        return max(ans, count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828964,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int res=0;\\n        while(i<n){\\n            int j=i+1;\\n            while(j<n and (int)(s[j]-s[j-1])==1){\\n                j++;\\n            }\\n          \\n            res=max(res,j-i);\\n            i=j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int res=0;\\n        while(i<n){\\n            int j=i+1;\\n            while(j<n and (int)(s[j]-s[j-1])==1){\\n                j++;\\n            }\\n          \\n            res=max(res,j-i);\\n            i=j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788894,
                "title": "90-faster-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int x = 1;\\n        int ans = 1;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s[i] == (s[i-1]+1)){\\n                x++;\\n            }else{\\n                x = 1;\\n            }\\n            ans = max(ans,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int x = 1;\\n        int ans = 1;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s[i] == (s[i-1]+1)){\\n                x++;\\n            }else{\\n                x = 1;\\n            }\\n            ans = max(ans,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783818,
                "title": "c-two-pointers-cleanest-code-easiest-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int res=0;\\n        while(i<n){\\n            int j=i+1;\\n            while(j<n and (int)(s[j]-s[j-1])==1){\\n                j++;\\n            }\\n            //so when we broke out basically we had encountered a character who doesnt satisfy the desired condition\\n\\t\\t\\t//    |  i..............j-1  |  j\\n\\t\\t\\t//  i till j-1 satisfies the condition,so the length will be j-1-i+1= j-i\\n            res=max(res,j-i);\\n            i=j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int res=0;\\n        while(i<n){\\n            int j=i+1;\\n            while(j<n and (int)(s[j]-s[j-1])==1){\\n                j++;\\n            }\\n            //so when we broke out basically we had encountered a character who doesnt satisfy the desired condition\\n\\t\\t\\t//    |  i..............j-1  |  j\\n\\t\\t\\t//  i till j-1 satisfies the condition,so the length will be j-1-i+1= j-i\\n            res=max(res,j-i);\\n            i=j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693978,
                "title": "97-faster-simplest-approach-o-n-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/68cff3cd-e11c-4bbb-ae6f-b5b7c23a362a_1665568787.1114748.png)\\n\\n\\n```\\npublic int LongestContinuousSubstring(string s) {\\n        int longestLen = 1;\\n        int currLen = 1;\\n        for(int i=1; i<s.Length; i++)\\n        {\\n            if(s[i] == s[i-1]+1) \\n            {\\n                currLen++;\\n                longestLen = Math.Max(currLen, longestLen);\\n            }\\n            else\\n            {\\n                currLen = 1;\\n            }\\n        }\\n        return longestLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int LongestContinuousSubstring(string s) {\\n        int longestLen = 1;\\n        int currLen = 1;\\n        for(int i=1; i<s.Length; i++)\\n        {\\n            if(s[i] == s[i-1]+1) \\n            {\\n                currLen++;\\n                longestLen = Math.Max(currLen, longestLen);\\n            }\\n            else\\n            {\\n                currLen = 1;\\n            }\\n        }\\n        return longestLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2650289,
                "title": "alternate-binarysearch-rolling-hash-solution-but-slow-optimized-o-n-sliding-window",
                "content": "``` Time Complexity : O(Nlog26) = O(N) ```\\n```\\nclass Solution {\\n    long pow = 31;\\n    HashSet<Long> set = new HashSet<>();\\n    public int longestContinuousSubstring(String s) {\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n        //  precomputing hashes of all valid \"Alphabetical Continuous Substring\"\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i; j < 26; j++) {\\n                char[] a = str.substring(i, j + 1).toCharArray();\\n                set.add(findHash(a, a.length));\\n            }\\n        }\\n        int l = 1, r = 26;\\n        int answer = 1;\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n            if (isPresent(s.toCharArray(), mid)) {\\n                //  check if a substring of length \"mid\" is present which \\n                //  follows the \"Alphabetical Continuous Substring\" constraint\\n                answer = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    //  Rolling Hash : \\n    //                  for finding hash of substrings of length \"len\" in char[] s\\n    public boolean isPresent(char[] s, int len) {\\n        if (len > s.length) {\\n            return false;\\n        }\\n        \\n        long fact = 1, temp = len;\\n        while (temp-- > 1) {\\n            fact *= pow;\\n        }\\n        \\n        long hash = findHash(s, len);\\n        if (set.contains(hash)) {\\n            return true;\\n        }\\n        \\n        for (int c = len; c < s.length; c++) {\\n            hash -= s[c - len] * fact;\\n            hash = hash * pow + s[c];\\n            if (set.contains(hash)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    //  finding the hash of the first substring of length \"len\" in char[] a\\n    public long findHash(char[] a, int len) {\\n        long hash = 0, currPow = 1;\\n        for (int i = len - 1; i >= 0; i--) {\\n            hash += a[i] * currPow;\\n            currPow *= pow;\\n        }\\n        return hash;\\n    }\\n}\\n\\n```\\n```\\n//  optimized solution Time Complexity : O(N)\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        char[] a = s.toCharArray();\\n        int n = a.length;\\n        int answer = 1, l = 0;\\n        for (int r = 1; r < n; r++) {\\n            while (r < a.length && a[r] == a[r - 1] + 1) {\\n                r++;\\n            }\\n            answer = Math.max(answer, r - l);\\n            l = r;\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [
                    "Binary Search",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "``` Time Complexity : O(Nlog26) = O(N) ```\n```\\nclass Solution {\\n    long pow = 31;\\n    HashSet<Long> set = new HashSet<>();\\n    public int longestContinuousSubstring(String s) {\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n        //  precomputing hashes of all valid \"Alphabetical Continuous Substring\"\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i; j < 26; j++) {\\n                char[] a = str.substring(i, j + 1).toCharArray();\\n                set.add(findHash(a, a.length));\\n            }\\n        }\\n        int l = 1, r = 26;\\n        int answer = 1;\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n            if (isPresent(s.toCharArray(), mid)) {\\n                //  check if a substring of length \"mid\" is present which \\n                //  follows the \"Alphabetical Continuous Substring\" constraint\\n                answer = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    //  Rolling Hash : \\n    //                  for finding hash of substrings of length \"len\" in char[] s\\n    public boolean isPresent(char[] s, int len) {\\n        if (len > s.length) {\\n            return false;\\n        }\\n        \\n        long fact = 1, temp = len;\\n        while (temp-- > 1) {\\n            fact *= pow;\\n        }\\n        \\n        long hash = findHash(s, len);\\n        if (set.contains(hash)) {\\n            return true;\\n        }\\n        \\n        for (int c = len; c < s.length; c++) {\\n            hash -= s[c - len] * fact;\\n            hash = hash * pow + s[c];\\n            if (set.contains(hash)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    //  finding the hash of the first substring of length \"len\" in char[] a\\n    public long findHash(char[] a, int len) {\\n        long hash = 0, currPow = 1;\\n        for (int i = len - 1; i >= 0; i--) {\\n            hash += a[i] * currPow;\\n            currPow *= pow;\\n        }\\n        return hash;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636695,
                "title": "c-concise",
                "content": "```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int max = 1, cnt = 1;        \\n        for (int i = 1; i < s.Length; i++) {\\n            cnt = s[i] - s[i - 1] == 1 ? cnt + 1 : 1;\\n            max = Math.Max(max, cnt);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int max = 1, cnt = 1;        \\n        for (int i = 1; i < s.Length; i++) {\\n            cnt = s[i] - s[i - 1] == 1 ? cnt + 1 : 1;\\n            max = Math.Max(max, cnt);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619902,
                "title": "38-ms-100-faster-and-85-space-efficient-cpp-solution-in-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int res=1;\\n        \\n        int curr=1;\\n        for(int i=1;i<s.length();i++){\\n            if(s[i]==(s[i-1]+1)){\\n                curr++;\\n            }\\n            else{\\n                res=max(res,curr);\\n                curr=1;\\n            }\\n        }\\n        res=max(res,curr);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int res=1;\\n        \\n        int curr=1;\\n        for(int i=1;i<s.length();i++){\\n            if(s[i]==(s[i-1]+1)){\\n                curr++;\\n            }\\n            else{\\n                res=max(res,curr);\\n                curr=1;\\n            }\\n        }\\n        res=max(res,curr);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612890,
                "title": "for-beginners-easy-to-understandable-solution-c",
                "content": "class Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int count =1,ans=0;\\n        if(s.size()>1)\\n        {for(int i=0;i<s.size()-1;i++)\\n        {\\n            int ch =s[i]-\\'a\\';\\n            int ch2=s[i+1]-\\'a\\';\\n            if(ch2-ch==1)\\n            {\\n             if(ans<=count)   \\n                ans=count++;\\n               else count++;             \\n            }\\n            \\n            \\n            else \\n            { count=1;\\n             }\\n            \\n            if(count>ans)\\n                ans=count;\\n            \\n        }\\n        return ans;\\n        }\\n        else \\n            return 1;\\n        \\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int count =1,ans=0;\\n        if(s.size()>1)\\n        {for(int i=0;i<s.size()-1;i++)\\n        {\\n            int ch =s[i]-\\'a\\';\\n            int ch2=s[i+1]-\\'a\\';\\n            if(ch2-ch==1)\\n            {\\n             if(ans<=count)   \\n                ans=count++;\\n               else count++;             \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2603272,
                "title": "java-15ms-runtime-easy-and-elegant-solution",
                "content": "```\\nint l=1, n=1;\\nchar[] c=s.toCharArray();       //iterating over each element of string takes time so convert it to char array\\nfor(int i=0; i<c.length-1; i++) {\\n\\tif(c[i]+1 == c[i+1] )       \\n\\t\\tn++;\\n\\telse n=1;\\n\\tl = Math.max(l,n);\\n}\\nreturn l;\\n```\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "solutionTags": [],
                "code": "```\\nint l=1, n=1;\\nchar[] c=s.toCharArray();       //iterating over each element of string takes time so convert it to char array\\nfor(int i=0; i<c.length-1; i++) {\\n\\tif(c[i]+1 == c[i+1] )       \\n\\t\\tn++;\\n\\telse n=1;\\n\\tl = Math.max(l,n);\\n}\\nreturn l;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602222,
                "title": "easy-o-n-sliding-window-solution",
                "content": "// time complexity o(n)\\n// space complexity o(1)\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int count=1;\\n        int max=1;\\n        for(int i=1;i<s.length();i++){\\n            if(s.charAt(i-1)-\\'a\\'+1==s.charAt(i)-\\'a\\'){\\n                count++;\\n                max=Math.max(count,max);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int count=1;\\n        int max=1;\\n        for(int i=1;i<s.length();i++){\\n            if(s.charAt(i-1)-\\'a\\'+1==s.charAt(i)-\\'a\\'){\\n                count++;\\n                max=Math.max(count,max);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600810,
                "title": "c-o-n-single-pass-with-line-by-line-comments-for-beginers",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans=1; //variable to store ans\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            int count=1;\\n            if(s[i+1]==s[i]+1)// this check can be skipped as it is getting covered in while loop\\n            {\\n                while(s[i+1]==s[i]+1) // if charecters are continous as example, int value for b = int value for a + 1\\n                {\\n                    count++;\\n                    i++;\\n                    ans=max(ans,count);// update global count\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans=1; //variable to store ans\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            int count=1;\\n            if(s[i+1]==s[i]+1)// this check can be skipped as it is getting covered in while loop\\n            {\\n                while(s[i+1]==s[i]+1) // if charecters are continous as example, int value for b = int value for a + 1\\n                {\\n                    count++;\\n                    i++;\\n                    ans=max(ans,count);// update global count\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599173,
                "title": "python-3-one-line-with-groupby",
                "content": "# Idea\\n\\nTransform the input `ycdezf` ... instead of looking for `bcd`, consider subtracting by index:\\n\\n`y - 0`, `c - 1`, `d - 2`, `e - 3`, `z - 4`, `f - 5`\\n\\nthat produces `ybbbva`. Now we just have to look for `bbb`. Or the longest streak of any character.\\n\\nWe don\\'t actually have to convert to different characters, we can just convert to the ordinal value, subtract the current index, and then look for streaks:\\n\\n`ord(c) - i`\\n\\nFinally, we can use `groupby` to look for the longest streak:\\n\\n`max(len([*g]) for _,g in groupby(...))`\\n\\n# Code\\n\\n\\nShort and simple:\\n```\\nclass Solution:\\n  def longestContinuousSubstring(self, s: str) -> int:\\n    return max(len([*g]) for _,g in groupby(ord(c) - i for i,c in enumerate(s)))\\n```\\nOr longer, but a bit slicker:\\n```\\n    return max(len(list(g)) for _,g in groupby(starmap(sub, enumerate(map(ord, s)))))\\n```\\n\\n# Complexity note\\n\\nThere is a problem with `len([*g])` and `len(list(g))`...\\n\\nThis uses worst case `O(n)` space, where `n` is the length of the input.\\n\\nWe can instead use `sum(1 for _ in g)` to always use `O(1)` space.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def longestContinuousSubstring(self, s: str) -> int:\\n    return max(len([*g]) for _,g in groupby(ord(c) - i for i,c in enumerate(s)))\\n```\n```\\n    return max(len(list(g)) for _,g in groupby(starmap(sub, enumerate(map(ord, s)))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596895,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int maxL = 1, l = 0, r = 1, n = s.size();\\n        for(; r < n; r++)\\n            s[r] - s[r - 1] == 1 ? maxL = max(maxL, r - l + 1) : l = r;\\n        return maxL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int maxL = 1, l = 0, r = 1, n = s.size();\\n        for(; r < n; r++)\\n            s[r] - s[r - 1] == 1 ? maxL = max(maxL, r - l + 1) : l = r;\\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596855,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n var longestContinuousSubstring = function(s) {\\n    let longest = 1;\\n    let currentCount = 1;\\n    \\n    for (let i = 1; i < s.length; i++){\\n        let currentCh = s[i].charCodeAt(0);\\n        let previousCh = s[i - 1].charCodeAt(0);\\n        \\n        if (currentCh - previousCh === 1){\\n            currentCount += 1;\\n        } else {\\n            currentCount = 1\\n        }\\n        \\n        if (currentCount > longest) {\\n            longest = currentCount;\\n        }\\n    }\\n    \\n    return longest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n var longestContinuousSubstring = function(s) {\\n    let longest = 1;\\n    let currentCount = 1;\\n    \\n    for (let i = 1; i < s.length; i++){\\n        let currentCh = s[i].charCodeAt(0);\\n        let previousCh = s[i - 1].charCodeAt(0);\\n        \\n        if (currentCh - previousCh === 1){\\n            currentCount += 1;\\n        } else {\\n            currentCount = 1\\n        }\\n        \\n        if (currentCount > longest) {\\n            longest = currentCount;\\n        }\\n    }\\n    \\n    return longest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2596698,
                "title": "c-easy-and-efficient-approach",
                "content": "\\'\\'\\'\\n//IT\\'s my birthday special contest\\uD83E\\uDD73\\n\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        \\n        int cnt = 1;\\n        int maxi = 1;\\n        \\n        for(int i = 0; i < s.size() - 1; i++){\\n            \\n            if((int)s[i+1] == (int)s[i] + 1){\\n                cnt++;\\n            }\\n            \\n            if((int)s[i+1] != (int)s[i] + 1){\\n                cnt = 1;\\n            }\\n            \\n            maxi = max(maxi, cnt);\\n        }\\n        \\n        \\n        return maxi;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        \\n        int cnt = 1;\\n        int maxi = 1;\\n        \\n        for(int i = 0; i < s.size() - 1; i++){\\n            \\n            if((int)s[i+1] == (int)s[i] + 1){\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2593812,
                "title": "rust-0-ms-simple-one-pass-counting-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/803019370/) employs a simple one-pass algorithm. It demonstrated **0 ms runtime (100.00%)** and used **2.3 MB memory (100.00%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn longest_continuous_substring(s: String) -> i32 \\n    {\\n        let mut max_len : i32 = 0;\\n        let mut cur_len : i32 = 0;\\n        let mut prev    : u8 = 0;\\n        \\n        // [1] we keep track of the current length \\'cur_len\\' of substring\\n\\t\\t//     and update \\'max_len\\' every time the continuous substring is broken\\n        for &ch in s.as_bytes()\\n        {\\n            if ch != prev + 1 \\n            { \\n                max_len = max_len.max(cur_len); \\n                cur_len = 0; \\n            }\\n            cur_len += 1;\\n            prev = ch;\\n        }\\n        \\n        // [2] update \\'max_len\\' for the last continuous substring\\n        max_len.max(cur_len)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn longest_continuous_substring(s: String) -> i32 \\n    {\\n        let mut max_len : i32 = 0;\\n        let mut cur_len : i32 = 0;\\n        let mut prev    : u8 = 0;\\n        \\n        // [1] we keep track of the current length \\'cur_len\\' of substring\\n\\t\\t//     and update \\'max_len\\' every time the continuous substring is broken\\n        for &ch in s.as_bytes()\\n        {\\n            if ch != prev + 1 \\n            { \\n                max_len = max_len.max(cur_len); \\n                cur_len = 0; \\n            }\\n            cur_len += 1;\\n            prev = ch;\\n        }\\n        \\n        // [2] update \\'max_len\\' for the last continuous substring\\n        max_len.max(cur_len)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2593387,
                "title": "one-pass-greedy-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = 1;\\n        int count = 1;\\n        int n = s.size();\\n        for(int i=1;i<n;i++){\\n            if((s[i-1]-\\'a\\')+1==(s[i]-\\'a\\')){\\n                count++;\\n            } else{\\n                ans = max(ans,count);\\n                count =1;\\n            }\\n        }\\n        ans = max(ans,count);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = 1;\\n        int count = 1;\\n        int n = s.size();\\n        for(int i=1;i<n;i++){\\n            if((s[i-1]-\\'a\\')+1==(s[i]-\\'a\\')){\\n                count++;\\n            } else{\\n                ans = max(ans,count);\\n                count =1;\\n            }\\n        }\\n        ans = max(ans,count);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593233,
                "title": "simple-two-pointer-solution-t-c-o-n-and-s-c-o-1",
                "content": "```\\n int longestContinuousSubstring(string s) {\\n        int n=s.length();\\n        int i=0,j=1;\\n        int ans=1;\\n        int currlen=1;\\n        while(j<n){\\n            if(s[j-1]+1==s[j]){\\n                currlen++;\\n                ans=max(ans,currlen);\\n            }else{\\n                i=j;\\n                currlen=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int longestContinuousSubstring(string s) {\\n        int n=s.length();\\n        int i=0,j=1;\\n        int ans=1;\\n        int currlen=1;\\n        while(j<n){\\n            if(s[j-1]+1==s[j]){\\n                currlen++;\\n                ans=max(ans,currlen);\\n            }else{\\n                i=j;\\n                currlen=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2592937,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        alphabet = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        start, max_len = 0, 0\\n        for i in range(1, len(s) + 1):  # from length 1 to len(s)\\n            if s[start:i] in alphabet:  # check whether slice is consecutive\\n                max_len = max(max_len, i - start)\\n            else:\\n                start = i - 1\\n        return max_len\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        alphabet = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        start, max_len = 0, 0\\n        for i in range(1, len(s) + 1):  # from length 1 to len(s)\\n            if s[start:i] in alphabet:  # check whether slice is consecutive\\n                max_len = max(max_len, i - start)\\n            else:\\n                start = i - 1\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592563,
                "title": "python-easy-solution",
                "content": "class Solution:\\n\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        dp = [1 for _ in range(len(s))]\\n        \\n        for i in range(1, len(s)):\\n            if ord(s[i]) == ord(s[i - 1]) + 1:\\n                dp[i] = dp[i - 1] + 1\\n                \\n        return max(dp)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        dp = [1 for _ in range(len(s))]\\n        \\n        for i in range(1, len(s)):\\n            if ord(s[i]) == ord(s[i - 1]) + 1:\\n                dp[i] = dp[i - 1] + 1\\n                \\n        return max(dp)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2592363,
                "title": "c-o-n-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        if(s.length()==1) return 1;\\n        int maxi= 1;\\n        int count=1;\\n        for(int i=1;i<s.length();i++) {\\n            if((s[i]-\\'a\\')-(s[i-1]-\\'a\\') ==1) { \\n                count++;\\n                maxi= max(maxi,count);\\n            } else {\\n                count=1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        if(s.length()==1) return 1;\\n        int maxi= 1;\\n        int count=1;\\n        for(int i=1;i<s.length();i++) {\\n            if((s[i]-\\'a\\')-(s[i-1]-\\'a\\') ==1) { \\n                count++;\\n                maxi= max(maxi,count);\\n            } else {\\n                count=1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592161,
                "title": "mapping-c-constant-space-o-n",
                "content": "**Mapping of characters to integer and check integer difference between 2 consecutive characters**\\n\\n\\n``` \\n\\t\\t\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        unordered_map<char , int> mpp ;\\n        mpp.insert({\\'a\\',1}) ;\\n        mpp.insert({\\'b\\',2}) ;\\n        mpp.insert({\\'c\\',3}) ;\\n        mpp.insert({\\'d\\',4}) ;\\n        mpp.insert({\\'e\\',5}) ;\\n        mpp.insert({\\'f\\',6}) ;\\n        mpp.insert({\\'g\\',7}) ;\\n        mpp.insert({\\'h\\',8}) ;\\n        mpp.insert({\\'i\\',9}) ;\\n        mpp.insert({\\'j\\',10}) ;\\n        mpp.insert({\\'k\\',11}) ;\\n        mpp.insert({\\'l\\',12}) ;\\n        mpp.insert({\\'m\\',13}) ;\\n        mpp.insert({\\'n\\',14}) ;\\n        mpp.insert({\\'o\\',15}) ;\\n        mpp.insert({\\'p\\',16}) ;\\n        mpp.insert({\\'q\\',17}) ;\\n        mpp.insert({\\'r\\',18}) ;\\n        mpp.insert({\\'s\\',19}) ;\\n        mpp.insert({\\'t\\',20}) ;\\n        mpp.insert({\\'u\\',21}) ;\\n        mpp.insert({\\'v\\',22}) ;\\n        mpp.insert({\\'w\\',23}) ;\\n        mpp.insert({\\'x\\',24}) ;\\n        mpp.insert({\\'y\\',25}) ;\\n        mpp.insert({\\'z\\',26}) ;\\n        \\n        int cnt = 1;\\n        int maxAns = INT_MIN ;\\n        for(int i = 0 ; i < s.size() ; i++){\\n            if(mpp[s[i]]+1 == mpp[s[i+1]]){\\n                cnt++ ;\\n            }else{\\n                maxAns = max(cnt , maxAns) ;\\n                cnt = 1 ;\\n            }\\n        }\\n        \\n        return maxAns ;\\n    }\\n};\\n\\t\\n```\\n\\n\\n**Without Hashmap**\\n\\n```  \\n\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {    \\n        int cnt = 1;\\n        int maxAns = INT_MIN ;\\n        for(int i = 0 ; i < s.size() ; i++){\\n            if((s[i]-0) +1 == (s[i+1]-0)){\\n                cnt++ ;\\n            }else{\\n                maxAns = max(cnt , maxAns) ;\\n                cnt = 1 ;\\n            }\\n        }\\n        \\n        return maxAns ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\n\\t\\t\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        unordered_map<char , int> mpp ;\\n        mpp.insert({\\'a\\',1}) ;\\n        mpp.insert({\\'b\\',2}) ;\\n        mpp.insert({\\'c\\',3}) ;\\n        mpp.insert({\\'d\\',4}) ;\\n        mpp.insert({\\'e\\',5}) ;\\n        mpp.insert({\\'f\\',6}) ;\\n        mpp.insert({\\'g\\',7}) ;\\n        mpp.insert({\\'h\\',8}) ;\\n        mpp.insert({\\'i\\',9}) ;\\n        mpp.insert({\\'j\\',10}) ;\\n        mpp.insert({\\'k\\',11}) ;\\n        mpp.insert({\\'l\\',12}) ;\\n        mpp.insert({\\'m\\',13}) ;\\n        mpp.insert({\\'n\\',14}) ;\\n        mpp.insert({\\'o\\',15}) ;\\n        mpp.insert({\\'p\\',16}) ;\\n        mpp.insert({\\'q\\',17}) ;\\n        mpp.insert({\\'r\\',18}) ;\\n        mpp.insert({\\'s\\',19}) ;\\n        mpp.insert({\\'t\\',20}) ;\\n        mpp.insert({\\'u\\',21}) ;\\n        mpp.insert({\\'v\\',22}) ;\\n        mpp.insert({\\'w\\',23}) ;\\n        mpp.insert({\\'x\\',24}) ;\\n        mpp.insert({\\'y\\',25}) ;\\n        mpp.insert({\\'z\\',26}) ;\\n        \\n        int cnt = 1;\\n        int maxAns = INT_MIN ;\\n        for(int i = 0 ; i < s.size() ; i++){\\n            if(mpp[s[i]]+1 == mpp[s[i+1]]){\\n                cnt++ ;\\n            }else{\\n                maxAns = max(cnt , maxAns) ;\\n                cnt = 1 ;\\n            }\\n        }\\n        \\n        return maxAns ;\\n    }\\n};\\n\\t\\n```\n```  \\n\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {    \\n        int cnt = 1;\\n        int maxAns = INT_MIN ;\\n        for(int i = 0 ; i < s.size() ; i++){\\n            if((s[i]-0) +1 == (s[i+1]-0)){\\n                cnt++ ;\\n            }else{\\n                maxAns = max(cnt , maxAns) ;\\n                cnt = 1 ;\\n            }\\n        }\\n        \\n        return maxAns ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591953,
                "title": "java-solution-o-n-time-o-1-space",
                "content": "```java \\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max=1;\\n        int c=1;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)==s.charAt(i+1)-1)\\n                c++;\\n            else\\n            {\\n                max=Math.max(max,c);\\n                c=1;\\n            }\\n        }\\n        return Math.max(max,c);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max=1;\\n        int c=1;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)==s.charAt(i+1)-1)\\n                c++;\\n            else\\n            {\\n                max=Math.max(max,c);\\n                c=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2591650,
                "title": "c-easy-solution-100-faster-33ms",
                "content": "* check if prev char is 1 less than the current character\\n* if prev char is 1 less, then increase the counter and update the ans with max `max(count,ans)`\\n* else reset the counter to `1`\\n* after getting out of the loop check if `ans==0` return `1`, as `1` is the least possible Continuous substring possible\\n* else return `ans` \\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = 0, cnt=1;\\n        for(int i=1;i<s.length();i++){\\n            if(s[i-1]-\\'a\\'+1==s[i]-\\'a\\'){ \\n                cnt+=1;\\n                ans=max(ans,cnt);   \\n            }else cnt=1;\\n        }\\n        return ans?ans:1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = 0, cnt=1;\\n        for(int i=1;i<s.length();i++){\\n            if(s[i-1]-\\'a\\'+1==s[i]-\\'a\\'){ \\n                cnt+=1;\\n                ans=max(ans,cnt);   \\n            }else cnt=1;\\n        }\\n        return ans?ans:1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591133,
                "title": "easy-to-understand-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int getEndingIndex(string & s, int i)\\n    {\\n        while (i < s.size())\\n        {\\n            char curr = s[i];\\n            char prev = s[i-1];\\n \\n            // If the current character appears after\\n            // the previous character according to\\n            // the given circular alphabetical order\\n            if (curr - prev == 1)\\n                i++;\\n            else\\n                break;\\n        }\\n \\n        return i;\\n    }\\n \\n    int longestContinuousSubstring(string s) {\\n        int longestLen = 0;\\n \\n        int i = 0;\\n        while (i < s.size())\\n        {\\n            // Valid sub-string exists from index i to end\\n            int end = getEndingIndex(s, i+1);\\n \\n            // Update the length\\n            longestLen = max(end - i, longestLen);\\n            i = end;\\n        }\\n \\n        return longestLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getEndingIndex(string & s, int i)\\n    {\\n        while (i < s.size())\\n        {\\n            char curr = s[i];\\n            char prev = s[i-1];\\n \\n            // If the current character appears after\\n            // the previous character according to\\n            // the given circular alphabetical order\\n            if (curr - prev == 1)\\n                i++;\\n            else\\n                break;\\n        }\\n \\n        return i;\\n    }\\n \\n    int longestContinuousSubstring(string s) {\\n        int longestLen = 0;\\n \\n        int i = 0;\\n        while (i < s.size())\\n        {\\n            // Valid sub-string exists from index i to end\\n            int end = getEndingIndex(s, i+1);\\n \\n            // Update the length\\n            longestLen = max(end - i, longestLen);\\n            i = end;\\n        }\\n \\n        return longestLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591111,
                "title": "using-set-easy-solution",
                "content": "```\\n int n=s.length();\\n\\n       unordered_set<int>st;\\n        st.insert(s[0]-\\'0\\');\\n       \\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            int val=s[i]-\\'0\\';\\n         \\n            if(st.find(val-1)==st.end()){\\n                //cout<<\"f\"<<\" \";\\n               if(ans<st.size()){\\n                   ans=st.size();\\n               }\\n               // ans=max(ans,st.size());\\n                st.clear();\\n                st.insert(val);\\n            }\\n            else{\\n                st.insert(val);\\n            }\\n        }\\n        \\n        if(st.size()>ans){\\n            ans=st.size();\\n        }\\n        \\n        return ans;",
                "solutionTags": [],
                "code": "```\\n int n=s.length();\\n\\n       unordered_set<int>st;\\n        st.insert(s[0]-\\'0\\');\\n       \\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            int val=s[i]-\\'0\\';\\n         \\n            if(st.find(val-1)==st.end()){\\n                //cout<<\"f\"<<\" \";\\n               if(ans<st.size()){\\n                   ans=st.size();\\n               }\\n               // ans=max(ans,st.size());\\n                st.clear();\\n                st.insert(val);\\n            }\\n            else{\\n                st.insert(val);\\n            }\\n        }\\n        \\n        if(st.size()>ans){\\n            ans=st.size();\\n        }\\n        \\n        return ans;",
                "codeTag": "C++"
            },
            {
                "id": 2591109,
                "title": "java-interview-format-explanation-with-all-approaches-clean-code",
                "content": "Upvote if the solution helped :) For all my optimised solutions, Click || -->[Here](https://github.com/abhideepghosh/Leetcode-Solutions)<-- ||\\n```\\n// Optimised Solution TC: O(N) SC: O(1)\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        \\n        // Handling Edge Cases\\n        if(s.length() == 0){\\n            return 0;\\n        }\\n        \\n        // Handling Edge Cases\\n        if(s.length() == 1){\\n            return 1;\\n        }\\n        \\n        // Taking 2 Pointers -> Front Being 1 Ahead Of Rear\\n        // We Use A Sliding Window Of Gap 1 To Check Current And Next Character\\n        int front = 1;\\n        int rear = 0;\\n        \\n        // Since We Now Know After The Edge Cases Being Handled, That There Will Be More Than 1 Character\\n        // We Can Iterate Over Characters. We Start Count With 1 As We Take The Frequency Of Current Character In The Sum Count\\n        // count Will Store The Value Of Length On Every Iteration\\n        // maxCount Will Store The Maximum Length\\n        int maxCount = 1;\\n        int count = 1;\\n        \\n        // Iterating With A Sliding Window Of Gap 1\\n        while(front < s.length()){\\n            // If CurrentChar + 1 Equals Next Char, Then We Increment Count\\n            if(s.charAt(rear) + 1 == s.charAt(front)){\\n                count++;\\n                rear++;\\n                front++;\\n                maxCount = Math.max(maxCount, count); // Storing The Max Length Reached By count In maxCount\\n            }\\n            // Else We Reset Count\\n            else{\\n                rear = front;\\n                front++;\\n                count = 1;\\n            }\\n        }\\n        \\n        // Returning The maxCount -> maxLength Substring Found\\n        return maxCount;\\n        \\n    }\\n}\\n\\n\\n\\n//Another Approach Using Stack TC: O(N) SC: O(N)\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int len = s.length();\\n\\t\\tint maxLongest = 1, result = 1;\\n\\t\\tStack<Character> stack = new Stack<>();\\n\\t\\tstack.add(s.charAt(0));\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tchar ch = s.charAt(i);\\n\\t\\t\\tif((ch-\\'0\\') - (stack.peek()-\\'0\\')  == 1) {\\n\\t\\t\\t\\tmaxLongest++;\\n\\t\\t\\t\\tif(maxLongest > result) {\\n\\t\\t\\t\\t\\tresult = maxLongest;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tmaxLongest = 1;\\n\\t\\t\\t}\\n            stack.pop();\\n\\t\\t\\tstack.add(s.charAt(i));\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n}\\n\\n\\n\\n// Brute Force Solution TC: O(n2) SC: O(1)\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        \\n        // If String Length Is 0, We Return 0\\n        if(s.length() == 0){\\n            return 0;\\n        }\\n        \\n        // If String Length Is 1, Then We Return 1\\n        if(s.length() == 1){\\n            return 1;\\n        }\\n        \\n        // With Edge Cases Covered, We Assume The Max Count As 1\\n        int maxCount = 1;\\n        \\n        // Traversing Through The Outer Loop\\n        for(int i=0; i<s.length() - 1; i++){\\n            int count = 1;\\n            char ch = s.charAt(i);\\n            \\n            // Simple Checking The Current Char + 1 With The Next Char\\n            // In Case It Equals, We Increment Count, Else We Break From The Inner Loop\\n            for(int j= i+1; j<s.length(); j++){\\n                if(ch + 1 == s.charAt(j)){\\n                    count++;\\n                    ch = s.charAt(j);\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            // Updating maxCount\\n            maxCount = Math.max(count, maxCount);\\n        }\\n        \\n        // Returning Result\\n        return maxCount;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Optimised Solution TC: O(N) SC: O(1)\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        \\n        // Handling Edge Cases\\n        if(s.length() == 0){\\n            return 0;\\n        }\\n        \\n        // Handling Edge Cases\\n        if(s.length() == 1){\\n            return 1;\\n        }\\n        \\n        // Taking 2 Pointers -> Front Being 1 Ahead Of Rear\\n        // We Use A Sliding Window Of Gap 1 To Check Current And Next Character\\n        int front = 1;\\n        int rear = 0;\\n        \\n        // Since We Now Know After The Edge Cases Being Handled, That There Will Be More Than 1 Character\\n        // We Can Iterate Over Characters. We Start Count With 1 As We Take The Frequency Of Current Character In The Sum Count\\n        // count Will Store The Value Of Length On Every Iteration\\n        // maxCount Will Store The Maximum Length\\n        int maxCount = 1;\\n        int count = 1;\\n        \\n        // Iterating With A Sliding Window Of Gap 1\\n        while(front < s.length()){\\n            // If CurrentChar + 1 Equals Next Char, Then We Increment Count\\n            if(s.charAt(rear) + 1 == s.charAt(front)){\\n                count++;\\n                rear++;\\n                front++;\\n                maxCount = Math.max(maxCount, count); // Storing The Max Length Reached By count In maxCount\\n            }\\n            // Else We Reset Count\\n            else{\\n                rear = front;\\n                front++;\\n                count = 1;\\n            }\\n        }\\n        \\n        // Returning The maxCount -> maxLength Substring Found\\n        return maxCount;\\n        \\n    }\\n}\\n\\n\\n\\n//Another Approach Using Stack TC: O(N) SC: O(N)\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int len = s.length();\\n\\t\\tint maxLongest = 1, result = 1;\\n\\t\\tStack<Character> stack = new Stack<>();\\n\\t\\tstack.add(s.charAt(0));\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tchar ch = s.charAt(i);\\n\\t\\t\\tif((ch-\\'0\\') - (stack.peek()-\\'0\\')  == 1) {\\n\\t\\t\\t\\tmaxLongest++;\\n\\t\\t\\t\\tif(maxLongest > result) {\\n\\t\\t\\t\\t\\tresult = maxLongest;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tmaxLongest = 1;\\n\\t\\t\\t}\\n            stack.pop();\\n\\t\\t\\tstack.add(s.charAt(i));\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n}\\n\\n\\n\\n// Brute Force Solution TC: O(n2) SC: O(1)\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        \\n        // If String Length Is 0, We Return 0\\n        if(s.length() == 0){\\n            return 0;\\n        }\\n        \\n        // If String Length Is 1, Then We Return 1\\n        if(s.length() == 1){\\n            return 1;\\n        }\\n        \\n        // With Edge Cases Covered, We Assume The Max Count As 1\\n        int maxCount = 1;\\n        \\n        // Traversing Through The Outer Loop\\n        for(int i=0; i<s.length() - 1; i++){\\n            int count = 1;\\n            char ch = s.charAt(i);\\n            \\n            // Simple Checking The Current Char + 1 With The Next Char\\n            // In Case It Equals, We Increment Count, Else We Break From The Inner Loop\\n            for(int j= i+1; j<s.length(); j++){\\n                if(ch + 1 == s.charAt(j)){\\n                    count++;\\n                    ch = s.charAt(j);\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            // Updating maxCount\\n            maxCount = Math.max(count, maxCount);\\n        }\\n        \\n        // Returning Result\\n        return maxCount;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591076,
                "title": "c-o-n-prefix-easy-to-understand-2414",
                "content": "If the value is greater than the previous value c++ else c is 1(every letter is a substring of \"abcd...\")\\nans is max of all cases\\n\\n```\\nint longestContinuousSubstring(string s) {\\n        int ans=1,c=1,n=s.size();\\n        for(int i=1;i<n;i++) {\\n            if(s[i]==s[i-1]+1) \\n                c++;\\n            else c=1;\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tHappy Coding!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "If the value is greater than the previous value c++ else c is 1(every letter is a substring of \"abcd...\")\\nans is max of all cases\\n\\n```\\nint longestContinuousSubstring(string s) {\\n        int ans=1,c=1,n=s.size();\\n        for(int i=1;i<n;i++) {\\n            if(s[i]==s[i-1]+1) \\n                c++;\\n            else c=1;\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tHappy Coding!",
                "codeTag": "Unknown"
            },
            {
                "id": 2591010,
                "title": "c-easiest-one-pass-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        vector<int> v;\\n        int ans = 1 , ct = 1;\\n        for(int i = 0 ; i < s.size() - 1 ;i++)\\n        {\\n            if(s[i] + 1 == s[i + 1])\\n            {\\n                ct++;\\n            }\\n            else\\n                ct = 1;\\n            ans = max(ans , ct);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        vector<int> v;\\n        int ans = 1 , ct = 1;\\n        for(int i = 0 ; i < s.size() - 1 ;i++)\\n        {\\n            if(s[i] + 1 == s[i + 1])\\n            {\\n                ct++;\\n            }\\n            else\\n                ct = 1;\\n            ans = max(ans , ct);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590661,
                "title": "java-solution-two-approaches",
                "content": "### ***Please Upvote !!!***\\n##### Approach 1: \\nBy converting given string to a numerical int array and checking the length of the longest consecutive subarray.\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int[] arr = new int[s.length()];\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            arr[i] = s.charAt(i) - \\'a\\';\\n        }\\n\\n        int count = 1, maxCount = 1;\\n\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            if (arr[i + 1] == arr[i]) continue;\\n            else if (arr[i + 1] != arr[i] + 1) count = 1;\\n            else count++;\\n            maxCount = Math.max(maxCount, count);\\n        }\\n\\n        return maxCount;\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(n)\\n```\\n##### Approach 2:\\nBy checking if the next character in string is consecutive or not with each iteration.\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        if (s.length() == 1) return 1;\\n\\n        int currLen = 1, maxLen = 1;\\n\\n        for(int i = 0; i < s.length() - 1; i++) {\\n            if (s.charAt(i + 1) - s.charAt(i) == 1) {\\n                currLen++;\\n            } else currLen = 1;\\n\\n            maxLen = Math.max(maxLen, currLen);\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int[] arr = new int[s.length()];\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            arr[i] = s.charAt(i) - \\'a\\';\\n        }\\n\\n        int count = 1, maxCount = 1;\\n\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            if (arr[i + 1] == arr[i]) continue;\\n            else if (arr[i + 1] != arr[i] + 1) count = 1;\\n            else count++;\\n            maxCount = Math.max(maxCount, count);\\n        }\\n\\n        return maxCount;\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(n)\\n```\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        if (s.length() == 1) return 1;\\n\\n        int currLen = 1, maxLen = 1;\\n\\n        for(int i = 0; i < s.length() - 1; i++) {\\n            if (s.charAt(i + 1) - s.charAt(i) == 1) {\\n                currLen++;\\n            } else currLen = 1;\\n\\n            maxLen = Math.max(maxLen, currLen);\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590656,
                "title": "one-pass-sliding-window-java",
                "content": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int i = 0, j = 1, max = 1;\\n        while (j < s.length()) {\\n            if (s.charAt(j) != s.charAt(j - 1) + 1) {\\n                max = Math.max(max, j - i);\\n                i = j;\\n            }\\n            j++;\\n        }\\n        return Math.max(max, j - i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int i = 0, j = 1, max = 1;\\n        while (j < s.length()) {\\n            if (s.charAt(j) != s.charAt(j - 1) + 1) {\\n                max = Math.max(max, j - i);\\n                i = j;\\n            }\\n            j++;\\n        }\\n        return Math.max(max, j - i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590636,
                "title": "c-sliding-window-easy-to-understand-beginner-friendly",
                "content": "***Intuition:-***  Whenever question is related to do something with substrings it will generally revolve around sliding window. Below is my approach for the same.\\n\\n***Problem Solution***\\n```\\nclass Solution {\\npublic:\\n    //Sliding Window Solution\\n    int longestContinuousSubstring(string s) {\\n        int n=s.length();\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        //If length is 1 then the ans would be one\\n        if(n==1) return 1;\\n        int mx=INT_MIN;\\n        \\n        int idx=s[i]-\\'a\\';\\n        int curr=s[j]-\\'a\\';\\n        \\n        //for storing the last visited alphabet value\\n        int prev=idx;\\n        \\n        while(j<n){\\n            if(i-j==0){\\n                j++;\\n                continue;\\n            }\\n            curr=s[j]-\\'a\\';\\n            \\n            //For the order to be alphabetical the difference between the current\\n            //and prev value should be 1\\n            if(curr!=prev+1){\\n                mx=max(mx,(j-i));\\n                i=j;\\n            }\\n            \\n            //Assigning current calculated value to prev\\n            prev=curr;\\n            j++;\\n        }\\n        //For checking the last thing\\n        mx=max(mx,j-i);\\n        return mx;\\n    }\\n};\\n```\\n***Pls upvote if you find this useful :)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Sliding Window Solution\\n    int longestContinuousSubstring(string s) {\\n        int n=s.length();\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        //If length is 1 then the ans would be one\\n        if(n==1) return 1;\\n        int mx=INT_MIN;\\n        \\n        int idx=s[i]-\\'a\\';\\n        int curr=s[j]-\\'a\\';\\n        \\n        //for storing the last visited alphabet value\\n        int prev=idx;\\n        \\n        while(j<n){\\n            if(i-j==0){\\n                j++;\\n                continue;\\n            }\\n            curr=s[j]-\\'a\\';\\n            \\n            //For the order to be alphabetical the difference between the current\\n            //and prev value should be 1\\n            if(curr!=prev+1){\\n                mx=max(mx,(j-i));\\n                i=j;\\n            }\\n            \\n            //Assigning current calculated value to prev\\n            prev=curr;\\n            j++;\\n        }\\n        //For checking the last thing\\n        mx=max(mx,j-i);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590585,
                "title": "one-pass-ascii-solution-adjacent-comparision",
                "content": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        res=1\\n        count=1\\n        for i in range(1,len(s)):\\n            if (ord(s[i])-ord(s[i-1]))==1:\\n                count+=1\\n                res=max(res,count)\\n            else:\\n                print(count)\\n                count=1\\n        res=max(res,count)\\n        \\n        return res\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        res=1\\n        count=1\\n        for i in range(1,len(s)):\\n            if (ord(s[i])-ord(s[i-1]))==1:\\n                count+=1\\n                res=max(res,count)\\n            else:\\n                print(count)\\n                count=1\\n        res=max(res,count)\\n        \\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590521,
                "title": "python-solution-with-stack",
                "content": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        st = []\\n        c = 0\\n        for i in s:\\n            if not st:\\n                st.append(i)\\n            else:\\n                if i>st[-1] and ord(i) == ord(st[-1]) + 1:\\n                    st.append(i)\\n                else:\\n                    c = max(c,len(st))\\n                    st = [i]\\n        return max(c,len(st))\\n```\\n***Please Upvote if you like this.***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        st = []\\n        c = 0\\n        for i in s:\\n            if not st:\\n                st.append(i)\\n            else:\\n                if i>st[-1] and ord(i) == ord(st[-1]) + 1:\\n                    st.append(i)\\n                else:\\n                    c = max(c,len(st))\\n                    st = [i]\\n        return max(c,len(st))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590506,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        String str=\"abcdefghijklmnopqrstuvwxyz\";\\n        int l=0;\\n        int k=0;\\n        for(int i=0;i<s.length();i++){\\n            if(str.contains(s.substring(k,i+1)))\\n                l=Math.max(l,(s.substring(k,i+1)).length());\\n            else{\\n                k=i;\\n                i--;\\n            }\\n        }\\n        return l;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int longestContinuousSubstring(String s) {\\n        String str=\"abcdefghijklmnopqrstuvwxyz\";\\n        int l=0;\\n        int k=0;\\n        for(int i=0;i<s.length();i++){\\n            if(str.contains(s.substring(k,i+1)))\\n                l=Math.max(l,(s.substring(k,i+1)).length());\\n            else{\\n                k=i;\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2590494,
                "title": "java-2-solutions-slide-window-one-pass-8-ms-faster-than-100-00",
                "content": "```\\n\\n    //Runtime: 8 ms, faster than 100.00% of Java online submissions for Length of the Longest Alphabetical Continuous Substring.\\n    //Memory Usage: 54.2 MB, less than 55.56% of Java online submissions for Length of the Longest Alphabetical Continuous Substring.\\n    //one pass\\n    //time: O(N); Space:(1)\\n    public int longestContinuousSubstring(String s) {\\n\\n        int res = 1, count = 1;\\n        char lastChar = \\'B\\';\\n        for (char c : s.toCharArray()) {\\n\\n            if (lastChar + count == c) {\\n                res = Math.max(res, ++count);\\n            } else {\\n                count = 1; lastChar = c;\\n            }\\n        }\\n        return res;\\n    }\\n\\n\\n    //Runtime: 10 ms, faster than 77.78% of Java online submissions for Length of the Longest Alphabetical Continuous Substring.\\n    //Memory Usage: 42.9 MB, less than 88.89% of Java online submissions for Length of the Longest Alphabetical Continuous Substring.\\n    //Slide window\\n    //time: O(N); Space:(1)\\n\\tpublic int longestContinuousSubstring(String s) {\\n        int maxLen = 1;\\n        int left = 0, right = 1;\\n\\n        while (right < s.length()) {\\n            if (s.charAt(right - 1) + 1 != s.charAt(right)) {\\n                maxLen = Math.max(maxLen, right - left);\\n                left = right;\\n            }\\n            right++;\\n        }\\n        return Math.max(maxLen, right - left);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n\\n    //Runtime: 8 ms, faster than 100.00% of Java online submissions for Length of the Longest Alphabetical Continuous Substring.\\n    //Memory Usage: 54.2 MB, less than 55.56% of Java online submissions for Length of the Longest Alphabetical Continuous Substring.\\n    //one pass\\n    //time: O(N); Space:(1)\\n    public int longestContinuousSubstring(String s) {\\n\\n        int res = 1, count = 1;\\n        char lastChar = \\'B\\';\\n        for (char c : s.toCharArray()) {\\n\\n            if (lastChar + count == c) {\\n                res = Math.max(res, ++count);\\n            } else {\\n                count = 1; lastChar = c;\\n            }\\n        }\\n        return res;\\n    }\\n\\n\\n    //Runtime: 10 ms, faster than 77.78% of Java online submissions for Length of the Longest Alphabetical Continuous Substring.\\n    //Memory Usage: 42.9 MB, less than 88.89% of Java online submissions for Length of the Longest Alphabetical Continuous Substring.\\n    //Slide window\\n    //time: O(N); Space:(1)\\n\\tpublic int longestContinuousSubstring(String s) {\\n        int maxLen = 1;\\n        int left = 0, right = 1;\\n\\n        while (right < s.length()) {\\n            if (s.charAt(right - 1) + 1 != s.charAt(right)) {\\n                maxLen = Math.max(maxLen, right - left);\\n                left = right;\\n            }\\n            right++;\\n        }\\n        return Math.max(maxLen, right - left);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590470,
                "title": "java-easy-understandable-code-o-n-time-o-1-space",
                "content": "```\\npublic int longestContinuousSubstring(String s) \\n{\\n        int n = s.length();\\n        int max = 1, len = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s.charAt(i) - s.charAt(i - 1) == 1)\\n                len++;\\n            else\\n            {\\n                if(max < len) \\n                    max = len;\\n                \\n                len = 1;\\n            }\\n        }\\n        if(max < len) \\n\\t\\t\\tmax = len;\\n        \\n        return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int longestContinuousSubstring(String s) \\n{\\n        int n = s.length();\\n        int max = 1, len = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s.charAt(i) - s.charAt(i - 1) == 1)\\n                len++;\\n            else\\n            {\\n                if(max < len) \\n                    max = len;\\n                \\n                len = 1;\\n            }\\n        }\\n        if(max < len) \\n\\t\\t\\tmax = len;\\n        \\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2590454,
                "title": "c-o-n-easy-understanding-begginer",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int mx=1;\\n        int ans=1;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]==s[i-1]+1)\\n            {\\n                ans++;\\n                mx=max(ans,mx);\\n            }\\n            else{\\n                ans=1;\\n            }\\n        }\\n        mx=max(mx,ans);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int mx=1;\\n        int ans=1;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]==s[i-1]+1)\\n            {\\n                ans++;\\n                mx=max(ans,mx);\\n            }\\n            else{\\n                ans=1;\\n            }\\n        }\\n        mx=max(mx,ans);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590378,
                "title": "c-dynamic-programming-o-n-2-o-n",
                "content": "Dynamic Programming Solution\\nTime complexity O(n^2)\\n```\\nint longestContinuousSubstring(string text1) {\\n        string text2=\"abcdefghijklmnopqrstuvwxyz\";//longest Possible substring, now we have two strings so we can easly calculate the               \\n\\t\\t//longest common Substring\\n         int n=text1.length();\\n        int m=text2.length();\\n        int t[n+1][m+1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<m+1;j++){\\n                if(i==0||j==0)\\n                    t[i][j]=0;\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(text1[i-1]==text2[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    ans=max(ans,t[i][j]);\\n                }\\n                else\\n                    t[i][j]=0;\\n            }\\n        }\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n//O(n) Time comlexity Solution\\n    \\n  int longestContinuousSubstring(string text1) {\\n         int ans=1,mx=1;\\n         for(int i=1;i<text1.size();i++)\\n         {\\n             if(text1[i-1]+1==text1[i]){\\n                 ans++;\\n                 mx=max(ans,mx);\\n            }\\n            else ans=1;\\n        }\\n        return mx;\\n    }\\n```\\n\\nPS: Upvote",
                "solutionTags": [],
                "code": "```\\nint longestContinuousSubstring(string text1) {\\n        string text2=\"abcdefghijklmnopqrstuvwxyz\";//longest Possible substring, now we have two strings so we can easly calculate the               \\n\\t\\t//longest common Substring\\n         int n=text1.length();\\n        int m=text2.length();\\n        int t[n+1][m+1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<m+1;j++){\\n                if(i==0||j==0)\\n                    t[i][j]=0;\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(text1[i-1]==text2[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    ans=max(ans,t[i][j]);\\n                }\\n                else\\n                    t[i][j]=0;\\n            }\\n        }\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n//O(n) Time comlexity Solution\\n    \\n  int longestContinuousSubstring(string text1) {\\n         int ans=1,mx=1;\\n         for(int i=1;i<text1.size();i++)\\n         {\\n             if(text1[i-1]+1==text1[i]){\\n                 ans++;\\n                 mx=max(ans,mx);\\n            }\\n            else ans=1;\\n        }\\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590361,
                "title": "javascript-cut-max-consecutive-289ms",
                "content": "```\\nconst ord = (c) => c.charCodeAt();\\nconst char = (ascii) => String.fromCharCode(ascii);\\n\\n/*\\nusually this function is to cut longest same item, for this problem, just cut the longest increasing\\n*/\\nconst cutMaxConsecutive = (s) => {\\n    let d = [], l = 0, n = s.length;\\n    for (let i = 0; i + 1 < n; i++) {\\n        let next = char(ord(s[i]) + 1)\\n        if (s[i + 1] != next || s[i] == \\'z\\') { // cut principle, not increasing + 1 or \\'z\\' occurs\\n            d.push(s.slice(l, i + 1));\\n            l = i + 1;\\n        }\\n    }\\n    d.push(s.slice(l));\\n    return d;\\n};\\n\\nconst longestContinuousSubstring = (s) => {\\n    let d = cutMaxConsecutive(s), res = 0;\\n    for (const e of d) res = Math.max(res, e.length)\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst ord = (c) => c.charCodeAt();\\nconst char = (ascii) => String.fromCharCode(ascii);\\n\\n/*\\nusually this function is to cut longest same item, for this problem, just cut the longest increasing\\n*/\\nconst cutMaxConsecutive = (s) => {\\n    let d = [], l = 0, n = s.length;\\n    for (let i = 0; i + 1 < n; i++) {\\n        let next = char(ord(s[i]) + 1)\\n        if (s[i + 1] != next || s[i] == \\'z\\') { // cut principle, not increasing + 1 or \\'z\\' occurs\\n            d.push(s.slice(l, i + 1));\\n            l = i + 1;\\n        }\\n    }\\n    d.push(s.slice(l));\\n    return d;\\n};\\n\\nconst longestContinuousSubstring = (s) => {\\n    let d = cutMaxConsecutive(s), res = 0;\\n    for (const e of d) res = Math.max(res, e.length)\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590351,
                "title": "python3-easy-solution",
                "content": "```\\n1. Add order of the character in a stack if it is empty\\n2. Otherwise check if the difference between current character and last character of stack is 1\\n3. If differece is 1 then increment the counter\\n4. Otherwise make the counter 1\\n5. Add respective character to the stack\\n6. take max(mx, c)\\n7. return mx\\n```\\n\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        c = 0\\n        mx = 0\\n        \\n        stack = []\\n        for i in s:\\n            if stack == []:\\n                stack.append(ord(i))\\n                c = 1\\n            else:\\n                if ord(i)-stack[-1]==1:\\n                    c += 1\\n                else:\\n                    c = 1\\n                stack.append(ord(i))\\n            mx = max(mx,c)\\n        mx = max(mx,c)\\n        return mx\\n```",
                "solutionTags": [],
                "code": "```\\n1. Add order of the character in a stack if it is empty\\n2. Otherwise check if the difference between current character and last character of stack is 1\\n3. If differece is 1 then increment the counter\\n4. Otherwise make the counter 1\\n5. Add respective character to the stack\\n6. take max(mx, c)\\n7. return mx\\n```\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        c = 0\\n        mx = 0\\n        \\n        stack = []\\n        for i in s:\\n            if stack == []:\\n                stack.append(ord(i))\\n                c = 1\\n            else:\\n                if ord(i)-stack[-1]==1:\\n                    c += 1\\n                else:\\n                    c = 1\\n                stack.append(ord(i))\\n            mx = max(mx,c)\\n        mx = max(mx,c)\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590292,
                "title": "2-pointer-o-n",
                "content": "Simply traverse keeping track of prev(point to index from where continuous string started) and update ans\\n**Time Complexity: O(N)\\nSpace Complexity: O(1)\\nCode:**\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string &s) {\\n        int prev=0,ans=1;\\n        for(int i=1;i<s.size();++i){\\n            if(s[i]!=(s[i-1]+1)){\\n                prev=i;\\n            } else{\\n                ans=max(ans,i-prev+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string &s) {\\n        int prev=0,ans=1;\\n        for(int i=1;i<s.size();++i){\\n            if(s[i]!=(s[i-1]+1)){\\n                prev=i;\\n            } else{\\n                ans=max(ans,i-prev+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590284,
                "title": "self-understandable-solution",
                "content": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        x=set()\\n        p=[s[0]]\\n        for i in s[1:]:\\n            if ord(p[-1])+1==ord(i):\\n                p.append(i)\\n            else:\\n                x.add(\"\".join(p))\\n                p=[i]\\n        x.add(\"\".join(p))\\n        ans=sorted(x,key=len)[-1]\\n        return len(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        x=set()\\n        p=[s[0]]\\n        for i in s[1:]:\\n            if ord(p[-1])+1==ord(i):\\n                p.append(i)\\n            else:\\n                x.add(\"\".join(p))\\n                p=[i]\\n        x.add(\"\".join(p))\\n        ans=sorted(x,key=len)[-1]\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590168,
                "title": "javascript-compare-adjacent",
                "content": "**Solution: Compare Adjacent**\\n\\nCompare adjacent characters and keep track of the length of the current continuous string.\\nRecord the maximum length.\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n```\\nvar longestContinuousSubstring = function(s) {\\n  let n = s.length, count = 1, ans = 1;\\n  for (let i = 1; i < n; i++) {\\n    let currCharcode = s.charCodeAt(i);\\n    let prevCharcode = s.charCodeAt(i - 1);\\n    if (currCharcode - prevCharcode === 1) count++;\\n    else count = 1;\\n    ans = Math.max(ans, count);\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestContinuousSubstring = function(s) {\\n  let n = s.length, count = 1, ans = 1;\\n  for (let i = 1; i < n; i++) {\\n    let currCharcode = s.charCodeAt(i);\\n    let prevCharcode = s.charCodeAt(i - 1);\\n    if (currCharcode - prevCharcode === 1) count++;\\n    else count = 1;\\n    ans = Math.max(ans, count);\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590166,
                "title": "python-dp-hashmap",
                "content": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        allC = \"abcdefghijklmnopqrstuvwxyz\"\\n        dit = {}\\n        for i in range(len(allC)-1):\\n            dit[allC[i]] = allC[i+1]\\n\\n        dp = [1] * len(s)\\n        \\n        for i in range(1, len(dp)):\\n            if s[i] == \"a\":\\n                continue\\n            if s[i-1] in dit and dit[s[i-1]] == s[i]:\\n                dp[i] += dp[i-1]\\n               \\n        return max(dp)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        allC = \"abcdefghijklmnopqrstuvwxyz\"\\n        dit = {}",
                "codeTag": "Java"
            },
            {
                "id": 2590107,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n     Appraoch; As long as we are getting alphabets in increasing order just increase counter other wise take update ans = max(ans,counter);\\n    */\\n    int longestContinuousSubstring(string s) {\\n        int cnt = 1;\\n        int ans =1;\\n        for(int i =1;i<s.size();i++){\\n            if(char(s[i]-1) == s[i-1]){\\n                ++cnt;\\n            }else{\\n                ans = max(cnt,ans);\\n                cnt = 1;\\n            }\\n        }\\n        ans = max(cnt,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n     Appraoch; As long as we are getting alphabets in increasing order just increase counter other wise take update ans = max(ans,counter);\\n    */\\n    int longestContinuousSubstring(string s) {\\n        int cnt = 1;\\n        int ans =1;\\n        for(int i =1;i<s.size();i++){\\n            if(char(s[i]-1) == s[i-1]){\\n                ++cnt;\\n            }else{\\n                ans = max(cnt,ans);\\n                cnt = 1;\\n            }\\n        }\\n        ans = max(cnt,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098773,
                "title": "very-easy-solution-o-n-time-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n=s.size();\\n        int cnt=1;int maxi=1;\\n        for(int i=0;i<n-1;i++){\\n            int a=s[i+1];\\n            int b=s[i];\\n            if(a==b+1){\\n                cnt++;\\n            }\\n            else{\\n                cnt=1;\\n            }\\n            maxi=max(maxi,cnt);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n=s.size();\\n        int cnt=1;int maxi=1;\\n        for(int i=0;i<n-1;i++){\\n            int a=s[i+1];\\n            int b=s[i];\\n            if(a==b+1){\\n                cnt++;\\n            }\\n            else{\\n                cnt=1;\\n            }\\n            maxi=max(maxi,cnt);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088482,
                "title": "c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int i=0;\\n        int maxChar = INT_MIN;\\n        while(i<s.size())\\n        {\\n            char curr = s[i];\\n            int count = 0;\\n            while(i<s.size() && s[i]==curr)\\n            {\\n                curr+=1;\\n                count++;\\n                i++;\\n            }\\n            maxChar=max(maxChar,count);\\n        }\\n        return maxChar;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int i=0;\\n        int maxChar = INT_MIN;\\n        while(i<s.size())\\n        {\\n            char curr = s[i];\\n            int count = 0;\\n            while(i<s.size() && s[i]==curr)\\n            {\\n                curr+=1;\\n                count++;\\n                i++;\\n            }\\n            maxChar=max(maxChar,count);\\n        }\\n        return maxChar;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084738,
                "title": "easy-2-ptr-java-soln-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif diff bw two char is 1, cnt++, else make cnt equalsTo 1 again\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int n = s.length();\\n        int i = 0;\\n        int max = 1;\\n        int cnt = 1;\\n        for(int j=1;j<n;j++) {\\n            if(s.charAt(j) - s.charAt(i) != 1) {\\n                cnt = 1;\\n                i = j;\\n            } else if(s.charAt(j) - s.charAt(i) == 1) {\\n                cnt++;\\n                i++;\\n            }\\n            max = Math.max(max, cnt);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int n = s.length();\\n        int i = 0;\\n        int max = 1;\\n        int cnt = 1;\\n        for(int j=1;j<n;j++) {\\n            if(s.charAt(j) - s.charAt(i) != 1) {\\n                cnt = 1;\\n                i = j;\\n            } else if(s.charAt(j) - s.charAt(i) == 1) {\\n                cnt++;\\n                i++;\\n            }\\n            max = Math.max(max, cnt);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076628,
                "title": "brute-force",
                "content": "# Intuition\\n**just check if difference of two continuous chars is 1**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max = 0;\\n        for(int i=0; i<s.length(); i++){\\n            int c = 1,st=i;\\n            for(int j =i+1; j<s.length(); j++){\\n                if(((s.charAt(j)-\\'0\\')-(s.charAt(i)-\\'0\\'))==1){\\n                    c++;\\n                    i++;\\n                }else{\\n                    i=st;\\n                    break;\\n                }\\n            }\\n            max = Math.max(max,c);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max = 0;\\n        for(int i=0; i<s.length(); i++){\\n            int c = 1,st=i;\\n            for(int j =i+1; j<s.length(); j++){\\n                if(((s.charAt(j)-\\'0\\')-(s.charAt(i)-\\'0\\'))==1){\\n                    c++;\\n                    i++;\\n                }else{\\n                    i=st;\\n                    break;\\n                }\\n            }\\n            max = Math.max(max,c);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067761,
                "title": "length-of-the-longest-alphabetically-continuous-substring",
                "content": "# Intuition\\nSince the question asks for the continuous substrings, it is like a growing window. The window stops growing when the first non-consecutive grapheme is found and then a new window starts from the next grapheme. So, the previous window leaves a chunk and so do the other windows. Then make a pass through the entire array and find the size of each chunk. \\n\\nIf the set of chunks is $P$, where $|P| = t$ is the number of chunks, then, size of the string $s$ in terms of number of graphemes is given by \\n$$\\n|s| = \\\\displaystyle\\\\sum_{p\\\\in P}|p|\\n$$\\nwhere $|s|$ denotes the size of the string. \\n\\n# Approach\\nChunk each consecutive strings and then find the size of each one and find the maximum size\\n\\n# Complexity\\n- Time complexity:\\n$$\\\\mathcal{O}(n)$$ where $n$ is the number of graphemes in the string $s$\\nThe time taken for this to exectue bet $100\\\\%$ of `Ruby` users.\\n\\n- Space complexity:\\n$$\\\\mathcal{O}(n)$$\\n\\n# Code\\n```ruby\\n# @param {String} s\\n# @return {Integer}\\ndef longest_continuous_substring s\\n    s.chars.chunk_while{_2.ord-_1.ord==1}.map(&:size).max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {String} s\\n# @return {Integer}\\ndef longest_continuous_substring s\\n    s.chars.chunk_while{_2.ord-_1.ord==1}.map(&:size).max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4060104,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n         int ans = 1;\\n         int running_length=1;\\n\\n         for (int i = 1; i < s.length(); ++i)\\n         {\\n             if (s[i] == s[i-1] + 1)\\n                running_length += 1;\\n             else {\\n                ans = max(ans, running_length);\\n                running_length = 1;\\n             }\\n         }\\n\\n         return max(ans, running_length);\\n        \\n    }\\n};\\n*/\\n\\n\\nclass Solution {\\n public:\\n  int longestContinuousSubstring(string s) {\\n    int ans = 1;\\n    int runningLen = 1;\\n\\n    for (int i = 1; i < s.length(); ++i)\\n      if (s[i] == s[i - 1] + 1)\\n        ans = max(ans, runningLen+=1);\\n      else\\n        runningLen = 1;\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n         int ans = 1;\\n         int running_length=1;\\n\\n         for (int i = 1; i < s.length(); ++i)\\n         {\\n             if (s[i] == s[i-1] + 1)\\n                running_length += 1;\\n             else {\\n                ans = max(ans, running_length);\\n                running_length = 1;\\n             }\\n         }\\n\\n         return max(ans, running_length);\\n        \\n    }\\n};\\n*/\\n\\n\\nclass Solution {\\n public:\\n  int longestContinuousSubstring(string s) {\\n    int ans = 1;\\n    int runningLen = 1;\\n\\n    for (int i = 1; i < s.length(); ++i)\\n      if (s[i] == s[i - 1] + 1)\\n        ans = max(ans, runningLen+=1);\\n      else\\n        runningLen = 1;\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044696,
                "title": "c-sliding-window-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        if(s.size()==1){\\n            return 1;\\n        }\\n        int i=0,j=1;\\n        char p=s[0];\\n        int ans=0;\\n        while(j<s.size()){\\n            if(p+1==s[j]){\\n                p=s[j];\\n                j++;\\n            }\\n            else{\\n                ans=max(ans,j-i);\\n                i=j;\\n                p=s[j];\\n                j=i+1;\\n            }\\n        }\\n        ans=max(ans,j-i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        if(s.size()==1){\\n            return 1;\\n        }\\n        int i=0,j=1;\\n        char p=s[0];\\n        int ans=0;\\n        while(j<s.size()){\\n            if(p+1==s[j]){\\n                p=s[j];\\n                j++;\\n            }\\n            else{\\n                ans=max(ans,j-i);\\n                i=j;\\n                p=s[j];\\n                j=i+1;\\n            }\\n        }\\n        ans=max(ans,j-i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041599,
                "title": "simple-and-easy-c-solution-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int max_string = 1, substring = 1;\\n\\n        for(int i = 0; i < s.size()-1; i++) {\\n            if(s[i] - \\'0\\' == (s[i+1] - \\'0\\') - 1) {\\n                substring++;\\n            }\\n            else {\\n                substring = 1;\\n            }\\n            max_string = max(max_string, substring);\\n        }\\n        \\n        return max_string;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int max_string = 1, substring = 1;\\n\\n        for(int i = 0; i < s.size()-1; i++) {\\n            if(s[i] - \\'0\\' == (s[i+1] - \\'0\\') - 1) {\\n                substring++;\\n            }\\n            else {\\n                substring = 1;\\n            }\\n            max_string = max(max_string, substring);\\n        }\\n        \\n        return max_string;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036361,
                "title": "union-find",
                "content": "I was just practising Union-Find so I thought why not...\\n\\n# Code\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        n = len(s)\\n\\n        parent = list(range(n))\\n        rank = [1]*n\\n\\n        def find(x):\\n            if x != parent[x]:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(a, b):\\n            x, y = find(a), find(b)\\n\\n            if x != y:\\n                if rank[x] >= rank[y]:\\n                    parent[y] = x\\n                    rank[x] += rank[y]\\n                else:\\n                    parent[x] = y\\n                    rank[y] += rank[x]\\n\\n        \\n        i = 0\\n        while i < n:\\n            j = i + 1\\n            while j < n and ord(s[j]) - ord(s[j-1]) == 1:\\n                union(j-1, j)\\n                j += 1\\n            i = j\\n\\n        return max(rank)\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        n = len(s)\\n\\n        parent = list(range(n))\\n        rank = [1]*n\\n\\n        def find(x):\\n            if x != parent[x]:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(a, b):\\n            x, y = find(a), find(b)\\n\\n            if x != y:\\n                if rank[x] >= rank[y]:\\n                    parent[y] = x\\n                    rank[x] += rank[y]\\n                else:\\n                    parent[x] = y\\n                    rank[y] += rank[x]\\n\\n        \\n        i = 0\\n        while i < n:\\n            j = i + 1\\n            while j < n and ord(s[j]) - ord(s[j-1]) == 1:\\n                union(j-1, j)\\n                j += 1\\n            i = j\\n\\n        return max(rank)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016910,
                "title": "contigious-substring-optimize-solution-with-no-extra-space-and-linear-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int res=0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            int ascii = (int)(s.charAt(i));\\n            int count=1;\\n            for(int j=i+1; j<s.length(); j++){\\n                if(ascii+1 == (int)(s.charAt(j))){\\n                    ascii = (int)(s.charAt(j));\\n                    count++;\\n                } else{\\n                    break;\\n                }\\n            }\\n            if(res<count) res=count;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int res=0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            int ascii = (int)(s.charAt(i));\\n            int count=1;\\n            for(int j=i+1; j<s.length(); j++){\\n                if(ascii+1 == (int)(s.charAt(j))){\\n                    ascii = (int)(s.charAt(j));\\n                    count++;\\n                } else{\\n                    break;\\n                }\\n            }\\n            if(res<count) res=count;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984461,
                "title": "java-from-134ms-to-11ms",
                "content": "# Complexity\\n- Time complexity: O(26*N)\\n\\n# Idea\\nThe idea is to check whether there is continuous alphabetical substring starting from each letter.\\n\\n# Code 1 | 134ms | 5% Faster\\n```\\nclass Solution {\\n    private static String alph = \"abcdefghijklmnopqrstuvwxyz\";\\n    public int longestContinuousSubstring(String s) {\\n        int count = 0, max = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < alph.length(); j++) {\\n                if (s.charAt(i) == alph.charAt(j)) {\\n                    count++;\\n                    if (!(i + 1 < s.length() && j + 1 < alph.length() && s.charAt(i + 1) == alph.charAt(j + 1))){\\n                        max = Math.max(max, count);\\n                        count = 0;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return Math.max(max, count);\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Idea\\nThe idea is to compare current char to previous and if the difference is 1, then I increment the counter and check if it is the max. Else I make count equal to 1 again.\\n\\nEverything is done in one run.\\n\\n# Code 2 | 11ms | 83% Faster\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int count = 1, max = 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i - 1) == s.charAt(i) - 1)\\n                max = Math.max(++count, max);\\n            else\\n                count = 1;\\n        }\\n        return Math.max(max, count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static String alph = \"abcdefghijklmnopqrstuvwxyz\";\\n    public int longestContinuousSubstring(String s) {\\n        int count = 0, max = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < alph.length(); j++) {\\n                if (s.charAt(i) == alph.charAt(j)) {\\n                    count++;\\n                    if (!(i + 1 < s.length() && j + 1 < alph.length() && s.charAt(i + 1) == alph.charAt(j + 1))){\\n                        max = Math.max(max, count);\\n                        count = 0;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return Math.max(max, count);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int count = 1, max = 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i - 1) == s.charAt(i) - 1)\\n                max = Math.max(++count, max);\\n            else\\n                count = 1;\\n        }\\n        return Math.max(max, count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965792,
                "title": "one-loop-easy-solution-java",
                "content": "\\n# Complexity\\n- Time complexity:\\n  - $$O(n)$$\\n\\n- Space complexity:\\n  - $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int len = s.length();\\n        int longestLength = 0;\\n        char currChar = \\'#\\';\\n        int lengthSubstring = 0;\\n        for (int idx =0; idx<len; idx++) {\\n            \\n            if ((s.charAt(idx) - currChar) == 1) {\\n                lengthSubstring++;\\n                longestLength = Math.max(longestLength, lengthSubstring);\\n                currChar = s.charAt(idx);\\n            }\\n            else {\\n                lengthSubstring = 1;\\n                currChar = s.charAt(idx);\\n            }\\n        }\\n        return Math.max(longestLength, lengthSubstring);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int len = s.length();\\n        int longestLength = 0;\\n        char currChar = \\'#\\';\\n        int lengthSubstring = 0;\\n        for (int idx =0; idx<len; idx++) {\\n            \\n            if ((s.charAt(idx) - currChar) == 1) {\\n                lengthSubstring++;\\n                longestLength = Math.max(longestLength, lengthSubstring);\\n                currChar = s.charAt(idx);\\n            }\\n            else {\\n                lengthSubstring = 1;\\n                currChar = s.charAt(idx);\\n            }\\n        }\\n        return Math.max(longestLength, lengthSubstring);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958407,
                "title": "c-basic-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string &s) \\n    {\\n        int maxi = INT_MIN, len = 1;\\n        for (int i=1;i<s.size();i++) \\n        {\\n            if (s[i] - s[i-1] == 1) \\n            {\\n                len++;\\n                maxi = max(len,maxi);\\n            } \\n            else \\n            {\\n                len=1;\\n            }\\n        }\\n        maxi = max(maxi, len);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string &s) \\n    {\\n        int maxi = INT_MIN, len = 1;\\n        for (int i=1;i<s.size();i++) \\n        {\\n            if (s[i] - s[i-1] == 1) \\n            {\\n                len++;\\n                maxi = max(len,maxi);\\n            } \\n            else \\n            {\\n                len=1;\\n            }\\n        }\\n        maxi = max(maxi, len);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930963,
                "title": "c-solution-with-t-c-o-n-and-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n = s.size(),i = 0,j = 1,mxLen = 1;\\n        while(j < n){\\n            while(j < n && s[j-1]-s[j] == -1)\\n                mxLen = max(mxLen,(j++) -i+1);\\n            i = j++;\\n        }\\n        return mxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n = s.size(),i = 0,j = 1,mxLen = 1;\\n        while(j < n){\\n            while(j < n && s[j-1]-s[j] == -1)\\n                mxLen = max(mxLen,(j++) -i+1);\\n            i = j++;\\n        }\\n        return mxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924653,
                "title": "simple-iterative-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int prev = s[0] - 1;\\n        int maxCount = 0, currCount = 0;\\n\\n        foreach(int c in s){\\n            if(c == prev + 1){\\n                ++currCount;\\n                maxCount = Math.Max(maxCount, currCount);\\n            }\\n            else{\\n                currCount = 1;\\n            }\\n\\n            prev = c;\\n        }\\n        \\n        return maxCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int prev = s[0] - 1;\\n        int maxCount = 0, currCount = 0;\\n\\n        foreach(int c in s){\\n            if(c == prev + 1){\\n                ++currCount;\\n                maxCount = Math.Max(maxCount, currCount);\\n            }\\n            else{\\n                currCount = 1;\\n            }\\n\\n            prev = c;\\n        }\\n        \\n        return maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921811,
                "title": "short-and-easy-to-understand-code-explained-in-comments",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n     int i = 0, n = s.length(), cnt = 0, maxLength = 0;\\n     char prev = \\' \\';\\n      for(auto curr : s)\\n      {\\n         if(prev == \\' \\' || curr - prev == 1) //keep increasing cnt till we find consecutive chracters\\n          cnt++;\\n         else\\n          cnt = 1; //start counting again from current character onwards\\n        maxLength = max(maxLength,cnt); //update max length of consecutive sub-string\\n        prev = curr; //update previous chracter for next iteration\\n      }\\n    return maxLength; //return max length\\n    }\\n};\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n     int i = 0, n = s.length(), cnt = 0, maxLength = 0;\\n     char prev = \\' \\';\\n      for(auto curr : s)\\n      {\\n         if(prev == \\' \\' || curr - prev == 1) //keep increasing cnt till we find consecutive chracters\\n          cnt++;\\n         else\\n          cnt = 1; //start counting again from current character onwards\\n        maxLength = max(maxLength,cnt); //update max length of consecutive sub-string\\n        prev = curr; //update previous chracter for next iteration\\n      }\\n    return maxLength; //return max length\\n    }\\n};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916355,
                "title": "c-solution-two-pointers-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(n) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n**Approach 1:**\\n\\n```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int j = 1, res = 1;\\n\\n        while(j < s.Length){\\n            int len = 1;\\n\\n            while(j < s.Length && s[j] == 1 + s[j-1]){\\n                j++;\\n                len++;\\n            }\\n\\n            j++;\\n            res = Math.Max(res, len);\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\n**Approach 2:**\\n```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int j = 1, res = 1;\\n\\n        while(j < s.Length){\\n            int len = 1;\\n\\n            while(j < s.Length && s[j] == 1 + s[j-1]){\\n                j++;\\n                len++;\\n            }\\n\\n            j++;\\n            res = Math.Max(res, len);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int j = 1, res = 1;\\n\\n        while(j < s.Length){\\n            int len = 1;\\n\\n            while(j < s.Length && s[j] == 1 + s[j-1]){\\n                j++;\\n                len++;\\n            }\\n\\n            j++;\\n            res = Math.Max(res, len);\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int j = 1, res = 1;\\n\\n        while(j < s.Length){\\n            int len = 1;\\n\\n            while(j < s.Length && s[j] == 1 + s[j-1]){\\n                j++;\\n                len++;\\n            }\\n\\n            j++;\\n            res = Math.Max(res, len);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913206,
                "title": "c-easy-100-faster-solution-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n    \\n        int maxLen = 1;\\n        for(int i  = 0; i < s.Length; i++) \\n        {   \\n            int currLen = 1;\\n            while(i < s.Length - 1 && (s[i+1] - \\'a\\') - (s[i] - \\'a\\') == 1) {\\n                currLen++;\\n                i++;\\n                maxLen = Math.Max(currLen, maxLen);\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n    \\n        int maxLen = 1;\\n        for(int i  = 0; i < s.Length; i++) \\n        {   \\n            int currLen = 1;\\n            while(i < s.Length - 1 && (s[i+1] - \\'a\\') - (s[i] - \\'a\\') == 1) {\\n                currLen++;\\n                i++;\\n                maxLen = Math.Max(currLen, maxLen);\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912375,
                "title": "dp-longest-common-substring-striver",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        string alpha = \"abcdefghijklmnopqrstuvwxyz\";\\n        vector<vector<int>> dp(alpha.size()+1, vector<int>(s.size()+1, 0));\\n        int ans = 0;\\n\\n        for(int i = 1; i <= alpha.size(); i++){\\n            for(int j = 1; j <= s.size(); j++){\\n                if(alpha[i-1]==s[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    ans = max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        string alpha = \"abcdefghijklmnopqrstuvwxyz\";\\n        vector<vector<int>> dp(alpha.size()+1, vector<int>(s.size()+1, 0));\\n        int ans = 0;\\n\\n        for(int i = 1; i <= alpha.size(); i++){\\n            for(int j = 1; j <= s.size(); j++){\\n                if(alpha[i-1]==s[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    ans = max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908737,
                "title": "fastest-solution-136ms-using-dict-and-zip",
                "content": "# Image\\n![1.png](https://assets.leetcode.com/users/images/e6a12998-6190-459c-bc0f-a151666d1433_1692016532.417051.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt\\'s not my solution, but very smartest.\\ncreate dict where key is previous letter in abc, value is next letter.\\nIn loop moving through string using zip and ours dict\\n# Code\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        abc = \"abcdefghijklmnopqrstuvwxyz\"\\n        sequence = {abc[i]: abc[i + 1] for i in range(len(abc) - 1)}\\n        sequence[\"z\"] = \"\"\\n        maximum = 0\\n        counter = 1\\n        for letter, next_letter in zip(s, s[1:]):\\n            if sequence[letter] == next_letter:\\n                counter += 1\\n                maximum = max(maximum, counter)\\n                continue\\n            counter = 1\\n        return max(maximum, counter)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        abc = \"abcdefghijklmnopqrstuvwxyz\"\\n        sequence = {abc[i]: abc[i + 1] for i in range(len(abc) - 1)}\\n        sequence[\"z\"] = \"\"\\n        maximum = 0\\n        counter = 1\\n        for letter, next_letter in zip(s, s[1:]):\\n            if sequence[letter] == next_letter:\\n                counter += 1\\n                maximum = max(maximum, counter)\\n                continue\\n            counter = 1\\n        return max(maximum, counter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907241,
                "title": "o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int m=1;\\n        int r=1;\\n        int c=1;\\n        int l=0;\\n        if(s.empty())\\n        return 0;\\n        while(r<s.length())\\n        {\\n            if(s[r]==s[l]+1)\\n            {\\n                ++c;\\n                ++r;\\n                ++l;\\n\\n            }\\n            else\\n            {\\n                 m = max(m, c);\\n               c=1;\\n               ++r;\\n               ++l; \\n            }\\n            m=max(m,c);\\n        }\\n        return m;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int m=1;\\n        int r=1;\\n        int c=1;\\n        int l=0;\\n        if(s.empty())\\n        return 0;\\n        while(r<s.length())\\n        {\\n            if(s[r]==s[l]+1)\\n            {\\n                ++c;\\n                ++r;\\n                ++l;\\n\\n            }\\n            else\\n            {\\n                 m = max(m, c);\\n               c=1;\\n               ++r;\\n               ++l; \\n            }\\n            m=max(m,c);\\n        }\\n        return m;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900847,
                "title": "sliding-window-technique",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int left = 0;\\n        int right = 1;\\n        int result = 1;\\n        while(right < s.length()) {\\n            int a = s.charAt(right-1) + 1;\\n            int b = s.charAt(right);\\n            if(a == b) {\\n                result = Integer.max(result, (right - left)+1);\\n                right++;\\n            }\\n            else {\\n                left = right;\\n                right++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int left = 0;\\n        int right = 1;\\n        int result = 1;\\n        while(right < s.length()) {\\n            int a = s.charAt(right-1) + 1;\\n            int b = s.charAt(right);\\n            if(a == b) {\\n                result = Integer.max(result, (right - left)+1);\\n                right++;\\n            }\\n            else {\\n                left = right;\\n                right++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884982,
                "title": "easy-loop-128-longest-consecutive-sequence-variation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis Question is variation of\\n128. Longest Consecutive Sequence\\nSame Question\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust we have to check current and previous Element if curr is just greater than prev then count++;\\n\\ncase 2:\\nprev==curr means duplicate element so just continue\\n\\ncase 3:\\nif not satisfied then count==1\\nwhy count=1 bz even single element is also the continous elem\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int len=1;\\n        if(s.length()==1)return 1;\\n            int count=1;\\n        for(int i=0;i<s.length()-1;i++){\\n            char c=s.charAt(i);\\n            if(s.charAt(i+1)==(++c)){\\n                count++;\\n            }\\n            else if(s.charAt(i+1)==s.charAt(i)){\\n                continue;\\n            }\\n            else{\\n                count=1;\\n            }\\n            len=Math.max(count,len);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int len=1;\\n        if(s.length()==1)return 1;\\n            int count=1;\\n        for(int i=0;i<s.length()-1;i++){\\n            char c=s.charAt(i);\\n            if(s.charAt(i+1)==(++c)){\\n                count++;\\n            }\\n            else if(s.charAt(i+1)==s.charAt(i)){\\n                continue;\\n            }\\n            else{\\n                count=1;\\n            }\\n            len=Math.max(count,len);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873420,
                "title": "simple-easy-cpp-solution-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int i = 0, j = 0, n = s.length();\\n        int ans = 1; //because even when j+1 != j char still length = 1\\n\\n        while(j < n){\\n            if(j+1 <n && (s[j] + 1 == s[j+1])){\\n                j++;\\n                ans = max(ans,j-i+1);\\n            }\\n            else{\\n                j++;\\n                i = j;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int i = 0, j = 0, n = s.length();\\n        int ans = 1; //because even when j+1 != j char still length = 1\\n\\n        while(j < n){\\n            if(j+1 <n && (s[j] + 1 == s[j+1])){\\n                j++;\\n                ans = max(ans,j-i+1);\\n            }\\n            else{\\n                j++;\\n                i = j;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857870,
                "title": "beats-89-26-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n = s.length();\\n        int ans = INT_MIN;\\n        if(n==1)\\n        return 1;\\n        int i=0,j=0;\\n        while(j<n-1)\\n        {\\n            if((s[j+1]-\\'0\\')-(s[j]-\\'0\\')==1)\\n            j++;\\n            else\\n            {\\n                ans = max(ans,j-i+1);\\n                j++;\\n                i = j;\\n            }\\n        }\\n        if(j==n-1)\\n        {\\n            if(i==n-1)\\n            ans = max(ans,1);\\n            else\\n            {\\n                ans = max(ans,j-i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n = s.length();\\n        int ans = INT_MIN;\\n        if(n==1)\\n        return 1;\\n        int i=0,j=0;\\n        while(j<n-1)\\n        {\\n            if((s[j+1]-\\'0\\')-(s[j]-\\'0\\')==1)\\n            j++;\\n            else\\n            {\\n                ans = max(ans,j-i+1);\\n                j++;\\n                i = j;\\n            }\\n        }\\n        if(j==n-1)\\n        {\\n            if(i==n-1)\\n            ans = max(ans,1);\\n            else\\n            {\\n                ans = max(ans,j-i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846468,
                "title": "c-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Record the start of the continuous string\\n- Update the max length if the current character can be included in the substring\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int maxLength = 1;\\n        int curStart = 0;\\n\\n        for(int i = 1; i < s.Length; i++)\\n        {\\n            if ((s[i] - s[i - 1]) == 1)\\n            {\\n                maxLength = Math.Max(maxLength, i - curStart + 1);\\n            }\\n            else\\n            {\\n                curStart = i;\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int maxLength = 1;\\n        int curStart = 0;\\n\\n        for(int i = 1; i < s.Length; i++)\\n        {\\n            if ((s[i] - s[i - 1]) == 1)\\n            {\\n                maxLength = Math.Max(maxLength, i - curStart + 1);\\n            }\\n            else\\n            {\\n                curStart = i;\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838348,
                "title": "simple-python3-solution-with-full-description-of-steps",
                "content": "# Intuition\\nWhen I\\'ve looked at this task, I thought that we need to somehow use implemented in python `ord()` function to get ASCII codes of characters. Because alphabetic characters lay down in ASCII table in ascending order. For lowercase english characters it is interval `[97, 122]`, that you can check by calling `ord(\\'a\\')` and `ord(\\'z\\')` in your python console.\\n\\n\\n# Approach\\nThe zeroth step is to add check for single character in input string. If so, just return 1, because single character will be alphabetic contnous string of length 1.\\n\\nAt first, we declare `max_l = 1` and `l = 1`, where the first value will help us to track maximum length of continous alphabetic substring and the second one for tracking current length.\\nAfter, we need to iterate through input string using `for` loop starting from the second element and compare ASCII codes of current character `ord(s[i])` and the previous one `ords([i - 1])`.\\nIf a statement above is true, do `l += 1` and continue iteration.\\nIf it\\'s not, update `max_l` with `max(max_l, l)` i.e. maximum between current length and stored maximum length. Don\\'t forget about set current length to it\\'s default value:\\n`l = 1`.\\n\\nAfter iteration we have one problem. If whole string was alphabetic continous, we will return defaul `max_l` value, i.e. 1.\\nSolution: use `max(max_l, l)` and return this value.\\n\\n##### Why we should start from the second element?\\n- First character already will be alphabetic continous substring of length 1.\\n- If comparison will be made as `ord(s[i]) == ord(s[i + 1])`, we should check **out of bounds exception**, so set end of `for` loop to `len(s) - 1`. That will lead as to additional check as above after ending of loop. Code will become less cleaner, as it is presented below.\\n\\n\\n# Complexity\\n- Time complexity:\\nAs we iterate through whole string single time, time complexity will be: $O(n)$, where $n$ is length of input string.\\n\\n- Space complexity:\\nAs we don\\'t use extra space except a few values, space complexity will be: $O(1)$.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        # By task constrain we have \\n        # that string will never contain zero characters i.g. equal to \"\"\\n        \\n        # Perform check for single character in string\\n        if len(s) == 1:\\n            return 1\\n        \\n        # max_l - maximum length of continuous substring\\n        #     l - current length\\n        max_l = 1\\n        l = 1\\n        \\n        # Iterating through string\\n        for i in range(1, len(s)):\\n            # If difference between ASCII codes of \\n            # character and the following character is equal to 1: \\n            # add 1 to current length\\n            if ord(s[i - 1]) == ord(s[i]) - 1:\\n                l += 1\\n                continue\\n\\n            # If it\\'s not, it means that substring is ended.\\n            # So we need to find max value of current and maximum lengths\\n            # and assing it to maximum length\\n            max_l = max(l, max_l)\\n            \\n            # Set current length to defaul value\\n            l = 1\\n\\n        # Finding max at this point needed because max() function in loop \\n        # will not be called if whole input string is alphabetic continous substring\\n        return max(l, max_l)\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        # By task constrain we have \\n        # that string will never contain zero characters i.g. equal to \"\"\\n        \\n        # Perform check for single character in string\\n        if len(s) == 1:\\n            return 1\\n        \\n        # max_l - maximum length of continuous substring\\n        #     l - current length\\n        max_l = 1\\n        l = 1\\n        \\n        # Iterating through string\\n        for i in range(1, len(s)):\\n            # If difference between ASCII codes of \\n            # character and the following character is equal to 1: \\n            # add 1 to current length\\n            if ord(s[i - 1]) == ord(s[i]) - 1:\\n                l += 1\\n                continue\\n\\n            # If it\\'s not, it means that substring is ended.\\n            # So we need to find max value of current and maximum lengths\\n            # and assing it to maximum length\\n            max_l = max(l, max_l)\\n            \\n            # Set current length to defaul value\\n            l = 1\\n\\n        # Finding max at this point needed because max() function in loop \\n        # will not be called if whole input string is alphabetic continous substring\\n        return max(l, max_l)\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821452,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int longestContinuousSubstring(String s) {\\n    var ans = 1;\\n    var currLength = 1;\\n\\n    for (int i = 1; i < s.length; i++) {\\n        if (s.codeUnitAt(i) == s.codeUnitAt(i - 1) + 1) {\\n          currLength += 1;\\n          ans = max(ans, currLength);\\n        } else {\\n          currLength = 1;\\n        }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int longestContinuousSubstring(String s) {\\n    var ans = 1;\\n    var currLength = 1;\\n\\n    for (int i = 1; i < s.length; i++) {\\n        if (s.codeUnitAt(i) == s.codeUnitAt(i - 1) + 1) {\\n          currLength += 1;\\n          ans = max(ans, currLength);\\n        } else {\\n          currLength = 1;\\n        }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812427,
                "title": "easy-c-sol",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans=0,curr=1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]-\\'a\\'+1==s[i+1]-\\'a\\')curr++;\\n            else curr=1;\\n            ans=max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans=0,curr=1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]-\\'a\\'+1==s[i+1]-\\'a\\')curr++;\\n            else curr=1;\\n            ans=max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795716,
                "title": "sliding-window-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max = 1;\\n        int start = 0, end = 1;\\n        while(end<s.length()){\\n            if((s.charAt(end)) - (s.charAt(end-1)) == 1){\\n                max = Math.max(max,end - start + 1);\\n                end++;\\n            }\\n            else{\\n                end++;\\n                start = end-1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max = 1;\\n        int start = 0, end = 1;\\n        while(end<s.length()){\\n            if((s.charAt(end)) - (s.charAt(end-1)) == 1){\\n                max = Math.max(max,end - start + 1);\\n                end++;\\n            }\\n            else{\\n                end++;\\n                start = end-1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789345,
                "title": "extending-and-reseting-a-window",
                "content": "# Approach\\nDenote i and j pointers as window\\'s left and right boundaries\\nStart iterating over the string once we face unordered character we reset a window by moving i=j\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar longestContinuousSubstring = function(s) {\\n    let maxWnd=0;\\n    for(let i=0,j=0;j<s.length;j++){\\n        // once we see unordered characters we start a new window\\n        if(j>0 && s[j].charCodeAt(0)-s[j-1].charCodeAt(0)!==1) i=j;\\n        maxWnd=Math.max(maxWnd, j-i+1);// track window size (i and j pointers)\\n    }\\n    return maxWnd;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestContinuousSubstring = function(s) {\\n    let maxWnd=0;\\n    for(let i=0,j=0;j<s.length;j++){\\n        // once we see unordered characters we start a new window\\n        if(j>0 && s[j].charCodeAt(0)-s[j-1].charCodeAt(0)!==1) i=j;\\n        maxWnd=Math.max(maxWnd, j-i+1);// track window size (i and j pointers)\\n    }\\n    return maxWnd;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3768875,
                "title": "easy-10-line-solution-beat-92-o-n-time-complexity-o-1-space-complexity-one-pass",
                "content": "![\\u2014Pngtree\\u2014janmashtami brush stroke frame with_8504820.png](https://assets.leetcode.com/users/images/72b83e1d-0e8e-40cf-b277-50021b05da1f_1689427565.067227.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int count=1,maxi=1;\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]+1==s[i+1]){\\n                count++;\\n                maxi=max(maxi,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int count=1,maxi=1;\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]+1==s[i+1]){\\n                count++;\\n                maxi=max(maxi,count);\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736098,
                "title": "simplest-c-beginner-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n     int ct=1,res=0,n=s.size();  \\n    for(int i=1;i<n;i++){\\n        if(s[i]-\\'a\\'==(s[i-1]-\\'a\\')+1){\\n        ct++;res=max(res,ct);\\n        }\\n        else ct=1;\\n    }\\n    res=max(res,ct);\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n     int ct=1,res=0,n=s.size();  \\n    for(int i=1;i<n;i++){\\n        if(s[i]-\\'a\\'==(s[i-1]-\\'a\\')+1){\\n        ct++;res=max(res,ct);\\n        }\\n        else ct=1;\\n    }\\n    res=max(res,ct);\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714152,
                "title": "light",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        max_l = 0\\n        c = 0\\n        aph = \"abcdefghijklmnopqrstuvwxyz\"\\n        for i, v in enumerate(s):\\n            if c == 0:\\n                letter = aph.find(v)\\n                c += 1\\n            elif letter < 25 and aph[letter+1] == v:\\n                c += 1\\n                letter += 1\\n            else:\\n                letter = aph.find(v)\\n                c = 1\\n            if c > max_l:\\n                max_l = c\\n        return max_l\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        max_l = 0\\n        c = 0\\n        aph = \"abcdefghijklmnopqrstuvwxyz\"\\n        for i, v in enumerate(s):\\n            if c == 0:\\n                letter = aph.find(v)\\n                c += 1\\n            elif letter < 25 and aph[letter+1] == v:\\n                c += 1\\n                letter += 1\\n            else:\\n                letter = aph.find(v)\\n                c = 1\\n            if c > max_l:\\n                max_l = c\\n        return max_l\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708869,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int cont_substr = 1, max_substr = 1;\\n        for(int idx = 1; idx < s.Length; idx++) {\\n            if(s[idx] - s[idx - 1] == 1)\\n                cont_substr++;\\n            else\\n                cont_substr = 1;\\n\\n            max_substr = Math.Max(max_substr, cont_substr);\\n        }\\n\\n        return max_substr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestContinuousSubstring(string s) {\\n        int cont_substr = 1, max_substr = 1;\\n        for(int idx = 1; idx < s.Length; idx++) {\\n            if(s[idx] - s[idx - 1] == 1)\\n                cont_substr++;\\n            else\\n                cont_substr = 1;\\n\\n            max_substr = Math.Max(max_substr, cont_substr);\\n        }\\n\\n        return max_substr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699073,
                "title": "beginner-s-friendly-solution-in-c-o-n-time-comp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing three pointers. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int start =0, end =1, mid =0;\\n        int ans = 0,maxAns = 1;\\n        while(end < s.length()){\\n            int diff = s[end] - s[mid];\\n            if(diff == 1){\\n                ans = end - start +1;\\n                mid++,end++;\\n            }\\n            else{\\n                end++,mid++;\\n                start = mid;\\n            }\\n            maxAns = max(maxAns, ans);\\n\\n        }\\n        return maxAns; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int start =0, end =1, mid =0;\\n        int ans = 0,maxAns = 1;\\n        while(end < s.length()){\\n            int diff = s[end] - s[mid];\\n            if(diff == 1){\\n                ans = end - start +1;\\n                mid++,end++;\\n            }\\n            else{\\n                end++,mid++;\\n                start = mid;\\n            }\\n            maxAns = max(maxAns, ans);\\n\\n        }\\n        return maxAns; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691888,
                "title": "simple-solution-easy-to-understand-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```Java []\\nclass Solution {\\n    public int longestContinuousSubstring(String s) { \\n        int c=1;\\n        int ans=0;\\n        \\n        for(int i=1;i<s.length();i++)\\n        {\\n            int ch2=s.charAt(i);\\n            int ch1=s.charAt(i-1);\\n\\n            if(ch2-ch1==1)\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                ans=Math.max(ans,c);\\n                c=1;\\n            }\\n        }\\n        \\n        // corner case like \"aaaaabcdef\"\\n\\n        ans=Math.max(ans,c);\\n\\n        return ans;\\n\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        ans=0\\n        c=1\\n        for i in range(1,len(s)):\\n            if(ord(s[i])-ord(s[i-1])==1):\\n                c+=1\\n            else:\\n                ans=max(ans,c)\\n                c=1\\n        ans=max(ans,c)\\n        return ans\\n\\n\\n\\n```\\n![Upvote.jpg](https://assets.leetcode.com/users/images/cf6c9fcd-3862-4697-9b50-5baed3e65ccf_1687936641.1020737.jpeg)\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int longestContinuousSubstring(String s) { \\n        int c=1;\\n        int ans=0;\\n        \\n        for(int i=1;i<s.length();i++)\\n        {\\n            int ch2=s.charAt(i);\\n            int ch1=s.charAt(i-1);\\n\\n            if(ch2-ch1==1)\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                ans=Math.max(ans,c);\\n                c=1;\\n            }\\n        }\\n        \\n        // corner case like \"aaaaabcdef\"\\n\\n        ans=Math.max(ans,c);\\n\\n        return ans;\\n\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        ans=0\\n        c=1\\n        for i in range(1,len(s)):\\n            if(ord(s[i])-ord(s[i-1])==1):\\n                c+=1\\n            else:\\n                ans=max(ans,c)\\n                c=1\\n        ans=max(ans,c)\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682539,
                "title": "one-pass-count-consecutive-easy-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = 1;\\n        int curr = 1;\\n        \\n        for(int i = 1; i < s.length(); i++) {\\n            if(s[i] == s[i - 1] + 1) curr++;\\n            else curr = 1;\\n            ans = max(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans = 1;\\n        int curr = 1;\\n        \\n        for(int i = 1; i < s.length(); i++) {\\n            if(s[i] == s[i - 1] + 1) curr++;\\n            else curr = 1;\\n            ans = max(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678929,
                "title": "c-solution-using-stack-unique-approach",
                "content": "**Here is my Solution. Although it is not very efficient I would say but it is pretty easy to understand\\nJust push to the stack if it is increasing and if not then store the max at that instance and clear the stack and add the last character.\\nAt last if Stack\\'s size is greater than ans then there are two possibilties : 1 The sequence is increasing throughout. 2. The sequence was increasing in last**.\\n# Here\\'s the C++ Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        stack<char>st;\\n        stack<char>empty;\\n        int ans = -1 ;\\n        for(char ch : s){\\n            if(st.empty()){\\n                st.push(ch);\\n            }\\n            if(!st.empty() && int(st.top())+1 == int (ch)){\\n                st.push(ch);\\n            }\\n            else if( int(st.top())+1 != int(ch) ){\\n                int size = st.size();\\n                ans=max(ans,size);\\n                st=empty;\\n                st.push(ch);\\n            }\\n        }\\n        if(st.size() > ans) return st.size();\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        stack<char>st;\\n        stack<char>empty;\\n        int ans = -1 ;\\n        for(char ch : s){\\n            if(st.empty()){\\n                st.push(ch);\\n            }\\n            if(!st.empty() && int(st.top())+1 == int (ch)){\\n                st.push(ch);\\n            }\\n            else if( int(st.top())+1 != int(ch) ){\\n                int size = st.size();\\n                ans=max(ans,size);\\n                st=empty;\\n                st.push(ch);\\n            }\\n        }\\n        if(st.size() > ans) return st.size();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674097,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo check with previous element that is it consecutive\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans=1,i=0;\\n        int n=s.size(); int cnt=1;\\n        while(i<n){\\n            if(i<n-1&&(s[i+1]-\\'a\\')==(s[i]-\\'a\\'+1)){\\n                cnt++;\\n                i++;\\n            }else{\\n             // if not consecutive then cnt=1\\n                i++;cnt=1;\\n            }\\n            ans=max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int ans=1,i=0;\\n        int n=s.size(); int cnt=1;\\n        while(i<n){\\n            if(i<n-1&&(s[i+1]-\\'a\\')==(s[i]-\\'a\\'+1)){\\n                cnt++;\\n                i++;\\n            }else{\\n             // if not consecutive then cnt=1\\n                i++;cnt=1;\\n            }\\n            ans=max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673648,
                "title": "longest-alphabetical-continuous-substring-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n = s.size();\\n        int ans = 1, curr = 1;\\n        for(int i=1; i<n; ++i){\\n            if(s[i]-s[i-1] == 1){\\n                curr++;\\n            }\\n            else{\\n                ans = max(ans, curr);\\n                curr = 1;\\n            }\\n        }\\n        ans = max(curr, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n = s.size();\\n        int ans = 1, curr = 1;\\n        for(int i=1; i<n; ++i){\\n            if(s[i]-s[i-1] == 1){\\n                curr++;\\n            }\\n            else{\\n                ans = max(ans, curr);\\n                curr = 1;\\n            }\\n        }\\n        ans = max(curr, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671742,
                "title": "simple-c-solution-which-beats-98-and-88-in-memory",
                "content": "# Intuition\\n\\n\\n# Approach\\nComapre the characters of the string with their Ascii value if the pattern of +1 is followed we will get the answer. otherwise start iterating again.\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) \\n    {\\n        if(s.size()==1)\\n        return 1;\\n        int a = (char)s[0]+1;\\n        int cnt=1;\\n        int ans=1;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if((char)s[i]==a)\\n            {\\n                cnt++;\\n                ans=max(ans,cnt);\\n            }\\n            else\\n            {\\n                a = (char)s[i];\\n                cnt=1;\\n            }\\n            a++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) \\n    {\\n        if(s.size()==1)\\n        return 1;\\n        int a = (char)s[0]+1;\\n        int cnt=1;\\n        int ans=1;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if((char)s[i]==a)\\n            {\\n                cnt++;\\n                ans=max(ans,cnt);\\n            }\\n            else\\n            {\\n                a = (char)s[i];\\n                cnt=1;\\n            }\\n            a++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668609,
                "title": "best-c-code-sliding-window-o-n-tc",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n## Please Upvote if u found my Solution helpful\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n = s.size(),maxi = 1,i = 0,j = 0;\\n        while(j < n){\\n            if(j+1 < n && s[j+1] - s[j] != 1){\\n                maxi = max(maxi,j-i+1);\\n                i = j+1;\\n            }\\n            maxi = max(maxi,j-i+1);\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n = s.size(),maxi = 1,i = 0,j = 0;\\n        while(j < n){\\n            if(j+1 < n && s[j+1] - s[j] != 1){\\n                maxi = max(maxi,j-i+1);\\n                i = j+1;\\n            }\\n            maxi = max(maxi,j-i+1);\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649844,
                "title": "easy-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        \\n        int n=s.size();\\n        int maxi=0;\\n        int count=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if((\\'a\\'-s[i-1])-(\\'a\\'-s[i])==1)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                maxi=max(maxi,count);\\n                count=1;\\n            }\\n        }\\n        maxi=max(maxi,count);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        \\n        int n=s.size();\\n        int maxi=0;\\n        int count=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if((\\'a\\'-s[i-1])-(\\'a\\'-s[i])==1)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                maxi=max(maxi,count);\\n                count=1;\\n            }\\n        }\\n        maxi=max(maxi,count);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636816,
                "title": "c-easy-solution-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n=s.size();\\n        int i=1,j=0;\\n        int ans=INT_MIN;\\n        while(i<n){\\n            if(s[i]!=s[i-1] + 1) {\\n            ans=max(ans,i-j);\\n            j=i;\\n        }\\n        i++;\\n        }\\n        ans=max(ans,n-j);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n=s.size();\\n        int i=1,j=0;\\n        int ans=INT_MIN;\\n        while(i<n){\\n            if(s[i]!=s[i-1] + 1) {\\n            ans=max(ans,i-j);\\n            j=i;\\n        }\\n        i++;\\n        }\\n        ans=max(ans,n-j);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630765,
                "title": "simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int answer = 0;\\n        int count = 1;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s[i+1]-s[i]==1){\\n                count++;\\n            }else{\\n                answer=max(answer,count);\\n                count=1;\\n            }\\n        }\\n        answer=max(answer,count);\\n        count=1;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int answer = 0;\\n        int count = 1;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s[i+1]-s[i]==1){\\n                count++;\\n            }else{\\n                answer=max(answer,count);\\n                count=1;\\n            }\\n        }\\n        answer=max(answer,count);\\n        count=1;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627256,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        longest = 1\\n\\n        current = 1\\n        i = 1\\n        while i<len(s):\\n            if ord(s[i]) == ord(s[i-1])+1:\\n                current += 1\\n            else:\\n                longest = max(current, longest)\\n                current = 1\\n            \\n            i += 1\\n        \\n        return max(current, longest)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        longest = 1\\n\\n        current = 1\\n        i = 1\\n        while i<len(s):\\n            if ord(s[i]) == ord(s[i-1])+1:\\n                current += 1\\n            else:\\n                longest = max(current, longest)\\n                current = 1\\n            \\n            i += 1\\n        \\n        return max(current, longest)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626927,
                "title": "simple-seen-hash-set-and-expected-letter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        seen = set()\\n        ans = 0\\n        expected = s[0]\\n        for c in s:\\n            if c in seen or c != expected:\\n                ans = max(ans, len(seen))\\n                seen = set()\\n\\n            seen.add(c)                \\n            expected = chr(ord(c)+ 1)   \\n\\n        return max(ans, len(seen))                  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        seen = set()\\n        ans = 0\\n        expected = s[0]\\n        for c in s:\\n            if c in seen or c != expected:\\n                ans = max(ans, len(seen))\\n                seen = set()\\n\\n            seen.add(c)                \\n            expected = chr(ord(c)+ 1)   \\n\\n        return max(ans, len(seen))                  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612805,
                "title": "two-pointer-easy-approach-o-n-time-complexity-and-80-beats",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        if(s.length()==1){\\n            return 1;\\n        }\\n        int ans = 0;\\n        int i=0,j=1;\\n        while(j<s.length()){\\n            if(s[j]-s[j-1] == 1){\\n                j++;\\n               \\n            }\\n            else{\\n                ans = max(ans,j-i);\\n                i=j;\\n                j++;\\n            }\\n        }\\n        ans = max(ans,j-i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        if(s.length()==1){\\n            return 1;\\n        }\\n        int ans = 0;\\n        int i=0,j=1;\\n        while(j<s.length()){\\n            if(s[j]-s[j-1] == 1){\\n                j++;\\n               \\n            }\\n            else{\\n                ans = max(ans,j-i);\\n                i=j;\\n                j++;\\n            }\\n        }\\n        ans = max(ans,j-i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605796,
                "title": "java-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//RITIK PATEL\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int differ[] = new int[s.length()];\\n        for(int i=1; i<differ.length; i++){\\n            differ[i] = s.charAt(i)-s.charAt(i-1);\\n        }\\n        int len = 0;\\n        int i=1, j=1;\\n        while(j<differ.length){\\n            if(differ[j]==1){\\n                j++;\\n            }\\n            else{\\n                // System.out.println(i+\"  \"+j);\\n                len = Math.max(len, j-i+1);\\n                if(differ[j]==1) i=j;\\n                else i=j+1;\\n                j++;\\n            }\\n        }\\n        // System.out.println(i+\"  \"+j);\\n        len = Math.max(len, j-i+1);\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//RITIK PATEL\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int differ[] = new int[s.length()];\\n        for(int i=1; i<differ.length; i++){\\n            differ[i] = s.charAt(i)-s.charAt(i-1);\\n        }\\n        int len = 0;\\n        int i=1, j=1;\\n        while(j<differ.length){\\n            if(differ[j]==1){\\n                j++;\\n            }\\n            else{\\n                // System.out.println(i+\"  \"+j);\\n                len = Math.max(len, j-i+1);\\n                if(differ[j]==1) i=j;\\n                else i=j+1;\\n                j++;\\n            }\\n        }\\n        // System.out.println(i+\"  \"+j);\\n        len = Math.max(len, j-i+1);\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605428,
                "title": "c-sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince problem asked about max length substring, sliding window should come into mind.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int i=1, j=1, c=1, mx=1, n=s.size();\\n        while(j<n){\\n            if(s[j]-s[j-1]!=1){\\n                mx = max(mx, j-i+1);\\n                i=j+1;\\n            }\\n            j++;\\n        }\\n        mx = max(mx, j-i+1);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int i=1, j=1, c=1, mx=1, n=s.size();\\n        while(j<n){\\n            if(s[j]-s[j-1]!=1){\\n                mx = max(mx, j-i+1);\\n                i=j+1;\\n            }\\n            j++;\\n        }\\n        mx = max(mx, j-i+1);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604659,
                "title": "easy-sliding-window-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        \\n        vector<int>nums;\\n        int total = 0,flag = 0, n = s.size();\\n        for(int i=0;i<n;++i){\\n            nums.push_back(s[i]-\\'a\\'+1);\\n        }\\n        if(n==1)return 1;\\n        int i=0,j=0,cnt=1,ans = 1;\\n        \\n       int diff = nums[1]-nums[0];\\n       if(diff==1){\\n           ans = 2,cnt=2;\\n       }\\n       i=2;\\n        while(i<n and j<n){\\n           if(nums[i]-nums[i-1]==1){\\n               cnt++;\\n           }else{\\n               ans = max(ans,cnt);\\n               cnt = 1;\\n           }\\n           i++;\\n\\n        }\\n        ans = max(ans,cnt);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        \\n        vector<int>nums;\\n        int total = 0,flag = 0, n = s.size();\\n        for(int i=0;i<n;++i){\\n            nums.push_back(s[i]-\\'a\\'+1);\\n        }\\n        if(n==1)return 1;\\n        int i=0,j=0,cnt=1,ans = 1;\\n        \\n       int diff = nums[1]-nums[0];\\n       if(diff==1){\\n           ans = 2,cnt=2;\\n       }\\n       i=2;\\n        while(i<n and j<n){\\n           if(nums[i]-nums[i-1]==1){\\n               cnt++;\\n           }else{\\n               ans = max(ans,cnt);\\n               cnt = 1;\\n           }\\n           i++;\\n\\n        }\\n        ans = max(ans,cnt);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603811,
                "title": "java-easy-t-c-0-n-complexity-solution-good-luck",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        if(s.length()==1){\\n            return 1;\\n        }\\n        int sum = 1;\\n        int maxl = 1;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)+1==s.charAt(i+1)){\\n                sum++;\\n                maxl = Math.max(sum,maxl);\\n            }\\n            else{\\n                sum=1;\\n            }\\n        }\\n        return maxl;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        if(s.length()==1){\\n            return 1;\\n        }\\n        int sum = 1;\\n        int maxl = 1;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)+1==s.charAt(i+1)){\\n                sum++;\\n                maxl = Math.max(sum,maxl);\\n            }\\n            else{\\n                sum=1;\\n            }\\n        }\\n        return maxl;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596799,
                "title": "go-runtime-beats-87",
                "content": "\\n# Code\\n```\\nfunc longestContinuousSubstring(s string) int {\\n    curCnt := 1\\n    ret := 1\\n    for i := 1; i < len(s); i ++ {\\n        if s[i] == s[i-1] + 1 {\\n            curCnt ++\\n            if curCnt > ret {\\n                ret = curCnt\\n            }\\n        } else {\\n            curCnt = 1\\n        }\\n    }\\n\\n    return ret \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestContinuousSubstring(s string) int {\\n    curCnt := 1\\n    ret := 1\\n    for i := 1; i < len(s); i ++ {\\n        if s[i] == s[i-1] + 1 {\\n            curCnt ++\\n            if curCnt > ret {\\n                ret = curCnt\\n            }\\n        } else {\\n            curCnt = 1\\n        }\\n    }\\n\\n    return ret \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571572,
                "title": "two-pointers-simple-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max=1;\\n        int c=1;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)+1 ==s.charAt(i+1)){\\n                c++;\\n                max=Math.max(c,max);\\n            }\\n            else{\\n                c=1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max=1;\\n        int c=1;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)+1 ==s.charAt(i+1)){\\n                c++;\\n                max=Math.max(c,max);\\n            }\\n            else{\\n                c=1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568505,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max=0;\\n        int count=1;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)+1==s.charAt(i+1))\\n                count++;\\n            \\n            else\\n            {\\n                if(max<count)\\n                    max=count;\\n                count=1;\\n\\n            }\\n        }\\n        if(count>max)\\n            max=count;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestContinuousSubstring(String s) {\\n        int max=0;\\n        int count=1;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)+1==s.charAt(i+1))\\n                count++;\\n            \\n            else\\n            {\\n                if(max<count)\\n                    max=count;\\n                count=1;\\n\\n            }\\n        }\\n        if(count>max)\\n            max=count;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561941,
                "title": "string",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int maxi=0;\\n        int cnt =0;\\n        for(int i =1;i<s.length();i++)\\n        {\\n            int j=s[i];\\n            int k=s[i-1];\\n        \\n              if(k+1==j)\\n              {\\n                 cnt=cnt+1;\\n                 maxi =max(cnt,maxi);\\n              }\\n            else{\\n                cnt=0;\\n            }\\n        }\\n        return maxi+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int maxi=0;\\n        int cnt =0;\\n        for(int i =1;i<s.length();i++)\\n        {\\n            int j=s[i];\\n            int k=s[i-1];\\n        \\n              if(k+1==j)\\n              {\\n                 cnt=cnt+1;\\n                 maxi =max(cnt,maxi);\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3559451,
                "title": "go-easy-to-understand",
                "content": "# Intuition\\nsliding window, \\'a\\' + 1 == \\'b\\' (\\'a\\' = 97, \\'b\\' = 98, \\'c\\' = 99 etc)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc longestContinuousSubstring(s string) int {\\n    answer := 0\\n    counter := 1\\n\\n    for i := 0; i < len(s); i++ {\\n        counter = 1\\n        for i + 1 < len(s) && isContinuous(s[i], s[i+1]) {\\n            counter++\\n            i++\\n        }\\n\\n        answer = max(answer, counter)\\n    }\\n\\n    return answer\\n}\\n\\nfunc isContinuous(a, b byte) bool {\\n    return b == a + 1\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestContinuousSubstring(s string) int {\\n    answer := 0\\n    counter := 1\\n\\n    for i := 0; i < len(s); i++ {\\n        counter = 1\\n        for i + 1 < len(s) && isContinuous(s[i], s[i+1]) {\\n            counter++\\n            i++\\n        }\\n\\n        answer = max(answer, counter)\\n    }\\n\\n    return answer\\n}\\n\\nfunc isContinuous(a, b byte) bool {\\n    return b == a + 1\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3559098,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        prev_index = -2\\n        ans = 0\\n        counter = 0\\n\\n        for i in range(len(s)):\\n            idx = alpha.index(s[i])\\n            if idx - prev_index == 1:\\n                counter += 1\\n            else:\\n                counter = 0\\n\\n            prev_index = idx\\n            ans = max(ans, counter)\\n\\n        return ans + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        prev_index = -2\\n        ans = 0\\n        counter = 0\\n\\n        for i in range(len(s)):\\n            idx = alpha.index(s[i])\\n            if idx - prev_index == 1:\\n                counter += 1\\n            else:\\n                counter = 0\\n\\n            prev_index = idx\\n            ans = max(ans, counter)\\n\\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557877,
                "title": "python-o-n-solution-easy-intuition",
                "content": "# Intuition\\nIf you solve it using ASCII codes in python solution is pretty easy.\\nord() converts alphabet to numerical value\\n\\n# Approach\\nIterate through the array and at each step check the ASCII value of current letter and the letter before it. If the difference of these two ASCII values is 1 then increment the length by 1\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        length = 1\\n        maxl = 1\\n        for i in range(1,len(s)):\\n            num = ord(s[i])\\n            prev_num = ord(s[i-1])\\n            if prev_num == num-1:\\n                length+=1\\n            else:\\n                length = 1\\n            maxl = max(maxl,length)\\n        \\n        return maxl\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestContinuousSubstring(self, s: str) -> int:\\n        length = 1\\n        maxl = 1\\n        for i in range(1,len(s)):\\n            num = ord(s[i])\\n            prev_num = ord(s[i-1])\\n            if prev_num == num-1:\\n                length+=1\\n            else:\\n                length = 1\\n            maxl = max(maxl,length)\\n        \\n        return maxl\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550749,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n = s.length();\\n        int ans = 1;\\n        vector<int> dp(n+2,1);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(s[i+1]-s[i]==1) dp[i+1] = dp[i] + 1;\\n            ans = max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestContinuousSubstring(string s) {\\n        int n = s.length();\\n        int ans = 1;\\n        vector<int> dp(n+2,1);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(s[i+1]-s[i]==1) dp[i+1] = dp[i] + 1;\\n            ans = max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1881454,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Should be **Easy**"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "To check the longest possible continuous substring, we can check if difference between two adjacent character is 1 or not. If it is 1 then increment the counter variable and update the answer. If it is not continuous then reset it to 1.\\nReturn the answer."
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Thanks"
                    },
                    {
                        "username": "ap3223",
                        "content": "that wasn\\'t even a medium level question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really don\\'t know if this should really be on medium , or my intuition is actually getting better !"
                    },
                    {
                        "username": "lucky_dog_me",
                        "content": "Compared to other string problems, this should not be medium I think"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "[@dimkat](/dimkat)  ord( ) in .py makes ASCII easy...\\n"
                    },
                    {
                        "username": "dimkat",
                        "content": "I had the same feeling. It sounds like an easy task, since the only extra step here is to know about ASCII codes..."
                    },
                    {
                        "username": "masterjul01",
                        "content": "was wondering the same"
                    }
                ]
            },
            {
                "id": 1845924,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Should be **Easy**"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "To check the longest possible continuous substring, we can check if difference between two adjacent character is 1 or not. If it is 1 then increment the counter variable and update the answer. If it is not continuous then reset it to 1.\\nReturn the answer."
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Thanks"
                    },
                    {
                        "username": "ap3223",
                        "content": "that wasn\\'t even a medium level question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really don\\'t know if this should really be on medium , or my intuition is actually getting better !"
                    },
                    {
                        "username": "lucky_dog_me",
                        "content": "Compared to other string problems, this should not be medium I think"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "[@dimkat](/dimkat)  ord( ) in .py makes ASCII easy...\\n"
                    },
                    {
                        "username": "dimkat",
                        "content": "I had the same feeling. It sounds like an easy task, since the only extra step here is to know about ASCII codes..."
                    },
                    {
                        "username": "masterjul01",
                        "content": "was wondering the same"
                    }
                ]
            },
            {
                "id": 1918940,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Should be **Easy**"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "To check the longest possible continuous substring, we can check if difference between two adjacent character is 1 or not. If it is 1 then increment the counter variable and update the answer. If it is not continuous then reset it to 1.\\nReturn the answer."
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Thanks"
                    },
                    {
                        "username": "ap3223",
                        "content": "that wasn\\'t even a medium level question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really don\\'t know if this should really be on medium , or my intuition is actually getting better !"
                    },
                    {
                        "username": "lucky_dog_me",
                        "content": "Compared to other string problems, this should not be medium I think"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "[@dimkat](/dimkat)  ord( ) in .py makes ASCII easy...\\n"
                    },
                    {
                        "username": "dimkat",
                        "content": "I had the same feeling. It sounds like an easy task, since the only extra step here is to know about ASCII codes..."
                    },
                    {
                        "username": "masterjul01",
                        "content": "was wondering the same"
                    }
                ]
            },
            {
                "id": 1707802,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Should be **Easy**"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "To check the longest possible continuous substring, we can check if difference between two adjacent character is 1 or not. If it is 1 then increment the counter variable and update the answer. If it is not continuous then reset it to 1.\\nReturn the answer."
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Thanks"
                    },
                    {
                        "username": "ap3223",
                        "content": "that wasn\\'t even a medium level question"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really don\\'t know if this should really be on medium , or my intuition is actually getting better !"
                    },
                    {
                        "username": "lucky_dog_me",
                        "content": "Compared to other string problems, this should not be medium I think"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "[@dimkat](/dimkat)  ord( ) in .py makes ASCII easy...\\n"
                    },
                    {
                        "username": "dimkat",
                        "content": "I had the same feeling. It sounds like an easy task, since the only extra step here is to know about ASCII codes..."
                    },
                    {
                        "username": "masterjul01",
                        "content": "was wondering the same"
                    }
                ]
            }
        ]
    }
]