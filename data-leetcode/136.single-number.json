[
    {
        "title": "Valid Sudoku",
        "question_content": "Determine if a&nbsp;9 x 9 Sudoku board&nbsp;is valid.&nbsp;Only the filled cells need to be validated&nbsp;according to the following rules:\n\n\tEach row&nbsp;must contain the&nbsp;digits&nbsp;1-9 without repetition.\n\tEach column must contain the digits&nbsp;1-9&nbsp;without repetition.\n\tEach of the nine&nbsp;3 x 3 sub-boxes of the grid must contain the digits&nbsp;1-9&nbsp;without repetition.\n\nNote:\n\n\tA Sudoku board (partially filled) could be valid but is not necessarily solvable.\n\tOnly the filled cells need to be validated according to the mentioned&nbsp;rules.\n\n&nbsp;\nExample 1:\n\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\n\nExample 2:\n\nInput: board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n&nbsp;\nConstraints:\n\n\tboard.length == 9\n\tboard[i].length == 9\n\tboard[i][j] is a digit 1-9 or '.'.",
        "solutions": [
            {
                "id": 15472,
                "title": "short-simple-java-using-strings",
                "content": "Collect the set of things we see, encoded as strings. For example:\\n\\n- `'4' in row 7` is encoded as `\"(4)7\"`.\\n- `'4' in column 7` is encoded as `\"7(4)\"`.\\n- `'4' in the top-right block` is encoded as `\"0(4)2\"`.\\n\\nScream `false` if we ever fail to add something because it was already added (i.e., seen before).\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != '.') {\\n                    String b = \"(\" + board[i][j] + \")\";\\n                    if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n---\\n\\n**Edit:** Just occurred to me that we can also make it really clear and self-explaining. I'm loving it.\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                char number = board[i][j];\\n                if (number != '.')\\n                    if (!seen.add(number + \" in row \" + i) ||\\n                        !seen.add(number + \" in column \" + j) ||\\n                        !seen.add(number + \" in block \" + i/3 + \"-\" + j/3))\\n                        return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Collect the set of things we see, encoded as strings. For example:\\n\\n- `'4' in row 7` is encoded as `\"(4)7\"`.\\n- `'4' in column 7` is encoded as `\"7(4)\"`.\\n- `'4' in the top-right block` is encoded as `\"0(4)2\"`.\\n\\nScream `false` if we ever fail to add something because it was already added (i.e., seen before).\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != '.') {\\n                    String b = \"(\" + board[i][j] + \")\";\\n                    if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n---\\n\\n**Edit:** Just occurred to me that we can also make it really clear and self-explaining. I'm loving it.\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                char number = board[i][j];\\n                if (number != '.')\\n                    if (!seen.add(number + \" in row \" + i) ||\\n                        !seen.add(number + \" in column \" + j) ||\\n                        !seen.add(number + \" in block \" + i/3 + \"-\" + j/3))\\n                        return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15464,
                "title": "my-short-solution-by-c-o-n2",
                "content": "Three flags are used to check whether a number appear.\\n\\nused1: check each row\\n\\nused2: check each column\\n\\nused3: check each sub-boxes\\n \\n    class Solution\\n    {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board)\\n        {\\n            int used1[9][9] = {0}, used2[9][9] = {0}, used3[9][9] = {0};\\n            \\n            for(int i = 0; i < board.size(); ++ i)\\n                for(int j = 0; j < board[i].size(); ++ j)\\n                    if(board[i][j] != '.')\\n                    {\\n                        int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3;\\n                        if(used1[i][num] || used2[j][num] || used3[k][num])\\n                            return false;\\n                        used1[i][num] = used2[j][num] = used3[k][num] = 1;\\n                    }\\n            \\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board)\\n        {\\n            int used1[9][9] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 15451,
                "title": "a-readable-python-solution",
                "content": "Apparently not the shortest solution but I think it's easy to follow the logic.\\n\\n    \\n    def isValidSudoku(self, board):\\n        return (self.is_row_valid(board) and\\n                self.is_col_valid(board) and\\n                self.is_square_valid(board))\\n    \\n    def is_row_valid(self, board):\\n        for row in board:\\n            if not self.is_unit_valid(row):\\n                return False\\n        return True\\n    \\n    def is_col_valid(self, board):\\n        for col in zip(*board):\\n            if not self.is_unit_valid(col):\\n                return False\\n        return True\\n        \\n    def is_square_valid(self, board):\\n        for i in (0, 3, 6):\\n            for j in (0, 3, 6):\\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\\n                if not self.is_unit_valid(square):\\n                    return False\\n        return True\\n        \\n    def is_unit_valid(self, unit):\\n        unit = [i for i in unit if i != '.']\\n        return len(set(unit)) == len(unit)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Apparently not the shortest solution but I think it's easy to follow the logic.\\n\\n    \\n    def isValidSudoku(self, board):\\n        return (self.is_row_valid(board) and\\n                self.is_col_valid(board) and\\n                self.is_square_valid(board))\\n    \\n    def is_row_valid(self, board):\\n        for row in board:\\n            if not self.is_unit_valid(row):\\n                return False\\n        return True\\n    \\n    def is_col_valid(self, board):\\n        for col in zip(*board):\\n            if not self.is_unit_valid(col):\\n                return False\\n        return True\\n        \\n    def is_square_valid(self, board):\\n        for i in (0, 3, 6):\\n            for j in (0, 3, 6):\\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\\n                if not self.is_unit_valid(square):\\n                    return False\\n        return True\\n        \\n    def is_unit_valid(self, unit):\\n        unit = [i for i in unit if i != '.']\\n        return len(set(unit)) == len(unit)",
                "codeTag": "Python3"
            },
            {
                "id": 15450,
                "title": "shared-my-concise-java-code",
                "content": "    public boolean isValidSudoku(char[][] board) {\\n        for(int i = 0; i<9; i++){\\n            HashSet<Character> rows = new HashSet<Character>();\\n            HashSet<Character> columns = new HashSet<Character>();\\n            HashSet<Character> cube = new HashSet<Character>();\\n            for (int j = 0; j < 9;j++){\\n                if(board[i][j]!='.' && !rows.add(board[i][j]))\\n                    return false;\\n                if(board[j][i]!='.' && !columns.add(board[j][i]))\\n                    return false;\\n                int RowIndex = 3*(i/3);\\n                int ColIndex = 3*(i%3);\\n                if(board[RowIndex + j/3][ColIndex + j%3]!='.' && !cube.add(board[RowIndex + j/3][ColIndex + j%3]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isValidSudoku(char[][] board) {\\n        for(int i = 0; i<9; i++){\\n            HashSet<Character> rows = new HashSet<Character>();\\n            HashSet<Character> columns = new HashSet<Character>();\\n            HashSet<Character> cube = new HashSet<Character>();\\n            for (int j = 0; j < 9;j++){\\n                if(board[i][j]!='.' && !rows.add(board[i][j]))\\n                    return false;\\n                if(board[j][i]!='.' && !columns.add(board[j][i]))\\n                    return false;\\n                int RowIndex = 3*(i/3);\\n                int ColIndex = 3*(i%3);\\n                if(board[RowIndex + j/3][ColIndex + j%3]!='.' && !cube.add(board[RowIndex + j/3][ColIndex + j%3]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15616,
                "title": "my-12-lines-c-c-solution-with-1-time-traversal-and-9x9x3-memory",
                "content": "\\n    int isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n        int rows[9][9]={0}; //rows[5][0] means whether number 1('0'+1) in row 5 has appeared.\\n    \\tint cols[9][9]={0}; //cols[3][8] means whether number 9('8'+1) in col 3 has appeared.\\n    \\tint blocks[3][3][9]={0};//blocks[0][2][5] means whether number '6' in block 0,2 (row 0~2,col 6~8) has appeared.\\n    \\tfor(int r=0;r<9;r++)    //traverse board r,c\\n    \\t\\tfor(int c=0;c<9;c++)\\n    \\t\\t\\tif(board[r][c]!='.'){   //skip all number '.'\\n    \\t\\t\\t\\tint number=board[r][c]-'1'; //calculate the number's index(board's number minus 1)\\n    \\t\\t\\t\\tif(rows[r][number]++) return 0; //if the number has already appeared once, return false.\\n    \\t\\t\\t\\tif(cols[c][number]++) return 0;\\n    \\t\\t\\t\\tif(blocks[r/3][c/3][number]++) return 0;\\n    \\t\\t\\t}\\n    \\treturn 1;\\n    }",
                "solutionTags": [],
                "code": "\\n    int isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n        int rows[9][9]={0}; //rows[5][0] means whether number 1('0'+1) in row 5 has appeared.\\n    \\tint cols[9][9]={0}; //cols[3][8] means whether number 9('8'+1) in col 3 has appeared.\\n    \\tint blocks[3][3][9]={0};//blocks[0][2][5] means whether number '6' in block 0,2 (row 0~2,col 6~8) has appeared.\\n    \\tfor(int r=0;r<9;r++)    //traverse board r,c\\n    \\t\\tfor(int c=0;c<9;c++)\\n    \\t\\t\\tif(board[r][c]!='.'){   //skip all number '.'\\n    \\t\\t\\t\\tint number=board[r][c]-'1'; //calculate the number's index(board's number minus 1)\\n    \\t\\t\\t\\tif(rows[r][number]++) return 0; //if the number has already appeared once, return false.\\n    \\t\\t\\t\\tif(cols[c][number]++) return 0;\\n    \\t\\t\\t\\tif(blocks[r/3][c/3][number]++) return 0;\\n    \\t\\t\\t}\\n    \\treturn 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15460,
                "title": "1-7-lines-python-4-solutions",
                "content": "**Idea**\\n\\nJust go through all you see (like \"7 in row 3\") and check for duplicates.\\n\\n**Solution 1**\\n\\nUsing `Counter`. One logical line, seven physical lines.\\n\\n    def isValidSudoku(self, board):\\n        return 1 == max(collections.Counter(\\n            x\\n            for i, row in enumerate(board)\\n            for j, c in enumerate(row)\\n            if c != '.'\\n            for x in ((c, i), (j, c), (i/3, j/3, c))\\n        ).values() + [1])\\n\\nThe ` + [1]` is only for the empty board, where `max` would get an empty list and complain. It's not necessary to get it accepted here, as the empty board isn't among the test cases, but it's good to have.\\n\\n**Solution 2**\\n\\nUsing `len(set)`.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i, row in enumerate(board)\\n                    for j, c in enumerate(row)\\n                    if c != '.'), [])\\n        return len(seen) == len(set(seen))\\n\\n**Solution 3**\\n\\nUsing `any`.\\n\\n    def isValidSudoku(self, board):\\n        seen = set()\\n        return not any(x in seen or seen.add(x)\\n                       for i, row in enumerate(board)\\n                       for j, c in enumerate(row)\\n                       if c != '.'\\n                       for x in ((c, i), (j, c), (i/3, j/3, c)))\\n\\n**Solution 4**\\n\\nIterating a different way.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i in range(9) for j in range(9)\\n                    for c in [board[i][j]] if c != '.'), [])\\n        return len(seen) == len(set(seen))",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Idea**\\n\\nJust go through all you see (like \"7 in row 3\") and check for duplicates.\\n\\n**Solution 1**\\n\\nUsing `Counter`. One logical line, seven physical lines.\\n\\n    def isValidSudoku(self, board):\\n        return 1 == max(collections.Counter(\\n            x\\n            for i, row in enumerate(board)\\n            for j, c in enumerate(row)\\n            if c != '.'\\n            for x in ((c, i), (j, c), (i/3, j/3, c))\\n        ).values() + [1])\\n\\nThe ` + [1]` is only for the empty board, where `max` would get an empty list and complain. It's not necessary to get it accepted here, as the empty board isn't among the test cases, but it's good to have.\\n\\n**Solution 2**\\n\\nUsing `len(set)`.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i, row in enumerate(board)\\n                    for j, c in enumerate(row)\\n                    if c != '.'), [])\\n        return len(seen) == len(set(seen))\\n\\n**Solution 3**\\n\\nUsing `any`.\\n\\n    def isValidSudoku(self, board):\\n        seen = set()\\n        return not any(x in seen or seen.add(x)\\n                       for i, row in enumerate(board)\\n                       for j, c in enumerate(row)\\n                       if c != '.'\\n                       for x in ((c, i), (j, c), (i/3, j/3, c)))\\n\\n**Solution 4**\\n\\nIterating a different way.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i in range(9) for j in range(9)\\n                    for c in [board[i][j]] if c != '.'), [])\\n        return len(seen) == len(set(seen))",
                "codeTag": "Python3"
            },
            {
                "id": 476369,
                "title": "javascript-solution-beats-100-with-explanation-real-explanations",
                "content": "Adopted from [@Lorraine921](https://leetcode.com/lorraine921)\\'s answer [here](https://leetcode.com/problems/valid-sudoku/discuss/15450/Shared-my-concise-Java-code) if anyone wants to check out the original answer. I wanted to share some of my thoughts as I was going through the solution:\\n\\n**Thinking**\\nBasically we need to check three things:\\n\\n1. Are there duplicates in each row? If yes, `return false`\\n2. Are there duplicates in each column? If yes, `return false`\\n3. Are there duplicates in each 3x3 box? If yes, `return false`\\n\\nif everything passes, `return true` at the end.\\n\\nWhen dealing with checking for duplicates, we use a Hash Set. \\n\\n**Representations**\\nLet\\'s deal with rows and columns first because it\\'s easier to tackle:\\n\\n```\\nfor (let i = 0; i < 9; i++) {\\n\\tlet row = new Set(); /* row Set */\\n\\tlet col = new Set(); /* column Set */\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[i][j] /* iterating row by row */\\n\\t\\tboard[j][i] /* iterating column by column */\\n\\t}\\n}\\n```\\nSo as we go through each row/column we add unseen number to the row/column `Set` accordingly. If `Set` has seen it, we `return false`.\\n```\\n/* example */\\nif (item != \\'.\\') {\\n\\tif (row.has(item)) return false;\\n\\trow.add(item);\\n}\\n```\\nNow let\\'s ace the 3x3 box iterating inside the same loop:\\nThis is a illustration of a sudoku in nine 3x3 boxes with each cell represented by a two-digit number `ij` (`i` means row index and `j` means column index).\\n```\\n00 01 02 | 03 04 05 | 06 07 08\\n10 11 12 | 13 14 15 | 16 17 18  // i = 0, 1, 2\\n20 21 22 | 23 24 25 | 26 27 28\\n------------------------------\\n30 31 32 | 33 34 35 | 36 37 38\\n40 41 42 | 43 44 45 | 46 47 48  // i = 3, 4, 5\\n50 51 52 | 53 54 55 | 56 57 58\\n------------------------------\\n60 61 62 | 63 64 65 | 66 67 68 \\n70 71 72 | 73 74 75 | 76 77 78  // i = 6, 7, 8\\n80 81 82 | 83 84 85 | 86 87 88\\n```\\nHow do we iterate using `i`, `j`, and `3`(because its 3x3)? \\nWe use `/` and `%` to help!\\n```\\t  \\nBecause we only want to start vertical traversal when horizontal traversal is done. \\n\\nUse / for vertical traversal because\\nMath.floor(0 / 3) = 0\\nMath.floor(1 / 3) = 0\\nMath.floor(2 / 3) = 0\\n\\nUse % for horizontal traversal beause \\n0 % 3 = 0\\n1 % 3 = 1\\n2 % 3 = 2\\n```\\nWe can represent the 3x3 box as:\\n```\\nfor (let i = 0; i < 9; i++) {\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[3 * Math.floor(i/3) + Math.floor(j/3)][3 * i%3 + j%3]\\n\\t}\\n}\\n```\\n**Code**\\n```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(),\\n        col = new Set(),\\n        box = new Set();\\n\\n    for (let j = 0; j < 9; j++) {\\n      let _row = board[i][j];\\n      let _col = board[j][i];\\n      let _box = board[3*Math.floor(i/3)+Math.floor(j/3)][3*(i%3)+(j%3)]\\n      \\n      if (_row != \\'.\\') {\\n        if (row.has(_row)) return false;\\n        row.add(_row);\\n      }\\n      if (_col != \\'.\\') {\\n        if (col.has(_col)) return false;\\n        col.add(_col);\\n      }\\n      \\n      if (_box != \\'.\\') {\\n        if (box.has(_box)) return false;\\n        box.add(_box);\\n      } \\n    }\\n  }\\n  return true\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor (let i = 0; i < 9; i++) {\\n\\tlet row = new Set(); /* row Set */\\n\\tlet col = new Set(); /* column Set */\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[i][j] /* iterating row by row */\\n\\t\\tboard[j][i] /* iterating column by column */\\n\\t}\\n}\\n```\n```\\n/* example */\\nif (item != \\'.\\') {\\n\\tif (row.has(item)) return false;\\n\\trow.add(item);\\n}\\n```\n```\\n00 01 02 | 03 04 05 | 06 07 08\\n10 11 12 | 13 14 15 | 16 17 18  // i = 0, 1, 2\\n20 21 22 | 23 24 25 | 26 27 28\\n------------------------------\\n30 31 32 | 33 34 35 | 36 37 38\\n40 41 42 | 43 44 45 | 46 47 48  // i = 3, 4, 5\\n50 51 52 | 53 54 55 | 56 57 58\\n------------------------------\\n60 61 62 | 63 64 65 | 66 67 68 \\n70 71 72 | 73 74 75 | 76 77 78  // i = 6, 7, 8\\n80 81 82 | 83 84 85 | 86 87 88\\n```\n```\\t  \\nBecause we only want to start vertical traversal when horizontal traversal is done. \\n\\nUse / for vertical traversal because\\nMath.floor(0 / 3) = 0\\nMath.floor(1 / 3) = 0\\nMath.floor(2 / 3) = 0\\n\\nUse % for horizontal traversal beause \\n0 % 3 = 0\\n1 % 3 = 1\\n2 % 3 = 2\\n```\n```\\nfor (let i = 0; i < 9; i++) {\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[3 * Math.floor(i/3) + Math.floor(j/3)][3 * i%3 + j%3]\\n\\t}\\n}\\n```\n```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(),\\n        col = new Set(),\\n        box = new Set();\\n\\n    for (let j = 0; j < 9; j++) {\\n      let _row = board[i][j];\\n      let _col = board[j][i];\\n      let _box = board[3*Math.floor(i/3)+Math.floor(j/3)][3*(i%3)+(j%3)]\\n      \\n      if (_row != \\'.\\') {\\n        if (row.has(_row)) return false;\\n        row.add(_row);\\n      }\\n      if (_col != \\'.\\') {\\n        if (col.has(_col)) return false;\\n        col.add(_col);\\n      }\\n      \\n      if (_box != \\'.\\') {\\n        if (box.has(_box)) return false;\\n        box.add(_box);\\n      } \\n    }\\n  }\\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332984,
                "title": "c-simple-and-easy-10-short-line-solution",
                "content": "For each row, column and block we keep a set of numbers.\\nIf we find a number that was seen already in that row, column or block - return false.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15452,
                "title": "c-very-simple-and-easy-understand-using-bit-operation",
                "content": "       bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<short> col(9, 0);\\n        vector<short> block(9, 0);\\n        vector<short> row(9, 0);\\n        for (int i = 0; i < 9; i++)\\n         for (int j = 0; j < 9; j++) {\\n             if (board[i][j] != '.') {\\n                 int idx = 1 << (board[i][j] - '0');\\n                 if (row[i] & idx || col[j] & idx || block[i/3 * 3 + j / 3] & idx)\\n                    return false;\\n                row[i] |= idx;\\n                col[j] |= idx;\\n                block[i/3 * 3 + j/3] |= idx;\\n             }\\n         }\\n         return true;\\n      }",
                "solutionTags": [],
                "code": "       bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<short> col(9, 0);\\n        vector<short> block(9, 0);\\n        vector<short> row(9, 0);\\n        for (int i = 0; i < 9; i++)\\n         for (int j = 0; j < 9; j++) {\\n             if (board[i][j] != '.') {\\n                 int idx = 1 << (board[i][j] - '0');\\n                 if (row[i] & idx || col[j] & idx || block[i/3 * 3 + j / 3] & idx)\\n                    return false;\\n                row[i] |= idx;\\n                col[j] |= idx;\\n                block[i/3 * 3 + j/3] |= idx;\\n             }\\n         }\\n         return true;\\n      }",
                "codeTag": "Unknown"
            },
            {
                "id": 15509,
                "title": "clean-and-easy82ms-python",
                "content": "class Solution(object):\\n\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        big = set()\\n        for i in xrange(0,9):\\n            for j in xrange(0,9):\\n                if board[i][j]!='.':\\n                    cur = board[i][j]\\n                    if (i,cur) in big or (cur,j) in big or (i/3,j/3,cur) in big:\\n                        return False\\n                    big.add((i,cur))\\n                    big.add((cur,j))\\n                    big.add((i/3,j/3,cur))\\n        return True",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "class Solution(object):\\n\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        big = set()\\n        for i in xrange(0,9):\\n            for j in xrange(0,9):\\n                if board[i][j]!='.':\\n                    cur = board[i][j]\\n                    if (i,cur) in big or (cur,j) in big or (i/3,j/3,cur) in big:\\n                        return False\\n                    big.add((i,cur))\\n                    big.add((cur,j))\\n                    big.add((i/3,j/3,cur))\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 3277043,
                "title": "beats-96-78-short-7-line-python-solution-with-detailed-explanation",
                "content": "\\n1)It initializes an empty list called \"res\", which will be used to store all the valid elements in the board.\\n\\n2)It loops through each cell in the board using two nested \"for\" loops.\\nFor each cell, it retrieves the value of the element in that cell and stores it in a variable called \"element\".\\n\\n3)If the element is not a dot (\\'.\\'), which means it\\'s a valid number, the method adds three tuples to the \"res\" list:\\n\\n- The first tuple contains the row index (i) and the element itself.\\n- The second tuple contains the element itself and the column index (j).\\n- The third tuple contains the floor division of the row index by 3 (i // 3), the floor division of the column index by 3 (j // 3), and the element itself. This tuple represents the 3x3 sub-grid that the current cell belongs to.\\n\\n4)After processing all the cells, the method checks if the length of \"res\" is equal to the length of the set of \"res\".\\n\\n```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        res = []\\n        for i in range(9):\\n            for j in range(9):\\n                element = board[i][j]\\n                if element != \\'.\\':\\n                    res += [(i, element), (element, j), (i // 3, j // 3, element)]\\n        return len(res) == len(set(res))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        res = []\\n        for i in range(9):\\n            for j in range(9):\\n                element = board[i][j]\\n                if element != \\'.\\':\\n                    res += [(i, element), (element, j), (i // 3, j // 3, element)]\\n        return len(res) == len(set(res))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15634,
                "title": "sharing-my-easy-understand-java-solution-using-set",
                "content": "    public class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int i=0; i<9; i++) {\\n            if (!isParticallyValid(board,i,0,i,8)) return false;\\n            if (!isParticallyValid(board,0,i,8,i)) return false;\\n        }\\n        for (int i=0;i<3;i++){\\n            for(int j=0;j<3;j++){\\n                if (!isParticallyValid(board,i*3,j*3,i*3+2,j*3+2)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isParticallyValid(char[][] board, int x1, int y1,int x2,int y2){\\n        Set singleSet = new HashSet();\\n        for (int i= x1; i<=x2; i++){\\n            for (int j=y1;j<=y2; j++){\\n                if (board[i][j]!='.') if(!singleSet.add(board[i][j])) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\nEach time send the coordinates to check if the board is partially valid.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int i=0; i<9; i++) {\\n            if (!isParticallyValid(board,i,0,i,8)) return false;\\n            if (!isParticallyValid(board,0,i,8,i)) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1414911,
                "title": "c-java-python-2-solutions-hashset-bitmasking-clean-concise-o-49",
                "content": "**\\u2714\\uFE0F Solution 1: Hash Set**\\n- The idea is super easy.\\n- For each row, we create a HashSet to check for duplicates in each row.\\n- For each column, we also create a HashSet to check for duplicates in each column.\\n- For each square, we also create a HashSet to check for duplicates in each square, but we need to convert the position `(r, c)` in the board to square by:\\n\\t- Square row: `sr = r / 3`.\\n\\t- Square col: `sc = c / 3`.\\n\\t- Square position: `sPos = sr * 3 + sc`.\\n\\n<iframe src=\"https://leetcode.com/playground/kopzUL7z/shared\" frameBorder=\"0\" width=\"100%\" height=\"520\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N^2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bitmasking (Beat 100%)**\\n- Since we only need to store 2 states (exist, not exist) and store up to 9 positions.\\n- So to save space, we can store in the bitmask, `i` th bit represent the existence of the number `i`.\\n\\n<iframe src=\"https://leetcode.com/playground/cnqUk6bW/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Hash Set**\\n- The idea is super easy.\\n- For each row, we create a HashSet to check for duplicates in each row.\\n- For each column, we also create a HashSet to check for duplicates in each column.\\n- For each square, we also create a HashSet to check for duplicates in each square, but we need to convert the position `(r, c)` in the board to square by:\\n\\t- Square row: `sr = r / 3`.\\n\\t- Square col: `sc = c / 3`.\\n\\t- Square position: `sPos = sr * 3 + sc`.\\n\\n<iframe src=\"https://leetcode.com/playground/kopzUL7z/shared\" frameBorder=\"0\" width=\"100%\" height=\"520\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N^2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bitmasking (Beat 100%)**\\n- Since we only need to store 2 states (exist, not exist) and store up to 9 positions.\\n- So to save space, we can store in the bitmask, `i` th bit represent the existence of the number `i`.\\n\\n<iframe src=\"https://leetcode.com/playground/cnqUk6bW/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 15560,
                "title": "yet-another-java-2ms-solution",
                "content": "    public boolean isValidSudoku(char[][] board) {\\n        int [] vset = new int [9];\\n        int [] hset = new int [9];\\n        int [] bckt = new int [9];\\n        int idx = 0;\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    idx = 1 << (board[i][j] - '0') ;\\n                    if ((hset[i] & idx) > 0 ||\\n                        (vset[j] & idx) > 0 ||\\n                        (bckt[(i / 3) * 3 + j / 3] & idx) > 0) return false;\\n                    hset[i] |= idx;\\n                    vset[j] |= idx;\\n                    bckt[(i / 3) * 3 + j / 3] |= idx;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isValidSudoku(char[][] board) {\\n        int [] vset = new int [9];\\n        int [] hset = new int [9];\\n        int [] bckt = new int [9];\\n        int idx = 0;\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    idx = 1 << (board[i][j] - '0') ;\\n                    if ((hset[i] & idx) > 0 ||\\n                        (vset[j] & idx) > 0 ||\\n                        (bckt[(i / 3) * 3 + j / 3] & idx) > 0) return false;\\n                    hset[i] |= idx;\\n                    vset[j] |= idx;\\n                    bckt[(i / 3) * 3 + j / 3] |= idx;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2572765,
                "title": "python-explained-steps-clean-code-best-method",
                "content": "Hello!\\n\\nTo solve this problem we have to check if each value in sudoku does not repeat in its:\\n1. column\\n2. row\\n3. square\\n\\nTo do this efficiently we will use **sets** to store elements in columns, rows and squares. This is easy to define column and row (by single index), but squares are defined using two indexes. We will use **//** (floor division) operator to know in which square we are right now.\\n\\nIndexes range from **0** to **8**. \\n0 // 3 = 0\\n1 // 3 = 0\\n2 // 3 = 0\\n3 // 3 = 1\\n4 // 3 = 1\\n5 // 3 = 1\\n6 // 3 = 2\\n7 // 3 = 2\\n8 // 3 = 2\\n\\nWe got 3 different values for each range (0-2: **0**, 3-5: **1**, 6-8: **2**), so we can use it to know in which square are currently are (by getting square **x** and **y** coordinate, we need 9 squares with indexes (0, 0), (0, 1), (0, 2), (1,0), ..., (2, 2)).\\n\\nIn code we do nothing if we meet **.** symbol, but if we have **digit** in cell, then we check if it is in cell\\'s row, column or square. \\nIf **yes**, then it means that the value is repeated, so sudoku is not valid one, so we return **False**.\\n\\nAfter checking, we add this value to its row, column and square.\\nIf number occurs 2 times in given row, cell or square, then the 2nd occurence is going to trigger **False** return (because in first occurence we add the value to the **sets**).\\n\\nCode:\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for x in range(9)]\\n        columns = [set() for x in range(9)]\\n        squares = [[set() for x in range(3)] for y in range(3)]\\n        \\n        for x in range(9):\\n            for y in range(9):\\n                cell_value = board[x][y]\\n                if cell_value == \".\":\\n                    continue\\n                if cell_value in rows[x] or cell_value in columns[y] or cell_value in squares[x//3][y//3]:\\n                    return False\\n\\n                rows[x].add(cell_value)\\n                columns[y].add(cell_value)\\n                squares[x//3][y//3].add(cell_value)\\n        \\n        return True\\n```\\n\\nPlease upvote if it was helpful :))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for x in range(9)]\\n        columns = [set() for x in range(9)]\\n        squares = [[set() for x in range(3)] for y in range(3)]\\n        \\n        for x in range(9):\\n            for y in range(9):\\n                cell_value = board[x][y]\\n                if cell_value == \".\":\\n                    continue\\n                if cell_value in rows[x] or cell_value in columns[y] or cell_value in squares[x//3][y//3]:\\n                    return False\\n\\n                rows[x].add(cell_value)\\n                columns[y].add(cell_value)\\n                squares[x//3][y//3].add(cell_value)\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461845,
                "title": "simple-solution-using-set-in-c",
                "content": "**If you understand the approach please upvote!!!**\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //since we have to verify that each element is appears once or not... for that purpose here we use \\n        //vector of sets since set stores only unique entries\\n        vector<set<int>> rows(9),cols(9),blocks(9); \\n        \\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                //if board[i][j] entry is \\'.\\' then we just continue as we only care about the duplicate values\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n                \\n                int curr = board[i][j]; //we can get the value at given index to check that if it is already \\n                // present in set or not\\n                \\n                //here our count function returns 1 if value is already present in row or column or block otherwise it will return 0\\n                \\n                //for block try this formula using pen and paper you will get it..\\n                if(rows[i].count(curr) || cols[j].count(curr) ||\\n                  blocks[(i/3)*3 + j/3].count(curr)){\\n                    return false; //we return false because the value currently we have is already present in set\\n                }\\n                //if we don\\'t found the value then after that we must enter this value in our set\\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3*3) + j/3].insert(curr);\\n            }\\n        }\\n        return true; //after loop finishes our control reaches here that means our sudoko is valid...\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //since we have to verify that each element is appears once or not... for that purpose here we use \\n        //vector of sets since set stores only unique entries\\n        vector<set<int>> rows(9),cols(9),blocks(9); \\n        \\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                //if board[i][j] entry is \\'.\\' then we just continue as we only care about the duplicate values\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n                \\n                int curr = board[i][j]; //we can get the value at given index to check that if it is already \\n                // present in set or not\\n                \\n                //here our count function returns 1 if value is already present in row or column or block otherwise it will return 0\\n                \\n                //for block try this formula using pen and paper you will get it..\\n                if(rows[i].count(curr) || cols[j].count(curr) ||\\n                  blocks[(i/3)*3 + j/3].count(curr)){\\n                    return false; //we return false because the value currently we have is already present in set\\n                }\\n                //if we don\\'t found the value then after that we must enter this value in our set\\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3*3) + j/3].insert(curr);\\n            }\\n        }\\n        return true; //after loop finishes our control reaches here that means our sudoko is valid...\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729180,
                "title": "python-solutions-single-traversal-single-dictionary",
                "content": "Just store the indexs of the numbers in a dictionary in `(x, y)` format. Then for every number check for same row, same col and same box condition.\\nThis will require a single traversal. The same box condition can be checked using `pos[0]//3 == x//3 and pos[1]//3 == y//3` since `i//3` and `j//3` give the box position.\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        boardMap = collections.defaultdict(list)\\n        for x in range(9):\\n            for y in range(9):\\n                char = board[x][y]\\n                if char != \\'.\\': \\n                    if char in boardMap:\\n                        for pos in boardMap[char]:\\n                            if (pos[0]== x) or (pos[1] == y) or (pos[0]//3 == x//3 and pos[1]//3 == y//3):\\n                                return False\\n                    boardMap[char].append((x,y))\\n   \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        boardMap = collections.defaultdict(list)\\n        for x in range(9):\\n            for y in range(9):\\n                char = board[x][y]\\n                if char != \\'.\\': \\n                    if char in boardMap:\\n                        for pos in boardMap[char]:\\n                            if (pos[0]== x) or (pos[1] == y) or (pos[0]//3 == x//3 and pos[1]//3 == y//3):\\n                                return False\\n                    boardMap[char].append((x,y))\\n   \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840656,
                "title": "java-explained-in-detail-simple-fast-solution-intuitive-hash-table",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n## 1st Approach - Intuitive\\n\\nUsing the intuitive way of checking, which is to check the row, the column and the box to see if any same number.\\n\\nWith that, we can split it into 3 separate methods to check the row, the column and the box respectively.\\n\\nThis approach is adapted from the solution to solving the whole sudoku.\\n\\nHowever, we need to take note to skip the current row and column when checking, which is not necessary when solving the sudoku.\\n\\n</br>\\n\\n## Complexity\\n\\n#### Time Complexity  : O(n^3),\\nwhere \\'n\\' is 9, the length and width of the \\'board\\'.\\n\\nFor each position in the board, we perform 3 checks, row, column and box, which iterates 9 positions each.\\n\\nThus, to be more exact, it is O(3 * 9 * 9 * 9).\\n\\n#### Space Complexity : O(1),\\nas only fixed auxiliary variable is used to check.\\n\\n</br>\\n\\n### Java - Intuitive (With Explanation)\\n```\\npublic class ValidSudoku {\\n\\n    // Main Method to check the valid sudoku.\\n    public boolean isValidSudoku(char[][] board) {\\n        // Checking every number in the \\'board\\'.\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n\\n    // Method to check if identical number found in the row.\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"column != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the row and return true if found.\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        // If we did not find any identical number in the row, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"row != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the column and return true if found.\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        // If we did not find any identical number in the column, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        // Here, we get the top left corner position of the box the \\'number\\' is in,\\n        // because we are going to scan from top left to bottom right of the box.\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n\\n        // Checking just the 3 row and 3 column position in the box.\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                // \"row != i && column != j\" to skip the current number.\\n                // Otherwise, check if any identical number in the box and return true if found.\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        // If we did not find any identical number in the box, then return false.\\n        return false;\\n    }\\n\\n    // Additional wrapper method for all three checks to make the code more readable.\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        // If the number is not found in the row, column and the box, then it is a valid placement and return true.\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n\\n```\\n\\n### Java - Intuitive (Clean Code)\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n```\\n---\\n## 2nd Approach\\nCredit to @StefanPochmann for this clean and readable solution.\\n\\nUsing a HashSet to record the number that was already found in the row, column and box.\\n\\nIf there are any same number in the row, column or box is already in the HashSet, then we have found the identical number, which resulted in an invalid sudoku board.\\n\\nThere are multiple approaches for the HashSet, either use separate HashSet for the rows, columns and boxes, or using String to include all the information into a single HashSet.\\n\\nThe latter approach is implemented here.\\n\\n</br>\\n\\n## Complexity\\n\\n#### Time Complexity  : O(n^2),\\nwhere \\'n\\' is 9, the length and width of the \\'board\\'.\\nThis is because we iterate through every number in \\'board\\'.\\nDo note that the string concatenation take use some additional time, but they are constant time and do not scale linearly with \\'n\\'.\\n\\n\\n#### Space Complexity : O(n^2),\\n\\nwhere \\'n\\' is 9, the length and width of the \\'board\\'.\\nThis is due to the HashSet used, which stores the information of the number in the row, column and box.\\nEvery row with every 9 numbers, likewise for every column and every box, thus, to be more precise, it is O (n^2 + n^2 + n^2).\\n\\n</br>\\n\\n### Java - Hash Table (With Explanation)\\n```\\nclass Solution {\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                // If the position is a number (!= \\'.\\'),\\n                // then we can try adding the number and its information into the HashSet.\\n                if (number != \\'.\\') {\\n                    // The HashSet.add() function returns a boolean result, true if added successfully and false otherwise.\\n                    // As such, we can just use this boolean return from add() to check if we successfully added.\\n                    // If any of the 3 (row, column and box) is not added successfully,\\n                    // then \\'board\\' is not a valid sudoku board.\\n                    // 1. Store the number in the row.\\n                    // 2. Store the number in the column.\\n                    // 3. Store the number in the box. (Make sure to separate row and column information with a delimiter).\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n}\\n```\\n\\n### Java - Hash Table (Clean Code)\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                if (number != \\'.\\') {\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class ValidSudoku {\\n\\n    // Main Method to check the valid sudoku.\\n    public boolean isValidSudoku(char[][] board) {\\n        // Checking every number in the \\'board\\'.\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n\\n    // Method to check if identical number found in the row.\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"column != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the row and return true if found.\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        // If we did not find any identical number in the row, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"row != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the column and return true if found.\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        // If we did not find any identical number in the column, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        // Here, we get the top left corner position of the box the \\'number\\' is in,\\n        // because we are going to scan from top left to bottom right of the box.\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n\\n        // Checking just the 3 row and 3 column position in the box.\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                // \"row != i && column != j\" to skip the current number.\\n                // Otherwise, check if any identical number in the box and return true if found.\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        // If we did not find any identical number in the box, then return false.\\n        return false;\\n    }\\n\\n    // Additional wrapper method for all three checks to make the code more readable.\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        // If the number is not found in the row, column and the box, then it is a valid placement and return true.\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                // If the position is a number (!= \\'.\\'),\\n                // then we can try adding the number and its information into the HashSet.\\n                if (number != \\'.\\') {\\n                    // The HashSet.add() function returns a boolean result, true if added successfully and false otherwise.\\n                    // As such, we can just use this boolean return from add() to check if we successfully added.\\n                    // If any of the 3 (row, column and box) is not added successfully,\\n                    // then \\'board\\' is not a valid sudoku board.\\n                    // 1. Store the number in the row.\\n                    // 2. Store the number in the column.\\n                    // 3. Store the number in the box. (Make sure to separate row and column information with a delimiter).\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                if (number != \\'.\\') {\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840666,
                "title": "python3-easy-to-understand-beginner-friendly",
                "content": "Since the Sudoku is 9 by 9, it doesn\\'t really matter if we go over it once, twice, or three times. I feel like if we get this question in an interview, the interviewer is looking for a clean code. The tricky part of this problem would be handling the sub-box indices.\\n\\n**Clear and Understandable Approach**\\n```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Given an arr of row/col/sub,\\n        # check if there are duplicates.\\n        def isValid(arr):\\n            s = \\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s) == len(set(s))\\n        \\n        # Check each row in the board\\n        def checkRow():\\n            for row in board:\\n                if not isValid(row):\\n                    return False\\n            return True\\n        \\n        # Check each col in the board,\\n        # To access each col, we first unpack the board into sperate lists using *\\n        # We then zip these rows together into columns.\\n        def checkCol():\\n            for col in zip(*board):\\n                if not isValid(col):\\n                    return False\\n            return True\\n        \\n        # To get each sub-box, we first get the top-left indices of each sub-box,\\n        # We then go 3 steps on each row and 3 steps on each col to construct the box.\\n        def checkSub():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    sub = [board[r+dr][c+dc] for dr in range(3) for dc in range(3)]\\n                    if not isValid(sub):\\n                        return False\\n            return True\\n        \\n        # In order to be a valid Sudoku, all row, col, and sub-box need to be valid\\n        return checkRow() and checkCol() and checkSub()\\n```\\n\\n**One pass using row, col, sub-box ID**\\nWe can also optimize the solution a little bit, using a hashmap to store the visited elements for each row, col, and sub-box.\\n```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Row, Col, and subBox will each contain 9 sets to keep track of the visited element.\\n        # Using 0-8 as the id for each row, col, and sub-box.\\n        # At any time if the same number is visited twice, return False. \\n        Row = defaultdict(set)\\n        Col = defaultdict(set)\\n        subBox = defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                \\n                cur = board[r][c]\\n                if cur==\\'.\\':\\n                    continue\\n                \\n                # r is the id for Row \\n                if cur in Row[r]:\\n                    return False\\n                Row[r].add(cur)\\n                \\n                # c is the id for Col\\n                if cur in Col[c]:\\n                    return False\\n                Col[c].add(cur)\\n                \\n                # sub-box id is a little bit tricky\\n                # r//3*3 will map the number 0-8 to 0,3,6 which is the starting id for each row.\\n                # c//3 will map the number 0-8 to 0,1,2, which is the column.\\n                # So r//3*3+c//3 is corresponding to sub-box id as shown\\n                                                             ----- ----- -----\\n                boxId = r//3*3+c//3                         |  0  |  1  |  2  |\\n                if cur in subBox[boxId]:                     ----- ----- -----\\n                    return False                            |  3  |  4  |  5  |\\n                subBox[boxId].add(cur)                       ----- ----- -----\\n                                                            |  6  |  7  |  8  |\\n                                                             ----- ----- -----\\n        # We passed all the tests, return True\\n        return True\\n```\\n\\nFor more advanced solutions check [HERE](https://leetcode.com/problems/valid-sudoku/discuss/2840529/PythonC%2B%2BJavaRust-O(1)-space-an-other-approaches...-%2B-BONUS-ONE-LINER-(explained))\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Given an arr of row/col/sub,\\n        # check if there are duplicates.\\n        def isValid(arr):\\n            s = \\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s) == len(set(s))\\n        \\n        # Check each row in the board\\n        def checkRow():\\n            for row in board:\\n                if not isValid(row):\\n                    return False\\n            return True\\n        \\n        # Check each col in the board,\\n        # To access each col, we first unpack the board into sperate lists using *\\n        # We then zip these rows together into columns.\\n        def checkCol():\\n            for col in zip(*board):\\n                if not isValid(col):\\n                    return False\\n            return True\\n        \\n        # To get each sub-box, we first get the top-left indices of each sub-box,\\n        # We then go 3 steps on each row and 3 steps on each col to construct the box.\\n        def checkSub():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    sub = [board[r+dr][c+dc] for dr in range(3) for dc in range(3)]\\n                    if not isValid(sub):\\n                        return False\\n            return True\\n        \\n        # In order to be a valid Sudoku, all row, col, and sub-box need to be valid\\n        return checkRow() and checkCol() and checkSub()\\n```\n```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Row, Col, and subBox will each contain 9 sets to keep track of the visited element.\\n        # Using 0-8 as the id for each row, col, and sub-box.\\n        # At any time if the same number is visited twice, return False. \\n        Row = defaultdict(set)\\n        Col = defaultdict(set)\\n        subBox = defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                \\n                cur = board[r][c]\\n                if cur==\\'.\\':\\n                    continue\\n                \\n                # r is the id for Row \\n                if cur in Row[r]:\\n                    return False\\n                Row[r].add(cur)\\n                \\n                # c is the id for Col\\n                if cur in Col[c]:\\n                    return False\\n                Col[c].add(cur)\\n                \\n                # sub-box id is a little bit tricky\\n                # r//3*3 will map the number 0-8 to 0,3,6 which is the starting id for each row.\\n                # c//3 will map the number 0-8 to 0,1,2, which is the column.\\n                # So r//3*3+c//3 is corresponding to sub-box id as shown\\n                                                             ----- ----- -----\\n                boxId = r//3*3+c//3                         |  0  |  1  |  2  |\\n                if cur in subBox[boxId]:                     ----- ----- -----\\n                    return False                            |  3  |  4  |  5  |\\n                subBox[boxId].add(cur)                       ----- ----- -----\\n                                                            |  6  |  7  |  8  |\\n                                                             ----- ----- -----\\n        # We passed all the tests, return True\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840529,
                "title": "python-c-java-o-logn-space-and-other-approaches-bonus-one-liner-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nHere, I provide several approaches to check for a valid sudoku game. The best of them has **O(m\\\\*n)** time compleixty and **O(logN)** space complexity.\\n****\\n\\n**Comment.** There are numerous approaches on how to tackle this problem, however, they all differ in the amount of memoization done. The typical solutions employ:\\n1. Bit manipulation to reduce memory requirements to just one number. \\n2. Memoizing into a hashset until a collision happens.\\n3. Memoizing into a list, then making a set and comparing its size to the size of the original list.\\n\\n**Python #1.** An **O(logN)**-space solution using *zip* to transpose, a generator to yield blocks and bit memoization to check for unique digits.\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # a function to check rows, columns and blocks using O(logN) space\\n        def not_valid(digits, m=0):\\n            return any( 1 & (m >> int(d)) + (m := (m | (1 << int(d))))*0\\n                        for d in digits if d != \".\")\\n                       \\n        # a generator to extract blocks\\n        def blocks():\\n            for i in range(3):\\n                for j in range(3):\\n                    yield (n for row in board[i*3:(i+1)*3] for n in row[j*3:(j+1)*3])\\n        \\n        if any(map(not_valid, board))       : return False       # [1] test rows\\n        if any(map(not_valid, zip(*board))) : return False       # [2] test columns\\n        if any(map(not_valid, blocks()))    : return False       # [3] test blocks\\n        \\n        return True\\n```\\nThe one-liner to check digits can be expanded as follows:\\n```\\ndef not_valid(digits, m=0):\\n\\tfor d in digits:\\n\\t\\tif d != \".\":\\n\\t\\t\\tif (1 & (m >> int(d))) == 1 : return True\\n\\t\\t\\tm |= (1 << int(d))\\n\\treturn False\\n```\\n\\nIf you\\'re not comfortable with it, you can use the standard `len(set(list)) != len(list)` technique that is linear in allocated space:\\n```\\ndef not_valid(digits):\\n\\treturn len(set(s:= [d for d in digits if d != \".\"])) != len(s)\\n```\\n\\n**Python #2.** Here, we use smart memoization where for rows, columns and blocks, different types of memoization elements are being constructed. This prevents interference between them when using `len(set(list)) == len(list)` approach.\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        seen = []\\n        \\n        for i, row in enumerate(board):\\n            for j, d in enumerate(row):\\n                if  d != \".\":\\n                    seen.extend([(d,i), (j,d), (d,i//3,j//3)])    # these tuples never interfere!\\n        \\n        return len(set(seen)) == len(seen)\\n```\\n\\n**Python #3.** Easy ranges with *numpy*.\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        board = np.array(board)\\n        \\n        def not_valid(digits):\\n            s = \"\".join(digits).replace(\".\", \"\")\\n            return len(s) != len(set(s))\\n        \\n        for k in range(9):\\n            r, c = board[k,:], board[:,k]\\n            i, j = 3*(k//3), 3*(k%3)\\n            b    = board[i:i+3,j:j+3].flatten()\\n            if any(map(not_valid, (r,c,b))) : return False\\n        \\n        return True\\n```\\n\\nSolutions in other languages.\\n\\n<iframe src=\"https://leetcode.com/playground/Jjxoh3cu/shared\" frameBorder=\"0\" width=\"800\" height=\"380\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python.** Finally, it\\'s one-liner time! The solution #2 can be compactified as follows.\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        return len(seen := sum(([(d,i),(j,d),(d,i//3,j//3)]\\n                                if  d != \".\" else []\\n                                for i, row in enumerate(board)\\n                                for j, d   in enumerate(row)),[])) == len(set(seen))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # a function to check rows, columns and blocks using O(logN) space\\n        def not_valid(digits, m=0):\\n            return any( 1 & (m >> int(d)) + (m := (m | (1 << int(d))))*0\\n                        for d in digits if d != \".\")\\n                       \\n        # a generator to extract blocks\\n        def blocks():\\n            for i in range(3):\\n                for j in range(3):\\n                    yield (n for row in board[i*3:(i+1)*3] for n in row[j*3:(j+1)*3])\\n        \\n        if any(map(not_valid, board))       : return False       # [1] test rows\\n        if any(map(not_valid, zip(*board))) : return False       # [2] test columns\\n        if any(map(not_valid, blocks()))    : return False       # [3] test blocks\\n        \\n        return True\\n```\n```\\ndef not_valid(digits, m=0):\\n\\tfor d in digits:\\n\\t\\tif d != \".\":\\n\\t\\t\\tif (1 & (m >> int(d))) == 1 : return True\\n\\t\\t\\tm |= (1 << int(d))\\n\\treturn False\\n```\n```\\ndef not_valid(digits):\\n\\treturn len(set(s:= [d for d in digits if d != \".\"])) != len(s)\\n```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        seen = []\\n        \\n        for i, row in enumerate(board):\\n            for j, d in enumerate(row):\\n                if  d != \".\":\\n                    seen.extend([(d,i), (j,d), (d,i//3,j//3)])    # these tuples never interfere!\\n        \\n        return len(set(seen)) == len(seen)\\n```\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        board = np.array(board)\\n        \\n        def not_valid(digits):\\n            s = \"\".join(digits).replace(\".\", \"\")\\n            return len(s) != len(set(s))\\n        \\n        for k in range(9):\\n            r, c = board[k,:], board[:,k]\\n            i, j = 3*(k//3), 3*(k%3)\\n            b    = board[i:i+3,j:j+3].flatten()\\n            if any(map(not_valid, (r,c,b))) : return False\\n        \\n        return True\\n```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        return len(seen := sum(([(d,i),(j,d),(d,i//3,j//3)]\\n                                if  d != \".\" else []\\n                                for i, row in enumerate(board)\\n                                for j, d   in enumerate(row)),[])) == len(set(seen))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794580,
                "title": "solution-very-detailed-explanation-in-c-please-upvote-if-you-like",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\nThis problem looks intimidating in the first glance but we just need to split our solution into three parts:\\n1. Check if the sudoku board fulfils the row requirement that \"Each row must contain the digits 1-9 without repetition.\"\\n\\n2. Check if it fulfils column requirement that \"Each column must contain the digits 1-9 without repetition.\"\\n\\n3. Check if it has the right subbox such that \"Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\"\\n\\nIf you scroll down to the bottom, \"Constraints\" section, you\\'ll find that board[i][j] must be a digit from 1 to 9. So all we need to check is if there is any repitition in row, column, and subbox. To support quick lookups, we can use hashmap, unordered_set specifically. \\n\\nA note is that I used two unordered_sets: check_row, check_col in my solution. However, you can just use one, which means that you reuse the unordered_set after part 1 by clearing its content and reusing it for part 2. \\n\\nTime complexity is O(1) because the nested for loops will run 81 (9 * 9) times. Space complexity is O(n). \\n\\nSince I\\'m a beginner, I\\'m still looking for ways to improve the time and memory efficiency of my solution, but I\\'m sure it\\'s an understandable, though not perfect, solution. \\n*/\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    // 1. Check row quality\\n    for (int row = 0; row < 9; row++){\\n        unordered_set<char> check_row;\\n        for (int col = 0; col < 9; col++){\\n            if (board[row][col] != \\'.\\' && check_row.find(board[row][col]) != check_row.end()){\\n                return false;\\n            }\\n            check_row.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 2. Check column quality\\n    for (int col = 0; col < 9; col++){\\n        unordered_set<char> check_col;\\n        for (int row = 0; row < 9; row++){\\n            if (board[row][col] != \\'.\\' && check_col.find(board[row][col]) != check_col.end()){\\n                return false;\\n            }\\n            check_col.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 3. Check 3*3 sub-boxes\\n    /*\\n    Idea here is that we can break the Sudoku board into 9 subboxes, numbered 0, 1, 2, ..., 8, and these box numbers correspond to the index in the vector \"check_subbox.\"\\n\\n    Then, we need to find a way to determine which subbox an element should go based on its row and col number. We can use a formula: int location = (row/3) * 3 + col/3. This way, we can put the element into the desire box. One example is coordinate [8, 8]. It should be put into the last subbox (subbox 8). By this formula, it should go to (8/3) * 3 + 8/3 = 2*3 + 2 = 8. You can take other examples to verify but that\\'s pretty much the logics. \\n    */\\n    vector<unordered_set<char>> check_subbox(9);\\n    for (int row = 0; row < 9; row++){\\n        for (int col = 0; col < 9; col++){\\n            int loc = (row / 3) * 3 + col / 3;\\n            if (board[row][col] != \\'.\\' && check_subbox[loc].find(board[row][col]) != check_subbox[loc].end()){\\n                return false;\\n            }\\n            check_subbox[loc].insert(board[row][col]);\\n        }\\n    }\\n    return true;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\nThis problem looks intimidating in the first glance but we just need to split our solution into three parts:\\n1. Check if the sudoku board fulfils the row requirement that \"Each row must contain the digits 1-9 without repetition.\"\\n\\n2. Check if it fulfils column requirement that \"Each column must contain the digits 1-9 without repetition.\"\\n\\n3. Check if it has the right subbox such that \"Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\"\\n\\nIf you scroll down to the bottom, \"Constraints\" section, you\\'ll find that board[i][j] must be a digit from 1 to 9. So all we need to check is if there is any repitition in row, column, and subbox. To support quick lookups, we can use hashmap, unordered_set specifically. \\n\\nA note is that I used two unordered_sets: check_row, check_col in my solution. However, you can just use one, which means that you reuse the unordered_set after part 1 by clearing its content and reusing it for part 2. \\n\\nTime complexity is O(1) because the nested for loops will run 81 (9 * 9) times. Space complexity is O(n). \\n\\nSince I\\'m a beginner, I\\'m still looking for ways to improve the time and memory efficiency of my solution, but I\\'m sure it\\'s an understandable, though not perfect, solution. \\n*/\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    // 1. Check row quality\\n    for (int row = 0; row < 9; row++){\\n        unordered_set<char> check_row;\\n        for (int col = 0; col < 9; col++){\\n            if (board[row][col] != \\'.\\' && check_row.find(board[row][col]) != check_row.end()){\\n                return false;\\n            }\\n            check_row.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 2. Check column quality\\n    for (int col = 0; col < 9; col++){\\n        unordered_set<char> check_col;\\n        for (int row = 0; row < 9; row++){\\n            if (board[row][col] != \\'.\\' && check_col.find(board[row][col]) != check_col.end()){\\n                return false;\\n            }\\n            check_col.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 3. Check 3*3 sub-boxes\\n    /*\\n    Idea here is that we can break the Sudoku board into 9 subboxes, numbered 0, 1, 2, ..., 8, and these box numbers correspond to the index in the vector \"check_subbox.\"\\n\\n    Then, we need to find a way to determine which subbox an element should go based on its row and col number. We can use a formula: int location = (row/3) * 3 + col/3. This way, we can put the element into the desire box. One example is coordinate [8, 8]. It should be put into the last subbox (subbox 8). By this formula, it should go to (8/3) * 3 + 8/3 = 2*3 + 2 = 8. You can take other examples to verify but that\\'s pretty much the logics. \\n    */\\n    vector<unordered_set<char>> check_subbox(9);\\n    for (int row = 0; row < 9; row++){\\n        for (int col = 0; col < 9; col++){\\n            int loc = (row / 3) * 3 + col / 3;\\n            if (board[row][col] != \\'.\\' && check_subbox[loc].find(board[row][col]) != check_subbox[loc].end()){\\n                return false;\\n            }\\n            check_subbox[loc].insert(board[row][col]);\\n        }\\n    }\\n    return true;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841310,
                "title": "c-use-hashmap-easy-efficient-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    \\n    bool isValidSudoku(vector<vector<char> > &board)\\n    {\\n\\t\\t//Hashmap for checking repeated number(from 1 to 9) in each row (9 rows), column (9 cols) and grid (9 grids)\\n        int row[9][9] = {0}, col[9][9] = {0}, grid_3x3[9][9] = {0}; \\n        \\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[i].size(); j++)\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'1\\', k = i/3*3+j/3; //k for finding grid index from 0 to 8\\n                    if(row[i][num] || col[j][num] || grid_3x3[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = grid_3x3[k][num] = 1;\\n                }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    \\n    bool isValidSudoku(vector<vector<char> > &board)\\n    {\\n\\t\\t//Hashmap for checking repeated number(from 1 to 9) in each row (9 rows), column (9 cols) and grid (9 grids)\\n        int row[9][9] = {0}, col[9][9] = {0}, grid_3x3[9][9] = {0}; \\n        \\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[i].size(); j++)\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'1\\', k = i/3*3+j/3; //k for finding grid index from 0 to 8\\n                    if(row[i][num] || col[j][num] || grid_3x3[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = grid_3x3[k][num] = 1;\\n                }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15643,
                "title": "simple-clear-java-solution",
                "content": "    public class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            \\n           boolean[][] row = new boolean[9][9];\\n           boolean[][] column = new boolean[9][9];\\n           boolean[][] block = new boolean[9][9];\\n           \\n           for(int i = 0;i<9;i++){\\n               for(int j=0;j<9;j++){\\n                    int c = board[i][j] - '1';       \\n                    if(board[i][j]=='.'){\\n                        continue;\\n                    }\\n                    if(row[i][c]||column[j][c]||block[i - i % 3 + j / 3][c]){\\n                        return false;\\n                    }\\n                    row[i][c] = column[j][c] = block[i - i % 3 + j / 3][c] = true;\\n               }\\n           }\\n           return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            \\n           boolean[][] row = new boolean[9][9];\\n           boolean[][] column = new boolean[9][9];\\n           boolean[][] block = new boolean[9][9];\\n           \\n           for(int i = 0;i<9;i++){\\n               for(int j=0;j<9;j++){\\n                    int c = board[i][j] - '1';       \\n                    if(board[i][j]=='.'){\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 511365,
                "title": "simple-intuitive-python-approach",
                "content": "![image](https://assets.leetcode.com/users/tohbaino/image_1581904292.png)\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        rows = [set() for i in range(9)]\\n        cols = [set() for i in range(9)]\\n        mMat = [set() for i in range(9)]\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                cur = board[i][j]\\n                if cur != \\'.\\':\\n                    \\n                    k = (i // 3 ) * 3 + j // 3\\n                \\n                    if cur not in rows[i]: rows[i].add(cur)\\n                    else: return False\\n                    \\n                    if cur not in cols[j]: cols[j].add(cur)\\n                    else: return False\\n                \\n                    if cur not in mMat[k]: mMat[k].add(cur)\\n                    else: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        rows = [set() for i in range(9)]\\n        cols = [set() for i in range(9)]\\n        mMat = [set() for i in range(9)]\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                cur = board[i][j]\\n                if cur != \\'.\\':\\n                    \\n                    k = (i // 3 ) * 3 + j // 3\\n                \\n                    if cur not in rows[i]: rows[i].add(cur)\\n                    else: return False\\n                    \\n                    if cur not in cols[j]: cols[j].add(cur)\\n                    else: return False\\n                \\n                    if cur not in mMat[k]: mMat[k].add(cur)\\n                    else: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15642,
                "title": "share-my-c-solution",
                "content": "    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char,int> row[9],col[9],blk[9];\\n        char c;\\n        for(int i = 0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                c = board[i][j];\\n                if((c!='.')&&(0<row[i][c]++ || 0<col[j][c]++ || 0<blk[i/3*3+j/3][c]++)) return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char,int> row[9],col[9],blk[9];\\n        char c;\\n        for(int i = 0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                c = board[i][j];\\n                if((c!='.')&&(0<row[i][c]++ || 0<col[j][c]++ || 0<blk[i/3*3+j/3][c]++)) return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 160227,
                "title": "python-solution",
                "content": "Time complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        dic_list1 = [set() for _ in range(9)]\\n        dic_list2 = [set() for _ in range(9)]\\n        dic_list3 = [[set() for _ in range(3)] for _ in range(3)]\\n        for i in range(9):\\n            for j in range(9):\\n                if not board[i][j].isnumeric():\\n                    continue\\n                y = i // 3\\n                x = j // 3\\n                num = board[i][j]\\n                if (num in dic_list1[i]) or (num in dic_list2[j]) or (num in dic_list3[x][y]):\\n                    return False\\n                else:\\n                    dic_list1[i].add(num)\\n                    dic_list2[j].add(num)\\n                    dic_list3[x][y].add(num)\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        dic_list1 = [set() for _ in range(9)]\\n        dic_list2 = [set() for _ in range(9)]\\n        dic_list3 = [[set() for _ in range(3)] for _ in range(3)]\\n        for i in range(9):\\n            for j in range(9):\\n                if not board[i][j].isnumeric():\\n                    continue\\n                y = i // 3\\n                x = j // 3\\n                num = board[i][j]\\n                if (num in dic_list1[i]) or (num in dic_list2[j]) or (num in dic_list3[x][y]):\\n                    return False\\n                else:\\n                    dic_list1[i].add(num)\\n                    dic_list2[j].add(num)\\n                    dic_list3[x][y].add(num)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156618,
                "title": "javascript-using-arrays-of-hash-maps-beats-99-54",
                "content": "My solution is relatively straight-forward (an explanation for the value of `k` is explained below in the comments).\\n\\n```javascript\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {    \\n    const boxes = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\\n    const cols = [{}, {}, {}, {}, {}, {}, {}, {}, {}]; \\n    const rows = [{}, {}, {}, {}, {}, {}, {}, {}, {}];   \\n    \\n    for (let i = 0; i < 9; i++) {              \\n        for (let j = 0; j < 9; j++) {            \\n            const digit = board[i][j];\\n            \\n            if (digit !== \\'.\\') {\\n                const k = Math.floor(j / 3) + (Math.floor(i / 3) * 3);\\n\\n                if (boxes[k][digit] || cols[j][digit] || rows[i][digit]) {\\n                    return false;\\n                }\\n\\n                boxes[k][digit] = cols[j][digit] = rows[i][digit] = true;       \\n            }\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {    \\n    const boxes = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\\n    const cols = [{}, {}, {}, {}, {}, {}, {}, {}, {}]; \\n    const rows = [{}, {}, {}, {}, {}, {}, {}, {}, {}];   \\n    \\n    for (let i = 0; i < 9; i++) {              \\n        for (let j = 0; j < 9; j++) {            \\n            const digit = board[i][j];\\n            \\n            if (digit !== \\'.\\') {\\n                const k = Math.floor(j / 3) + (Math.floor(i / 3) * 3);\\n\\n                if (boxes[k][digit] || cols[j][digit] || rows[i][digit]) {\\n                    return false;\\n                }\\n\\n                boxes[k][digit] = cols[j][digit] = rows[i][digit] = true;       \\n            }\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055145,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][9]={0};\\n\\tint cols[9][9]={0};\\n\\tint blocks[3][3][9]={0};\\n\\tfor(int r=0;r<9;r++)\\n\\t\\tfor(int c=0;c<9;c++)\\n\\t\\t\\tif(board[r][c]!=\\'.\\'){\\n\\t\\t\\t\\tint number=board[r][c]-\\'1\\';\\n\\t\\t\\t\\tif(rows[r][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(cols[c][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(blocks[r/3][c/3][number]++)\\n                 return 0;\\n\\t\\t\\t}\\n\\treturn 1;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][9]={0};\\n\\tint cols[9][9]={0};\\n\\tint blocks[3][3][9]={0};\\n\\tfor(int r=0;r<9;r++)\\n\\t\\tfor(int c=0;c<9;c++)\\n\\t\\t\\tif(board[r][c]!=\\'.\\'){\\n\\t\\t\\t\\tint number=board[r][c]-\\'1\\';\\n\\t\\t\\t\\tif(rows[r][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(cols[c][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(blocks[r/3][c/3][number]++)\\n                 return 0;\\n\\t\\t\\t}\\n\\treturn 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513191,
                "title": "java-tc-o-9-9-sc-o-1-most-optimized-solution-using-bit-manipulation",
                "content": "```java\\n/**\\n * Most Optimized solution using Bit Manipulation\\n * \\n * Using only one int to store the bits for Row, Column and Box.\\n *\\n * This Solution uses True O(1) space and requires True O(N^2) time.\\n *\\n * Bit 0 -> 8 will represent ith Row\\n * Bit 9 -> 17 will represent ith Column\\n * Bit 18 -> 26 will represent ith Box\\n *\\n * Time Complexity: O(9*9)\\n *\\n * Space Complexity: O(1). Using only one integer.\\n */\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        if (board == null || board.length != 9 || board[0].length != 9) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int rowColBox = 0;\\n\\n        for (int i = 0; i < 9; i++) { // Index of row, column and box\\n            for (int j = 0; j < 9; j++) {\\n                // Check ith row\\n                rowColBox = validateAndAddCell(board[i][j], 0, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith column\\n                rowColBox = validateAndAddCell(board[j][i], 1, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith box\\n                int boxRow = 3 * (i / 3) + (j / 3);\\n                int colRow = 3 * (i % 3) + (j % 3);\\n                rowColBox = validateAndAddCell(board[boxRow][colRow], 2, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n            }\\n            rowColBox = 0;\\n        }\\n\\n        return true;\\n    }\\n\\n    private int validateAndAddCell(char c, int type, int rowColBox) {\\n        if (c == \\'.\\') {\\n            return rowColBox;\\n        }\\n        if (c < \\'1\\' || c > \\'9\\') {\\n            return -1;\\n        }\\n\\n        int bitIdx = type * 9 + (c - \\'1\\');\\n        if (((rowColBox >> bitIdx) & 1) == 1) {\\n            return -1;\\n        }\\n\\n        return rowColBox | (1 << bitIdx);\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Sudoku question on LeetCode:\\n- [37. Sudoku Solver](https://leetcode.com/problems/sudoku-solver/discuss/1513192/Java-or-TC:-O(9N)-or-SC:-O(N)-or-Most-Optimized-Backtracking-solution-using-Bit-Manipulation)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Most Optimized solution using Bit Manipulation\\n * \\n * Using only one int to store the bits for Row, Column and Box.\\n *\\n * This Solution uses True O(1) space and requires True O(N^2) time.\\n *\\n * Bit 0 -> 8 will represent ith Row\\n * Bit 9 -> 17 will represent ith Column\\n * Bit 18 -> 26 will represent ith Box\\n *\\n * Time Complexity: O(9*9)\\n *\\n * Space Complexity: O(1). Using only one integer.\\n */\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        if (board == null || board.length != 9 || board[0].length != 9) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int rowColBox = 0;\\n\\n        for (int i = 0; i < 9; i++) { // Index of row, column and box\\n            for (int j = 0; j < 9; j++) {\\n                // Check ith row\\n                rowColBox = validateAndAddCell(board[i][j], 0, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith column\\n                rowColBox = validateAndAddCell(board[j][i], 1, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith box\\n                int boxRow = 3 * (i / 3) + (j / 3);\\n                int colRow = 3 * (i % 3) + (j % 3);\\n                rowColBox = validateAndAddCell(board[boxRow][colRow], 2, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n            }\\n            rowColBox = 0;\\n        }\\n\\n        return true;\\n    }\\n\\n    private int validateAndAddCell(char c, int type, int rowColBox) {\\n        if (c == \\'.\\') {\\n            return rowColBox;\\n        }\\n        if (c < \\'1\\' || c > \\'9\\') {\\n            return -1;\\n        }\\n\\n        int bitIdx = type * 9 + (c - \\'1\\');\\n        if (((rowColBox >> bitIdx) & 1) == 1) {\\n            return -1;\\n        }\\n\\n        return rowColBox | (1 << bitIdx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653359,
                "title": "solution-swift-valid-sudoku-test-cases",
                "content": "```swift\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in board.indices {\\n            let rows = board[i].filter { $0 != \".\" }\\n            let cols = board.map{ $0[i] }.filter { $0 != \".\" }\\n            let n = (a: 3 * (i / 3), b: 3 * (i % 3))\\n            let blks = board[n.a ..< n.a + 3].flatMap{$0[n.b ..< n.b + 3]}.filter{$0 != \".\"}\\n            if rows.count != Set(rows).count ||\\n                cols.count != Set(cols).count ||\\n                blks.count != Set(blks).count { return false }\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.076 (0.078) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isValidSudoku([[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, true)\\n    }\\n    func test1() {\\n        let value = solution.isValidSudoku([[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in board.indices {\\n            let rows = board[i].filter { $0 != \".\" }\\n            let cols = board.map{ $0[i] }.filter { $0 != \".\" }\\n            let n = (a: 3 * (i / 3), b: 3 * (i % 3))\\n            let blks = board[n.a ..< n.a + 3].flatMap{$0[n.b ..< n.b + 3]}.filter{$0 != \".\"}\\n            if rows.count != Set(rows).count ||\\n                cols.count != Set(cols).count ||\\n                blks.count != Set(blks).count { return false }\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isValidSudoku([[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, true)\\n    }\\n    func test1() {\\n        let value = solution.isValidSudoku([[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237662,
                "title": "easiest-java-100-faster-98-2-less-memory",
                "content": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(!isValid(board,i,j,board[i][j]))\\n                        return false;\\n                }\\n            }\\n         }\\n        return true;\\n    }\\n    \\n    public boolean isValid(char[][] board, int row, int col, char num){\\n        \\n        //for row checking\\n        for(int i=col+1;i<9;i++){\\n            if(board[row][i] == num)\\n                return false;\\n        }\\n        \\n        //For col checking\\n        for(int i=row+1;i<9;i++){\\n            if(board[i][col] == num)\\n                return false;\\n        }\\n        \\n        //for internal square\\n        int x = row - row%3, y = col-col%3;\\n        for(int i=x; i<x+3; i++){\\n            for(int j=y; j<y+3; j++){\\n                if(board[i][j]==num && !(i==row && j==col))\\n                    return false;\\n            }\\n        }   \\n        return true;\\n    }   \\n}\\n\\n\\n\\nPlease upvote if you find it easy and simple to understand\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(!isValid(board,i,j,board[i][j]))\\n                        return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 780278,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    let seen = new Set();\\n    for(let i = 0; i < 9; i++) {\\n      for(let j = 0; j < 9; j++) {\\n        let cell = board[i][j];\\n        if(cell != \\'.\\') {\\n            let colCell = `cell: ${j} ${cell}`;\\n            let rowCell = `row: ${i} ${cell}`;\\n            let subBoxCell = `subBox: ${parseInt(i/3)}-${parseInt(j/3)} ${cell}`;\\n        \\n            if(!seen.has(colCell) && !seen.has(rowCell) && !seen.has(subBoxCell)) {\\n                seen.add(colCell);\\n                seen.add(rowCell);\\n                seen.add(subBoxCell);\\n            }\\n            else \\n                return false;\\n          }\\n      }\\n    }\\n    return true;\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    let seen = new Set();\\n    for(let i = 0; i < 9; i++) {\\n      for(let j = 0; j < 9; j++) {\\n        let cell = board[i][j];\\n        if(cell != \\'.\\') {\\n            let colCell = `cell: ${j} ${cell}`;\\n            let rowCell = `row: ${i} ${cell}`;\\n            let subBoxCell = `subBox: ${parseInt(i/3)}-${parseInt(j/3)} ${cell}`;\\n        \\n            if(!seen.has(colCell) && !seen.has(rowCell) && !seen.has(subBoxCell)) {\\n                seen.add(colCell);\\n                seen.add(rowCell);\\n                seen.add(subBoxCell);\\n            }\\n            else \\n                return false;\\n          }\\n      }\\n    }\\n    return true;\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124036,
                "title": "readable-javascript-solution-w-comments",
                "content": "Didn\\'t come up with this, but I think I made it a bit more readable.\\n\\nInspired by:\\n1. https://leetcode.com/problems/valid-sudoku/discuss/15527/Simple-JavaScript-One-Pass-Solution \\n2. https://leetcode.com/problems/valid-sudoku/discuss/121921/javascript \\n\\n```\\nvar isValidSudoku = function(board) {\\n  // create an empty set for each row/col/square\\n  const rowRules = new Array(9).fill().map(() => new Set())\\n  const colRules = new Array(9).fill().map(() => new Set())\\n  const mixedRules = new Array(9).fill().map(() => new Set())\\n  \\n  // iterate through each cell on the board\\n  for (let row = 0; row < 9; row++) {\\n    for (let col = 0; col < 9; col++) {\\n      const curr = board[row][col]\\n      \\n      // some tricky math to get the index of the 3x3 squares\\n      const mixedIdx = Math.floor(row / 3) * 3 + Math.floor(col / 3)\\n\\n      if (curr === \".\") continue  // ignore dots\\n      \\n      // if the current number already exists in the set, board is invalid\\n      const a = rowRules[row].has(curr)\\n      const b = colRules[col].has(curr)\\n      const c = mixedRules[mixedIdx].has(curr)\\n      if (a || b || c) return false\\n      \\n      // add the number to the appropriate set\\n      rowRules[row].add(curr)\\n      colRules[col].add(curr)\\n      mixedRules[mixedIdx].add(curr)\\n    }\\n  }\\n  \\n  // all checks out\\n  return true\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  // create an empty set for each row/col/square\\n  const rowRules = new Array(9).fill().map(() => new Set())\\n  const colRules = new Array(9).fill().map(() => new Set())\\n  const mixedRules = new Array(9).fill().map(() => new Set())\\n  \\n  // iterate through each cell on the board\\n  for (let row = 0; row < 9; row++) {\\n    for (let col = 0; col < 9; col++) {\\n      const curr = board[row][col]\\n      \\n      // some tricky math to get the index of the 3x3 squares\\n      const mixedIdx = Math.floor(row / 3) * 3 + Math.floor(col / 3)\\n\\n      if (curr === \".\") continue  // ignore dots\\n      \\n      // if the current number already exists in the set, board is invalid\\n      const a = rowRules[row].has(curr)\\n      const b = colRules[col].has(curr)\\n      const c = mixedRules[mixedIdx].has(curr)\\n      if (a || b || c) return false\\n      \\n      // add the number to the appropriate set\\n      rowRules[row].add(curr)\\n      colRules[col].add(curr)\\n      mixedRules[mixedIdx].add(curr)\\n    }\\n  }\\n  \\n  // all checks out\\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3194965,
                "title": "python-clean-simple-faster-than-96-in-runtime",
                "content": "To solve this problem we have to check if each value in sudoku does not repeat in its:\\n\\n1. Row\\n1. Column\\n1. Block\\n\\n# Complexity\\n- Time complexity: $$O(n*n)$$ \\n    where n is fiexed here.\\n    so, Time Complexity will be O(81) ==> O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for _ in range(9)]\\n        cols = [set() for _ in range(9)]\\n        block = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                curr = board[i][j]\\n                if curr == \\'.\\':\\n                    continue\\n                if (curr in rows[i]) or (curr in cols[j]) or (curr in block[i // 3][j // 3]):\\n                    return False\\n                rows[i].add(curr)\\n                cols[j].add(curr)\\n                block[i // 3][j // 3].add(curr)\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for _ in range(9)]\\n        cols = [set() for _ in range(9)]\\n        block = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                curr = board[i][j]\\n                if curr == \\'.\\':\\n                    continue\\n                if (curr in rows[i]) or (curr in cols[j]) or (curr in block[i // 3][j // 3]):\\n                    return False\\n                rows[i].add(curr)\\n                cols[j].add(curr)\\n                block[i // 3][j // 3].add(curr)\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15617,
                "title": "java-solution-easy-to-understand",
                "content": "    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] block = new boolean[9][9];\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == '.') {\\n                    continue;\\n                }\\n                int digit = board[i][j] - '1';\\n                int blockId = i / 3 * 3 + j / 3;\\n                if (col[j][digit]) {\\n                    return false;\\n                } else {\\n                    col[j][digit] = true;\\n                }\\n                if (row[i][digit]) {\\n                    return false;\\n                } else {\\n                    row[i][digit] = true;\\n                }\\n                if (block[blockId][digit]) {\\n                    return false;\\n                } else {\\n                    block[blockId][digit] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] block = new boolean[9][9];\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == '.') {\\n                    continue;\\n                }\\n                int digit = board[i][j] - '1';\\n                int blockId = i / 3 * 3 + j / 3;\\n                if (col[j][digit]) {\\n                    return false;\\n                } else {\\n                    col[j][digit] = true;\\n                }\\n                if (row[i][digit]) {\\n                    return false;\\n                } else {\\n                    row[i][digit] = true;\\n                }\\n                if (block[blockId][digit]) {\\n                    return false;\\n                } else {\\n                    block[blockId][digit] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 936699,
                "title": "c-easiest-to-understand-hashset",
                "content": "Sharing my Very Readable C++ Solution:\\n\\n```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n\\tvector<unordered_set<int>> rows(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> columns(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> boxes(9, unordered_set<int>());\\n\\n\\tfor (int i = 0; i < 9; ++i) {\\n\\t  for (int j = 0; j < 9; ++j) {\\n\\t\\tif (board[i][j] == \\'.\\')\\n\\t\\t  continue;\\n\\n\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\tif (rows[i].count(num))\\n\\t\\t  return false;\\n\\n\\t\\tif (columns[j].count(num))\\n\\t\\t  return false;\\n\\n\\t\\t// This is a straight-forward math formula to locate a box\\n\\t\\t// Out of the 9 boxes\\n\\t\\tint box_index = (i / 3) * 3 + j / 3;\\n\\n\\t\\tif (boxes[box_index].count(num))\\n\\t\\t  return false;\\n\\n\\t\\trows[i].insert(num);\\n\\t\\tcolumns[j].insert(num);\\n\\t\\tboxes[box_index].insert(num);\\n\\t  }\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n\\tvector<unordered_set<int>> rows(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> columns(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> boxes(9, unordered_set<int>());\\n\\n\\tfor (int i = 0; i < 9; ++i) {\\n\\t  for (int j = 0; j < 9; ++j) {\\n\\t\\tif (board[i][j] == \\'.\\')\\n\\t\\t  continue;\\n\\n\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\tif (rows[i].count(num))\\n\\t\\t  return false;\\n\\n\\t\\tif (columns[j].count(num))\\n\\t\\t  return false;\\n\\n\\t\\t// This is a straight-forward math formula to locate a box\\n\\t\\t// Out of the 9 boxes\\n\\t\\tint box_index = (i / 3) * 3 + j / 3;\\n\\n\\t\\tif (boxes[box_index].count(num))\\n\\t\\t  return false;\\n\\n\\t\\trows[i].insert(num);\\n\\t\\tcolumns[j].insert(num);\\n\\t\\tboxes[box_index].insert(num);\\n\\t  }\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2134346,
                "title": "c-fast-easy-short-commented-code-8-lines-of-code",
                "content": "# Here we will run two for loops, one for rows and one for columns,\\n# If the element in the board is a number from 1 to 9 then we will check their presence---->\\n* ***IN THAT ROW :***   by using a row checker 2d array\\n* ***IN THE COLUMN :*** by using a column checker 2d array\\n* ***IN THAT BOX :*** by using the formula  **(row/3)3+(col/3)** \\uD83D\\uDE0E\\n\\n```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n        int checkrow[10][10]={0},checkcol[10][10]={0},checkbox[10][10]={0};       //declaring three check arrays with initially zero values.\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col]==\\'.\\')continue;         //if not a number we need to skip to the next index.\\n                int num=board[row][col]-\\'0\\';                //as \\'char\\' is given we make it int.\\n                int box=(row/3)*3+(col/3);                 //applying formula\\n                if(checkrow[row][num] || checkcol[num][col] || checkbox[box][num])       //if any of the checker gives true then the number is already present in that row/col/box.\\n                    return false;\\n                checkrow[row][num]=checkcol[num][col]=checkbox[box][num]=true;       //after checking we set the values true\\n            }\\n        }\\n        return true;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/d9d71f90-6afb-45c0-8a51-f7af505db1da_1654853094.572027.png)\\n\\n\\uD83D\\uDE0E\\uD83D\\uDE4C HAPPY CODING !! \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n        int checkrow[10][10]={0},checkcol[10][10]={0},checkbox[10][10]={0};       //declaring three check arrays with initially zero values.\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col]==\\'.\\')continue;         //if not a number we need to skip to the next index.\\n                int num=board[row][col]-\\'0\\';                //as \\'char\\' is given we make it int.\\n                int box=(row/3)*3+(col/3);                 //applying formula\\n                if(checkrow[row][num] || checkcol[num][col] || checkbox[box][num])       //if any of the checker gives true then the number is already present in that row/col/box.\\n                    return false;\\n                checkrow[row][num]=checkcol[num][col]=checkbox[box][num]=true;       //after checking we set the values true\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647166,
                "title": "javascript",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  \\n    const set = new Set()\\n    \\n    \\n    //i rows, j columns\\n    //check valid columns and rows O(9*9)\\n    for(let i = 0; i < board.length; i++){\\n        for(let j = 0; j < board[0].length; j++){\\n            const value = board[i][j]\\n            if(value !== \".\"){\\n                const rowString = `${value} at row ${i}`\\n                const colString = `${value} at col ${j}`\\n                const boxString = `${value} at box ${Math.floor(i/3)}, ${Math.floor(j/3)}`\\n                \\n                if(set.has(rowString) || set.has(colString) || set.has(boxString)){\\n                    return false\\n                }else{\\n                    set.add(rowString)\\n                    set.add(colString)\\n                    set.add(boxString)\\n                }\\n            }\\n        }\\n    }\\n\\n    return true\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  \\n    const set = new Set()\\n    \\n    \\n    //i rows, j columns\\n    //check valid columns and rows O(9*9)\\n    for(let i = 0; i < board.length; i++){\\n        for(let j = 0; j < board[0].length; j++){\\n            const value = board[i][j]\\n            if(value !== \".\"){\\n                const rowString = `${value} at row ${i}`\\n                const colString = `${value} at col ${j}`\\n                const boxString = `${value} at box ${Math.floor(i/3)}, ${Math.floor(j/3)}`\\n                \\n                if(set.has(rowString) || set.has(colString) || set.has(boxString)){\\n                    return false\\n                }else{\\n                    set.add(rowString)\\n                    set.add(colString)\\n                    set.add(boxString)\\n                }\\n            }\\n        }\\n    }\\n\\n    return true\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15660,
                "title": "share-my-solution-for-valid-sudoku",
                "content": "    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tboolean[][] row = new boolean[9][9];\\n\\t\\tboolean[][] col = new boolean[9][9];\\n\\t\\tboolean[][] box = new boolean[9][9];\\n\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tchar c = board[i][j];\\n\\t\\t\\t\\tif (c == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (c < '0' || c > '9')\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\tint number = c - '1';\\n\\t\\t\\t\\tif (row[i][number] || col[j][number] || box[(i / 3) * 3 + j / 3][number])\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\trow[i][number] = true;\\n\\t\\t\\t\\tcol[j][number] = true;\\n\\t\\t\\t\\tbox[(i / 3) * 3 + j / 3][number] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [],
                "code": "    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tboolean[][] row = new boolean[9][9];\\n\\t\\tboolean[][] col = new boolean[9][9];\\n\\t\\tboolean[][] box = new boolean[9][9];\\n\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tchar c = board[i][j];\\n\\t\\t\\t\\tif (c == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (c < '0' || c > '9')\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\tint number = c - '1';\\n\\t\\t\\t\\tif (row[i][number] || col[j][number] || box[(i / 3) * 3 + j / 3][number])\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\trow[i][number] = true;\\n\\t\\t\\t\\tcol[j][number] = true;\\n\\t\\t\\t\\tbox[(i / 3) * 3 + j / 3][number] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2730348,
                "title": "java-hashset-easy",
                "content": "## Don\\'t forget to upvote if you like my solution \\uD83D\\uDE07\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (set.contains(n + \"r\" + i) || set.contains(n + \"c\" + j) ||\\n                        set.contains(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                    set.add(n + \"r\" + i);\\n                    set.add(n + \"c\" + j);\\n                    set.add(n + \"b\" + i / 3 + j / 3);\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n**The same thing can be done in a shorter way:**\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (!set.add(n + \"r\" + i) || \\n                        !set.add(n + \"c\" + j) ||\\n                        !set.add(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(9 ^ 2) => O(1)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (set.contains(n + \"r\" + i) || set.contains(n + \"c\" + j) ||\\n                        set.contains(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                    set.add(n + \"r\" + i);\\n                    set.add(n + \"c\" + j);\\n                    set.add(n + \"b\" + i / 3 + j / 3);\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (!set.add(n + \"r\" + i) || \\n                        !set.add(n + \"c\" + j) ||\\n                        !set.add(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(9 ^ 2) => O(1)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251171,
                "title": "c-explained-24ms-o-n2",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // To check if it is valid,\\n    // Firstly, replace the character with a \\'.\\' so that we can check even after this it is already present or not .. \\n    //  - Check for the entire row if it already has the same character twice? Return false if it does\\n    //  - Check for the entire col if it already has the same character twice? Return false if it does\\n    //  - Check for the 3x3 box to see it already has it? Return false if it does\\n    // Replace the incorrect \\'.\\' back to the character c\\n    \\n    // NOTE: Given a row, col, if we need to find the starting i,j of that 3x3 box, then we do row/3*3 and col/3*3\\n    \\n    bool isValid(vector<vector<char>>& board, int row, int col){\\n        int c = board[row][col];\\n        board[row][col] = \\'.\\';\\n        for(int i=0;i<9;i++)\\n            if(board[row][i] == c) return false;\\n        for(int i=0;i<9;i++)\\n            if(board[i][col] == c) return false;\\n        for(int i=0;i<3;i++)\\n            for(int j=0;j<3;j++)\\n                if(board[row/3*3 + i][col/3*3 + j] == c)\\n                    return false;\\n        \\n        board[row][col] = c;\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // Go for all the rows & columns looking for an invalid number\\n        // If you find an invalid entry, return false\\n        // If you don not find an invalid entry till the end, it has to be good, return true.\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\' && !isValid(board,i,j)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // To check if it is valid,\\n    // Firstly, replace the character with a \\'.\\' so that we can check even after this it is already present or not .. \\n    //  - Check for the entire row if it already has the same character twice? Return false if it does\\n    //  - Check for the entire col if it already has the same character twice? Return false if it does\\n    //  - Check for the 3x3 box to see it already has it? Return false if it does\\n    // Replace the incorrect \\'.\\' back to the character c\\n    \\n    // NOTE: Given a row, col, if we need to find the starting i,j of that 3x3 box, then we do row/3*3 and col/3*3\\n    \\n    bool isValid(vector<vector<char>>& board, int row, int col){\\n        int c = board[row][col];\\n        board[row][col] = \\'.\\';\\n        for(int i=0;i<9;i++)\\n            if(board[row][i] == c) return false;\\n        for(int i=0;i<9;i++)\\n            if(board[i][col] == c) return false;\\n        for(int i=0;i<3;i++)\\n            for(int j=0;j<3;j++)\\n                if(board[row/3*3 + i][col/3*3 + j] == c)\\n                    return false;\\n        \\n        board[row][col] = c;\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // Go for all the rows & columns looking for an invalid number\\n        // If you find an invalid entry, return false\\n        // If you don not find an invalid entry till the end, it has to be good, return true.\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\' && !isValid(board,i,j)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266986,
                "title": "c-solution-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_map<string,int>hash;\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col] != \\'.\\')\\n                {\\n    \\n                    string r= \"row\"+to_string(row)+to_string(board[row][col]);\\n                    string c= \"col\"+to_string(col)+to_string(board[row][col]);\\n                    int b = (row/3) * 3 + (col/3);\\n                    string box= \"box\"+ to_string(b) + to_string(board[row][col]);\\n\\n                    if(hash[r] != 1 && hash[c] != 1 && hash[box] != 1){\\n                        hash[r]=1;\\n                        hash[c]=1;\\n                        hash[box]=1;\\n                    }else{\\n                        return false;\\n                    }\\n\\n                    }\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_map<string,int>hash;\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col] != \\'.\\')\\n                {\\n    \\n                    string r= \"row\"+to_string(row)+to_string(board[row][col]);\\n                    string c= \"col\"+to_string(col)+to_string(board[row][col]);\\n                    int b = (row/3) * 3 + (col/3);\\n                    string box= \"box\"+ to_string(b) + to_string(board[row][col]);\\n\\n                    if(hash[r] != 1 && hash[c] != 1 && hash[box] != 1){\\n                        hash[r]=1;\\n                        hash[c]=1;\\n                        hash[box]=1;\\n                    }else{\\n                        return false;\\n                    }\\n\\n                    }\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15613,
                "title": "share-my-java-solution",
                "content": "    public class Solution {\\n    public Set<Character> set=new HashSet<Character>();\\n    public boolean isValidSudoku(char[][] board) {\\n       for(int i=0;i<9;i++){\\n           if(validPartial(board,i,i,0,8)==false) return false;\\n           if(validPartial(board,0,8,i,i)==false) return false;\\n       } \\n       for(int i=0;i<9;i+=3){\\n           for(int j=0;j<9;j+=3){\\n               if(validPartial(board,i,i+2,j,j+2)==false) return false;\\n           }\\n       }\\n       return true;\\n    }\\n    public boolean validPartial(char[][] board,int row1,int row2,int col1,int col2){\\n        set.clear();\\n        for(int i=row1;i<=row2;i++){\\n            for(int j=col1;j<=col2;j++){\\n                if(board[i][j]!='.') {\\n                    if(!set.add(board[i][j])) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public Set<Character> set=new HashSet<Character>();\\n    public boolean isValidSudoku(char[][] board) {\\n       for(int i=0;i<9;i++){\\n           if(validPartial(board,i,i,0,8)==false) return false;\\n           if(validPartial(board,0,8,i,i)==false) return false;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2291325,
                "title": "java-best-solution-to-ever-exist",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            char number = board[i][j];\\n            if(!map.add(number + \"in row\" + i) \\n               || !map.add(number + \"in column\" + j) \\n               || !map.add(number + \"in block\" + i / 3 + \"-\" + j / 3))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF YOU LIKED IT",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            char number = board[i][j];\\n            if(!map.add(number + \"in row\" + i) \\n               || !map.add(number + \"in column\" + j) \\n               || !map.add(number + \"in block\" + i / 3 + \"-\" + j / 3))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916780,
                "title": "javascript-simple-and-fast-solution-with-comments-easy-to-remember",
                "content": "```javascript\\nvar isValidSudoku = function(board) {\\n\\n    const map = {};                            // Map for storing our key-strings.\\n    \\n    for (let i = 0; i < 9; i++) {              // Outer-loop for rows.\\n        for (let j = 0; j < 9; j++) {          // Inner-loop for cols.\\n            \\n            if (board[i][j] === \\'.\\') continue; // Skip checking empty spaces.\\n            \\n            let num = board[i][j],\\n                x   = Math.floor(i / 3),       // We can iterate through each box\\n                y   = Math.floor(j / 3);       // using indices (i, j) divided by 3.\\n                \\n\\t\\t\\tlet err = (map[\\'r\\'+i+num] ||       // Check if any of the computed\\n\\t\\t\\t\\t\\t   map[\\'c\\'+j+num] ||       // key-strings already exist in\\n\\t\\t\\t\\t\\t   map[\\'b\\'+x+y+num]);      // our map object.\\n            \\n            if (err) return false;             // If \\'err\\' is true, board is invalid.\\n            \\n            map[\\'r\\'+i+num]   = 1;              // Add \\'row\\' key-string to map.\\n            map[\\'c\\'+j+num]   = 1;              // Add \\'col\\' key-string to map.\\n            map[\\'b\\'+x+y+num] = 1;              // Add \\'box\\' key-string to map.\\n        }\\n    }\\n    \\n    return true;                               // If no error, board is valid.\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isValidSudoku = function(board) {\\n\\n    const map = {};                            // Map for storing our key-strings.\\n    \\n    for (let i = 0; i < 9; i++) {              // Outer-loop for rows.\\n        for (let j = 0; j < 9; j++) {          // Inner-loop for cols.\\n            \\n            if (board[i][j] === \\'.\\') continue; // Skip checking empty spaces.\\n            \\n            let num = board[i][j],\\n                x   = Math.floor(i / 3),       // We can iterate through each box\\n                y   = Math.floor(j / 3);       // using indices (i, j) divided by 3.\\n                \\n\\t\\t\\tlet err = (map[\\'r\\'+i+num] ||       // Check if any of the computed\\n\\t\\t\\t\\t\\t   map[\\'c\\'+j+num] ||       // key-strings already exist in\\n\\t\\t\\t\\t\\t   map[\\'b\\'+x+y+num]);      // our map object.\\n            \\n            if (err) return false;             // If \\'err\\' is true, board is invalid.\\n            \\n            map[\\'r\\'+i+num]   = 1;              // Add \\'row\\' key-string to map.\\n            map[\\'c\\'+j+num]   = 1;              // Add \\'col\\' key-string to map.\\n            map[\\'b\\'+x+y+num] = 1;              // Add \\'box\\' key-string to map.\\n        }\\n    }\\n    \\n    return true;                               // If no error, board is valid.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427130,
                "title": "very-clear-js-solution-memory-100-time-95",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  let rows = new Set();\\n  let cols = new Set();\\n  let boxes = new Set();\\n  let curRowElem;\\n  let curColElem;\\n  let curBoxElem;\\n\\n  for (let i = 0; i < board.length; i += 1) {\\n    for (let j = 0; j < board[0].length; j += 1) {\\n      curRowElem = board[i][j]\\n      curColElem = board[j][i]\\n      curBoxElem = board[3 * Math.floor(i / 3) + Math.floor(j / 3)][((i * 3) % 9) + (j % 3)]\\n\\n      if (rows.has(curRowElem)) return false;\\n      if (curRowElem !== \".\") rows.add(curRowElem);\\n\\n      if (cols.has(curColElem)) return false;\\n      if (curColElem !== \".\") cols.add(curColElem);\\n\\n      if (boxes.has(curBoxElem)) return false;\\n      if (curBoxElem !== \".\") boxes.add(curBoxElem);\\n    }\\n\\n    rows.clear()\\n    cols.clear()\\n    boxes.clear()\\n  }\\n\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  let rows = new Set();\\n  let cols = new Set();\\n  let boxes = new Set();\\n  let curRowElem;\\n  let curColElem;\\n  let curBoxElem;\\n\\n  for (let i = 0; i < board.length; i += 1) {\\n    for (let j = 0; j < board[0].length; j += 1) {\\n      curRowElem = board[i][j]\\n      curColElem = board[j][i]\\n      curBoxElem = board[3 * Math.floor(i / 3) + Math.floor(j / 3)][((i * 3) % 9) + (j % 3)]\\n\\n      if (rows.has(curRowElem)) return false;\\n      if (curRowElem !== \".\") rows.add(curRowElem);\\n\\n      if (cols.has(curColElem)) return false;\\n      if (curColElem !== \".\") cols.add(curColElem);\\n\\n      if (boxes.has(curBoxElem)) return false;\\n      if (curBoxElem !== \".\") boxes.add(curBoxElem);\\n    }\\n\\n    rows.clear()\\n    cols.clear()\\n    boxes.clear()\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729690,
                "title": "swift-easy-solution-using-hashset",
                "content": "```\\nfinal class Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        var seen = Set<String>()\\n        for i in 0..<9 {\\n            for j in 0..<9 {\\n                let currVal = board[i][j]\\n                if currVal == \".\" {\\n                    continue\\n                }\\n                let row = \"\\\\(currVal) found in row \\\\(i)\"\\n                let col = \"\\\\(currVal) found in col \\\\(j)\"\\n                let box = \"\\\\(currVal) found in box \\\\((i/3)) - \\\\((j/3))\"\\n                if seen.contains(row) {\\n                    return false\\n                } else {\\n                    seen.insert(row)\\n                }\\n                if seen.contains(col) {\\n                    return false\\n                } else {\\n                    seen.insert(col)\\n                }\\n                if seen.contains(box) {\\n                    return false\\n                } else {\\n                    seen.insert(box)\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        var seen = Set<String>()\\n        for i in 0..<9 {\\n            for j in 0..<9 {\\n                let currVal = board[i][j]\\n                if currVal == \".\" {\\n                    continue\\n                }\\n                let row = \"\\\\(currVal) found in row \\\\(i)\"\\n                let col = \"\\\\(currVal) found in col \\\\(j)\"\\n                let box = \"\\\\(currVal) found in box \\\\((i/3)) - \\\\((j/3))\"\\n                if seen.contains(row) {\\n                    return false\\n                } else {\\n                    seen.insert(row)\\n                }\\n                if seen.contains(col) {\\n                    return false\\n                } else {\\n                    seen.insert(col)\\n                }\\n                if seen.contains(box) {\\n                    return false\\n                } else {\\n                    seen.insert(box)\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15469,
                "title": "11-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        vector<unordered_map<char, int>>row(n);\\n        vector<unordered_map<char, int>>col(n);\\n        vector<vector<unordered_map<char, int>>>sub(n/3, vector<unordered_map<char, int>>(n/3));\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                char c = board[i][j];\\n                if(c == '.') continue;\\n                if(row[i][c]++ > 0 || col[j][c]++ > 0 || sub[i/3][j/3][c]++ > 0) return false;\\n            }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        vector<unordered_map<char, int>>row(n);\\n        vector<unordered_map<char, int>>col(n);\\n        vector<vector<unordered_map<char, int>>>sub(n/3, vector<unordered_map<char, int>>(n/3));\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                char c = board[i][j];\\n                if(c == '.') continue;\\n                if(row[i][c]++ > 0 || col[j][c]++ > 0 || sub[i/3][j/3][c]++ > 0) return false;\\n            }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430239,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<String> check = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    // Making a unique key for every element\\n                    String row = board[i][j] + \"in row\" + i;\\n                    String col = board[i][j] + \"in col\" + j;\\n                    String box = board[i][j] + \"in box\" + i/3 + \"and\" + j/3;\\n                    \\n                    if(check.contains(row) || check.contains(col) || check.contains(box)){\\n                        return false;\\n                    }\\n                    \\n                    check.add(row);\\n                    check.add(col);\\n                    check.add(box);\\n                }\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n\\n\\n**Upvote if you find it easy to understand :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<String> check = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    // Making a unique key for every element\\n                    String row = board[i][j] + \"in row\" + i;\\n                    String col = board[i][j] + \"in col\" + j;\\n                    String box = board[i][j] + \"in box\" + i/3 + \"and\" + j/3;\\n                    \\n                    if(check.contains(row) || check.contains(col) || check.contains(box)){\\n                        return false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1206509,
                "title": "python3-no-need-explanation-solution-15-lines",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        row_bag = defaultdict(set)\\n        col_bag = defaultdict(set)\\n        sec_bag = defaultdict(set)\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                num = board[i][j]\\n\\n                if not num.isdigit():\\n                    continue\\n\\n                sec = (i // 3, j // 3)\\n                if num in row_bag[i] or num in col_bag[j] or num in sec_bag[sec]:\\n                    return False\\n                else:\\n                    row_bag[i].add(num)\\n                    col_bag[j].add(num)\\n                    sec_bag[sec].add(num)\\n        return True\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        row_bag = defaultdict(set)\\n        col_bag = defaultdict(set)\\n        sec_bag = defaultdict(set)\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                num = board[i][j]\\n\\n                if not num.isdigit():\\n                    continue\\n\\n                sec = (i // 3, j // 3)\\n                if num in row_bag[i] or num in col_bag[j] or num in sec_bag[sec]:\\n                    return False\\n                else:\\n                    row_bag[i].add(num)\\n                    col_bag[j].add(num)\\n                    sec_bag[sec].add(num)\\n        return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 15578,
                "title": "fast-and-clean-java-solution",
                "content": "       public boolean isValidSudoku(char[][] board) {\\n            //first dimension 0/horizontal 1/vertical 2/square\\n            //second dimension 0-8 represents the ith row/column/square\\n            //third dimension represents the occurrence of number 1-9\\n            boolean[][][] occur = new boolean[3][9][9];\\n            for (int i = 0; i < 9; i++){\\n                for (int j = 0; j < 9; j++){\\n                    if (board[i][j] == '.') continue;\\n                    int num = board[i][j] - '1';\\n                    if (occur[0][i][num]) return false;\\n                    else occur[0][i][num] = true;\\n                    if (occur[1][j][num]) return false;\\n                    else occur[1][j][num] = true;\\n                    int s = (i / 3) * 3 + j / 3;\\n                    if (occur[2][s][num]) return false;\\n                    else occur[2][s][num] = true;\\n                }\\n            }\\n            return true;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "       public boolean isValidSudoku(char[][] board) {\\n            //first dimension 0/horizontal 1/vertical 2/square\\n            //second dimension 0-8 represents the ith row/column/square\\n            //third dimension represents the occurrence of number 1-9\\n            boolean[][][] occur = new boolean[3][9][9];\\n            for (int i = 0; i < 9; i++){\\n                for (int j = 0; j < 9; j++){\\n                    if (board[i][j] == '.') continue;\\n                    int num = board[i][j] - '1';\\n                    if (occur[0][i][num]) return false;\\n                    else occur[0][i][num] = true;\\n                    if (occur[1][j][num]) return false;\\n                    else occur[1][j][num] = true;\\n                    int s = (i / 3) * 3 + j / 3;\\n                    if (occur[2][s][num]) return false;\\n                    else occur[2][s][num] = true;\\n                }\\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3689261,
                "title": "very-easy-to-understand-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Very first approach in my mind** : Iterate through begining and create vector of vector of size 9 and keep checking for duplicates .\\nthis approach will also accpeted due to small size of problem .\\nTime complaxity O(n^3) // we check every index 3 times .\\nSpace complexiyt O(n^2)  // we create vector of vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create set of pair of integer and char. And iterate through each index and check for row,col and grid , If yes they are there than we return false. Because the integer part denote the Row number abd character part denote the value at that respective row .If any pair will be same means the same value is presemt in same row .\\nSame for col and grid .\\n\\ngrid means the division of 3*3 sections,which we give the numbering from 0-9. we can calculate it through the given row and column number .\\n\\n---\\n\\n000 111 222  \\n000 111 222\\n000 111 222        \\n333 444 555\\n333 444 555\\n333 444 555\\n666 777 888\\n666 777 888\\n666 777 888\\n\\n---\\n\\nThis is our grid number and we can simply calculate it as we iterater following **:::::::** (0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(1,0)..... so on.\\nso our grid will will be such that ---> Divide the row by 3 **(gives the row no and divide by 3 gives the grid )**  than multiply by 3 **(represent that one row has the vlaue of 3 grid)** than add in it the vlaue of col/3;\\n\\n**you can give your view also to make better understanding**\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \"where n is the size of box\" \\n as we iterate onces at every index \\n\\n//give your view also ,your view is very helpful for me \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n) we create set of pair\\n\\n//give your view also ,your view is very helpful for me \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<pair<int,char>> row,col,grid;\\n\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                int count=(i/3)*3 +j/3;\\n                \\n                if(row.find({i,board[i][j]})==row.end())\\n                    row.insert({{i,board[i][j]}});\\n                 else return false;\\n\\n                if(col.find({j,board[i][j]})==col.end())\\n                    col.insert({{j,board[i][j]}});\\n                 else return false;\\n\\n                if(grid.find({count,board[i][j]})==grid.end())\\n                    grid.insert({{count,board[i][j]}});\\n                 else  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<pair<int,char>> row,col,grid;\\n\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                int count=(i/3)*3 +j/3;\\n                \\n                if(row.find({i,board[i][j]})==row.end())\\n                    row.insert({{i,board[i][j]}});\\n                 else return false;\\n\\n                if(col.find({j,board[i][j]})==col.end())\\n                    col.insert({{j,board[i][j]}});\\n                 else return false;\\n\\n                if(grid.find({count,board[i][j]})==grid.end())\\n                    grid.insert({{count,board[i][j]}});\\n                 else  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415177,
                "title": "c-simple-and-easy-10-short-line-solution",
                "content": "For each row, column and block we keep a set of numbers.\\nIf we find a number that was seen already in that row, column or block - return false.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414924,
                "title": "python-check-27-conditions-explained",
                "content": "We just need to check all `27` conditions - for every row, every column and every square.\\n\\n1. First `3` lines of code to check rows and columns: we check each row in `board` and in transposed board `*board` and collect all elements which are not equal to `.`\\n2. Next `4` lines of code to check all `9` cells: first we create all centers of `3x3` cells and then again collect all elements, not equal to `.`\\n\\n#### Complexity\\nTime complexity is `O(n^2)`, where `n` is size of board, space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def isValidSudoku(self, board):\\n        for row in chain(board, zip(*board)):\\n            cand = [i for i in row if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n            \\n        for x, y in product([1,4,7],[1,4,7]):\\n            cand = [board[x+i][y+j] for i,j in product([-1,0,1],[-1,0,1])]\\n            cand = [i for i in cand if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n        \\n        return True\\n```\\n\\nf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def isValidSudoku(self, board):\\n        for row in chain(board, zip(*board)):\\n            cand = [i for i in row if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n            \\n        for x, y in product([1,4,7],[1,4,7]):\\n            cand = [board[x+i][y+j] for i,j in product([-1,0,1],[-1,0,1])]\\n            cand = [i for i in cand if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15662,
                "title": "java-solution-using-array-of-hashset",
                "content": "\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet[] row = new HashSet[9];\\n        HashSet[] col = new HashSet[9];\\n        HashSet[] cell = new HashSet[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<Character>();\\n            col[i] = new HashSet<Character>();\\n            cell[i] = new HashSet<Character>();\\n        }\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    if (row[i].contains(board[i][j]) || col[j].contains(board[i][j]) || cell[3*(i/3)+j/3].contains(board[i][j])) {\\n                        return false;\\n                    } else {\\n                        row[i].add(board[i][j]);\\n                        col[j].add(board[i][j]);\\n                        cell[3*(i/3)+j/3].add(board[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet[] row = new HashSet[9];\\n        HashSet[] col = new HashSet[9];\\n        HashSet[] cell = new HashSet[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<Character>();\\n            col[i] = new HashSet<Character>();\\n            cell[i] = new HashSet<Character>();\\n        }\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    if (row[i].contains(board[i][j]) || col[j].contains(board[i][j]) || cell[3*(i/3)+j/3].contains(board[i][j])) {\\n                        return false;\\n                    } else {\\n                        row[i].add(board[i][j]);\\n                        col[j].add(board[i][j]);\\n                        cell[3*(i/3)+j/3].add(board[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3471217,
                "title": "solution-with-explanatory",
                "content": "# Intuition\\nWe will go through 3 steps to check the correctness of the sudoku.\\n1-By checking each line, we will see if there are any numbers that are the same as each other.\\n2-We will check every 3x3 square to see if there are any numbers that are the same.\\n3- By checking each column, we will see if there are any numbers that are the same.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1- We will sort each row in order and check if it is a consecutive number.\\n\\n2-We will check with for loops for every3x3 block. While the first 2 for loops will travel through the squares in order, the next 2 for loops will travel inside the squares and each number inside the squares will be assigned to the vector we call control. Then, the elements in the vector will be sorted and it will be checked whether they are consecutive numbers.\\n\\n3- A for loop will return every column. The other for loop will through the columns and assign the elements inside each column to the control2 vector. We will perform a sequential number comparison by sorting the assigned elements.\\n\\nif consecutive number detection occurs at these stages, the function return false. Function return true if sudoku doesn\\'t get stuck in controls\\n<!-- Describe your approach to solving the problem. -->\\n\\n# extra\\nIf you get stuck on the solution, I can help you in the comments.\\n\\nI spend a lot of effort deciphering the codes, if you found the solution useful, you can support me by upvoting.Thanks.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    \\t\\n\\n//      1-Rows--------------------\\n\\n    \\tfor(int t=0; t<9; t++){\\n    \\t\\tvector<char> vv = board[t];\\n    \\t    std::sort(vv.begin(), vv.end());\\n    \\t    for(int a=0; a<8; a++){\\n    \\t        if(vv[a] == vv[a+1] && vv[a] != \\'.\\'){\\n    \\t        \\treturn false;\\n    \\t        }\\n    \\t    }\\n    \\t}\\n//      2-3x3 Squares-------------\\n\\n    \\tfor(int i=0; i<9; i+=3) { \\n\\t        for(int j=0; j<9; j+=3) {\\n\\t            vector<char> control;\\n\\t            for(int k=0; k<3; k++) {\\n\\t                for(int l=0; l<3; l++) {\\n\\t                    control.push_back(board[i+k][j+l]);\\n\\t                }\\n\\t            }\\n\\t            sort(control.begin(), control.end()); \\n\\t            for(int k=1; k<control.size(); k++) {\\n\\t                if(control[k] == control[k-1] && control[k] != \\'.\\') {\\n\\t                    return false; \\n\\t                }\\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n\\n//      3-Columns------------------\\n\\n    \\tfor(int j=0; j<9; j++) { \\n\\t        vector<char> control2;\\n\\t        for(int i=0; i<9; i++) {\\n\\t            control2.push_back(board[i][j]);\\n\\t        }\\n\\t        sort(control2.begin(), control2.end()); \\n\\t        for(int k=1; k<control2.size(); k++) {\\n\\t            if(control2[k] == control2[k-1] && control2[k] != \\'.\\') {\\n\\t                return false; \\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n    \\treturn true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    \\t\\n\\n//      1-Rows--------------------\\n\\n    \\tfor(int t=0; t<9; t++){\\n    \\t\\tvector<char> vv = board[t];\\n    \\t    std::sort(vv.begin(), vv.end());\\n    \\t    for(int a=0; a<8; a++){\\n    \\t        if(vv[a] == vv[a+1] && vv[a] != \\'.\\'){\\n    \\t        \\treturn false;\\n    \\t        }\\n    \\t    }\\n    \\t}\\n//      2-3x3 Squares-------------\\n\\n    \\tfor(int i=0; i<9; i+=3) { \\n\\t        for(int j=0; j<9; j+=3) {\\n\\t            vector<char> control;\\n\\t            for(int k=0; k<3; k++) {\\n\\t                for(int l=0; l<3; l++) {\\n\\t                    control.push_back(board[i+k][j+l]);\\n\\t                }\\n\\t            }\\n\\t            sort(control.begin(), control.end()); \\n\\t            for(int k=1; k<control.size(); k++) {\\n\\t                if(control[k] == control[k-1] && control[k] != \\'.\\') {\\n\\t                    return false; \\n\\t                }\\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n\\n//      3-Columns------------------\\n\\n    \\tfor(int j=0; j<9; j++) { \\n\\t        vector<char> control2;\\n\\t        for(int i=0; i<9; i++) {\\n\\t            control2.push_back(board[i][j]);\\n\\t        }\\n\\t        sort(control2.begin(), control2.end()); \\n\\t        for(int k=1; k<control2.size(); k++) {\\n\\t            if(control2[k] == control2[k-1] && control2[k] != \\'.\\') {\\n\\t                return false; \\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n    \\treturn true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414952,
                "title": "python-super-easy-set-validation",
                "content": "**Idea**\\n* First create function `valid` to check duplicates \\n* Then simply check Validation **row wise**, **Column wise** and **Block wise** \\n* if either of them found not valid return **false**    and if all of them passed validation then simply return **true**\\n\\n**Complexity**\\n* Time Complexity :- `O(n^2)` i.e `O(81)`\\n* Space Complexity :- `O(n)` i.e. `O(9)` , because of `seen`, `col` and `block`\\n\\n**Block creation**\\ni/j \\xA0   0..2 3..5 6..8\\n0..2 \\xA0B1  \\xA0B2 \\xA0 B3\\n3..5 \\xA0B4  \\xA0B5  \\xA0B6\\n6..8 \\xA0B7 \\xA0 B8 \\xA0 B9\\n\\n**B1** and **B6** can be represented as \\n```\\nB1 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  B6\\n00 01 02 \\xA0 \\xA0 \\xA0 \\xA036 37 38\\n10 11 12 \\xA0 \\xA0 \\xA0 \\xA046 47 48\\n20 21 22 \\xA0 \\xA0 \\xA0 \\xA056 57 58\\n```\\n\\n**code** \\xA0 \\xA0 \\xA0 \\xA0\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking if 1D array valid\\n        def valid(arr):\\n            seen = set()\\n            for val in arr:\\n                if val == \\'.\\':\\n                    continue\\n                if val in seen:\\n                    return False\\n                seen.add(val)\\n            return True\\n        \\n        #Row wise\\n        for row in board:\\n            if not valid(row):\\n                return False\\n        \\n        #column wise\\n        for j in range(9):\\n            col = [board[i][j] for i in range(9)]\\n            if not valid(col):\\n                return False\\n       \\n        #Block wise\\n        for i in range(0, 9, 3):\\n            for j in range(0, 9, 3):\\n                block = [board[k][l] for k in range(i, i+3) for l in range(j, j+3)]\\n                if not valid(block):\\n                    return False\\n \\xA0 \\xA0 \\xA0 \\xA0return True\\n```\\n\\n*Please upvote if you like the solution and comment if have queries*. \\xA0 \\xA0 \\xA0",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nB1 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  B6\\n00 01 02 \\xA0 \\xA0 \\xA0 \\xA036 37 38\\n10 11 12 \\xA0 \\xA0 \\xA0 \\xA046 47 48\\n20 21 22 \\xA0 \\xA0 \\xA0 \\xA056 57 58\\n```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking if 1D array valid\\n        def valid(arr):\\n            seen = set()\\n            for val in arr:\\n                if val == \\'.\\':\\n                    continue\\n                if val in seen:\\n                    return False\\n                seen.add(val)\\n            return True\\n        \\n        #Row wise\\n        for row in board:\\n            if not valid(row):\\n                return False\\n        \\n        #column wise\\n        for j in range(9):\\n            col = [board[i][j] for i in range(9)]\\n            if not valid(col):\\n                return False\\n       \\n        #Block wise\\n        for i in range(0, 9, 3):\\n            for j in range(0, 9, 3):\\n                block = [board[k][l] for k in range(i, i+3) for l in range(j, j+3)]\\n                if not valid(block):\\n                    return False\\n \\xA0 \\xA0 \\xA0 \\xA0return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827706,
                "title": "c-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][10];\\n        int cols[9][10];\\n        int boxes[9][10];\\n        memset(rows, 0, sizeof(rows));\\n        memset(cols, 0, sizeof(cols));\\n        memset(boxes, 0, sizeof(boxes));\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    int num = board[i][j] - \\'0\\';\\n                    if (++rows[i][num] > 1 || ++cols[j][num] > 1 || ++boxes[(i/3)*3 + j/3][num] > 1) return false;\\n                \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][10];\\n        int cols[9][10];\\n        int boxes[9][10];\\n        memset(rows, 0, sizeof(rows));\\n        memset(cols, 0, sizeof(cols));\\n        memset(boxes, 0, sizeof(boxes));\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    int num = board[i][j] - \\'0\\';\\n                    if (++rows[i][num] > 1 || ++cols[j][num] > 1 || ++boxes[(i/3)*3 + j/3][num] > 1) return false;\\n                \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15576,
                "title": "java-clear-solution",
                "content": "    public class Solution {\\n    public static boolean isValidSudoku(char[][] board) {\\n    \\t\\tSet<Character>[] setXX = new HashSet[9];\\n    \\t\\tSet<Character>[] setYY = new HashSet[9];\\n    \\t\\tSet<Character>[] setXY = new HashSet[9];\\n    \\t\\tfor (int i = 0; i < 9; i++) {\\n    \\t\\t\\tsetXX[i] = new HashSet<>();\\n    \\t\\t\\tsetYY[i] = new HashSet<>();\\n    \\t\\t\\tsetXY[i] = new HashSet<>();\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor (int i = 0; i < 9; i++) {\\n    \\t\\t\\tfor (int j = 0; j < 9; j++) {\\n    \\t\\t\\t\\tif (board[i][j] == '.') {\\n    \\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(!setXX[i].add(board[i][j])){\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(!setYY[j].add(board[i][j])){\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(!setXY[(j / 3)* 3 + i / 3].add(board[i][j])){\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public static boolean isValidSudoku(char[][] board) {\\n    \\t\\tSet<Character>[] setXX = new HashSet[9];\\n    \\t\\tSet<Character>[] setYY = new HashSet[9];\\n    \\t\\tSet<Character>[] setXY = new HashSet[9];\\n    \\t\\tfor (int i = 0; i < 9; i++) {\\n    \\t\\t\\tsetXX[i] = new HashSet<>();\\n    \\t\\t\\tsetYY[i] = new HashSet<>();\\n    \\t\\t\\tsetXY[i] = new HashSet<>();\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2840682,
                "title": "c-java-not-the-fastest-but-the-most-simple-to-grasp",
                "content": "\\nHere we will run two for loops, one for rows and one for columns,\\nIf the element in the board is a number from 1 to 9 then we will check their presence---->\\n* IN THAT ROW : by using a row checker 2d array\\n* IN THE COLUMN : by using a column checker 2d array\\n* IN THAT BOX : by using the formula (row/3)3+(col/3) \\n\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean IsSafe(char[][] board, int row, int col, char num){\\n\\n        for(int i = col+1; i < 9; i++){         //for row checking\\n            if(board[row][i] == num)\\n                return false;\\n        }\\n\\n        for(int i = row+1; i < 9; i++){         //For col checking\\n            if(board[i][col] == num)\\n                return false;\\n        }\\n\\n        int x = row - row%3, y = col-col%3;        //for internal square\\n        for(int i = x; i < x+3; i++){\\n            for(int j = y; j < y+3; j++){\\n                if(board[i][j] == num && !(i == row && j == col))\\n                    return false;\\n            }\\n        }   \\n        return true;\\n    } \\n    public boolean isValidSudoku(char[][] board) {\\n\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    if(!IsSafe(board, i, j, board[i][j]))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n--------------------------------------------\\n\\n**c++**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isSafe(vector<vector<char>>& board , int temp, int row, int col)\\n    {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[row][i] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[i][col] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[row/3 *3 + i/3] [  col/3 * 3 +   (i%3)  ] == temp)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board.size();j++)\\n            {\\n                \\n                if(board[i][j] != \\'.\\')                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                {\\n                    int temp = board[i][j];\\n                    board[i][j]  = \\'*\\';\\n                    if(!isSafe(board, temp, i ,j))\\n                    {\\n                        return false;\\n                    }\\n                    board[i][j] =  temp;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n-----------------------------------------------\\n\\n**However, if you need a faster and more optimal solution, here it is:**\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int row[9][9] = {0}, col[9][9] = {0}, sub[9][9] = {0};\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++)  {\\n                if(board[i][j] != \\'.\\')  {\\n                    int num = board[i][j] - \\'0\\' - 1, k = i/3*3 + j/3;\\n                    if(row[i][num] || col[j][num] || sub[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = sub[k][num] = 1;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean IsSafe(char[][] board, int row, int col, char num){\\n\\n        for(int i = col+1; i < 9; i++){         //for row checking\\n            if(board[row][i] == num)\\n                return false;\\n        }\\n\\n        for(int i = row+1; i < 9; i++){         //For col checking\\n            if(board[i][col] == num)\\n                return false;\\n        }\\n\\n        int x = row - row%3, y = col-col%3;        //for internal square\\n        for(int i = x; i < x+3; i++){\\n            for(int j = y; j < y+3; j++){\\n                if(board[i][j] == num && !(i == row && j == col))\\n                    return false;\\n            }\\n        }   \\n        return true;\\n    } \\n    public boolean isValidSudoku(char[][] board) {\\n\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    if(!IsSafe(board, i, j, board[i][j]))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool isSafe(vector<vector<char>>& board , int temp, int row, int col)\\n    {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[row][i] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[i][col] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[row/3 *3 + i/3] [  col/3 * 3 +   (i%3)  ] == temp)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board.size();j++)\\n            {\\n                \\n                if(board[i][j] != \\'.\\')                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                {\\n                    int temp = board[i][j];\\n                    board[i][j]  = \\'*\\';\\n                    if(!isSafe(board, temp, i ,j))\\n                    {\\n                        return false;\\n                    }\\n                    board[i][j] =  temp;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int row[9][9] = {0}, col[9][9] = {0}, sub[9][9] = {0};\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++)  {\\n                if(board[i][j] != \\'.\\')  {\\n                    int num = board[i][j] - \\'0\\' - 1, k = i/3*3 + j/3;\\n                    if(row[i][num] || col[j][num] || sub[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = sub[k][num] = 1;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397764,
                "title": "java-simple-solution-hashset",
                "content": "PLEASE UPVOTE IF YOU LIKE IT-\\n\\n**keypoint**- HashSet returns true if element is not present in HashSet else returns false;\\n\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n       HashSet<String> seen = new HashSet<>();\\n      \\n        for(int i=0; i<9; i++){\\n             for(int j=0; j<9; j++){\\n              if(board[i][j] != \\'.\\'){ \\n                  char currentVal = board[i][j];\\n                   if(!(seen.add(currentVal + \"found in row \"+ i)) ||\\n                      !(seen.add(currentVal + \"found in column \"+ j) ) ||\\n                      !(seen.add(currentVal + \"found in sub box \"+ i/3 + \"-\"+ j/3)))\\n                       return false;\\n              }\\n          \\n           } \\n        \\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n       HashSet<String> seen = new HashSet<>();\\n      \\n        for(int i=0; i<9; i++){\\n             for(int j=0; j<9; j++){\\n              if(board[i][j] != \\'.\\'){ \\n                  char currentVal = board[i][j];\\n                   if(!(seen.add(currentVal + \"found in row \"+ i)) ||\\n                      !(seen.add(currentVal + \"found in column \"+ j) ) ||\\n                      !(seen.add(currentVal + \"found in sub box \"+ i/3 + \"-\"+ j/3)))\\n                       return false;\\n              }\\n          \\n           } \\n        \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905778,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        func isInvalid(_ box: [Character]) -> Bool {\\n            var chars: [Character] = []\\n            for c in box where c != \".\" {\\n                if chars.contains(c) { return true } else { chars.append(c) }\\n            }\\n            return false\\n        }\\n\\n        for i in 0..<9 {\\n            if isInvalid(board[i]) { return false }\\n            if isInvalid(board.map({ $0[i] })) { return false }\\n            let col = (i % 3) * 3\\n            let row = (i / 3) * 3\\n            let box = Array(board[row][col..<col + 3]) + Array(board[row + 1][col..<col + 3]) + Array(board[row + 2][col..<col + 3])\\n            if isInvalid(box) { return false }\\n        }\\n        return true\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        func isInvalid(_ box: [Character]) -> Bool {\\n            var chars: [Character] = []\\n            for c in box where c != \".\" {\\n                if chars.contains(c) { return true } else { chars.append(c) }\\n            }\\n            return false\\n        }\\n\\n        for i in 0..<9 {\\n            if isInvalid(board[i]) { return false }\\n            if isInvalid(board.map({ $0[i] })) { return false }\\n            let col = (i % 3) * 3\\n            let row = (i / 3) * 3\\n            let box = Array(board[row][col..<col + 3]) + Array(board[row + 1][col..<col + 3]) + Array(board[row + 2][col..<col + 3])\\n            if isInvalid(box) { return false }\\n        }\\n        return true\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15605,
                "title": "3ms-concise-java-solution-with-bit-operation",
                "content": "    public class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            int[] rows = new int[9];\\n            int[] columns = new int[9];\\n            int[] blocks = new int[9];\\n            for(int i=0;i<9;i++){\\n                for(int j=0;j<9;j++){\\n                    int mask = board[i][j]=='.'?0:(1<<(board[i][j]-'0'));\\n                    if(mask==0) continue;\\n                    if((rows[i]&mask)!=0) return false;\\n                    if((columns[j]&mask)!=0) return false;\\n                    if((blocks[i/3*3+j/3]&mask)!=0) return false;\\n                    rows[i] |= mask;\\n                    columns[j] |= mask;\\n                    blocks[i/3*3+j/3] |= mask;\\n                }\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            int[] rows = new int[9];\\n            int[] columns = new int[9];\\n            int[] blocks = new int[9];\\n            for(int i=0;i<9;i++){\\n                for(int j=0;j<9;j++){\\n                    int mask = board[i][j]=='.'?0:(1<<(board[i][j]-'0'));\\n                    if(mask==0) continue;\\n                    if((rows[i]&mask)!=0) return false;\\n                    if((columns[j]&mask)!=0) return false;\\n                    if((blocks[i/3*3+j/3]&mask)!=0) return false;\\n                    rows[i] |= mask;\\n                    columns[j] |= mask;\\n                    blocks[i/3*3+j/3] |= mask;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 705765,
                "title": "good-explanation-for-the-same-code-as-in-discussion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // Ok so it was a freaking great solution\\n        // What are we going to do is, lets say i got 3 2d vectors\\n        /// Now, I am going to start with current i,j i.e each row will have its\\n        // Own box, so my 0th row, will have a unique element box as well as 0th Column\\n        // So, for eg, if we start with the first element 5, we are going to check if\\n        // [0][5] present or not, that is, does current row have 5 as element or not\\n        // In similar way [0][5] for column, now, what about, the 3x3 box, what to do \\n        // about that, well this where freakin thinking of the user paid off\\n        // Ok so what we are going to do is, we are going to assign every 3x3 grid \\n        // as 1 box, i.e, First 3x3 Grid will have 0 number box, which will store all\\n        // The unique elements.\\n        \\n        vector<vector<int>> rbox(9, vector<int>(9)), cbox(9, vector<int>(9)), ubox(9, vector<int>(9));\\n        // Ok so this are row boxes, column boxes, unique boxes\\n        \\n        for(int i = 0;i<board.size();i++){\\n            for(int j = 0; j< board[i].size(); j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int nums = board[i][j] - \\'0\\' - 1;\\n                    // Now this is how we are going to check with respect to particular point\\n                    // Lets say our point is (1,2) That means I need to check 0th Unique Box if\\n                    // The element present is there or not\\n                    // Now how are we going to achieve that 0th Number, lets see,\\n                    // First of all, as you can see both are less than 3 becoz we need 3x3 grid\\n                    // Now lets take another example (2,6) Now which Unique Box it will be in\\n                    // It will be in 3rd Box, now how should we make a value that unique,\\n                    // Ok so we could reduce both numbers 2/3 = 0, 6/3 = 2 (As per indexing)\\n                    // Ok so if we divide the index by 3 it will be good, but\\n                    // Lets take another point, (6, 7) 6/3 = 2, 7/3 = 2 => 4th Unique Box\\n                    // Which is wrong, instead it will be in 9th Unique Box, so we are going to \\n                    // do that, by multiplying, ith index by 3 we will get 2x3 = 6, 6 + 2 \\n                    // which is 8(Indexing), we got our 9th Unique Box, noice\\n                    // Lets apply for our first point, and see if it helps\\n                    // 1/3 = 0, 0x3 = 0; 2/3 = 0 => Which means we are at our 1st Unique box\\n                    // Noice.....\\n                    int k = i/3*3 + j/3;\\n\\n                    if(rbox[i][nums] || cbox[j][nums] || ubox[k][nums]){\\n                        return false;\\n                    }\\n\\n                    rbox[i][nums] = cbox[j][nums] = ubox[k][nums] = 1;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // Ok so it was a freaking great solution\\n        // What are we going to do is, lets say i got 3 2d vectors\\n        /// Now, I am going to start with current i,j i.e each row will have its\\n        // Own box, so my 0th row, will have a unique element box as well as 0th Column\\n        // So, for eg, if we start with the first element 5, we are going to check if\\n        // [0][5] present or not, that is, does current row have 5 as element or not\\n        // In similar way [0][5] for column, now, what about, the 3x3 box, what to do \\n        // about that, well this where freakin thinking of the user paid off\\n        // Ok so what we are going to do is, we are going to assign every 3x3 grid \\n        // as 1 box, i.e, First 3x3 Grid will have 0 number box, which will store all\\n        // The unique elements.\\n        \\n        vector<vector<int>> rbox(9, vector<int>(9)), cbox(9, vector<int>(9)), ubox(9, vector<int>(9));\\n        // Ok so this are row boxes, column boxes, unique boxes\\n        \\n        for(int i = 0;i<board.size();i++){\\n            for(int j = 0; j< board[i].size(); j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int nums = board[i][j] - \\'0\\' - 1;\\n                    // Now this is how we are going to check with respect to particular point\\n                    // Lets say our point is (1,2) That means I need to check 0th Unique Box if\\n                    // The element present is there or not\\n                    // Now how are we going to achieve that 0th Number, lets see,\\n                    // First of all, as you can see both are less than 3 becoz we need 3x3 grid\\n                    // Now lets take another example (2,6) Now which Unique Box it will be in\\n                    // It will be in 3rd Box, now how should we make a value that unique,\\n                    // Ok so we could reduce both numbers 2/3 = 0, 6/3 = 2 (As per indexing)\\n                    // Ok so if we divide the index by 3 it will be good, but\\n                    // Lets take another point, (6, 7) 6/3 = 2, 7/3 = 2 => 4th Unique Box\\n                    // Which is wrong, instead it will be in 9th Unique Box, so we are going to \\n                    // do that, by multiplying, ith index by 3 we will get 2x3 = 6, 6 + 2 \\n                    // which is 8(Indexing), we got our 9th Unique Box, noice\\n                    // Lets apply for our first point, and see if it helps\\n                    // 1/3 = 0, 0x3 = 0; 2/3 = 0 => Which means we are at our 1st Unique box\\n                    // Noice.....\\n                    int k = i/3*3 + j/3;\\n\\n                    if(rbox[i][nums] || cbox[j][nums] || ubox[k][nums]){\\n                        return false;\\n                    }\\n\\n                    rbox[i][nums] = cbox[j][nums] = ubox[k][nums] = 1;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355779,
                "title": "python-solution-using-set-76ms",
                "content": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        rows  = [set() for _ in range(9)]\\n        cols  = [set() for _ in range(9)]\\n        dices = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                if e == \\'.\\': continue\\n                if e in rows[i] or e in cols[j] or e in dices[i//3][j//3]: return False\\n                rows[i].add(e)\\n                cols[j].add(e)\\n                dices[i//3][j//3].add(e)\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        rows  = [set() for _ in range(9)]\\n        cols  = [set() for _ in range(9)]\\n        dices = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                if e == \\'.\\': continue\\n                if e in rows[i] or e in cols[j] or e in dices[i//3][j//3]: return False\\n                rows[i].add(e)\\n                cols[j].add(e)\\n                dices[i//3][j//3].add(e)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326928,
                "title": "python-4-lines",
                "content": "```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = [[x for x in y if x != \\'.\\'] for y in board]\\n        col = [[x for x in y if x != \\'.\\'] for y in zip(*board)]\\n        pal = [[board[i+m][j+n] for m in range(3) for n in range(3) if board[i+m][j+n] != \\'.\\'] for i in (0, 3, 6) for j in (0, 3, 6)]\\n        return all(len(set(x)) == len(x) for x in (*row, *col, *pal))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = [[x for x in y if x != \\'.\\'] for y in board]\\n        col = [[x for x in y if x != \\'.\\'] for y in zip(*board)]\\n        pal = [[board[i+m][j+n] for m in range(3) for n in range(3) if board[i+m][j+n] != \\'.\\'] for i in (0, 3, 6) for j in (0, 3, 6)]\\n        return all(len(set(x)) == len(x) for x in (*row, *col, *pal))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160973,
                "title": "go-solution",
                "content": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, cols, boxes []map[byte]bool\\n    for i := 0; i < 9; i++ {\\n        rows = append(rows, make(map[byte]bool))\\n        cols = append(cols, make(map[byte]bool))\\n        boxes = append(boxes, make(map[byte]bool))\\n    }\\n    for i := range board {\\n        for j, num := range board[i] {\\n            if num == \\'.\\' { continue }\\n            if rows[i][num] || cols[j][num] || boxes[(i/3)*3+j/3][num] {\\n                return false\\n            }\\n            rows[i][num] = true\\n            cols[j][num] = true\\n            boxes[(i/3)*3+j/3][num] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, cols, boxes []map[byte]bool\\n    for i := 0; i < 9; i++ {\\n        rows = append(rows, make(map[byte]bool))\\n        cols = append(cols, make(map[byte]bool))\\n        boxes = append(boxes, make(map[byte]bool))\\n    }\\n    for i := range board {\\n        for j, num := range board[i] {\\n            if num == \\'.\\' { continue }\\n            if rows[i][num] || cols[j][num] || boxes[(i/3)*3+j/3][num] {\\n                return false\\n            }\\n            rows[i][num] = true\\n            cols[j][num] = true\\n            boxes[(i/3)*3+j/3][num] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15687,
                "title": "sharing-my-simple-o-n-2-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            int rows = board.size();\\n            int cols = board[0].size();\\n            int mask=0;\\n            int val;\\n            for(int i=0;i<rows;i++){\\n                mask=0;\\n                for(int j=0;j<cols;j++){\\n                    if(board[i][j]!='.'){\\n                        int val = (int)(board[i][j]-'0');\\n                        if(mask & (1<<val))\\n                            return false;\\n                        else mask |= (1<<val);\\n                    }\\n                }\\n            }\\n            //rows are checked\\n            for(int j=0;j<cols;j++){\\n                mask=0;\\n                for(int i=0;i<rows;i++){\\n                    if(board[i][j]!='.'){\\n                        int val = (int)(board[i][j]-'0');\\n                        if(mask & (1<<val))\\n                            return false;\\n                        else mask |= (1<<val);\\n                    }\\n                }\\n            }\\n            //cols are checked\\n            for(int i=0;i<rows;i+=3)\\n            {\\n                for(int j=0;j<cols;j+=3)\\n                {\\n                    mask=0;\\n                    for(int k=i;k<=i+2;k++)\\n                    {\\n                        for(int l=j;l<=j+2;l++)\\n                        {\\n                            if(board[k][l]!='.'){\\n                                val = (int)(board[k][l]-'0');\\n                                if(mask&(1<<val))\\n                                    return false;\\n                                else mask|=(1<<val);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return true;\\n        }\\n    };\\n\\nI use 'mask' to see which all digits have occurred before. This check is done using binary operators. This check is done for each row, each column and each block of 3*3. Any comments/suggestions/improvements are welcome!",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            int rows = board.size();\\n            int cols = board[0].size();\\n            int mask=0;\\n            int val;\\n            for(int i=0;i<rows;i++){\\n                mask=0;\\n                for(int j=0;j<cols;j++){\\n                    if(board[i][j]!='.'){\\n                        int val = (int)(board[i][j]-'0');\\n                        if(mask & (1<<val))\\n                            return false;\\n                        else mask |= (1<<val);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3254549,
                "title": "c-easiest-solution-hashing",
                "content": "# Intuition\\nCheck Every Row,Column,Box, if there is duplicate of not.\\nWe will do it in one iteration.\\n\\n# Approach\\nThere will be 9 row, 9 col and 9 box. We can determine the row and col no. easily (i,j if we iterate throw board ). And to to determine the box no --> [(i/3)*3 +(j/3)] ;\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<char> row[9];\\n        set<char> col[9];\\n        set<char> box[9];\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                char ch=board[i][j];\\n                if(ch==\\'.\\') continue;\\n\\n                <!-- Checking the Row -->\\n                if(row[i].count(ch)>=1) return false;\\n                else row[i].insert(ch);\\n\\n                <!-- Checking the Col -->\\n                if(col[j].count(ch)>=1) return false;\\n                else col[j].insert(ch);\\n                \\n                <!-- Calculating the box no-->\\n                int bi=(i/3)*3 + (j/3);\\n\\n                <!-- Checking the Box -->\\n                if(box[bi].count(ch)>=1) return false;\\n                else box[bi].insert(ch);\\n            }\\n        }\\n\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<char> row[9];\\n        set<char> col[9];\\n        set<char> box[9];\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                char ch=board[i][j];\\n                if(ch==\\'.\\') continue;\\n\\n                <!-- Checking the Row -->\\n                if(row[i].count(ch)>=1) return false;\\n                else row[i].insert(ch);\\n\\n                <!-- Checking the Col -->\\n                if(col[j].count(ch)>=1) return false;\\n                else col[j].insert(ch);\\n                \\n                <!-- Calculating the box no-->\\n                int bi=(i/3)*3 + (j/3);\\n\\n                <!-- Checking the Box -->\\n                if(box[bi].count(ch)>=1) return false;\\n                else box[bi].insert(ch);\\n            }\\n        }\\n\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925966,
                "title": "time-o-1-space-o-1",
                "content": "# Intuition\\nIn this problem, we simply need to check whether the board is a valid board, i.e. there are no duplicate numbers in any row, column, or box. We could brute force it by repeating work to check each row, column, box, individually. However, to improve performance, we will maintain 9 hashsets for each row/col/box. The only complication is how to determine the box based on the row, col. Let\\'s consider a couple options:\\n\\n```\\nrow = 2, col = 2, box should be 0\\nrow = 2, col = 8, box should be 2\\nrow = 5, col = 5, box should be 4\\nrow = 7, col = 7, box should be 8\\n```\\n\\nBased on the above examples, I came up with the following:\\n```\\nbox = 3*(row/3) + (col/3)\\n```\\n\\nYou can check the math yourself if you are interested.\\n\\n\\n# Approach\\n1. Maintain hashsets for each row, col, and box\\n2. If \\'.\\' continue, otherwise, check if element in the corresponding hashset\\n3. If ever found, return false. Otherwise, after processing all elements, return true \\n\\n# Complexity in general case\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(3 * n)$$ ~ $$O(n)$$\\n\\n# Complexity in specific case\\n- Time complexity:\\n$$O(9 * 9)$$ = $$O(81)$$ ~ $$O(1)$$\\n\\n- Space complexity:\\n$$O(9 * 9 * 3)$$ ~ $$O(243)$$ ~ $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsValidSudoku(char[][] board) {\\n        HashSet<char>[] row = new HashSet<char>[9];\\n        HashSet<char>[] col = new HashSet<char>[9];\\n        HashSet<char>[] box = new HashSet<char>[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<char>();\\n            col[i] = new HashSet<char>();\\n            box[i] = new HashSet<char>();\\n        }\\n\\n        for (int r = 0; r < board.Length; r++) {\\n            for (int c = 0; c < board[r].Length; c++) {\\n                char elem = board[r][c];\\n                if (elem == \\'.\\') {\\n                    continue;\\n                }\\n\\n                if (!row[r].Add(elem)) {\\n                    return false;\\n                }\\n\\n                if (!col[c].Add(elem)) {\\n                    return false;\\n                }\\n                \\n                int b = (3 * (r / 3)) + (c / 3);\\n                if (!box[b].Add(elem)) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nrow = 2, col = 2, box should be 0\\nrow = 2, col = 8, box should be 2\\nrow = 5, col = 5, box should be 4\\nrow = 7, col = 7, box should be 8\\n```\n```\\nbox = 3*(row/3) + (col/3)\\n```\n```\\npublic class Solution {\\n    public bool IsValidSudoku(char[][] board) {\\n        HashSet<char>[] row = new HashSet<char>[9];\\n        HashSet<char>[] col = new HashSet<char>[9];\\n        HashSet<char>[] box = new HashSet<char>[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<char>();\\n            col[i] = new HashSet<char>();\\n            box[i] = new HashSet<char>();\\n        }\\n\\n        for (int r = 0; r < board.Length; r++) {\\n            for (int c = 0; c < board[r].Length; c++) {\\n                char elem = board[r][c];\\n                if (elem == \\'.\\') {\\n                    continue;\\n                }\\n\\n                if (!row[r].Add(elem)) {\\n                    return false;\\n                }\\n\\n                if (!col[c].Add(elem)) {\\n                    return false;\\n                }\\n                \\n                int b = (3 * (r / 3)) + (c / 3);\\n                if (!box[b].Add(elem)) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116277,
                "title": "python-brute-force-use-3-dictionaries-with-comments",
                "content": "I use brute force to scan through each cell in the sudoku. Use 3 dictionaries to store:\\n1. number that filled in each row\\n2. number that filled in each column\\n3. number that filled in each block\\nA trick is to use ```(r//3, c//3)``` to identify each block as follows\\n![image](https://assets.leetcode.com/users/images/88531b71-a215-4561-a269-c6e8327fdbc6_1654479090.7013428.jpeg)\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = collections.defaultdict(set) # r: set(\"1\", \"2\", \"3\", ...)\\n        col = collections.defaultdict(set) # c: set(\"1\", \"2\", \"3\", ...)       \\n        block = collections.defaultdict(set) # (r//3, c//3): set(\"1\", \"2\", \"3\", ...)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\": # don\\'t need to check empty cells\\n                    continue\\n                # return false if the number in the cell has been filled in the same row, column, or block.\\n                if (board[r][c] in row[r]) or (board[r][c] in col[c]) or (board[r][c] in block[(r//3, c//3)]):\\n                    return False\\n                # otherwise, add the number to the hash set\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                block[(r//3, c//3)].add(board[r][c])\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```(r//3, c//3)```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = collections.defaultdict(set) # r: set(\"1\", \"2\", \"3\", ...)\\n        col = collections.defaultdict(set) # c: set(\"1\", \"2\", \"3\", ...)       \\n        block = collections.defaultdict(set) # (r//3, c//3): set(\"1\", \"2\", \"3\", ...)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\": # don\\'t need to check empty cells\\n                    continue\\n                # return false if the number in the cell has been filled in the same row, column, or block.\\n                if (board[r][c] in row[r]) or (board[r][c] in col[c]) or (board[r][c] in block[(r//3, c//3)]):\\n                    return False\\n                # otherwise, add the number to the hash set\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                block[(r//3, c//3)].add(board[r][c])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074970,
                "title": "valid-sudoku-using-back-tracking-100-faster-with-proper-explanation",
                "content": "Just tell me who hasn\\'t played sudoku ,there might be some.\\nBut now tell me who hasn\\'t even listen sudoku word ,nobody. Right!. thats all we need.\\nHowever,if you want to learn more about sudoku you can read it here\\nhttps://en.wikipedia.org/wiki/Sudoku\\nlet\\'s solve this problem together.\\nThis is a problem of sudoku which will be solved using techniques \\n1. Recursion.\\n2. only BackTracking\\n3. Hashing\\nQuestion says you need to tell whether the given sudoku is valid or not\\n\\nYou really donot need to solve \"Sudoku\" to find out whether it is valid or not\\nSay if our sudoku is whole empty thats also a valid sudoku \"The Question clearly says\".and we donot need Recursion anymore.\\n-\\nyou can really get the idea if you pass the test case \\nyou can check out by having the test case \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nif you are  really a sudoku solver  you will say this is an invalid sudoku ,but unfortunately this is what the question says.\\nNow comes the point how will you tell whether the sudoku is valid or not.\\nProgram-All we need to check the given number present in any 1* 1 cell should not be present in the row,column ,big 3* 3 cell associated with that 1* 1 cell.\\nAlgorithm\\n1. we here traverse the sudoku in breadth search manner this is row-wise we will assess each cell character.\\n2. if 1*1 cell conatins \\'.\\' then nothing needs to be checked\\n3. else store the present number and change it to \\' .\\' . \\n4. check the stored number if present anywhere in the row,in the column,or  in the block associated with that cell ,immediately return false;\\n5. else change it back to the number it was storing repeat the process until gets completed.\\n6. \\nNow ,the question arises how will you check whether the given number is present anywhere in the row ,in the column or in the block to with which the cell is associated.\\n-\\nwe will solve it using one for loop.\\n1. we are supposed to get the row no. of the cell and column no. of the cell and number that was there\\n2. run a loop from 0 to 9\\n3. fix row as row no. given \\n4. fix colum as column number given\\n\\t5. now divide the sudoku into 3 * 3 from 9* 9 i.e, coordinate shifting as shown\\n\\t![image](https://assets.leetcode.com/users/images/03a9ef26-b35e-44d2-80d3-4f8ce945a16f_1653546224.107758.png)\\n0 to 8 can be shifted to block \\nfirst of all the find the \\nblock row no.-row no./3\\nblock column number -column no./3\\nreal row index-(row no./3)*3+(k/3)\\n//k/3 will always gives value\\nfor k={0,1,2}->k/3 is {0,0,0} respectively/*row remains same for block*/\\nfor k={3,4,5}->k/3 is {1,1,1} respectively/*row remains same for block*/\\nfor k={6,7,8}->k/3 is t{2,2,2} respectively/*row remains same for block*/\\n#add respective block column number you will get required indexes\\nreal column idex-(column no./3)*3+(k%3)\\n//k%3 will always gives value\\nfor k={0,1,2}->k%3 is {0,1,2} respectively/*column varies for block*/\\nfor k={3,4,5}->k%3 is {0,1,2} respectively/*column varies for block*/\\nfor k={6,7,8}->k%3 is {0,1,2} respectively/*column varies for block*/\\nthat is used to switch columns within block\\n#add respective block row number you will get required indexes\\n\\ncode-\\n-\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n     for(int i=0;i<9;i++)\\n     {\\n         for(int j=0;j<9;j++)//traverse in bfs manner \\n         {\\n             char ch=board[i][j];\\n             if(ch!=\\'.\\')//if ch is apart from \\'.\\'we need to check whether the given number is verifiable\\n             {\\n                 board[i][j]=\\'.\\';//change it to . so that it cannot consider itself\\n                 if(!isValid(board,ch,i,j))//if not verifiable\\n                     return false;//invalid sudoku\\n                 board[i][j]=ch;//after checking change it to its initial value\\n             }\\n         }\\n     }\\n        return true;\\n    }\\n    static boolean isValid(char[][]ch,char ch1,int i,int j)\\n    {\\n      for(int k=0;k<9;k++)\\n      {\\n          if(ch[i][k]==ch1)return false;//for checking row associated with it\\n          if(ch[k][j]==ch1)return false;//for checking column associated with it\\n          if(ch[3*(i/3)+k/3][3*(j/3)+k%3]==ch1)return false;//for checking block associated with it\\n      }\\n        return true;\\n    }\\n}\\n```\\nthis question is very easy ,just in any case if you face any problem anywhere let me know in the comments.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n     for(int i=0;i<9;i++)\\n     {\\n         for(int j=0;j<9;j++)//traverse in bfs manner \\n         {\\n             char ch=board[i][j];\\n             if(ch!=\\'.\\')//if ch is apart from \\'.\\'we need to check whether the given number is verifiable\\n             {\\n                 board[i][j]=\\'.\\';//change it to . so that it cannot consider itself\\n                 if(!isValid(board,ch,i,j))//if not verifiable\\n                     return false;//invalid sudoku\\n                 board[i][j]=ch;//after checking change it to its initial value\\n             }\\n         }\\n     }\\n        return true;\\n    }\\n    static boolean isValid(char[][]ch,char ch1,int i,int j)\\n    {\\n      for(int k=0;k<9;k++)\\n      {\\n          if(ch[i][k]==ch1)return false;//for checking row associated with it\\n          if(ch[k][j]==ch1)return false;//for checking column associated with it\\n          if(ch[3*(i/3)+k/3][3*(j/3)+k%3]==ch1)return false;//for checking block associated with it\\n      }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135904,
                "title": "0ms-simple-go-code",
                "content": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    rowsMap := [9][9]bool{}\\n    colsMap := [9][9]bool{}\\n    gridMap := [9][9]bool{}\\n    \\n    for row:=0; row<9; row++ {\\n        for col:=0; col<9; col++ {\\n            val, err := strconv.Atoi(string(board[row][col]))\\n            if err != nil {\\n                continue\\n            }\\n            val--\\n            gridIndex := col/3 + (row/3) * 3\\n            if rowsMap[row][val] || colsMap[col][val] || gridMap[gridIndex][val] {\\n                return false\\n            } \\n            rowsMap[row][val] = true\\n            colsMap[col][val] = true    \\n            gridMap[gridIndex][val] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    rowsMap := [9][9]bool{}\\n    colsMap := [9][9]bool{}\\n    gridMap := [9][9]bool{}\\n    \\n    for row:=0; row<9; row++ {\\n        for col:=0; col<9; col++ {\\n            val, err := strconv.Atoi(string(board[row][col]))\\n            if err != nil {\\n                continue\\n            }\\n            val--\\n            gridIndex := col/3 + (row/3) * 3\\n            if rowsMap[row][val] || colsMap[col][val] || gridMap[gridIndex][val] {\\n                return false\\n            } \\n            rowsMap[row][val] = true\\n            colsMap[col][val] = true    \\n            gridMap[gridIndex][val] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476302,
                "title": "javascript-string-map-solution",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  const map = {};\\n  \\n  for (let row = 0; row < 9; row ++) {\\n    for (let col = 0; col < 9; col ++) {\\n      const val = board[row][col];\\n      \\n      if (val === \\'.\\') continue;\\n      \\n      const keyRow = `row ${row} has ${val}`;\\n      const keyCol = `col ${col} has ${val}`;\\n      const keyBox = `box ${Math.floor(row / 3)}-${Math.floor(col / 3)} has ${val}`;\\n\\n      if (map[keyRow] || map[keyCol] || map[keyBox]) return false;\\n\\n      map[keyRow] = true;\\n      map[keyCol] = true;\\n      map[keyBox] = true;\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  const map = {};\\n  \\n  for (let row = 0; row < 9; row ++) {\\n    for (let col = 0; col < 9; col ++) {\\n      const val = board[row][col];\\n      \\n      if (val === \\'.\\') continue;\\n      \\n      const keyRow = `row ${row} has ${val}`;\\n      const keyCol = `col ${col} has ${val}`;\\n      const keyBox = `box ${Math.floor(row / 3)}-${Math.floor(col / 3)} has ${val}`;\\n\\n      if (map[keyRow] || map[keyCol] || map[keyBox]) return false;\\n\\n      map[keyRow] = true;\\n      map[keyCol] = true;\\n      map[keyBox] = true;\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15587,
                "title": "my-one-pass-o-1-space-solution-using-java",
                "content": " \\n  This solution saves more space. \\n  Using bit-map to represent the occupation of each number.\\n  In the outer loop, the i represents ith row, column and block \\n  for the row, col and block variable separately to validate \\n  the jth element in this row (column and the block) seperately.\\n\\n\\n  Time complexity: O(n^2); where n is the width of the board.\\n\\n  Space complexity: O(1);\\n\\n  Status: Accepted.\\n \\n\\n    public class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            // precondition: board is not null\\n            if (board == null) {\\n                throw new NullPointerException();\\n            }\\n    \\n            for (int i = 0; i < 9; i++) {\\n                int row = 0;\\n                int col = 0;\\n                int block = 0;\\n                for (int j = 0; j < 9; j++) {\\n                    int rowVal = board[i][j] - '1';\\n                    int colVal = board[j][i] - '1';\\n                    int blockVal = board[i/3*3 + j/3][i%3*3 + j%3] - '1';\\n                    if (rowVal >= 0 && (row & (1 << rowVal)) != 0\\n                     || colVal >= 0 && (col & (1 << colVal)) != 0\\n                     || blockVal >= 0 && (block & (1 << blockVal)) !=0) {\\n                        return false;\\n                    }\\n                    row |= rowVal >= 0 ? 1 << rowVal : 0;\\n                    col |= colVal >=0 ? 1 << colVal : 0;\\n                    block |= blockVal >= 0 ? 1 << blockVal : 0;\\n                }\\n            }\\n    \\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            // precondition: board is not null\\n            if (board == null) {\\n                throw new NullPointerException();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3919253,
                "title": "beats-96-06-50-145-top-interview-question",
                "content": "# Intuition\\n*A simple straight-forward solution!*\\n\\n# Approach\\nThis code block is an implementation of the solution to `isValidSudoku`. Let\\'s break down the code step by step:\\n\\n1. The code starts by importing the `collections` module, which is used to create defaultdicts (Why? Will explain!).\\n   \\n2. Within the `isValidSudoku` method, three defaultdicts are created: `rows`, `columns`, and `sub_boxes`. These defaultdicts will store sets of numbers that are present in each row, column, and sub-box of the Sudoku board, respectively.\\n\\n3. The code then uses two nested loops to iterate through each cell in the 9x9 Sudoku board.\\n\\n4. For each cell, it checks the value of the number in the cell (`num`):\\n\\n   - If the cell contains a period (`.`), which represents an empty cell, it skips the current iteration using `continue`.\\n\\n   - If the cell contains a number, it checks three conditions to determine if the number violates the rules of Sudoku:\\n\\n     - It checks if the number is already present in the set of numbers in the same row (`rows[row]`).\\n     \\n     - It checks if the number is already present in the set of numbers in the same column (`columns[col]`).\\n     \\n     - It checks if the number is already present in the set of numbers in the corresponding sub-box (`sub_boxes[(row//3, col//3)]`).\\n\\n   - If any of these conditions are met, it means the Sudoku rules are violated, and the function immediately returns `False`, indicating that the Sudoku board is not valid.\\n\\n5. If none of the conditions are met, meaning the number can be safely placed in the current cell without violating any rules, the code updates the sets in `rows`, `columns`, and `sub_boxes` to include the new number.\\n\\n6. After iterating through the entire board, if no violations were found, the function returns `True`, indicating that the Sudoku board is valid.\\n\\n\\n# Complexity\\n- Time complexity:\\n    O(1) , ***Actually O(81) since constant\\'s are O(1)***\\n\\n- Space complexity:\\n    O(1),  ***Confusing? It\\'s simple. The total space incurred will be three times the size of the Sudoku board, and it\\'s constant in length! It might get smaller but will never exceed 3(9+1 x 9+1).***\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Create dictionaries to keep track of numbers in rows, columns, and sub-boxes\\n        rows = collections.defaultdict(set)\\n        columns = collections.defaultdict(set)\\n        sub_boxes = collections.defaultdict(set)\\n\\n        # Iterate through each cell in the 9x9 Sudoku board\\n        for row in range(9):\\n            for col in range(9):\\n                num = board[row][col]\\n\\n                # Skip empty cells represented by \".\"\\n                if num == \".\":\\n                    continue\\n\\n                # Check if the current number violates Sudoku rules\\n                if (num in rows[row] or \\n                    num in columns[col] or \\n                    num in sub_boxes[(row // 3, col // 3)]):\\n                   return False\\n\\n                # Update sets to keep track of encountered numbers\\n                rows[row].add(num)\\n                columns[col].add(num)\\n                sub_boxes[(row // 3, col // 3)].add(num)\\n\\n        # If all cells satisfy Sudoku rules, the board is valid\\n        return True\\n\\n```\\n\\n***Extra note:***\\n\\n*Why we used **defaultdict?**.*\\n-- *It is to simplify the process of initializing and accessing values in a dictionary, especially when dealing with keys that might not exist yet. It provides a convenient way to handle default values for keys that are not present in the dictionary.*\\n\\n\\n- `num in sub_boxes[(row // 3, col // 3)]`:\\n\\n*This line checks whether the number `num` is already present in the set that corresponds to the specific ***3x3*** sub-box where the current cell is located.*\\n\\n*Imagine you\\'re playing a game on a ***9x9*** Sudoku board. To make sure you\\'re not violating the rules, you want to know if the number you\\'re considering ***(let\\'s say \"5\")*** is already in the little ***3x3*** box that your current cell is part of. You\\'d look at that ***3x3*** box, see if the number ***\"5\"*** is already there, and if it is, you\\'d know you can\\'t place another ***\"5\"*** there. This line of code is doing that exact check for you, but programmatically.*\\n\\n```\\n    0       1      2\\n   - - - | - - - | - - -\\n0  - - - | - - - | - - -  // sub_boxes key\\'s as a tuple (x,y)\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n1  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n2  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n```\\n\\n- `sub_boxes[(row // 3, col // 3)].add(num)`:\\n\\n*This line adds the current number `num` to the set that corresponds to the ***3x3*** sub-box where the current cell is located.*\\n\\n*Continuing from the previous analogy, let\\'s say you found that the number **\"5\"** isn\\'t in the ***3x3*** box yet, so you want to add it there. You take your pen and add the ***\"5\"*** to the list of numbers you\\'ve placed in that box. This line of code does the same thing in code. It adds the current number `num` to the set that represents the numbers placed in that specific ***3x3*** sub-box.*\\n\\n***In both cases, these lines help ensure that you\\'re following the rules of Sudoku by keeping track of the numbers in rows, columns, and sub-boxes, making sure no number repeats within the same row, column, or sub-box.***\\n\\n***END***\\n\\n\\n*It took a lot of time and effort to write this documentation, but I will be really happy if it becomes useful to someone!* \\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Create dictionaries to keep track of numbers in rows, columns, and sub-boxes\\n        rows = collections.defaultdict(set)\\n        columns = collections.defaultdict(set)\\n        sub_boxes = collections.defaultdict(set)\\n\\n        # Iterate through each cell in the 9x9 Sudoku board\\n        for row in range(9):\\n            for col in range(9):\\n                num = board[row][col]\\n\\n                # Skip empty cells represented by \".\"\\n                if num == \".\":\\n                    continue\\n\\n                # Check if the current number violates Sudoku rules\\n                if (num in rows[row] or \\n                    num in columns[col] or \\n                    num in sub_boxes[(row // 3, col // 3)]):\\n                   return False\\n\\n                # Update sets to keep track of encountered numbers\\n                rows[row].add(num)\\n                columns[col].add(num)\\n                sub_boxes[(row // 3, col // 3)].add(num)\\n\\n        # If all cells satisfy Sudoku rules, the board is valid\\n        return True\\n\\n```\n```\\n    0       1      2\\n   - - - | - - - | - - -\\n0  - - - | - - - | - - -  // sub_boxes key\\'s as a tuple (x,y)\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n1  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n2  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474482,
                "title": "typescript-easy-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\nfunction isValidSudoku(board: string[][]): boolean {\\n    const set = new Set()\\n\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            const cell = board[i][j]\\n            if(cell === \\'.\\') continue\\n            const row = `row: ${i}, value: ${cell}`\\n            const column = `column: ${j}, value: ${cell}`\\n            const boxNumber = 3 * Math.floor(i / 3) + Math.floor(j / 3)\\n            const box = `boxNumber: ${boxNumber}, value: ${cell}`\\n            if(set.has(row) || set.has(column) || set.has(box)) return false\\n            set.add(row).add(column).add(box)\\n        }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nfunction isValidSudoku(board: string[][]): boolean {\\n    const set = new Set()\\n\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            const cell = board[i][j]\\n            if(cell === \\'.\\') continue\\n            const row = `row: ${i}, value: ${cell}`\\n            const column = `column: ${j}, value: ${cell}`\\n            const boxNumber = 3 * Math.floor(i / 3) + Math.floor(j / 3)\\n            const box = `boxNumber: ${boxNumber}, value: ${cell}`\\n            if(set.has(row) || set.has(column) || set.has(box)) return false\\n            set.add(row).add(column).add(box)\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2840609,
                "title": "python-solution-using-set-faster-than-95",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # idea: mark row, col, and sub-board appearance for each element. Check repetition at the end. \\n        tags = []\\n        for i in range(9):\\n            for j in range(9):\\n                ele = board[i][j]\\n                if ele != \\'.\\':\\n                    tags.append(f\\'{ele} @ {i}th row\\')\\n                    tags.append(f\\'{ele} @ {j}th col\\') \\n                    tags.append(f\\'{ele} @ {i//3}-{j//3}th subboard\\')\\n\\n        return len(tags) == len(set(tags))\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # idea: mark row, col, and sub-board appearance for each element. Check repetition at the end. \\n        tags = []\\n        for i in range(9):\\n            for j in range(9):\\n                ele = board[i][j]\\n                if ele != \\'.\\':\\n                    tags.append(f\\'{ele} @ {i}th row\\')\\n                    tags.append(f\\'{ele} @ {j}th col\\') \\n                    tags.append(f\\'{ele} @ {i//3}-{j//3}th subboard\\')\\n\\n        return len(tags) == len(set(tags))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534738,
                "title": "typescript-javascript-map-hashset",
                "content": "This solution is technically constant time because the number of cells never exceeds 81\\n\\n```\\nconst EMPTY_CELL = \".\";\\nconst NUMBER_OF_CELLS = 81;\\nconst SUB_BOARD_WIDTH = 3;\\nconst SUB_BOARD_HEIGHT = 3;\\n\\nfunction isValidSudoku(board: string[][]): boolean {\\n  const rows = new Map<number, Set<number>>();\\n  const columns = new Map<number, Set<number>>();\\n  const boxes = new Map<number, Set<number>>();\\n  \\n  for(let i = 0 ; i < NUMBER_OF_CELLS ; i++){\\n    const row = Math.floor(i / 9);\\n    const column = i % 9;\\n    const box =  Math.floor(row / 3) * 3 + Math.floor(column / 3);\\n    const cell = Number(board[row][column]);\\n    \\n    // if empty cell, skip\\n    if(isNaN(cell)) continue;\\n    \\n    // initialize sets if not initialized for\\n    // row, column, or box\\n    if(!rows.has(row)) rows.set(row, new Set<number>());\\n    if(!columns.has(column)) columns.set(column, new Set<number>());\\n    if(!boxes.has(box)) boxes.set(box, new Set<number>());\\n    \\n    // if the cell value was seen before, this means\\n    // this is an invalid sudoku, return false\\n    if(rows.get(row).has(cell)) return false;\\n    if(columns.get(column).has(cell)) return false;\\n    if(boxes.get(box).has(cell)) return false;\\n    \\n    // if we haven\\'t seen the cell before, add it to\\n    // row, column, and box\\n    rows.get(row).add(cell)\\n    columns.get(column).add(cell)\\n    boxes.get(box).add(cell)\\n  }\\n  \\n  \\n  // if we manage to exit the loop without breaking\\n  // sudoku rules, then this is a valid sudoku\\n  return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst EMPTY_CELL = \".\";\\nconst NUMBER_OF_CELLS = 81;\\nconst SUB_BOARD_WIDTH = 3;\\nconst SUB_BOARD_HEIGHT = 3;\\n\\nfunction isValidSudoku(board: string[][]): boolean {\\n  const rows = new Map<number, Set<number>>();\\n  const columns = new Map<number, Set<number>>();\\n  const boxes = new Map<number, Set<number>>();\\n  \\n  for(let i = 0 ; i < NUMBER_OF_CELLS ; i++){\\n    const row = Math.floor(i / 9);\\n    const column = i % 9;\\n    const box =  Math.floor(row / 3) * 3 + Math.floor(column / 3);\\n    const cell = Number(board[row][column]);\\n    \\n    // if empty cell, skip\\n    if(isNaN(cell)) continue;\\n    \\n    // initialize sets if not initialized for\\n    // row, column, or box\\n    if(!rows.has(row)) rows.set(row, new Set<number>());\\n    if(!columns.has(column)) columns.set(column, new Set<number>());\\n    if(!boxes.has(box)) boxes.set(box, new Set<number>());\\n    \\n    // if the cell value was seen before, this means\\n    // this is an invalid sudoku, return false\\n    if(rows.get(row).has(cell)) return false;\\n    if(columns.get(column).has(cell)) return false;\\n    if(boxes.get(box).has(cell)) return false;\\n    \\n    // if we haven\\'t seen the cell before, add it to\\n    // row, column, and box\\n    rows.get(row).add(cell)\\n    columns.get(column).add(cell)\\n    boxes.get(box).add(cell)\\n  }\\n  \\n  \\n  // if we manage to exit the loop without breaking\\n  // sudoku rules, then this is a valid sudoku\\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494087,
                "title": "easy-100-fully-explained-java-clean-solution-two-approaches",
                "content": "# **Java Solution:**\\n```\\n/** First Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        // Base case...\\n        if (board == null || board.length != 9 || board[0].length != 9)\\n\\t\\t    return false;\\n        \\n\\t    //For each column check that their is repeatation of any digit present in filled cells...\\n\\t    for (int i = 0; i < 9; i++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int j = 0; j < 9; j++) {\\n                // For filled cells only...\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\n\\t    // For each row check that their is repeatation of any digit present in filled cells...\\n\\t    for (int j = 0; j < 9; j++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int i = 0; i < 9; i++) {\\n                // For filled cells only\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n \\n\\t    // Check that every 3*3 grid must contain different values means no repeatation of any digit present in filled cells...\\n\\t    for (int grid = 0; grid < 9; grid++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n            // Traverse each grid through the loops...\\n\\t\\t    for (int i = grid / 3 * 3; i < grid / 3 * 3 + 3; i++) {\\n\\t\\t\\t    for (int j = grid % 3 * 3; j < grid % 3 * 3 + 3; j++) {\\n                    // For filled cells only...\\n\\t\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                        // That number-1, is its index in every checking array\\n\\t\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\t    return true;\\n    }\\n}\\n\\n__________________________________________________________________________________________________________________________________________________________________\\n\\n\\n/** Second Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        // Traverse all the elements of all the boxes through loops...\\n        for (int i = 0; i < 9; ++i)\\n            for (int j = 0; j < 9; ++j) {\\n                // For filled cells only...\\n                if (board[i][j] == \\'.\\')\\n                    continue;\\n                final char ch = board[i][j];\\n                // Check each row, column & 3x3 box...\\n                if (!set.add(ch + \"@row\" + i) || !set.add(ch + \"@col\" + j) || !set.add(ch + \"@box\" + i/3 + j/3))\\n                    return false;\\n            }\\n        return true;\\n    }\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\n/** First Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        // Base case...\\n        if (board == null || board.length != 9 || board[0].length != 9)\\n\\t\\t    return false;\\n        \\n\\t    //For each column check that their is repeatation of any digit present in filled cells...\\n\\t    for (int i = 0; i < 9; i++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int j = 0; j < 9; j++) {\\n                // For filled cells only...\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\n\\t    // For each row check that their is repeatation of any digit present in filled cells...\\n\\t    for (int j = 0; j < 9; j++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int i = 0; i < 9; i++) {\\n                // For filled cells only\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n \\n\\t    // Check that every 3*3 grid must contain different values means no repeatation of any digit present in filled cells...\\n\\t    for (int grid = 0; grid < 9; grid++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n            // Traverse each grid through the loops...\\n\\t\\t    for (int i = grid / 3 * 3; i < grid / 3 * 3 + 3; i++) {\\n\\t\\t\\t    for (int j = grid % 3 * 3; j < grid % 3 * 3 + 3; j++) {\\n                    // For filled cells only...\\n\\t\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                        // That number-1, is its index in every checking array\\n\\t\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\t    return true;\\n    }\\n}\\n\\n__________________________________________________________________________________________________________________________________________________________________\\n\\n\\n/** Second Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        // Traverse all the elements of all the boxes through loops...\\n        for (int i = 0; i < 9; ++i)\\n            for (int j = 0; j < 9; ++j) {\\n                // For filled cells only...\\n                if (board[i][j] == \\'.\\')\\n                    continue;\\n                final char ch = board[i][j];\\n                // Check each row, column & 3x3 box...\\n                if (!set.add(ch + \"@row\" + i) || !set.add(ch + \"@col\" + j) || !set.add(ch + \"@box\" + i/3 + j/3))\\n                    return false;\\n            }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466662,
                "title": "java-hashset-with-minimal-lines-of-code",
                "content": "```\\npublic boolean isValidSudoku(char[][] board) {\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                char currVal = board[i][j];\\n                if(currVal!=\\'.\\'){\\n                    if(!set.add(currVal+\" found in row \"+i) ||\\n                        !set.add(currVal+\" found in column \"+j) ||\\n                        !set.add(currVal+\" found in sub Box \"+i/3+j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isValidSudoku(char[][] board) {\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                char currVal = board[i][j];\\n                if(currVal!=\\'.\\'){\\n                    if(!set.add(currVal+\" found in row \"+i) ||\\n                        !set.add(currVal+\" found in column \"+j) ||\\n                        !set.add(currVal+\" found in sub Box \"+i/3+j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668785,
                "title": "java-clean-code",
                "content": "```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    String r = \\'r\\' + \"-\" + i + \"-\" + board[i][j];\\n                    String c = \\'c\\' + \"-\" + j + \"-\" + board[i][j];\\n                    String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n                    if (!hs.add(r) || !hs.add(c) || !hs.add(rc)) \\n                        return false;\\n\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    String r = \\'r\\' + \"-\" + i + \"-\" + board[i][j];\\n                    String c = \\'c\\' + \"-\" + j + \"-\" + board[i][j];\\n                    String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n                    if (!hs.add(r) || !hs.add(c) || !hs.add(rc)) \\n                        return false;\\n\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622505,
                "title": "pythonic-python",
                "content": "Very python\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \"\"\"\\n        Let\\'s keep tracking each element and see where they belong\\n        \"\"\"\\n        \\n        # Initialize tackers for each row, column and box\\n        row = {i: [] for i in range(9)}\\n        col = {i: [] for i in range(9)}\\n        box = {i: [] for i in range(9)}\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                box_index = (i // 3) * 3 + j // 3\\n                \\n                if e == \\'.\\':\\n                    continue\\n                    \\n                if e in row[i] or e in col[j] or e in box[box_index]:\\n                    return False\\n                else:\\n                    row[i].append(e)\\n                    col[j].append(e)\\n                    box[box_index].append(e)\\n                    \\n        return True\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \"\"\"\\n        Let\\'s keep tracking each element and see where they belong\\n        \"\"\"\\n        \\n        # Initialize tackers for each row, column and box\\n        row = {i: [] for i in range(9)}\\n        col = {i: [] for i in range(9)}\\n        box = {i: [] for i in range(9)}\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                box_index = (i // 3) * 3 + j // 3\\n                \\n                if e == \\'.\\':\\n                    continue\\n                    \\n                if e in row[i] or e in col[j] or e in box[box_index]:\\n                    return False\\n                else:\\n                    row[i].append(e)\\n                    col[j].append(e)\\n                    box[box_index].append(e)\\n                    \\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320921,
                "title": "python-clean-soln",
                "content": "```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        cols = defaultdict(set)\\n        rows = defaultdict(set)\\n        squares = defaultdict(set)\\n\\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \\'.\\':\\n                    continue\\n                if (board[r][c] in rows[r] or board[r][c] in cols[c] or\\n                        board[r][c] in squares[(r//3, c//3)]):\\n                    return False\\n\\n                rows[r].add(board[r][c])\\n                cols[c].add(board[r][c])\\n                squares[(r//3, c//3)].add(board[r][c])\\n\\n        return True\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        cols = defaultdict(set)\\n        rows = defaultdict(set)\\n        squares = defaultdict(set)\\n\\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \\'.\\':\\n                    continue\\n                if (board[r][c] in rows[r] or board[r][c] in cols[c] or\\n                        board[r][c] in squares[(r//3, c//3)]):\\n                    return False\\n\\n                rows[r].add(board[r][c])\\n                cols[c].add(board[r][c])\\n                squares[(r//3, c//3)].add(board[r][c])\\n\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1151068,
                "title": "python-clean-easy-solution",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        seen = set()\\n        for i in range(9):\\n            for j in range(9):\\n                number = str(board[i][j])\\n                if number != \\'.\\':\\n                    row = number +\\'in row\\' + str(i)\\n                    col = number +\\'in col\\' + str(j)\\n                    # // for integer\\n                    block = number +\\'in block\\' + str(i//3) + str(j//3)\\n                    if row in seen or col in seen or block in seen:\\n                        return False\\n                    seen.add(row)\\n                    seen.add(col)\\n                    seen.add(block)\\n        return True\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        seen = set()\\n        for i in range(9):\\n            for j in range(9):\\n                number = str(board[i][j])\\n                if number != \\'.\\':\\n                    row = number +\\'in row\\' + str(i)\\n                    col = number +\\'in col\\' + str(j)\\n                    # // for integer\\n                    block = number +\\'in block\\' + str(i//3) + str(j//3)\\n                    if row in seen or col in seen or block in seen:\\n                        return False\\n                    seen.add(row)\\n                    seen.add(col)\\n                    seen.add(block)\\n        return True\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 410216,
                "title": "easy-to-understand-c-solution-8ms-beats-98",
                "content": "Runtime: 8 ms, faster than 98.48% of C++ online submissions for Valid Sudoku.\\nMemory Usage: 9.8 MB, less than 58.97% of C++ online submissions for Valid Sudoku.\\n\\n```\\n bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        //check for each row\\n        for(int r=0; r<board.size(); r++)\\n        {\\n            vector<int> mpRow(10,0);\\n            for(int elem=0; elem < board[0].size(); elem++)\\n            {\\n                if(\\'1\\' <= board[r][elem] && board[r][elem] <= \\'9\\')\\n                    mpRow[board[r][elem]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpRow[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for each col\\n        for(int c=0; c<board[0].size(); c++)\\n        {\\n            vector<int> mpCol(10,0);\\n            for(int elem=0; elem < board.size(); elem++)\\n            {\\n                if(\\'1\\' <= board[elem][c] && board[elem][c] <= \\'9\\')\\n                    mpCol[board[elem][c]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpCol[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for 3*3 cells\\n        for(int i=0; i<9; i+=3)\\n        {\\n            for(int j=0; j<9; j+=3)\\n            {\\n                vector<int> mpBox(10,0);\\n                for(int k=i; k<i+3; k++)\\n                {\\n                    for(int l=j; l<j+3; l++)\\n                    {\\n                        if(\\'1\\' <= board[k][l] && board[k][l] <= \\'9\\')\\n                            mpBox[board[k][l]-\\'0\\']++;\\n                    }\\n                }\\n                \\n                for(int i=1; i<10; i++)\\n                {\\n                    if(mpBox[i] > 1)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Runtime: 8 ms, faster than 98.48% of C++ online submissions for Valid Sudoku.\\nMemory Usage: 9.8 MB, less than 58.97% of C++ online submissions for Valid Sudoku.\\n\\n```\\n bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        //check for each row\\n        for(int r=0; r<board.size(); r++)\\n        {\\n            vector<int> mpRow(10,0);\\n            for(int elem=0; elem < board[0].size(); elem++)\\n            {\\n                if(\\'1\\' <= board[r][elem] && board[r][elem] <= \\'9\\')\\n                    mpRow[board[r][elem]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpRow[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for each col\\n        for(int c=0; c<board[0].size(); c++)\\n        {\\n            vector<int> mpCol(10,0);\\n            for(int elem=0; elem < board.size(); elem++)\\n            {\\n                if(\\'1\\' <= board[elem][c] && board[elem][c] <= \\'9\\')\\n                    mpCol[board[elem][c]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpCol[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for 3*3 cells\\n        for(int i=0; i<9; i+=3)\\n        {\\n            for(int j=0; j<9; j+=3)\\n            {\\n                vector<int> mpBox(10,0);\\n                for(int k=i; k<i+3; k++)\\n                {\\n                    for(int l=j; l<j+3; l++)\\n                    {\\n                        if(\\'1\\' <= board[k][l] && board[k][l] <= \\'9\\')\\n                            mpBox[board[k][l]-\\'0\\']++;\\n                    }\\n                }\\n                \\n                for(int i=1; i<10; i++)\\n                {\\n                    if(mpBox[i] > 1)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 338064,
                "title": "javascript-13-lines-short-solution",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(), col = new Set(), sqr = new Set();\\n    for (let j = 0; j < 9; j++) {\\n      let rowc = board[i][j];\\n      let colc = board[j][i];\\n      let sqrc = board[Math.floor(i / 3) * 3 + Math.floor(j / 3)][(i % 3) * 3 + j % 3];\\n      if (row.has(rowc) || col.has(colc) || sqr.has(sqrc)) return false;\\n      if (rowc !== \".\") row.add(rowc);\\n      if (colc !== \".\") col.add(colc);\\n      if (sqrc !== \".\") sqr.add(sqrc);\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(), col = new Set(), sqr = new Set();\\n    for (let j = 0; j < 9; j++) {\\n      let rowc = board[i][j];\\n      let colc = board[j][i];\\n      let sqrc = board[Math.floor(i / 3) * 3 + Math.floor(j / 3)][(i % 3) * 3 + j % 3];\\n      if (row.has(rowc) || col.has(colc) || sqr.has(sqrc)) return false;\\n      if (rowc !== \".\") row.add(rowc);\\n      if (colc !== \".\") col.add(colc);\\n      if (sqrc !== \".\") sqr.add(sqrc);\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15455,
                "title": "simple-ruby-solution-using-sets",
                "content": "The idea is to initialize a set per collection of (1-9) characters that we care about (each row, each column, and each box) to ensure that there are no duplicate numbers, which would make the solution invalid.\\n\\n```\\ndef is_valid_sudoku(board)\\n    boxes = Array.new(3) { Array.new(3) { Set.new } }\\n    rows = Array.new(9) { Set.new }\\n    cols = Array.new(9) { Set.new }\\n    \\n    board.each_with_index do |array, row|\\n        array.each_with_index do |num, col|\\n            next if num == '.'\\n            return false unless boxes[row/3][col/3].add?(num) && rows[row].add?(num) && cols[col].add?(num)\\n        end\\n    end\\n    true\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef is_valid_sudoku(board)\\n    boxes = Array.new(3) { Array.new(3) { Set.new } }\\n    rows = Array.new(9) { Set.new }\\n    cols = Array.new(9) { Set.new }\\n    \\n    board.each_with_index do |array, row|\\n        array.each_with_index do |num, col|\\n            next if num == '.'\\n            return false unless boxes[row/3][col/3].add?(num) && rows[row].add?(num) && cols[col].add?(num)\\n        end\\n    end\\n    true\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3427605,
                "title": "simple-swift-solution-easy-to-understand",
                "content": "# Approach\\nThe solution iterates through each `row` of the board. For each `row`, it creates a new `set` to keep track of the digits seen so far. It then iterates through each cell of the `row` and checks if the cell is empty or not. If the cell is not empty, it checks if the digit already exists in the `set` or not. If the digit already exists in the `set`, it returns `false` as it violates the Sudoku rule. Otherwise, it adds the digit to the `set` and continues to the next cell. If the iteration completes without finding any violation, it continues to the next `row`.\\n\\nThe solution then iterates through each `column` of the board. For each `column`, it creates a new `set` to keep track of the digits seen so far. It then iterates through each cell of the `column` and checks if the cell is empty or not. If the cell is not empty, it checks if the digit already exists in the `set` or not. If the digit already exists in the `set`, it returns `false` as it violates the Sudoku rule. Otherwise, it adds the digit to the `set` and continues to the next cell. If the iteration completes without finding any violation, it continues to the next `column`.\\n\\nThe solution then iterates through each $$3 \\\\times 3$$ sub-box of the board. For each $$3 \\\\times 3$$ sub-box, it creates a new `set` to keep track of the digits seen so far. It then iterates through each cell of the sub-box and checks if the cell is empty or not. If the cell is not empty, it checks if the digit already exists in the `set` or not. If the digit already exists in the `set`, it returns `false` as it violates the Sudoku rule. Otherwise, it adds the digit to the `set` and continues to the next cell. If the iteration completes without finding any violation, it continues to the next $$3 \\\\times 3$$ sub-box.\\n\\nIf the solution completes all iterations without finding any violation, it returns `true` indicating that the board is a valid Sudoku board. Otherwise, it returns `false` indicating that the board is not valid.\\n\\n# Complexity\\nThe *time complexity* of the given solution is $$O(n^2)$$, where $$n$$ is the number of cells in the Sudoku board.\\n\\nThe *space complexity* of the solution is $$O(n)$$, where $$n$$ is the number of cells in the Sudoku board.\\n\\n# Code\\n```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for j in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for j in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for k in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in k / 3 * 3 ..< k / 3 * 3 + 3 {\\n                for j in k % 3 * 3 ..< k % 3 * 3 + 3 {\\n                    if board[i][j] != \".\", set.contains(board[i][j]) {\\n                        return false\\n                    }\\n                    set.insert(board[i][j])\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/241e5676-737d-4137-ab6b-440f1d715ee1_1681748155.5014086.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for j in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for j in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for k in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in k / 3 * 3 ..< k / 3 * 3 + 3 {\\n                for j in k % 3 * 3 ..< k % 3 * 3 + 3 {\\n                    if board[i][j] != \".\", set.contains(board[i][j]) {\\n                        return false\\n                    }\\n                    set.insert(board[i][j])\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140050,
                "title": "simple-java-c-easy-readable-3-lines-code-100-working",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet <String> seen = new HashSet <>();\\n        \\n        for (int i = 0; i < 9; i ++) {\\n            for (int j = 0; j < 9; j ++) {\\n                char cur = board[i][j];\\n                if(cur != \\'.\\') if(!seen.add(cur + \"row\" + i)||!seen.add(cur + \"col\" + j)||!seen.add(cur + \"grid\" + i / 3 + \"-\" + j / 3)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet <String> seen = new HashSet <>();\\n        \\n        for (int i = 0; i < 9; i ++) {\\n            for (int j = 0; j < 9; j ++) {\\n                char cur = board[i][j];\\n                if(cur != \\'.\\') if(!seen.add(cur + \"row\" + i)||!seen.add(cur + \"col\" + j)||!seen.add(cur + \"grid\" + i / 3 + \"-\" + j / 3)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843298,
                "title": "python-3-explained-solution-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking for each row if a value doesn\\'t repeat \\n        for row in range(9): #for each row\\n            row_values=[] #we create a list of values that are in the row\\n            for col in range(9): #we go through each column\\n                if board[row][col] != \".\": #if there is a number \\n                    if board[row][col] in row_values: #and the number is already in the list of values that are in the row => repetition \\n                        return False #sudoku is not valid\\n                    row_values.append(board[row][col]) #if the number is not in the list of values that are in the row, we add it\\n                    \\n        #checking for each col if a value doesn\\'t repeat\\n        for col in range(9): #for each column\\n            col_values=[] #we create a list of values that are in the column\\n            for row in range(9): #we go through each row\\n                if board[row][col] != \".\": #if there is a number\\n                    if board[row][col] in col_values: #and the number is already in the list of values that are in the column => repetition\\n                        return False #sudoku is not valid \\n                    col_values.append(board[row][col]) #if the number is not in the list of values that are in the column, we add it\\n    \\n        #checking for each 3*3 squares\\n        #the combination of squares are : \\n\\t\\t#[0,1,2][0,1,2] [0,1,2][3,4,5] [0,1,2][6,7,8]\\n\\t\\t#[3,4,5][0,1,2] [3,4,5][3,4,5] [3,4,5][6,7,8]\\n\\t\\t#[6,7,8][0,1,2] [6,7,8][3,4,5] [6,7,8][6,7,8]\\n\\t\\tlist = [[0,1,2], [3,4,5], [6,7,8]] \\n\\t\\t#those squares are the combination of the same indexes so we create a list to iterate upon with i and j\\n        for i in range(3): \\n            for j in range(3):\\n                square_values = [] #for each square we create a list of value that are in the square\\n                for col in list[i]: #we\\'re gonna go through 3 columns (1st : col 0, col 1 & col 2, then : col 3, col 4 & col 5 and finally : col 6, col 7, col 8)\\n                    for row in list[j]:#and 3 rows (1st : row 0, row 1 & row 2, then : row 3, row 4 & row 5 and finally : row 6, row 7, row 8)\\n                        if board[row][col] != \".\": #if there is a number \\n                            if board[row][col] in square_values: #and the number is already in the list of values that are in the square\\n                                return False #sudoku isn\\'t valid\\n                            square_values.append(board[row][col]) #if the number is not in the list of values that are in the square, we add it \\n        \\n        return True #if we could not find invalid sudoku in those 3 cases, then sudoku is valid\\n```\\nPlease upvote if it does help ! :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking for each row if a value doesn\\'t repeat \\n        for row in range(9): #for each row\\n            row_values=[] #we create a list of values that are in the row\\n            for col in range(9): #we go through each column\\n                if board[row][col] != \".\": #if there is a number \\n                    if board[row][col] in row_values: #and the number is already in the list of values that are in the row => repetition \\n                        return False #sudoku is not valid\\n                    row_values.append(board[row][col]) #if the number is not in the list of values that are in the row, we add it\\n                    \\n        #checking for each col if a value doesn\\'t repeat\\n        for col in range(9): #for each column\\n            col_values=[] #we create a list of values that are in the column\\n            for row in range(9): #we go through each row\\n                if board[row][col] != \".\": #if there is a number\\n                    if board[row][col] in col_values: #and the number is already in the list of values that are in the column => repetition\\n                        return False #sudoku is not valid \\n                    col_values.append(board[row][col]) #if the number is not in the list of values that are in the column, we add it\\n    \\n        #checking for each 3*3 squares\\n        #the combination of squares are : \\n\\t\\t#[0,1,2][0,1,2] [0,1,2][3,4,5] [0,1,2][6,7,8]\\n\\t\\t#[3,4,5][0,1,2] [3,4,5][3,4,5] [3,4,5][6,7,8]\\n\\t\\t#[6,7,8][0,1,2] [6,7,8][3,4,5] [6,7,8][6,7,8]\\n\\t\\tlist = [[0,1,2], [3,4,5], [6,7,8]] \\n\\t\\t#those squares are the combination of the same indexes so we create a list to iterate upon with i and j\\n        for i in range(3): \\n            for j in range(3):\\n                square_values = [] #for each square we create a list of value that are in the square\\n                for col in list[i]: #we\\'re gonna go through 3 columns (1st : col 0, col 1 & col 2, then : col 3, col 4 & col 5 and finally : col 6, col 7, col 8)\\n                    for row in list[j]:#and 3 rows (1st : row 0, row 1 & row 2, then : row 3, row 4 & row 5 and finally : row 6, row 7, row 8)\\n                        if board[row][col] != \".\": #if there is a number \\n                            if board[row][col] in square_values: #and the number is already in the list of values that are in the square\\n                                return False #sudoku isn\\'t valid\\n                            square_values.append(board[row][col]) #if the number is not in the list of values that are in the square, we add it \\n        \\n        return True #if we could not find invalid sudoku in those 3 cases, then sudoku is valid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841289,
                "title": "c-using-set-comments-added-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) \\n    {\\n        map<int,set<int>> rows;                                      // for keep cheking the previous row value\\n        map<int,set<int>> cols;                                       // for keep cheking the previous col value\\n        map<pair<int,int>,set<int>> subBox;                 // for keep cheking the previous curr 3x3 matrix value by pair\\n        \\n        for(int r=0;r<9;r++)                                              // each row\\n        {\\n            for(int c=0;c<9;c++)                                        // each col\\n            {\\n                // if it is . skip it\\n                if(board[r][c]==\\'.\\') continue;\\n                \\n                // if we found current value previously then return false\\n                \\n                // Check row\\n                if(rows[r].find(board[r][c]-\\'0\\') != rows[r].end())\\n                    return false;\\n                \\n                // check col\\n                if(cols[c].find(board[r][c]-\\'0\\') != cols[c].end())\\n                    return false;\\n                \\n                // check sub boxes\\n\\t\\t\\t\\t// (r/3,c/3) will tell the curr sub Box as we are taking them from (0,0) to (2,2)\\n                if(subBox[{r/3,c/3}].find(board[r][c]-\\'0\\') != subBox[{r/3,c/3}].end())\\n                    return false;\\n                \\n                \\n                // if none of then return false then add curr board value to the declared set for next check\\n                rows[r].insert(board[r][c]-\\'0\\');\\n                cols[c].insert(board[r][c]-\\'0\\');\\n                subBox[{r/3,c/3}].insert(board[r][c]-\\'0\\');\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) \\n    {\\n        map<int,set<int>> rows;                                      // for keep cheking the previous row value\\n        map<int,set<int>> cols;                                       // for keep cheking the previous col value\\n        map<pair<int,int>,set<int>> subBox;                 // for keep cheking the previous curr 3x3 matrix value by pair\\n        \\n        for(int r=0;r<9;r++)                                              // each row\\n        {\\n            for(int c=0;c<9;c++)                                        // each col\\n            {\\n                // if it is . skip it\\n                if(board[r][c]==\\'.\\') continue;\\n                \\n                // if we found current value previously then return false\\n                \\n                // Check row\\n                if(rows[r].find(board[r][c]-\\'0\\') != rows[r].end())\\n                    return false;\\n                \\n                // check col\\n                if(cols[c].find(board[r][c]-\\'0\\') != cols[c].end())\\n                    return false;\\n                \\n                // check sub boxes\\n\\t\\t\\t\\t// (r/3,c/3) will tell the curr sub Box as we are taking them from (0,0) to (2,2)\\n                if(subBox[{r/3,c/3}].find(board[r][c]-\\'0\\') != subBox[{r/3,c/3}].end())\\n                    return false;\\n                \\n                \\n                // if none of then return false then add curr board value to the declared set for next check\\n                rows[r].insert(board[r][c]-\\'0\\');\\n                cols[c].insert(board[r][c]-\\'0\\');\\n                subBox[{r/3,c/3}].insert(board[r][c]-\\'0\\');\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840703,
                "title": "c-hashset-faster-easy-to-understand",
                "content": "* ***Using Hashset***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& mat) {\\n        \\n        // declare a set\\n        \\n        unordered_set<string> s;\\n        \\n        // box number for any cell [i, j] is (i / 3) * + j / 3, taking (3 * 3) boxes\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(mat[i][j] != \\'.\\')\\n                {\\n                    // if the curr number is already present in set\\n                    \\n                    if(s.count(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                \\n                    if(s.count(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                         return false;\\n                    }\\n                \\n                    if(s.count(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    // insert the curr number in set with row no., col no., box no.\\n                \\n                    s.insert(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& mat) {\\n        \\n        // declare a set\\n        \\n        unordered_set<string> s;\\n        \\n        // box number for any cell [i, j] is (i / 3) * + j / 3, taking (3 * 3) boxes\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(mat[i][j] != \\'.\\')\\n                {\\n                    // if the curr number is already present in set\\n                    \\n                    if(s.count(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                \\n                    if(s.count(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                         return false;\\n                    }\\n                \\n                    if(s.count(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    // insert the curr number in set with row no., col no., box no.\\n                \\n                    s.insert(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423241,
                "title": "c-best-explanation-simple-100-faster",
                "content": "**Approach**\\n**1. Brute Force**\\n(a) - You can use 3 nested loops \\n(b) - For checking rows,column and box seperately.\\n\\n**2. Using a Single loop**\\n(a) - Make vectors of sets.\\n(b) - Each vector contain 9 sets. i.e, *9 set for rows, 9 set for column & 9 for box.*\\n(c) - Check if element is present in the box or not.\\n(d) - If Present, **return false**.\\n(e) - If Not Present, insert it into set and check for next element.\\n\\n`For accessing box set we use this formula  (i/3)*3 + (j/3)`\\n\\n![image](https://assets.leetcode.com/users/images/740929b0-0a47-4a0f-bd75-cc83920148c2_1660460466.4924154.jpeg)\\n\\n**Code :-**\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        vector<set<int>> row(9),col(9),box(9);\\n        \\n        for(int i=0;i< 9;i++)\\n        {\\n            for(int j = 0;j < 9;j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'0\\';\\n                    \\n                    if(row[i].count(num) || col[j].count(num) || box[(i/3)*3 + (j/3)].count(num))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    row[i].insert(num);\\n                    col[j].insert(num);\\n                    box[(i/3)*3 + (j/3)].insert(num);\\n            \\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        vector<set<int>> row(9),col(9),box(9);\\n        \\n        for(int i=0;i< 9;i++)\\n        {\\n            for(int j = 0;j < 9;j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'0\\';\\n                    \\n                    if(row[i].count(num) || col[j].count(num) || box[(i/3)*3 + (j/3)].count(num))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    row[i].insert(num);\\n                    col[j].insert(num);\\n                    box[(i/3)*3 + (j/3)].insert(num);\\n            \\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151963,
                "title": "c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        unordered_map<string, int> seen;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                int element = board[i][j];\\n                // skip if the cell is not filled\\n                if(element == \\'.\\')\\n                    continue;\\n                \\n                // string for each element found at a row to store in hashmap\\n                string rowFind = to_string(element) + \"found at row\" + to_string(i);\\n                \\n                // string for each element found at a column to store in hashmap\\n                string colFind = to_string(element) + \"found at column\" + to_string(j);\\n                \\n                // string for each element found at a sub-box to store in hashmap\\n                string boxFind = to_string(element) + \"found at box\" + to_string(i/3) + \\'-\\' + to_string(j/3);\\n                \\n                // checking if those are already inside hashmap, if not we\\'ll be putting em into hashmap\\n                if(seen.find(rowFind) != seen.end() ||\\n                   seen.find(colFind) != seen.end() ||\\n                   seen.find(boxFind) != seen.end()){\\n                    return false;\\n                }\\n                else{\\n                    seen[rowFind]++;\\n                    seen[colFind]++;\\n                    seen[boxFind]++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        unordered_map<string, int> seen;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                int element = board[i][j];\\n                // skip if the cell is not filled\\n                if(element == \\'.\\')\\n                    continue;\\n                \\n                // string for each element found at a row to store in hashmap\\n                string rowFind = to_string(element) + \"found at row\" + to_string(i);\\n                \\n                // string for each element found at a column to store in hashmap\\n                string colFind = to_string(element) + \"found at column\" + to_string(j);\\n                \\n                // string for each element found at a sub-box to store in hashmap\\n                string boxFind = to_string(element) + \"found at box\" + to_string(i/3) + \\'-\\' + to_string(j/3);\\n                \\n                // checking if those are already inside hashmap, if not we\\'ll be putting em into hashmap\\n                if(seen.find(rowFind) != seen.end() ||\\n                   seen.find(colFind) != seen.end() ||\\n                   seen.find(boxFind) != seen.end()){\\n                    return false;\\n                }\\n                else{\\n                    seen[rowFind]++;\\n                    seen[colFind]++;\\n                    seen[boxFind]++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527978,
                "title": "java-short-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    if(!set.add(\"row\" + i+ board[i][j]) || !set.add(\"col\" + j + board[i][j]) || !set.add(\"box\" + (i/3) *3+j/3 + board[i][j] )){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    if(!set.add(\"row\" + i+ board[i][j]) || !set.add(\"col\" + j + board[i][j]) || !set.add(\"box\" + (i/3) *3+j/3 + board[i][j] )){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462256,
                "title": "js-set-time-and-space-o-1",
                "content": "```\\n\\n//approach: using set\\n//as I loop through the board\\'s col and row, I will make sure to put the element inside the set\\n//we know same row, col and the subBox cannot have the same value more than once, if it does, return false\\n\\nvar isValidSudoku = function(board) {\\n    let set = new Set();\\n    \\n    for(let r = 0; r < board.length; r++){\\n        for(let c = 0; c < board[r].length; c++){\\n            let val = board[r][c];\\n            \\n            if(val === \\'.\\')\\n                continue;\\n            \\n            //basically, formula is 3 * row + col --> to turn 2d array into 1d array\\n            //using Math.floor(row/3) + Math.floor(col/3) --> so we can find row and col of our sub box \\n            let boxNum = 3 * Math.floor(r/3) + Math.floor(c/3);\\n            \\n            let inRow = `row: ${r}, value: ${val}`;\\n            let inCol = `col: ${c}, value: ${val}`;\\n            let inSubBox = `subBox: ${boxNum}, value: ${val}`;\\n            \\n            if(set.has(inRow) || set.has(inCol) || set.has(inSubBox))\\n                return false;\\n            \\n            set.add(inRow);\\n            set.add(inCol);\\n            set.add(inSubBox);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n\\n//approach: using set\\n//as I loop through the board\\'s col and row, I will make sure to put the element inside the set\\n//we know same row, col and the subBox cannot have the same value more than once, if it does, return false\\n\\nvar isValidSudoku = function(board) {\\n    let set = new Set();\\n    \\n    for(let r = 0; r < board.length; r++){\\n        for(let c = 0; c < board[r].length; c++){\\n            let val = board[r][c];\\n            \\n            if(val === \\'.\\')\\n                continue;\\n            \\n            //basically, formula is 3 * row + col --> to turn 2d array into 1d array\\n            //using Math.floor(row/3) + Math.floor(col/3) --> so we can find row and col of our sub box \\n            let boxNum = 3 * Math.floor(r/3) + Math.floor(c/3);\\n            \\n            let inRow = `row: ${r}, value: ${val}`;\\n            let inCol = `col: ${c}, value: ${val}`;\\n            let inSubBox = `subBox: ${boxNum}, value: ${val}`;\\n            \\n            if(set.has(inRow) || set.has(inCol) || set.has(inSubBox))\\n                return false;\\n            \\n            set.add(inRow);\\n            set.add(inCol);\\n            set.add(inSubBox);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 684745,
                "title": "98-5-time-python3-using-prime-numbers",
                "content": "Assign each value (1-9) to a unique prime number, doesn\\'t matter which.\\n\\nFor each container, e.g. row,col, or box, assign its value to be the product of all the chosen primes.\\n\\nWhen you encounter a value x in some container, divide that container\\'s value by x. If this division results in a non-zero remainder, you know the container is invalid. This works because the remainder will only be nonzero if we\\'ve divided by x more than once. \\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        primes = [2,3,5,7,11,13,17,19,23]\\n        prod = 1\\n        for p in primes:\\n            prod *= p\\n        boxes = [prod] * 9\\n        rows = [prod] * 9\\n        cols = [prod] * 9\\n        for r in range(9):\\n            for c in range(9):\\n                s = board[r][c]\\n                if s == \".\":\\n                    continue\\n                b = (r // 3) * 3 + c // 3\\n                p = primes[int(s)-1]\\n                if boxes[b] % p != 0:\\n                    return False\\n                boxes[b] /= p\\n                if rows[r] % p != 0:\\n                    return False\\n                rows[r] /= p\\n                if cols[c] % p != 0:\\n                    return False\\n                cols[c] /= p\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        primes = [2,3,5,7,11,13,17,19,23]\\n        prod = 1\\n        for p in primes:\\n            prod *= p\\n        boxes = [prod] * 9\\n        rows = [prod] * 9\\n        cols = [prod] * 9\\n        for r in range(9):\\n            for c in range(9):\\n                s = board[r][c]\\n                if s == \".\":\\n                    continue\\n                b = (r // 3) * 3 + c // 3\\n                p = primes[int(s)-1]\\n                if boxes[b] % p != 0:\\n                    return False\\n                boxes[b] /= p\\n                if rows[r] % p != 0:\\n                    return False\\n                rows[r] /= p\\n                if cols[c] % p != 0:\\n                    return False\\n                cols[c] /= p\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15552,
                "title": "python-solution-simple-and-fast",
                "content": "    class Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n    \\n        map_row = [{} for _ in xrange(9)]\\n        map_col = [{} for _ in xrange(9)]\\n        map_cell = [[{} for _ in xrange(3)] for __ in xrange(3)]\\n        for i in xrange(9):\\n            for j in xrange(9):\\n                char = board[i][j]\\n                if char == '.': continue\\n                if char in map_row[i]: return False\\n                else: map_row[i][char] = [i,j]\\n                if char in map_col[j]: return False\\n                else: map_col[j][char] = [i,j]\\n                if char in map_cell[i/3][j/3]: return False\\n                else: map_cell[i/3][j/3][char] = [i,j]\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n    \\n        map_row = [{}",
                "codeTag": "Java"
            },
            {
                "id": 4073241,
                "title": "simple-java-solutions-runtime-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java\\nclass Solution {\\n   public boolean isValidSudoku(char[][] board) {\\n\\n         for (int i = 0; i < 9; i++) {\\n            HashSet<Character> RowSet = new HashSet<>();\\n            HashSet<Character> ColSet = new HashSet<>();\\n            for (int j = 0; j < 9; j++) {\\n                char r = board[i][j];\\n                char c = board[j][i];\\n                if ( (r != \\'.\\' && !RowSet.add(r) ) || (c != \\'.\\' && !ColSet.add(c))) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < 9; i = i + 3) {\\n            for (int j = 0; j < 9; j = j + 3) {\\n                if (!checkBlock(i, j, board))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static boolean checkBlock(int IdI, int IdJ, char[][] boards) {\\n        HashSet<Character> set = new HashSet<>();\\n\\n        int rows = IdI + 3;\\n        int cols = IdJ + 3;\\n        for (int i = IdI; i < rows; i++) {\\n            for (int j = IdJ; j < cols; j++) {\\n                char c = boards[i][j];\\n                if (c != \\'.\\' && !set.add(c)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/19750e74-99dc-4312-82af-f5aaa467fe64_1695313499.690562.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n   public boolean isValidSudoku(char[][] board) {\\n\\n         for (int i = 0; i < 9; i++) {\\n            HashSet<Character> RowSet = new HashSet<>();\\n            HashSet<Character> ColSet = new HashSet<>();\\n            for (int j = 0; j < 9; j++) {\\n                char r = board[i][j];\\n                char c = board[j][i];\\n                if ( (r != \\'.\\' && !RowSet.add(r) ) || (c != \\'.\\' && !ColSet.add(c))) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < 9; i = i + 3) {\\n            for (int j = 0; j < 9; j = j + 3) {\\n                if (!checkBlock(i, j, board))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static boolean checkBlock(int IdI, int IdJ, char[][] boards) {\\n        HashSet<Character> set = new HashSet<>();\\n\\n        int rows = IdI + 3;\\n        int cols = IdJ + 3;\\n        for (int i = IdI; i < rows; i++) {\\n            for (int j = IdJ; j < cols; j++) {\\n                char c = boards[i][j];\\n                if (c != \\'.\\' && !set.add(c)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842282,
                "title": "brute-force-c-solution-working-fine",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char, int> mp;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\')\\n                mp[board[i][j]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[j][i] != \\'.\\')\\n                mp[board[j][i]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n        for(int m=0; m<9; m+=3){\\n            for(int i=0; i<9; i+=3){\\n                for(int j=m; j<m+3; j++){\\n                    for(int k=i; k<i+3; k++){\\n                        if(board[j][k] != \\'.\\')\\n                        mp[board[j][k]]++;\\n                    }\\n                }\\n                for(auto x : mp){\\n                    if(x.second > 1)\\n                    return false;\\n                }\\n                mp.clear();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char, int> mp;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\')\\n                mp[board[i][j]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[j][i] != \\'.\\')\\n                mp[board[j][i]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n        for(int m=0; m<9; m+=3){\\n            for(int i=0; i<9; i+=3){\\n                for(int j=m; j<m+3; j++){\\n                    for(int k=i; k<i+3; k++){\\n                        if(board[j][k] != \\'.\\')\\n                        mp[board[j][k]]++;\\n                    }\\n                }\\n                for(auto x : mp){\\n                    if(x.second > 1)\\n                    return false;\\n                }\\n                mp.clear();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841489,
                "title": "rust-iterators-14-lines-4mc",
                "content": "```\\nfn uniq<\\'a>(it: impl Iterator<Item = &\\'a char>) -> bool {\\n    let mut v = [0; 10];\\n    it.filter_map(|c| c.to_digit(10))\\n        .for_each(|c| v[c as usize] += 1);\\n    v.iter().all(|&v| v < 2)\\n}\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let block_it = |i, j| board[i..i + 3].iter().flat_map(move |row| &row[j..j + 3]);\\n\\n        (0..3).all(|i| (0..3).all(|j| uniq(block_it(i * 3, j * 3))))\\n            && (0..9).all(|i| uniq(board.iter().map(|row| &row[i])))\\n            && board.iter().map(|v| v.iter()).all(uniq)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nfn uniq<\\'a>(it: impl Iterator<Item = &\\'a char>) -> bool {\\n    let mut v = [0; 10];\\n    it.filter_map(|c| c.to_digit(10))\\n        .for_each(|c| v[c as usize] += 1);\\n    v.iter().all(|&v| v < 2)\\n}\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let block_it = |i, j| board[i..i + 3].iter().flat_map(move |row| &row[j..j + 3]);\\n\\n        (0..3).all(|i| (0..3).all(|j| uniq(block_it(i * 3, j * 3))))\\n            && (0..9).all(|i| uniq(board.iter().map(|row| &row[i])))\\n            && board.iter().map(|v| v.iter()).all(uniq)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807940,
                "title": "easy-c-solution-explanation-in-simple-hinglish-for-intuition",
                "content": "Pure sudoku board ko 9 boxes/grid mein divide kar do aur numbering 0 to 8 kar do\\n0 1 2\\n3 4 5 \\n6 7 8\\n\\nHar ek box ek grid ki tarah hai to ab usko calculate karne ka formula hai :=\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(row/3)*3+(col/3)\\n\\npure ke pure value ko string bana ke attach kar do= \"ROW+row_val+element\".....\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tsimilarly column aur box ke liye karo.\\n\\nFir set mein check karo kya pehle se row ya col ya grid ka strings set mein h?? \\nAgar hai to false return kar do nai to insert kar do.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<string> s;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(board[i][j]!=\\'.\\')\\n                {\\n                    string row=\"row\"+to_string(i)+board[i][j];\\n                    string col=\"col\"+to_string(j)+board[i][j];\\n                    string box=\"box\"+to_string((i/3)*3+(j/3))+board[i][j];\\n                    \\n                    if(s.find(row)==s.end() && s.find(col)==s.end() && s.find(box)==s.end())\\n                    {\\n                        s.insert(row);\\n                        s.insert(col);\\n                        s.insert(box);\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<string> s;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(board[i][j]!=\\'.\\')\\n                {\\n                    string row=\"row\"+to_string(i)+board[i][j];\\n                    string col=\"col\"+to_string(j)+board[i][j];\\n                    string box=\"box\"+to_string((i/3)*3+(j/3))+board[i][j];\\n                    \\n                    if(s.find(row)==s.end() && s.find(col)==s.end() && s.find(box)==s.end())\\n                    {\\n                        s.insert(row);\\n                        s.insert(col);\\n                        s.insert(box);\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504217,
                "title": "python-hashset-simple-solution",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Validate each row\\n        for r in range(9):\\n            hashSet = set()\\n            for c in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each column\\n        for c in range(9):\\n            hashSet = set()\\n            for r in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each box\\n        r, c = 0, 0\\n        while True:\\n            hashSet = set()\\n            for i in range(r, r+3):\\n                for j in range(c, c+3):\\n                    if board[i][j] != \\'.\\':\\n                        if board[i][j] in hashSet:\\n                            return False\\n                        hashSet.add(board[i][j])\\n            c += 3\\n            if c == 9:\\n                r += 3\\n                # Break if we have verified all 9 boxes\\n                if r == 9:\\n                    break\\n                c = 0\\n        return True\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Validate each row\\n        for r in range(9):\\n            hashSet = set()\\n            for c in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each column\\n        for c in range(9):\\n            hashSet = set()\\n            for r in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each box\\n        r, c = 0, 0\\n        while True:\\n            hashSet = set()\\n            for i in range(r, r+3):\\n                for j in range(c, c+3):\\n                    if board[i][j] != \\'.\\':\\n                        if board[i][j] in hashSet:\\n                            return False\\n                        hashSet.add(board[i][j])\\n            c += 3\\n            if c == 9:\\n                r += 3\\n                # Break if we have verified all 9 boxes\\n                if r == 9:\\n                    break\\n                c = 0\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488448,
                "title": "c-just-12-lines-of-code-no-space-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& ar) {\\n        \\n        for(int i=0;i<ar.size();i++)\\n            for(int j=0;j<ar.size();j++)\\n                if(ar[i][j] != \\'.\\'){\\n                    for(int k=0;k<9;k++)\\n                        if( (i!=k && ar[k][j]==ar[i][j]) || (j!=k && ar[i][k]==ar[i][j]) )\\n                            return 0;\\n                    for(int row=3*(i/3); row<3*(i/3)+3; row++)\\n                        for(int col=3*(j/3); col<3*(j/3)+3; col++)\\n                            if( (row!=i || col!=j) && ar[row][col]==ar[i][j])\\n                                return 0;\\n                }\\n        return 1;\\n    }\\n};\\n\\nHit like if found helpful : )",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& ar) {\\n        \\n        for(int i=0;i<ar.size();i++)\\n            for(int j=0;j<ar.size();j++)\\n                if(ar[i][j] != \\'.\\'){\\n                    for(int k=0;k<9;k++)\\n                        if( (i!=k && ar[k][j]==ar[i][j]) || (j!=k && ar[i][k]==ar[i][j]) )\\n                            return 0;\\n                    for(int row=3*(i/3); row<3*(i/3)+3; row++)\\n                        for(int col=3*(j/3); col<3*(j/3)+3; col++)\\n                            if( (row!=i || col!=j) && ar[row][col]==ar[i][j])\\n                                return 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1471156,
                "title": "1ms-java-solution-brute-force-hashmap-hashset",
                "content": "**HashMap**\\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<9; i++)\\n            for(int j=0; j<9; j++)\\n                if(board[i][j] != \\'.\\') {\\n                    \\n                    String row = board[i][j] + \" row \" + i;\\n                    String col = board[i][j] + \" col \" + j;\\n                    String box = board[i][j] + \" box \" + i/3 + \"and\" + j/3;\\n                    \\n                    map.put(row, map.getOrDefault(row, 0) + 1);\\n                    map.put(col, map.getOrDefault(col, 0) + 1);\\n                    map.put(box, map.getOrDefault(box, 0) + 1);\\n                    \\n                    if(map.get(row) > 1 || map.get(col) > 1 || map.get(box) > 1)\\n                        return false;\\n                }\\n                \\n        return true;\\n    }\\n```\\nSimilarly, You can implement this using HahsSet.\\n\\n**Brute force**\\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] box = new boolean[9][9];\\n        \\n        for (int i = 0; i < 9; i++)\\n            for (int j = 0; j < 9; j++)\\n                if (board[i][j] != \\'.\\') {\\n                    \\n                    int n = board[i][j] - \\'1\\';\\n                    \\n                    if (row[n][i]) \\n                        return false;\\n                    row[n][i] = true;\\n                    \\n                    if (col[n][j]) \\n                        return false;\\n                    col[n][j] = true;\\n                    \\n                    int bi = (i / 3) * 3 + (j / 3);\\n                    \\n                    if (box[n][bi]) \\n                        return false;\\n                    box[n][bi] = true;\\n                }\\n                \\n        return true;\\n    }\\n```\\n\\n**Please UPVOTE ^ If this post is useful for you.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean isValidSudoku(char[][] board) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<9; i++)\\n            for(int j=0; j<9; j++)\\n                if(board[i][j] != \\'.\\') {\\n                    \\n                    String row = board[i][j] + \" row \" + i;\\n                    String col = board[i][j] + \" col \" + j;\\n                    String box = board[i][j] + \" box \" + i/3 + \"and\" + j/3;\\n                    \\n                    map.put(row, map.getOrDefault(row, 0) + 1);\\n                    map.put(col, map.getOrDefault(col, 0) + 1);\\n                    map.put(box, map.getOrDefault(box, 0) + 1);\\n                    \\n                    if(map.get(row) > 1 || map.get(col) > 1 || map.get(box) > 1)\\n                        return false;\\n                }\\n                \\n        return true;\\n    }\\n```\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] box = new boolean[9][9];\\n        \\n        for (int i = 0; i < 9; i++)\\n            for (int j = 0; j < 9; j++)\\n                if (board[i][j] != \\'.\\') {\\n                    \\n                    int n = board[i][j] - \\'1\\';\\n                    \\n                    if (row[n][i]) \\n                        return false;\\n                    row[n][i] = true;\\n                    \\n                    if (col[n][j]) \\n                        return false;\\n                    col[n][j] = true;\\n                    \\n                    int bi = (i / 3) * 3 + (j / 3);\\n                    \\n                    if (box[n][bi]) \\n                        return false;\\n                    box[n][bi] = true;\\n                }\\n                \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1415732,
                "title": "kotlin-simple-easy-and-short-solution",
                "content": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n        val rowRecord = Array(9) { mutableSetOf<Char>() }\\n        val columnRecord = Array(9) { mutableSetOf<Char>() }\\n        val subBoxRecord = Array(9) { mutableSetOf<Char>() }\\n\\n        board.forEachIndexed { rowIndex, chars ->\\n            chars.forEachIndexed { columnIndex, c ->\\n                if (c in \\'1\\'..\\'9\\') {\\n                    val subBoxIndex = rowIndex / 3 * 3 + columnIndex / 3\\n                    if (!rowRecord[rowIndex].add(c)\\n                        || !columnRecord[columnIndex].add(c)\\n                        || !subBoxRecord[subBoxIndex].add(c)) {\\n                        return false\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n        val rowRecord = Array(9) { mutableSetOf<Char>() }\\n        val columnRecord = Array(9) { mutableSetOf<Char>() }\\n        val subBoxRecord = Array(9) { mutableSetOf<Char>() }\\n\\n        board.forEachIndexed { rowIndex, chars ->\\n            chars.forEachIndexed { columnIndex, c ->\\n                if (c in \\'1\\'..\\'9\\') {\\n                    val subBoxIndex = rowIndex / 3 * 3 + columnIndex / 3\\n                    if (!rowRecord[rowIndex].add(c)\\n                        || !columnRecord[columnIndex].add(c)\\n                        || !subBoxRecord[subBoxIndex].add(c)) {\\n                        return false\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700753,
                "title": "python-solution",
                "content": "The goal of this problem is to check if the current board is valid or not.\\nLet\\'s define what it means to be valid in a game of sudoku:\\n1. Each row should have unique numbers from 1 - 9\\n2. Each column should have unique numbers from 1 - 9\\n3. Each box should have unique numbers from 1 - 9\\n\\nThus, this means if we hold the values of each row, column, and box and check for duplicates, we will be able to check if the board is valid or not.\\nThe trickiest part would be to check the duplicate values for each box.\\nOne way to do this would be to name each box as 0~8, and consider the box as (row // 3)*3 + (col // 3).\\n\\n```\\ndef isValidSudoku(self, board):\\n\\trows = [set() for i in range(9)]\\n\\tcols = [set() for i in range(9)]\\n\\tboxes = [set() for i in range(9)]\\n\\t#quadrant = (row / 3) * 3 + (col / 3)\\n\\tfor row in range(len(board)):\\n\\t\\tfor col in range(len(board)):\\n\\t\\t\\tif board[row][col] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tnumber = board[row][col]\\n\\t\\t\\tbox = (row // 3) * 3 + col // 3\\n\\t\\t\\tif number in rows[row] or number in cols[col] or number in boxes[box]:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\trows[row].add(number)\\n\\t\\t\\tcols[col].add(number)\\n\\t\\t\\tboxes[box].add(number)\\n\\treturn True\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef isValidSudoku(self, board):\\n\\trows = [set() for i in range(9)]\\n\\tcols = [set() for i in range(9)]\\n\\tboxes = [set() for i in range(9)]\\n\\t#quadrant = (row / 3) * 3 + (col / 3)\\n\\tfor row in range(len(board)):\\n\\t\\tfor col in range(len(board)):\\n\\t\\t\\tif board[row][col] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tnumber = board[row][col]\\n\\t\\t\\tbox = (row // 3) * 3 + col // 3\\n\\t\\t\\tif number in rows[row] or number in cols[col] or number in boxes[box]:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\trows[row].add(number)\\n\\t\\t\\tcols[col].add(number)\\n\\t\\t\\tboxes[box].add(number)\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 304054,
                "title": "java-beats-100",
                "content": "```java\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int[] rows = new int[9], cols = new int[9], squares = new int[9];\\n        for(int r=0; r<board.length; r++){\\n            for(int c=0; c<board[0].length; c++){\\n                if(board[r][c] != \\'.\\'){\\n                    int value = (1 << (board[r][c] - \\'1\\'));\\n                    if((value & rows[r]) > 0 || (value & cols[c]) > 0 || (value & squares[3*(r/3)+c/3]) > 0) return false;\\n                    rows[r] |= value;\\n                    cols[c] |= value;\\n                    squares[3*(r/3)+c/3] |= value;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int[] rows = new int[9], cols = new int[9], squares = new int[9];\\n        for(int r=0; r<board.length; r++){\\n            for(int c=0; c<board[0].length; c++){\\n                if(board[r][c] != \\'.\\'){\\n                    int value = (1 << (board[r][c] - \\'1\\'));\\n                    if((value & rows[r]) > 0 || (value & cols[c]) > 0 || (value & squares[3*(r/3)+c/3]) > 0) return false;\\n                    rows[r] |= value;\\n                    cols[c] |= value;\\n                    squares[3*(r/3)+c/3] |= value;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15493,
                "title": "c-o-n-2-solution",
                "content": "```\\npublic class Solution {\\n    public bool IsValidSudoku(char[,] board) {\\n        for(var i=0;i<9;++i){\\n            var col = new HashSet<char>();\\n            var row = new HashSet<char>();\\n            var sub = new HashSet<char>();\\n\\n            for(var j=0;j<9;j++){\\n                \\n                if(board[i,j]!='.' && col.Contains(board[i,j])) return false;\\n                col.Add(board[i,j]);\\n                \\n                if(board[j,i]!='.' && row.Contains(board[j,i])) return false;\\n                row.Add(board[j,i]);\\n                \\n                var x = (i%3)*3 + j%3;\\n                var y = (i/3)*3 + j/3;\\n                if(board[x,y]!='.' && sub.Contains(board[x,y])) return false;\\n                sub.Add(board[x,y]);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsValidSudoku(char[,] board) {\\n        for(var i=0;i<9;++i){\\n            var col = new HashSet<char>();\\n            var row = new HashSet<char>();\\n            var sub = new HashSet<char>();\\n\\n            for(var j=0;j<9;j++){\\n                \\n                if(board[i,j]!='.' && col.Contains(board[i,j])) return false;\\n                col.Add(board[i,j]);\\n                \\n                if(board[j,i]!='.' && row.Contains(board[j,i])) return false;\\n                row.Add(board[j,i]);\\n                \\n                var x = (i%3)*3 + j%3;\\n                var y = (i/3)*3 + j/3;\\n                if(board[x,y]!='.' && sub.Contains(board[x,y])) return false;\\n                sub.Add(board[x,y]);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15612,
                "title": "simple-solution-with-explanation",
                "content": "For this problem, just according to the define of Sudoku, \\n\\n1. row: in the row, there can't have  same number.\\n\\n2. column: in the  column, there can't have  same number.\\n\\n3. 3 * 3 grid:  in the 3 * 3 grid, there can't have  same number.\\n\\nwe can get a simple solution. One place to need to pay attention to is board[i / 3 * 3][j / 3 * 3] is the top left of the 3 * 3 grid.\\n\\n    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tif (board[i][j] == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (!isValid(board, i, j))\\n\\t\\t\\t\\t\\treturn false;\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n\\tprivate static  boolean isValid(char[][] board, int i, int j) {\\n\\t\\tfor (int m = 0; m < 9; m++) {\\n\\t\\t\\tif (m != j && board[i][m] == board[i][j]) // row\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (m != i && board[m][j] == board[i][j]) // column\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor (int m = i / 3 * 3; m < i / 3 * 3 + 3; m++) { // 3 * 3 grid\\n\\t\\t\\tfor (int n = j / 3 * 3; n < j / 3 * 3 + 3; n++) {\\n\\t\\t\\t\\tif (m != i && n != j && board[m][n] == board[i][j])\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [],
                "code": "For this problem, just according to the define of Sudoku, \\n\\n1. row: in the row, there can't have  same number.\\n\\n2. column: in the  column, there can't have  same number.\\n\\n3. 3 * 3 grid:  in the 3 * 3 grid, there can't have  same number.\\n\\nwe can get a simple solution. One place to need to pay attention to is board[i / 3 * 3][j / 3 * 3] is the top left of the 3 * 3 grid.\\n\\n    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tif (board[i][j] == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (!isValid(board, i, j))\\n\\t\\t\\t\\t\\treturn false;\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n\\tprivate static  boolean isValid(char[][] board, int i, int j) {\\n\\t\\tfor (int m = 0; m < 9; m++) {\\n\\t\\t\\tif (m != j && board[i][m] == board[i][j]) // row\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (m != i && board[m][j] == board[i][j]) // column\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor (int m = i / 3 * 3; m < i / 3 * 3 + 3; m++) { // 3 * 3 grid\\n\\t\\t\\tfor (int n = j / 3 * 3; n < j / 3 * 3 + 3; n++) {\\n\\t\\t\\t\\tif (m != i && n != j && board[m][n] == board[i][j])\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 15705,
                "title": "my-c-code-o-n2-time-and-space",
                "content": "The basic idea is to use an array to indicate whether a number in a row/column/3x3 sub-block already occurs. We need a 9x9 array existNum and\\na) the LSB of existNum[i][j] indicates whether number j occurs on the i-th row before\\nb) the 2-LSB of existNum[i][j] indicates whether number j occurs on the i-th column before\\nc) the 3-LSB of existNum[i][j] indicates whether number j occurs on the i-th sub-block before, k= (i/3)*3 + j/3\\n\\n\\n    class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            char existNum[10][10]={0};\\n            int i,j;\\n            \\n            for(i=0; i<9; i++)\\n            {\\n                for(j=0; j<9; j++)\\n                {\\n                    if(board[i][j]!='.')\\n                    {\\n                        if(existNum[i][board[i][j] - '0'] & 0x1)return false; // check if the i-row already has such number, LSB\\n                        if(existNum[j][board[i][j] - '0'] & 0x2) return false; // check if the j-col already has such number, 2-LSB\\n                        if(existNum[(i/3) *3 + j/3][board[i][j] - '0'] & 0x4) return false; // check if the k-subblock already has such number, 3-LSB\\n                        existNum[i][board[i][j] - '0'] ^=0x1;\\n                        existNum[j][board[i][j] - '0'] ^=0x2;\\n                        existNum[(i/3) *3 + j/3][board[i][j] - '0'] ^=0x4;\\n                    }\\n                    \\n                }\\n            }\\n            \\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            char existNum[10][10]={0}",
                "codeTag": "Java"
            },
            {
                "id": 3768728,
                "title": "100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        return solve(board);\\n    }\\n     boolean solve(char[][]board)\\n    { for(int i=0;i<board.length;i++)\\n    {for(int j=0;j<board.length;j++)\\n    { if(board[i][j] != \\'.\\')\\n    { char num=board[i][j];\\n     board[i][j]=\\'.\\';\\n     if(!isSafe(board,i,j,num)) return false;\\n      else\\n    //backtrack\\n     board[i][j]=num;\\n     } }}\\n    return true; }\\n     boolean isSafe(char[][] board,int row,int col,char num)\\n    { // check the row\\n      for(int i=0;i<board.length;i++)\\n      { // check if the number is in the row\\n        if(board[i][col] == num)  return false;\\n         // check the column\\n        // check if the number is in the column\\n        if(board[row][i]== num) return false;\\n      }int sqrt=(int)(Math.sqrt(board.length));\\n      int rowStart=row - row % sqrt;\\n      int colStart=col - col % sqrt;\\n      for(int r=rowStart;r<rowStart + sqrt;r++)\\n      { for(int c=colStart;c<colStart + sqrt;c++)\\n       {if(board[r][c] == num)   return false; }\\n      }return true;\\n}\\n}\\n\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/91a30870-3320-44a9-84bb-88a9fb3a4f2e_1689425161.7847996.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        return solve(board);\\n    }\\n     boolean solve(char[][]board)\\n    { for(int i=0;i<board.length;i++)\\n    {for(int j=0;j<board.length;j++)\\n    { if(board[i][j] != \\'.\\')\\n    { char num=board[i][j];\\n     board[i][j]=\\'.\\';\\n     if(!isSafe(board,i,j,num)) return false;\\n      else\\n    //backtrack\\n     board[i][j]=num;\\n     } }}\\n    return true; }\\n     boolean isSafe(char[][] board,int row,int col,char num)\\n    { // check the row\\n      for(int i=0;i<board.length;i++)\\n      { // check if the number is in the row\\n        if(board[i][col] == num)  return false;\\n         // check the column\\n        // check if the number is in the column\\n        if(board[row][i]== num) return false;\\n      }int sqrt=(int)(Math.sqrt(board.length));\\n      int rowStart=row - row % sqrt;\\n      int colStart=col - col % sqrt;\\n      for(int r=rowStart;r<rowStart + sqrt;r++)\\n      { for(int c=colStart;c<colStart + sqrt;c++)\\n       {if(board[r][c] == num)   return false; }\\n      }return true;\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653296,
                "title": "c-easy-fully-explained-hindi-english-best",
                "content": "\\n\\n# Approach\\nThe question is asking us to check whether any integer between 1-9 appears more than once in a particular row, column, or 3x3 grid.\\n\\nFor this, we will create three hash arrays, a, b, and c. Array a will check whether any integer from 1 to 9 appears more than once in a particular row, array b will check whether any integer from 1 to 9 appears more than once in a particular column, and array c will check whether any integer from 1 to 9 appears more than once in a particular 3x3 grid.\\n\\nIf any of these conditions are true, we will return false; otherwise, we will return true\\n\\nk = i / 3 * 3 + j / 3\\nfor those who need to visualize k > here\\n\\n0 0 0 | 1 1 1 | 2 2 2\\n0 0 0 | 1 1 1 | 2 2 2\\n0 0 0 | 1 1 1 | 2 2 2\\n--------+---------+---------\\n3 3 3 | 4 4 4 | 5 5 5\\n3 3 3 | 4 4 4 | 5 5 5\\n3 3 3 | 4 4 4 | 5 5 5\\n--------+----------+--------\\n6 6 6 | 7 7 7 | 8 8 8\\n6 6 6 | 7 7 7 | 8 8 8\\n6 6 6 | 7 7 7 | 8 8 8\\n\\nPLease upvote the solution.****\\n\\nhindi-\\nEss question mai hame check karna hai ki koi integer{1-9} particular row ya coloum ya 3*3 ki grid mai ek se jayda baar na aaye .\\n\\niske liye ham a,b,c 3 hash array create karenge jisme A check karegi ki kya koi integer[1-9] ek row mai do baar toh nahi aa rha or B check karegi ki kya koi integer[1-9] ek coloum mai do baar toh nahi aa rha or C ka kaam hoga ki check karna ki kya koi integer[1-9] ek 3*3 ki grid mai do baar toh nahi aa rha agar isme se ek bhi condition true hoti hai to ham false return karenge else true return karenge\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int a[9][9]={0},b[9][9]={0},c[9][9]={0};\\n        for(int i=0;i<board.size();++i){\\n            for(int j=0;j<board.size();++j){\\n                if(board[i][j]!=\\'.\\'){\\n                    int num=board[i][j]-\\'0\\'-1;\\n                    int k= i / 3 * 3 + j / 3;\\n                    if(a[i][num]||b[j][num]||c[k][num]){\\n                        return false;\\n                    }\\n                        a[i][num]=b[j][num]=c[k][num]=1;\\n                    \\n                }\\n\\n            \\n            }\\n\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int a[9][9]={0},b[9][9]={0},c[9][9]={0};\\n        for(int i=0;i<board.size();++i){\\n            for(int j=0;j<board.size();++j){\\n                if(board[i][j]!=\\'.\\'){\\n                    int num=board[i][j]-\\'0\\'-1;\\n                    int k= i / 3 * 3 + j / 3;\\n                    if(a[i][num]||b[j][num]||c[k][num]){\\n                        return false;\\n                    }\\n                        a[i][num]=b[j][num]=c[k][num]=1;\\n                    \\n                }\\n\\n            \\n            }\\n\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613853,
                "title": "w-explanation-c-c-python-solution-uses-bool-arrays-bitsets-sets-as-hash-tables",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9>, boolean arrays or sets suffice to use for recording and checking and play the role of hash tables!! \\n\\nLeetcode 37. Sudoku Solver is also solved in the similar manner.\\n[https://leetcode.com/problems/sudoku-solver/solutions/3622243/w-explain-c-c-solves-via-backtracking-bool-arrays-in-3-ms/](https://leetcode.com/problems/sudoku-solver/solutions/3622243/w-explain-c-c-solves-via-backtracking-bool-arrays-in-3-ms/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nC solution Runtime 8 ms Beats 92.31%.\\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/hkXrewUTqyc](https://youtu.be/hkXrewUTqyc)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bitset<9> Col[9];\\n        bitset<9> Row[9];\\n        bitset<9> Block[9];\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c == \\'.\\') continue;\\n                int x=(c-\\'0\\')%9; \\n                // Convert the character digit to an index (0-8) 0 for 9\\n\\n                if (Row[i][x]) return 0;\\n                Row[i][x] = 1;\\n\\n                if (Col[j][x]) return 0;\\n                Col[j][x] = 1;\\n                \\n                int bidx = (i / 3) * 3 + j / 3;\\n                if (Block[bidx][x]) return 0;\\n                Block[bidx][x] = 1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```\\n```C []\\nbool isValidSudoku(char** board, int boardSize, int* boardColSize)\\n{\\n    bool Col[9][9]={0};\\n    bool Row[9][9]={0};\\n    bool Block[9][9]={0};\\n\\n    for(int i=0; i<9; i++){\\n        for(int j=0; j<9; j++){\\n            char c = board[i][j];\\n            if (c == \\'.\\') continue;\\n            int x=(c-\\'0\\')%9; \\n            // Convert the character digit to an index (0-8) 0 for 9\\n\\n            if (Row[i][x]==1) return 0;\\n            Row[i][x] = 1;\\n\\n            if (Col[j][x]==1) return 0;\\n            Col[j][x] = 1;\\n                \\n            int bidx = (i / 3) * 3 + j / 3;\\n            if (Block[bidx][x]==1) return 0;\\n            Block[bidx][x] = 1;\\n        }\\n    }\\n    return 1;\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Use sets\\n        Col = [set() for _ in range(9)]\\n        Row = [set() for _ in range(9)]\\n        Block = [set() for _ in range(9)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                c=board[i][j]\\n                if c==\\'.\\': continue\\n                x=(ord(c)-ord(\\'0\\'))%9\\n\\n                if x in Row[i]: return False\\n                Row[i].add(x)\\n\\n                if x in Col[j]: return False\\n                Col[j].add(x)\\n\\n                idx=i//3*3+j//3\\n                if x in Block[idx]: return False\\n                Block[idx].add(x)\\n        return True\\'\\n```\\nAnother approach uses C++ unordered_set for strings.\\n# C++ solution uses unordered_set\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> C;\\n        int n=0;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c != \\'.\\') {\\n                    n++;\\n                    string row=\"row\"+to_string(i)+c;\\n                    string col=\"col\"+to_string(j)+c;\\n                    int bidx = (i / 3) * 3 + j / 3;\\n                    string block=\"block\"+to_string(bidx)+c;\\n                    C.insert(row);\\n                    C.insert(col);\\n                    C.insert(block);\\n                }\\n            }\\n        }\\n        return C.size()==3*n;\\n    }\\n};\\n```\\nNext step is to use backtracking solving it!\\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bitset<9> Col[9];\\n        bitset<9> Row[9];\\n        bitset<9> Block[9];\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c == \\'.\\') continue;\\n                int x=(c-\\'0\\')%9; \\n                // Convert the character digit to an index (0-8) 0 for 9\\n\\n                if (Row[i][x]) return 0;\\n                Row[i][x] = 1;\\n\\n                if (Col[j][x]) return 0;\\n                Col[j][x] = 1;\\n                \\n                int bidx = (i / 3) * 3 + j / 3;\\n                if (Block[bidx][x]) return 0;\\n                Block[bidx][x] = 1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```\n```C []\\nbool isValidSudoku(char** board, int boardSize, int* boardColSize)\\n{\\n    bool Col[9][9]={0};\\n    bool Row[9][9]={0};\\n    bool Block[9][9]={0};\\n\\n    for(int i=0; i<9; i++){\\n        for(int j=0; j<9; j++){\\n            char c = board[i][j];\\n            if (c == \\'.\\') continue;\\n            int x=(c-\\'0\\')%9; \\n            // Convert the character digit to an index (0-8) 0 for 9\\n\\n            if (Row[i][x]==1) return 0;\\n            Row[i][x] = 1;\\n\\n            if (Col[j][x]==1) return 0;\\n            Col[j][x] = 1;\\n                \\n            int bidx = (i / 3) * 3 + j / 3;\\n            if (Block[bidx][x]==1) return 0;\\n            Block[bidx][x] = 1;\\n        }\\n    }\\n    return 1;\\n}\\n```\n```Python []\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Use sets\\n        Col = [set() for _ in range(9)]\\n        Row = [set() for _ in range(9)]\\n        Block = [set() for _ in range(9)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                c=board[i][j]\\n                if c==\\'.\\': continue\\n                x=(ord(c)-ord(\\'0\\'))%9\\n\\n                if x in Row[i]: return False\\n                Row[i].add(x)\\n\\n                if x in Col[j]: return False\\n                Col[j].add(x)\\n\\n                idx=i//3*3+j//3\\n                if x in Block[idx]: return False\\n                Block[idx].add(x)\\n        return True\\'\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> C;\\n        int n=0;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c != \\'.\\') {\\n                    n++;\\n                    string row=\"row\"+to_string(i)+c;\\n                    string col=\"col\"+to_string(j)+c;\\n                    int bidx = (i / 3) * 3 + j / 3;\\n                    string block=\"block\"+to_string(bidx)+c;\\n                    C.insert(row);\\n                    C.insert(col);\\n                    C.insert(block);\\n                }\\n            }\\n        }\\n        return C.size()==3*n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324188,
                "title": "powerful-logic-with-two-method",
                "content": "\\n\\n# 1. Without Hashtable Approach\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def valid(arr):\\n            s=\\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s)==len(set(s))\\n        def checkrow():\\n            for row in board:\\n                if not valid(row):\\n                    return False\\n            return True\\n        def checkcol():\\n            for col in zip(*board):\\n                if not valid(col):\\n                    return False\\n            return True\\n        def square():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    nums=[board[r+i][c+j] for i in range(3) for j in range(3)]\\n                    if not valid(nums):\\n                        return False\\n            return True\\n        return checkrow() and checkcol() and square()\\n\\n//please upvote me it would encourage me alot\\n\\n```\\n\\n# 2.With Hashtable Approach\\n```\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row=defaultdict(set)\\n        col=defaultdict(set)\\n        square=defaultdict(set)\\n        for r in range(9):\\n            for c in range(9):\\n                x=board[r][c]\\n                if board[r][c]==\".\":\\n                    continue\\n                if x in row[r] or x in col[c] or x in square[(r//3,c//3)]:\\n                    return False\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                square[(r//3,c//3)].add(board[r][c])\\n        return True\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def valid(arr):\\n            s=\\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s)==len(set(s))\\n        def checkrow():\\n            for row in board:\\n                if not valid(row):\\n                    return False\\n            return True\\n        def checkcol():\\n            for col in zip(*board):\\n                if not valid(col):\\n                    return False\\n            return True\\n        def square():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    nums=[board[r+i][c+j] for i in range(3) for j in range(3)]\\n                    if not valid(nums):\\n                        return False\\n            return True\\n        return checkrow() and checkcol() and square()\\n\\n//please upvote me it would encourage me alot\\n\\n```\n```\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row=defaultdict(set)\\n        col=defaultdict(set)\\n        square=defaultdict(set)\\n        for r in range(9):\\n            for c in range(9):\\n                x=board[r][c]\\n                if board[r][c]==\".\":\\n                    continue\\n                if x in row[r] or x in col[c] or x in square[(r//3,c//3)]:\\n                    return False\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                square[(r//3,c//3)].add(board[r][c])\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079159,
                "title": "javascript-99-4-fast-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/yaMicoAZsrI\\n\\n# Code\\n```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    \\n    for(let i =0; i<board.length;i++){\\n        let rowMap = {}\\n        let colMap = {}\\n        let boxMap = {}\\n        for(let j=0; j<board[i].length;j++){\\n\\n            let box = board[3* Math.floor(i/3) +Math.floor(j/3)][3*(i%3)+(j%3)]\\n            \\n            if(board[i][j] != \\'.\\'){\\n                if(rowMap[board[i][j]]) return false;\\n                rowMap[board[i][j]] = 1;\\n            }\\n            if(board[j][i] != \\'.\\') {\\n                if(colMap[board[j][i]]) return false;\\n                colMap[board[j][i]] = 1;\\n            }\\n            if(box!= \\'.\\'){\\n                if(boxMap[box]) return false;\\n                boxMap[box] = 1;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    \\n    for(let i =0; i<board.length;i++){\\n        let rowMap = {}\\n        let colMap = {}\\n        let boxMap = {}\\n        for(let j=0; j<board[i].length;j++){\\n\\n            let box = board[3* Math.floor(i/3) +Math.floor(j/3)][3*(i%3)+(j%3)]\\n            \\n            if(board[i][j] != \\'.\\'){\\n                if(rowMap[board[i][j]]) return false;\\n                rowMap[board[i][j]] = 1;\\n            }\\n            if(board[j][i] != \\'.\\') {\\n                if(colMap[board[j][i]]) return false;\\n                colMap[board[j][i]] = 1;\\n            }\\n            if(box!= \\'.\\'){\\n                if(boxMap[box]) return false;\\n                boxMap[box] = 1;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3005232,
                "title": "single-pass-python-solution-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe initial approach was to traverse the sudoku 3 times and check for row satisfiability in first pass, column satisfiability in second pass and sub-box satisfiability in third pass. However, we could design an approach with an extra space to optimize this and check for all conditions in a single pass of the sudoku.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare an defaultdict(taking set as the default_factory). Iterate the Sudoku and check if the number exists in our defaultdict for row, column and sub-box condition with the help of keys (discussed below). If it is not present at all 3 keys, add the number in the 3 locations. If it is present, return False as it is not a valid Sudoku.\\nIf we successfully traverse the Sudoku without encountering a single instance where number is already present in the defaultdict, it means it is a valid Sudoku so return True.\\n\\n# Keys:\\n**i** : For Row i.e. defaultdict[i] will have the numbers in i\\'th row.\\n**j+9**: For Column i.e. defaultdict[j+9] will have numbers in the j\\'th column. 9 added to avoid clash with keys of rows.\\n**(i//3,j//3)**: For Sub-box condition, as the key represent\\'s the sub box in which the element of (i\\'th row,j\\'th column) exists.\\n\\n# Complexity\\n- Time complexity: O(N^2) [Basically Single pass over the Sudoku. ]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) [A dictionary of 27 keys and each having a set as the value to store the numbers].\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n***Please Like the Solution if you understood it***.\\n\\n# Code\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        checker = defaultdict(set)\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j]==\".\":\\n                    continue\\n\\n                box = (i//3,j//3)\\n                if board[i][j] in checker[i] or board[i][j] in checker[j+9] or board[i][j] in checker[box]:\\n                    return False\\n                else:\\n                    checker[i].add(board[i][j])\\n                    checker[j+9].add(board[i][j])\\n                    checker[box].add(board[i][j])\\n        #print(checker)\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        checker = defaultdict(set)\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j]==\".\":\\n                    continue\\n\\n                box = (i//3,j//3)\\n                if board[i][j] in checker[i] or board[i][j] in checker[j+9] or board[i][j] in checker[box]:\\n                    return False\\n                else:\\n                    checker[i].add(board[i][j])\\n                    checker[j+9].add(board[i][j])\\n                    checker[box].add(board[i][j])\\n        #print(checker)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597616,
                "title": "python3-simple-solution-using-hashset",
                "content": "Code:\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        cols = collections.defaultdict(set)\\n        rows = collections.defaultdict(set)\\n        squares = collections.defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\":\\n                    continue\\n                if (board[r][c] in rows[r] or \\n                    board[r][c] in cols[c] or \\n                    board[r][c] in squares[(r//3,c//3)]):\\n                    return False\\n                cols[c].add(board[r][c])\\n                rows[r].add(board[r][c])\\n                squares[(r//3,c//3)].add(board[r][c])\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        cols = collections.defaultdict(set)\\n        rows = collections.defaultdict(set)\\n        squares = collections.defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\":\\n                    continue\\n                if (board[r][c] in rows[r] or \\n                    board[r][c] in cols[c] or \\n                    board[r][c] in squares[(r//3,c//3)]):\\n                    return False\\n                cols[c].add(board[r][c])\\n                rows[r].add(board[r][c])\\n                squares[(r//3,c//3)].add(board[r][c])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457762,
                "title": "c-easy-solution-set-solution",
                "content": "Here ATQ,\\n  For Valid sudoko , we need some validation .\\n  1. No two elements should be in the same row .\\n  2. No two elements should be in the same column.\\n  3. No same should present in each 3*3  Block Matrix.\\n \\n So for that we are taking the set data structures to store and validate.\\n The main key is here for the  9block  -   3* 3 blocks  to validate.\\n For traversing in the block index becomes   (i/3)*3 + j/3;\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // using set data structure to store and validate in rows , cols  and 3*3 each blocks.\\n        \\n       vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // using set data structure to store and validate in rows , cols  and 3*3 each blocks.\\n        \\n       vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434689,
                "title": "simple-optimal-solution-kotlin-using-string",
                "content": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n       val seen = HashSet<String>()\\n       \\n       for(i in 0 until 9){\\n           for(j in 0 until 9){\\n               var number = board[i][j]\\n               if(number != \\'.\\'){\\n                   if(!seen.add(\"$number in row $i\") ||\\n                      !seen.add(\"$number in column $j\") ||\\n                      !seen.add(\"$number in block ${i/3}-${j/3}\")) return false\\n                   \\n               }\\n           }\\n       }\\n       \\n       return true\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n       val seen = HashSet<String>()\\n       \\n       for(i in 0 until 9){\\n           for(j in 0 until 9){\\n               var number = board[i][j]\\n               if(number != \\'.\\'){\\n                   if(!seen.add(\"$number in row $i\") ||\\n                      !seen.add(\"$number in column $j\") ||\\n                      !seen.add(\"$number in block ${i/3}-${j/3}\")) return false\\n                   \\n               }\\n           }\\n       }\\n       \\n       return true\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430291,
                "title": "python-91ms-faster-than-98-w-proof-easy-to-understand-readable",
                "content": "1. Initialize a set\\n2. Traverse through the cells one by one and add them to set with proper names for example,\\n\\t1. If `3` is in `board[0][1]`, then add these three keys to the set\\n\\t2. `3 in row 0`\\n\\t3. `3 in col 1`\\n\\t4. `3 in box 0`\\n3. If the key already exists in the set, then return False\\n\\n```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\ts = set()\\n\\n\\tfor i in range(9):\\n\\t\\tfor j in range(9):\\n\\t\\t\\tif board[i][j] != \\'.\\':\\n\\t\\t\\t\\tc = board[i][j]\\n\\n\\t\\t\\t\\t# Row check\\n\\t\\t\\t\\tkey = f\\'{c} in row {i}\\' # same as -> str(c) + \\' in row \\' + str(i)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Column check\\n\\t\\t\\t\\tkey = f\\'{c} in col {j}\\' # same as -> str(c) + \\' in col \\' + str(j)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Box check\\n\\t\\t\\t\\tboxIndex = (i // 3) * 3 + (j // 3)\\n\\t\\t\\t\\tkey = f\\'{c} in box {boxIndex}\\' # same as -> str(c) + \\' in box \\' + str(boxIndex)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key) \\n\\n\\treturn True\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6a37c991-15e9-4c82-915d-81f86191a795_1660582920.076614.png)\\n\\n![image](https://assets.leetcode.com/users/images/ae445c1c-9ed7-447e-bb74-134e7cd36e35_1660753850.275268.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\ts = set()\\n\\n\\tfor i in range(9):\\n\\t\\tfor j in range(9):\\n\\t\\t\\tif board[i][j] != \\'.\\':\\n\\t\\t\\t\\tc = board[i][j]\\n\\n\\t\\t\\t\\t# Row check\\n\\t\\t\\t\\tkey = f\\'{c} in row {i}\\' # same as -> str(c) + \\' in row \\' + str(i)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Column check\\n\\t\\t\\t\\tkey = f\\'{c} in col {j}\\' # same as -> str(c) + \\' in col \\' + str(j)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Box check\\n\\t\\t\\t\\tboxIndex = (i // 3) * 3 + (j // 3)\\n\\t\\t\\t\\tkey = f\\'{c} in box {boxIndex}\\' # same as -> str(c) + \\' in box \\' + str(boxIndex)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key) \\n\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2374430,
                "title": "simple-java-0ms-100-faster-solution",
                "content": "**Java \\u2705 || 0ms || 100% faster Solution**\\n\\n**Please  \\uD83D\\uDC4D this.solution if(you understood == true)**\\n\\n```\\n// Best Approach : HashSet\\n// Time Complexity : O(n2)\\n// Space Complexity : O(n2)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set set = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != \\'.\\') {\\n                    String el = \"[\" + board[i][j] + \"]\";\\n                    if (!set.add(el + i) || !set.add(j + el) || !set.add(i/3 + el + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n// Best Approach : HashSet\\n// Time Complexity : O(n2)\\n// Space Complexity : O(n2)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set set = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != \\'.\\') {\\n                    String el = \"[\" + board[i][j] + \"]\";\\n                    if (!set.add(el + i) || !set.add(j + el) || !set.add(i/3 + el + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287201,
                "title": "rust-simple-hashset-0ms",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let mut row_set = HashSet::new();\\n        let mut col_set = HashSet::new();\\n        let mut sub_box_sets = vec![HashSet::new(); 9];\\n        \\n        for r in 0..9 {\\n            for c in 0..9 {\\n                if let Some(digit) = board[r][c].to_digit(10) {\\n\\t\\t\\t\\t\\t// Has this combination of row number r and digit already been encountered?\\n                    if !row_set.insert((r, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Has this combination of column number c and digit already been encountered?\\n                    if !col_set.insert((c, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Iterator math to determine which of the 9 sub boxes the current board[r][c] is in. \\n\\t\\t\\t\\t\\t// Has it already been encountered?\\n                    if !sub_box_sets[3 * (r/3) + c/3].insert(digit) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let mut row_set = HashSet::new();\\n        let mut col_set = HashSet::new();\\n        let mut sub_box_sets = vec![HashSet::new(); 9];\\n        \\n        for r in 0..9 {\\n            for c in 0..9 {\\n                if let Some(digit) = board[r][c].to_digit(10) {\\n\\t\\t\\t\\t\\t// Has this combination of row number r and digit already been encountered?\\n                    if !row_set.insert((r, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Has this combination of column number c and digit already been encountered?\\n                    if !col_set.insert((c, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Iterator math to determine which of the 9 sub boxes the current board[r][c] is in. \\n\\t\\t\\t\\t\\t// Has it already been encountered?\\n                    if !sub_box_sets[3 * (r/3) + c/3].insert(digit) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745150,
                "title": "c-simple-and-easy-hashset",
                "content": "For each row, column and block we keep a set of characters.\\nIf we find the char again while inserting we return a false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\n        vector<set<char>> row(9), col(9), block(9); // each char set for checking every row coloumn and block\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') {\\n                    char c = board[i][j];\\n                    if(!row[j].insert(c).second or !col[i].insert(c).second or !block[(i/3)*3 + j/3].insert(c).second) \\n\\t\\t\\t\\t\\t\\treturn false;\\n/* checking while inserting in the set\\t\\t\\t\\t\\t\\t\\n   An insert operation on a set returns a pair, with its member first set to an iterator pointing\\n   to either the newly inserted element or to the equivalent element already in the set. \\n   The second element in the pair is set to true if a new element was inserted or false if an equivalent element already existed.*/\\t\\t\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nFor block[(i/3)*3 + j/3] \\nWe have to map each 3x3 boxes, and label the boxes like this:\\n\\n0 1 2\\n3 4 5\\n6 7 8\\n\\nSo we have boxIndex as  r/3*3 +c/3\\nDo a dry run you will get to know easily.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\n        vector<set<char>> row(9), col(9), block(9); // each char set for checking every row coloumn and block\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') {\\n                    char c = board[i][j];\\n                    if(!row[j].insert(c).second or !col[i].insert(c).second or !block[(i/3)*3 + j/3].insert(c).second) \\n\\t\\t\\t\\t\\t\\treturn false;\\n/* checking while inserting in the set\\t\\t\\t\\t\\t\\t\\n   An insert operation on a set returns a pair, with its member first set to an iterator pointing\\n   to either the newly inserted element or to the equivalent element already in the set. \\n   The second element in the pair is set to true if a new element was inserted or false if an equivalent element already existed.*/\\t\\t\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706655,
                "title": "o-1-time-complexity-using-set-with-comments",
                "content": "```\\nclass Solution {\\n    /*in this we have to check 3 things\\n    1:-that each number should be unique in the colum\\n    2:- each number should be unique in th row\\n    3:- each number should be unique in the box\\n   steps:-\\n   \\n   1:-we will make set of string type\\n   2:- then we will make 3 string row,colum,box\\n   3:-and we will make the string in this way like:-\\n   \\n   row = row+number(board[i][j])+i;\\n   colum = colum+number+j;\\n   and to get the which in which box it belongs we have one formula\\n   int Box=((i/3)*3+(j/3));\\n   and every itration row colum will change accordingly string will also change .\\n   \\n   so if supppose we have string like:-\\n   row+number+i = row5 abd the row is 3\\n   row+number+i = row5 and the row is 3\\n   then it will give false same for colum and box;\\n   \\n   4:- if(box[i][j]!=\\'.\\') then only we have to chck\\n   \\n   5:- now check if have the string then return false;\\n   \\n   6:- otherwise add into the set.\\n   */\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n         unordered_set<string>u;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                string row=\"\";\\n                row+=\"row\";\\n                row+=board[i][j];\\n                row+=i;\\n                \\n                string colum=\"\";\\n                colum+=\"colum\";\\n                colum+=board[i][j];\\n                colum+=j;\\n                \\n                int Box=((i/3)*3+(j/3));\\n                string box=\"\";\\n                box+=\"box\";\\n                box+=board[i][j];\\n                box+=Box;\\n                if(board[i][j]!=\\'.\\')\\n                if(u.count(row) || u.count(colum) ||u.count(box))\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    u.insert(row);\\n                    u.insert(colum);\\n                    u.insert(box);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n};\\n```\\n\\n**PLEASE LET ME KNOW IF ANY SUGGESTION OR DOUBTS**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    /*in this we have to check 3 things\\n    1:-that each number should be unique in the colum\\n    2:- each number should be unique in th row\\n    3:- each number should be unique in the box\\n   steps:-\\n   \\n   1:-we will make set of string type\\n   2:- then we will make 3 string row,colum,box\\n   3:-and we will make the string in this way like:-\\n   \\n   row = row+number(board[i][j])+i;\\n   colum = colum+number+j;\\n   and to get the which in which box it belongs we have one formula\\n   int Box=((i/3)*3+(j/3));\\n   and every itration row colum will change accordingly string will also change .\\n   \\n   so if supppose we have string like:-\\n   row+number+i = row5 abd the row is 3\\n   row+number+i = row5 and the row is 3\\n   then it will give false same for colum and box;\\n   \\n   4:- if(box[i][j]!=\\'.\\') then only we have to chck\\n   \\n   5:- now check if have the string then return false;\\n   \\n   6:- otherwise add into the set.\\n   */\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n         unordered_set<string>u;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                string row=\"\";\\n                row+=\"row\";\\n                row+=board[i][j];\\n                row+=i;\\n                \\n                string colum=\"\";\\n                colum+=\"colum\";\\n                colum+=board[i][j];\\n                colum+=j;\\n                \\n                int Box=((i/3)*3+(j/3));\\n                string box=\"\";\\n                box+=\"box\";\\n                box+=board[i][j];\\n                box+=Box;\\n                if(board[i][j]!=\\'.\\')\\n                if(u.count(row) || u.count(colum) ||u.count(box))\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    u.insert(row);\\n                    u.insert(colum);\\n                    u.insert(box);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493936,
                "title": "c-easy-solution-using-hashmap-runtime-32-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int N = board.size();\\n        unordered_set<char>rowset[N],colset[N],boxset[N];\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                int boxno = (i/3)*3+(j/3);\\n                char val = board[i][j];\\n                if(val==\\'.\\')\\n                    continue;\\n                if(rowset[i].count(val) || colset[j].count(val) || boxset[boxno].count(val))\\n                    return false;\\n                rowset[i].insert(val);\\n                colset[j].insert(val);\\n                boxset[boxno].insert(val);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n*Please feel free to ask in the comments if you were not able to grasp anything from this solution*\\n**Happy Coding\\uD83D\\uDE07**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int N = board.size();\\n        unordered_set<char>rowset[N],colset[N],boxset[N];\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                int boxno = (i/3)*3+(j/3);\\n                char val = board[i][j];\\n                if(val==\\'.\\')\\n                    continue;\\n                if(rowset[i].count(val) || colset[j].count(val) || boxset[boxno].count(val))\\n                    return false;\\n                rowset[i].insert(val);\\n                colset[j].insert(val);\\n                boxset[boxno].insert(val);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416689,
                "title": "c-3-approaches-with-diagrams",
                "content": "```\\n//Approach-1 (Naive and simplest using 3 iterations of the sudoku)\\nclass Solution {\\npublic:\\n    bool validSub(vector<vector<char>>& board, int sr, int er, int sc, int ec) {\\n        unordered_set<char> st;\\n        for(int row = sr; row<=er; row++) {\\n            for(int col = sc; col <= ec; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //validate rows\\n        for(int row = 0; row<9; row++) {\\n            unordered_set<char> st;\\n            for(int col = 0; col <9; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n        //validate columns\\n        for(int col = 0; col<9; col++) {\\n            unordered_set<char> st;\\n            for(int row = 0; row <9; row++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n\\t\\t//validate ech 3*3 box\\n\\t\\t/*\\n\\t\\t\\tsr = start row\\n\\t\\t\\ter = end row\\n\\t\\t\\tsc = start column\\n\\t\\t\\tec = end column\\n\\t\\t*/\\n        for(int sr = 0; sr < 9; sr+=3) {\\n            int er = sr+2;\\n            for(int sc = 0; sc < 9; sc+=3) {\\n                int ec = sc+2;\\n                if(!validSub(board, sr, er, sc, ec))\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (One iteration using hashmap and indexing boxes)\\n//see the diagrma below to understand the indexing of the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> st;\\n        \\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                string row = string(1, board[i][j]) + \"_row_\" + to_string(i);\\n                string col = string(1, board[i][j]) + \"_col_\" + to_string(j);\\n                string box = string(1, board[i][j]) + \"_box_\" + to_string(i/3) + \"_\" + to_string(j/3);\\n                if(st.count(row) || st.count(col) || st.count(box)) return false;\\n                st.insert(row);\\n                st.insert(col);\\n                st.insert(box);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\nDiagram for approach-2 :\\n![image](https://assets.leetcode.com/users/images/57d3cdd5-96a8-4e92-a247-0cf704cd6975_1629523773.4062777.jpeg)\\n\\n\\n```\\n//Approach-3 (Assigning a number to each box)\\n//see the diagrma below to understand how I have numbered the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool row[9][9] = {0};\\n        bool col[9][9] = {0};\\n        bool box[9][9] = {0};\\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                int digit     = board[i][j] - \\'0\\' - 1; //(-1 to avoid overflow in index)\\n                \\n                //we have numbered 9 boxes of (3*3) as 0, 1, 2, 3, 4 ... 9 (see the diagram below)\\n                int boxIndex  = (i/3)*3 + (j/3);\\n                \\n                if(row[i][digit] || col[j][digit] || box[boxIndex][digit]) return false;\\n                row[i][digit]        = true;\\n                col[j][digit]        = true;\\n                box[boxIndex][digit] = true;\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n//YouTube : https://www.youtube.com/watch?v=dGZjzA9zLW8\\n```\\n\\nDiagram for approach-2 :\\n![image](https://assets.leetcode.com/users/images/9feb7938-89d9-4bfe-a336-177037ebdf04_1629523884.2286322.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Naive and simplest using 3 iterations of the sudoku)\\nclass Solution {\\npublic:\\n    bool validSub(vector<vector<char>>& board, int sr, int er, int sc, int ec) {\\n        unordered_set<char> st;\\n        for(int row = sr; row<=er; row++) {\\n            for(int col = sc; col <= ec; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //validate rows\\n        for(int row = 0; row<9; row++) {\\n            unordered_set<char> st;\\n            for(int col = 0; col <9; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n        //validate columns\\n        for(int col = 0; col<9; col++) {\\n            unordered_set<char> st;\\n            for(int row = 0; row <9; row++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n\\t\\t//validate ech 3*3 box\\n\\t\\t/*\\n\\t\\t\\tsr = start row\\n\\t\\t\\ter = end row\\n\\t\\t\\tsc = start column\\n\\t\\t\\tec = end column\\n\\t\\t*/\\n        for(int sr = 0; sr < 9; sr+=3) {\\n            int er = sr+2;\\n            for(int sc = 0; sc < 9; sc+=3) {\\n                int ec = sc+2;\\n                if(!validSub(board, sr, er, sc, ec))\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\n//Approach-2 (One iteration using hashmap and indexing boxes)\\n//see the diagrma below to understand the indexing of the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> st;\\n        \\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                string row = string(1, board[i][j]) + \"_row_\" + to_string(i);\\n                string col = string(1, board[i][j]) + \"_col_\" + to_string(j);\\n                string box = string(1, board[i][j]) + \"_box_\" + to_string(i/3) + \"_\" + to_string(j/3);\\n                if(st.count(row) || st.count(col) || st.count(box)) return false;\\n                st.insert(row);\\n                st.insert(col);\\n                st.insert(box);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\n//Approach-3 (Assigning a number to each box)\\n//see the diagrma below to understand how I have numbered the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool row[9][9] = {0};\\n        bool col[9][9] = {0};\\n        bool box[9][9] = {0};\\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                int digit     = board[i][j] - \\'0\\' - 1; //(-1 to avoid overflow in index)\\n                \\n                //we have numbered 9 boxes of (3*3) as 0, 1, 2, 3, 4 ... 9 (see the diagram below)\\n                int boxIndex  = (i/3)*3 + (j/3);\\n                \\n                if(row[i][digit] || col[j][digit] || box[boxIndex][digit]) return false;\\n                row[i][digit]        = true;\\n                col[j][digit]        = true;\\n                box[boxIndex][digit] = true;\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n//YouTube : https://www.youtube.com/watch?v=dGZjzA9zLW8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261934,
                "title": "rust-solution-using-three-1-d-arrays-with-bit-manipulation-instead-of-hashset",
                "content": "Normally, simplest approach here would be to instantiate 9 HashSets for Rows, Columns, and Boxes to check for duplicate entries - but it is very wasteful. Instead, we could simply use an array and represent values as bits which span from 1 to 9. Thus, it is possible to represent all in `u16` type.\\n\\n```rust\\nimpl Solution \\n{\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool \\n    {\\n        let mut rows: [u16; 9] = [0; 9];\\n        let mut cols: [u16; 9] = [0; 9];\\n        let mut boxes: [u16; 9] = [0; 9];\\n        \\n        for i in 0..9 {\\n            for j in 0..9 {\\n                match board[i][j] \\n                {\\n                    \\'.\\' => continue,\\n                    c => {\\n                        let b: usize = (i / 3) * 3 + (j / 3);\\n                        let curr = 1 << (c.to_digit(10).unwrap());\\n                        \\n                        if rows[i] & curr != 0 || cols[j] & curr != 0 || boxes[b] & curr != 0 {\\n                            return false;\\n                        }\\n    \\n                        rows[i] |= curr;\\n                        cols[j] |= curr;\\n                        boxes[b] |= curr;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```rust\\nimpl Solution \\n{\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool \\n    {\\n        let mut rows: [u16; 9] = [0; 9];\\n        let mut cols: [u16; 9] = [0; 9];\\n        let mut boxes: [u16; 9] = [0; 9];\\n        \\n        for i in 0..9 {\\n            for j in 0..9 {\\n                match board[i][j] \\n                {\\n                    \\'.\\' => continue,\\n                    c => {\\n                        let b: usize = (i / 3) * 3 + (j / 3);\\n                        let curr = 1 << (c.to_digit(10).unwrap());\\n                        \\n                        if rows[i] & curr != 0 || cols[j] & curr != 0 || boxes[b] & curr != 0 {\\n                            return false;\\n                        }\\n    \\n                        rows[i] |= curr;\\n                        cols[j] |= curr;\\n                        boxes[b] |= curr;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788607,
                "title": "swift-simple-sweet-for-100-complexity",
                "content": "Time; O(n), Space: O(n) where n is 81. In other words, it is **O(1)** for both\\n```\\nfunc isValidSudoku(_ board: [[Character]]) -> Bool {\\n\\tvar set = Set<String>()\\n\\n\\tfor row in 0..<9 {\\n\\t\\tfor col in 0..<9 {\\n\\t\\t\\tlet char = board[row][col]\\n\\t\\t\\tif char != \".\" {\\n\\t\\t\\t\\tlet num = char.wholeNumberValue!\\n\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row)(\\\\(num))\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"(\\\\(num))\\\\(col)\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row/3)(\\\\(num))\\\\(col/3)\").0 { return false }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValidSudoku(_ board: [[Character]]) -> Bool {\\n\\tvar set = Set<String>()\\n\\n\\tfor row in 0..<9 {\\n\\t\\tfor col in 0..<9 {\\n\\t\\t\\tlet char = board[row][col]\\n\\t\\t\\tif char != \".\" {\\n\\t\\t\\t\\tlet num = char.wholeNumberValue!\\n\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row)(\\\\(num))\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"(\\\\(num))\\\\(col)\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row/3)(\\\\(num))\\\\(col/3)\").0 { return false }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 310692,
                "title": "java-o-2-beats-100",
                "content": "Rule 1 and 2 are trivial, rule 3 a little bit tricky. We use division to get whole part. Lets say we have item [3][5], so it will be 3* (3/3) + 5/3 = 3 + 1 = 4 hence it will be block 4 (overall there are 9 blocks with indicies from 0 to 8). I used 10 iteams instead of 9 just to avoid -1 every time since java indicies start with 0.\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] rule1 = new boolean[9][10];\\n        boolean[][] rule2 = new boolean[9][10];\\n        boolean[][] rule3 = new boolean[9][10];\\n        for(int i=0; i<9; ++i) {\\n            for(int j=0; j<9; j++) {\\n                char digit = board[i][j];\\n\\n                if (digit != \\'.\\') {\\n                    int idx3 = 3 * (i / 3) + j / 3;\\n                    // convert char to int \\'0\\' -> 0\\n                    digit -= \\'0\\';\\n                    if (rule1[j][digit] || rule2[i][digit] || rule3[idx3][digit]) {\\n                        return false;\\n                    }\\n                    rule1[j][digit] = true;\\n                    rule2[i][digit] = true;\\n                    rule3[idx3][digit] = true; \\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] rule1 = new boolean[9][10];\\n        boolean[][] rule2 = new boolean[9][10];\\n        boolean[][] rule3 = new boolean[9][10];\\n        for(int i=0; i<9; ++i) {\\n            for(int j=0; j<9; j++) {\\n                char digit = board[i][j];\\n\\n                if (digit != \\'.\\') {\\n                    int idx3 = 3 * (i / 3) + j / 3;\\n                    // convert char to int \\'0\\' -> 0\\n                    digit -= \\'0\\';\\n                    if (rule1[j][digit] || rule2[i][digit] || rule3[idx3][digit]) {\\n                        return false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 240709,
                "title": "simple-c-code",
                "content": "```\\nbool isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n    char tmpR[9][9] = {0};\\n    char tmpC[9][9] = {0};\\n    char tmpI[9][9] = {0};\\n    int num;\\n    int index;\\n    for(int i = 0 ; i < 9;++i){\\n        for(int j = 0; j < 9; ++j){\\n            if(board[i][j] == \\'.\\'){\\n                continue;\\n            }\\n            num = board[i][j] - \\'1\\';\\n            index = (i/3)*3 + j/3;\\n            if(tmpR[i][num]|tmpC[j][num]|tmpI[index][num]){\\n                return false;\\n            }\\n            tmpR[i][num] = tmpC[j][num] = tmpI[index][num] = 1;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n    char tmpR[9][9] = {0};\\n    char tmpC[9][9] = {0};\\n    char tmpI[9][9] = {0};\\n    int num;\\n    int index;\\n    for(int i = 0 ; i < 9;++i){\\n        for(int j = 0; j < 9; ++j){\\n            if(board[i][j] == \\'.\\'){\\n                continue;\\n            }\\n            num = board[i][j] - \\'1\\';\\n            index = (i/3)*3 + j/3;\\n            if(tmpR[i][num]|tmpC[j][num]|tmpI[index][num]){\\n                return false;\\n            }\\n            tmpR[i][num] = tmpC[j][num] = tmpI[index][num] = 1;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 196923,
                "title": "java-beat-97-code",
                "content": "\\u6C42\\u70B9\\u8D5E\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] map_row = new boolean[10][10];\\n        boolean[][] map_col = new boolean[10][10];       \\n        //check row and col\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    if(map_row[i][num]) return false;\\n                    map_row[i][num] = true;\\n                    if(map_col[num][j]) return false;\\n                    map_col[num][j] = true;\\n                }\\n            }\\n        }\\n        \\n        //check 3*3\\n        for(int i=0; i<9; i= i+3){\\n            for(int j=0; j<9; j=j+3) {\\n                boolean[] map = new boolean[10];\\n                for(int k=0; k<3; k++){\\n                    for(int t=0; t<3; t++){\\n                        int num = board[k+i][t+j] - \\'0\\';\\n                        if(board[k+i][t+j] != \\'.\\'){\\n                            if(map[num]) return false;\\n                            map[num] = true;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n     return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] map_row = new boolean[10][10];\\n        boolean[][] map_col = new boolean[10][10];       \\n        //check row and col\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    if(map_row[i][num]) return false;\\n                    map_row[i][num] = true;\\n                    if(map_col[num][j]) return false;\\n                    map_col[num][j] = true;\\n                }\\n            }\\n        }\\n        \\n        //check 3*3\\n        for(int i=0; i<9; i= i+3){\\n            for(int j=0; j<9; j=j+3) {\\n                boolean[] map = new boolean[10];\\n                for(int k=0; k<3; k++){\\n                    for(int t=0; t<3; t++){\\n                        int num = board[k+i][t+j] - \\'0\\';\\n                        if(board[k+i][t+j] != \\'.\\'){\\n                            if(map[num]) return false;\\n                            map[num] = true;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n     return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175187,
                "title": "beats-77-java-with-explanations",
                "content": "**Logic**\\nA valid Sudoku should satisfy 3 requirements. For each requirement, we go through the whole grid once.\\n**Thought**\\nThe bottleneck of the Brute Force approach described above is that we traverse the grid 3 times. Could we do better?\\nWe could do row-validation and column-validation together within one traversal. That reduces the time complexity from O(3n) to O(2n) - n is the number of cells in the board (9 x 9 in this case).\\nAs for the validation on sub-boxes, it\\'s tricky to do with multi-level for-loops. If we regard a sub-box as a whole, there are 3 x 3 sub-boxes. Then we focus on the cells within a sub-box. \\n\\n**Code**\\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<Character> rowSet = new HashSet<>(); // Helper set to check duplicates of one row.\\n        Set<Character> colSet = new HashSet<>(); // Helper set to check duplicates of one column.\\n        Set<Character> boxSet = new HashSet<>(); // Helper set to check duplicates of one 3x3 sub-box.\\n        \\n        // Check for row and column (together).\\n        for (int i = 0; i < 9; i++) {\\n            rowSet.clear();\\n            colSet.clear();\\n            for (int j = 0; j < 9; j++) {               \\n                char val = board[i][j];\\n                if (val != \\'.\\') {\\n                    if (rowSet.contains(val))\\n                        return false;\\n                    rowSet.add(val);\\n                }\\n                char symmetricVal = board[j][i];\\n                if (symmetricVal != \\'.\\') {\\n                    if (colSet.contains(symmetricVal))\\n                        return false;\\n                    colSet.add(symmetricVal);                    \\n                }\\n            }\\n        }\\n        \\n        // Check for 3x3 sub-boxes of the grid.\\n        for (int i = 0; i < 3; i++) { // Subbox row number.\\n            for (int j = 0; j < 3; j++) { // Subbox column number.\\n                boxSet.clear();\\n                for (int x = i * 3; x < i * 3 + 3; x++) { // Cell row number.\\n                    for (int y = j * 3; y < j * 3 + 3; y++) { // Cel column number.\\n                        if (board[x][y] != \\'.\\' && !boxSet.add(board[x][y])) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n           }\\n        }\\n        \\n        return true;\\n    }\\n```\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<Character> rowSet = new HashSet<>(); // Helper set to check duplicates of one row.\\n        Set<Character> colSet = new HashSet<>(); // Helper set to check duplicates of one column.\\n        Set<Character> boxSet = new HashSet<>(); // Helper set to check duplicates of one 3x3 sub-box.\\n        \\n        // Check for row and column (together).\\n        for (int i = 0; i < 9; i++) {\\n            rowSet.clear();\\n            colSet.clear();\\n            for (int j = 0; j < 9; j++) {               \\n                char val = board[i][j];\\n                if (val != \\'.\\') {\\n                    if (rowSet.contains(val))\\n                        return false;\\n                    rowSet.add(val);\\n                }\\n                char symmetricVal = board[j][i];\\n                if (symmetricVal != \\'.\\') {\\n                    if (colSet.contains(symmetricVal))\\n                        return false;\\n                    colSet.add(symmetricVal);                    \\n                }\\n            }\\n        }\\n        \\n        // Check for 3x3 sub-boxes of the grid.\\n        for (int i = 0; i < 3; i++) { // Subbox row number.\\n            for (int j = 0; j < 3; j++) { // Subbox column number.\\n                boxSet.clear();\\n                for (int x = i * 3; x < i * 3 + 3; x++) { // Cell row number.\\n                    for (int y = j * 3; y < j * 3 + 3; y++) { // Cel column number.\\n                        if (board[x][y] != \\'.\\' && !boxSet.add(board[x][y])) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n           }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576940,
                "title": "go-15-lines-using-array-100-100",
                "content": "\\n```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, columns, squares [9][9]bool\\n    for i, row := range board {\\n        for j, v := range row {\\n            if v != \\'.\\' {\\n                k := int(v)-49\\n                if rows[i][k] || columns[j][k] || squares[i/3*3 + j/3][k] {\\n                    return false\\n                }\\n                rows[i][k], columns[j][k], squares[i/3*3 + j/3][k] = true, true, true\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, columns, squares [9][9]bool\\n    for i, row := range board {\\n        for j, v := range row {\\n            if v != \\'.\\' {\\n                k := int(v)-49\\n                if rows[i][k] || columns[j][k] || squares[i/3*3 + j/3][k] {\\n                    return false\\n                }\\n                rows[i][k], columns[j][k], squares[i/3*3 + j/3][k] = true, true, true\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545709,
                "title": "easy-intuitive-java-solution-beats-100-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n\\n        int[] res;\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[i][j]-\\'1\\']++;\\n\\n                if(res[board[i][j]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[j][i] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[j][i]-\\'1\\']++;\\n\\n                if(res[board[j][i]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0;i < 3;i++){\\n            for(int j = 0;j < 3;j++){\\n                res = new int[9];\\n                for(int p = 3*i;p < 3*i+3;p++){\\n                    for(int q = 3*j;q < 3*j+3;q++){\\n                        if(board[p][q] == \\'.\\'){\\n                            continue;\\n                        }\\n\\n                        res[board[p][q]-\\'1\\']++;\\n\\n                        if(res[board[p][q]-\\'1\\'] > 1){\\n                            return false;\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n\\n        int[] res;\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[i][j]-\\'1\\']++;\\n\\n                if(res[board[i][j]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[j][i] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[j][i]-\\'1\\']++;\\n\\n                if(res[board[j][i]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0;i < 3;i++){\\n            for(int j = 0;j < 3;j++){\\n                res = new int[9];\\n                for(int p = 3*i;p < 3*i+3;p++){\\n                    for(int q = 3*j;q < 3*j+3;q++){\\n                        if(board[p][q] == \\'.\\'){\\n                            continue;\\n                        }\\n\\n                        res[board[p][q]-\\'1\\']++;\\n\\n                        if(res[board[p][q]-\\'1\\'] > 1){\\n                            return false;\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951286,
                "title": "single-iteration-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n- O(n\\xB2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n\\xB2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        set<string> s;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    string r = \"r\" + to_string(i) +  board[i][j];\\n                    string c = \"c\" + to_string(j) +  board[i][j];\\n                    string sqr = \"sqr\" + to_string((i/3)*3 + (j/3)) +  board[i][j];\\n\\n                    if(s.find(r)==s.end() && s.find(c)==s.end() && s.find(sqr)==s.end()){\\n                        s.insert(r);\\n                        s.insert(c);\\n                        s.insert(sqr);\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        set<string> s;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    string r = \"r\" + to_string(i) +  board[i][j];\\n                    string c = \"c\" + to_string(j) +  board[i][j];\\n                    string sqr = \"sqr\" + to_string((i/3)*3 + (j/3)) +  board[i][j];\\n\\n                    if(s.find(r)==s.end() && s.find(c)==s.end() && s.find(sqr)==s.end()){\\n                        s.insert(r);\\n                        s.insert(c);\\n                        s.insert(sqr);\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843411,
                "title": "python-easy-99-73-faster-using-set",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def check(a):\\n            s=set()\\n            for i in a:\\n                if i==\\'.\\':\\n                    continue\\n                if i in s:\\n                    return False\\n                s.add(i)\\n            return True\\n        \\n        #To check each row must contain the digits 1-9 without repetition.\\n        for row in board:\\n            if not check(row):\\n                return False\\n        \\n        #To check each column must contain the digits 1-9 without repetition.\\n        for i in range(9):\\n            column=[]\\n            for j in range(9):\\n                column.append(board[j][i])\\n            if not check(column):\\n                return False\\n        \\n        #To check each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9                without repetition.\\n        for i in range(0,9,3):\\n            for j in range(0,9,3):\\n                square=[]\\n                for k in range(i,i+3):\\n                    for l in range(j,j+3):\\n                        square.append(board[k][l])\\n                if not check(square):\\n                    return False\\n        return True\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def check(a):\\n            s=set()\\n            for i in a:\\n                if i==\\'.\\':\\n                    continue\\n                if i in s:\\n                    return False\\n                s.add(i)\\n            return True\\n        \\n        #To check each row must contain the digits 1-9 without repetition.\\n        for row in board:\\n            if not check(row):\\n                return False\\n        \\n        #To check each column must contain the digits 1-9 without repetition.\\n        for i in range(9):\\n            column=[]\\n            for j in range(9):\\n                column.append(board[j][i])\\n            if not check(column):\\n                return False\\n        \\n        #To check each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9                without repetition.\\n        for i in range(0,9,3):\\n            for j in range(0,9,3):\\n                square=[]\\n                for k in range(i,i+3):\\n                    for l in range(j,j+3):\\n                        square.append(board[k][l])\\n                if not check(square):\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841718,
                "title": "c-just-check-for-everything",
                "content": "```\\n#define vb vector<bool>\\n#define vvc vector<vector<char>>\\nclass Solution {\\npublic:\\n    void hash_setter (vb &hash){\\n        for (int i = 0; i < 10; i++) hash[i] = 0;\\n    }    \\n    \\n    bool row_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[i][j] == \\'.\\') continue;\\n                if (hash[board[i][j]-\\'0\\']) return 0;\\n                \\n                hash[board[i][j]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool col_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[j][i] == \\'.\\') continue;\\n                if (hash[board[j][i]-\\'0\\']) return 0;\\n                \\n                hash[board[j][i]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool sub_box_check (vvc &board, int i, int j){\\n        vb hash (10,0);\\n        \\n        for (int k = i; k < i+3; k++){\\n            for (int l = j; l < j+3; l++){\\n                if (board[k][l] == \\'.\\') continue;\\n                if (hash[board[k][l]-\\'0\\']) return 0;\\n                \\n                hash[board[k][l]-\\'0\\'] = 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool sub_box_generate (vvc &board){\\n        for (int i = 0; i < 9; i+=3){\\n            for (int j = 0; j < 9; j+=3){\\n                if (sub_box_check (board, i, j) == 0) return 0;\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) { \\n        if (!row_check (board) || !col_check (board) || !sub_box_generate (board)) return 0;\\n        \\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define vb vector<bool>\\n#define vvc vector<vector<char>>\\nclass Solution {\\npublic:\\n    void hash_setter (vb &hash){\\n        for (int i = 0; i < 10; i++) hash[i] = 0;\\n    }    \\n    \\n    bool row_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[i][j] == \\'.\\') continue;\\n                if (hash[board[i][j]-\\'0\\']) return 0;\\n                \\n                hash[board[i][j]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool col_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[j][i] == \\'.\\') continue;\\n                if (hash[board[j][i]-\\'0\\']) return 0;\\n                \\n                hash[board[j][i]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool sub_box_check (vvc &board, int i, int j){\\n        vb hash (10,0);\\n        \\n        for (int k = i; k < i+3; k++){\\n            for (int l = j; l < j+3; l++){\\n                if (board[k][l] == \\'.\\') continue;\\n                if (hash[board[k][l]-\\'0\\']) return 0;\\n                \\n                hash[board[k][l]-\\'0\\'] = 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool sub_box_generate (vvc &board){\\n        for (int i = 0; i < 9; i+=3){\\n            for (int j = 0; j < 9; j+=3){\\n                if (sub_box_check (board, i, j) == 0) return 0;\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) { \\n        if (!row_check (board) || !col_check (board) || !sub_box_generate (board)) return 0;\\n        \\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841476,
                "title": "c-bit-masking-easy-to-understand",
                "content": "# Approach 1: bitmasking\\nN.B. ```\\'1\\' & 0xf == 1```, this yields the same result as ```\\'1\\' - \\'0\\'```, but is still a neat trick to convert ASCII digits. That\\'s a trick from the times when CPUs where a lot slower and it was cheaper to do ```and``` than ```sub```.\\n\\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                // row\\n                if (rows[r] & mask) return false;\\n                rows[r] |= mask;\\n                // col\\n                if (cols[c] & mask) return false;\\n                cols[c] |= mask;\\n                // box    \\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if (boxes[box] & mask) return false;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\\n\\nMaybe a quesion of taste, but we could also write this a bit more compact:\\n\\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if ((rows[r] & mask) || (cols[c] & mask) || (boxes[box] & mask))\\n                    return false;\\n                rows[r] |= mask;\\n                cols[c] |= mask;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\\n\\nStrictly speaking we could use ```array<short, 9>``` instead of ```array<int, 9>``` or maybe even pack everything into a ```bitset<81>```.\\n\\n**Complexity Analysis**\\nThe input size is fixed, hence this is $$O(1)$$ in both cases. Is this correct?\\n  * Time complexity: $$O(1)$$.\\n  * Space complexity: $$O(1)$$.\\n\\nOTAH if we considered $$n$$ as the length of the board, i.e. 9 and assume it could grow then:\\n  * Time complexity: $$O(n^2)$$ and\\n  * Space complexity: $$O(n)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\'1\\' & 0xf == 1```\n```\\'1\\' - \\'0\\'```\n```and```\n```sub```\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                // row\\n                if (rows[r] & mask) return false;\\n                rows[r] |= mask;\\n                // col\\n                if (cols[c] & mask) return false;\\n                cols[c] |= mask;\\n                // box    \\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if (boxes[box] & mask) return false;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if ((rows[r] & mask) || (cols[c] & mask) || (boxes[box] & mask))\\n                    return false;\\n                rows[r] |= mask;\\n                cols[c] |= mask;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\n```array<short, 9>```\n```array<int, 9>```\n```bitset<81>```",
                "codeTag": "Unknown"
            },
            {
                "id": 2841425,
                "title": "java-easy-to-understand-with-comments-using-hashset-beats-100",
                "content": "*Upvote if you like the solution!!!*\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<Character> Rset = new HashSet<>(); //to check repetition in rows\\n        HashSet<Character> Cset = new HashSet<>(); //to check repetition in columns\\n\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board.length;j++){\\n                if(board[i][j]==\\'.\\') continue;\\n                else {\\n                    if(!Rset.add(board[i][j])) return false;  //if same elemets are added Rset.add return false;\\n                }\\n                }\\n            Rset = new HashSet<>();  //clearing the Rset after checking for one row.\\n            }\\n        \\n\\n        for(int j=0;j<board.length;j++){\\n            for(int i=0;i<board.length;i++){\\n                if(board[i][j]==\\'.\\')continue;\\n                    else{\\n                    if(!Cset.add(board[i][j])) return false; //if same elemets are added Cset.add return false;\\n                    }\\n            }\\n            Cset = new HashSet<>();  //clearing the Cset after checking for one column.\\n        }\\n        \\n        //now the 3rd condition checking repetitions in 3x3 sub-boxes.\\n        for(int i=0;i<9;i+=3){\\n            for(int j=0;j<9;j+=3){\\n                if(!check3(i,j,board)) return false;\\n            }\\n        }\\n        \\n        //if all conditions are validated we return true.\\n        return true;\\n        }\\n    \\n    //this function checks repetition in a 3x3 matrix\\n    public boolean check3(int i,int j,char[][] board){\\n        HashSet<Character> set3 = new HashSet<>();\\n        for(int m=i;m<3+i;m++){\\n            for(int n=j;n<3+j;n++){\\n                if(board[m][n]==\\'.\\') continue;\\n                else {\\n                    if(!set3.add(board[m][n])) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<Character> Rset = new HashSet<>(); //to check repetition in rows\\n        HashSet<Character> Cset = new HashSet<>(); //to check repetition in columns\\n\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board.length;j++){\\n                if(board[i][j]==\\'.\\') continue;\\n                else {\\n                    if(!Rset.add(board[i][j])) return false;  //if same elemets are added Rset.add return false;\\n                }\\n                }\\n            Rset = new HashSet<>();  //clearing the Rset after checking for one row.\\n            }\\n        \\n\\n        for(int j=0;j<board.length;j++){\\n            for(int i=0;i<board.length;i++){\\n                if(board[i][j]==\\'.\\')continue;\\n                    else{\\n                    if(!Cset.add(board[i][j])) return false; //if same elemets are added Cset.add return false;\\n                    }\\n            }\\n            Cset = new HashSet<>();  //clearing the Cset after checking for one column.\\n        }\\n        \\n        //now the 3rd condition checking repetitions in 3x3 sub-boxes.\\n        for(int i=0;i<9;i+=3){\\n            for(int j=0;j<9;j+=3){\\n                if(!check3(i,j,board)) return false;\\n            }\\n        }\\n        \\n        //if all conditions are validated we return true.\\n        return true;\\n        }\\n    \\n    //this function checks repetition in a 3x3 matrix\\n    public boolean check3(int i,int j,char[][] board){\\n        HashSet<Character> set3 = new HashSet<>();\\n        for(int m=i;m<3+i;m++){\\n            for(int n=j;n<3+j;n++){\\n                if(board[m][n]==\\'.\\') continue;\\n                else {\\n                    if(!set3.add(board[m][n])) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840675,
                "title": "python-3-10-lines-bitmaps-t-m-95-85",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\n        row, col, hse = [0]*9, [0]*9, [0]*9\\n\\n        for i,j in product(range(9), range(9)):\\n\\n            b = board[i][j]\\n            if not b.isdigit(): continue\\n            b, ij = 1<<int(b), 3*(i//3)+j//3\\n\\n            if row[i]&b or col[j]&b or hse[ij]&b: return False\\n\\n            row[i ]|=b\\n            col[j ]|=b\\n            hse[ij]|=b\\n\\n        return True\\n```\\n[https://leetcode.com/problems/valid-sudoku/submissions/997890268/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\n        row, col, hse = [0]*9, [0]*9, [0]*9\\n\\n        for i,j in product(range(9), range(9)):\\n\\n            b = board[i][j]\\n            if not b.isdigit(): continue\\n            b, ij = 1<<int(b), 3*(i//3)+j//3\\n\\n            if row[i]&b or col[j]&b or hse[ij]&b: return False\\n\\n            row[i ]|=b\\n            col[j ]|=b\\n            hse[ij]|=b\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291296,
                "title": "java-cleanest-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            String r = \\'r\\' + \"-\" + i + board[i][j];\\n            String c = \\'c\\' + \"-\" + j + board[i][j];\\n            String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n            \\n            if(!map.add(r) || !map.add(c) || !map.add(rc))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            String r = \\'r\\' + \"-\" + i + board[i][j];\\n            String c = \\'c\\' + \"-\" + j + board[i][j];\\n            String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n            \\n            if(!map.add(r) || !map.add(c) || !map.add(rc))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281872,
                "title": "java-in-depth-explanation-easy-to-implement",
                "content": "**Intuition**\\nBasically, we need to check three conditions:\\n\\n1. Each row must contain the digits 1-9 without repetition.\\n2. Each column must contain the digits 1-9 without repetition.\\n3. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\\n\\nIf all of them are true, then return true. Otherwise, return false.\\n\\n**Debat**\\nI personally think both time and space complexity are O(1) since we would achieve O(81) mostly because of the size of board[ ][ ]. But this could be debatable. You could talk this to your interviewer during the interview. My interviwer agrees my point by the way. \\n\\n```\\nclass Solution \\n{\\n    public boolean isValidSudoku(char[][] board)\\n    {\\n        // O(1) time | O(1) space\\n        HashSet<String> mySet = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    if(mySet.contains(\"row\" + i + board[i][j]) || mySet.contains(\"col\" + j + board[i][j]) || mySet.contains(\"box\" + i/3 + j/3 + board[i][j]))\\n                        return false;\\n                    \\n                    mySet.add(\"row\" + i + board[i][j]);\\n                    mySet.add(\"col\" + j + board[i][j]);\\n                    mySet.add(\"box\" + i/3 + j/3 + board[i][j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean isValidSudoku(char[][] board)\\n    {\\n        // O(1) time | O(1) space\\n        HashSet<String> mySet = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    if(mySet.contains(\"row\" + i + board[i][j]) || mySet.contains(\"col\" + j + board[i][j]) || mySet.contains(\"box\" + i/3 + j/3 + board[i][j]))\\n                        return false;\\n                    \\n                    mySet.add(\"row\" + i + board[i][j]);\\n                    mySet.add(\"col\" + j + board[i][j]);\\n                    mySet.add(\"box\" + i/3 + j/3 + board[i][j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033555,
                "title": "javascript-hashmap-solution-with-short-comment-97-12-faster",
                "content": "```\\nvar isValidSudoku = function(board) {\\n    const hash = {};\\n    \\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            if(board[i][j] === \\'.\\') continue; // if current value is equal \\'.\\' , skip to next index\\n            if(hash[board[i][j]] === undefined) { \\n                const box = calculateBox(i,j);\\n                hash[board[i][j]] = [[i, j, box]]; // because the same value can be repeated, it is created as an array\\n            } \\n            else { \\n                for(let k = 0; k < hash[board[i][j]].length; k++) {  \\n                    const [row, col, box] = hash[board[i][j]][k];  // Get row, col, and box information of the same value as the current value\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// check current value is validated with sdoku rules\\n                    if(row === i || col === j) return false;  \\n                    else if(calculateBox(i,j) === box) return false;\\n                }\\n                hash[board[i][j]].push([i, j, calculateBox(i,j)]); // if it is valitated sudoku rules, push to hashmap  for example hash {\\'5\\': [ [ 2, 0, 1 ], [ 3, 3, 5 ] ] }\\n            }\\n        }\\n    }\\n    return true;\\n};\\n\\n\\nfunction calculateBox(row, col) { //calculate box number with row and col\\n return Math.floor(row/3) * 3 + Math.floor(col/3);\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidSudoku = function(board) {\\n    const hash = {};\\n    \\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            if(board[i][j] === \\'.\\') continue; // if current value is equal \\'.\\' , skip to next index\\n            if(hash[board[i][j]] === undefined) { \\n                const box = calculateBox(i,j);\\n                hash[board[i][j]] = [[i, j, box]]; // because the same value can be repeated, it is created as an array\\n            } \\n            else { \\n                for(let k = 0; k < hash[board[i][j]].length; k++) {  \\n                    const [row, col, box] = hash[board[i][j]][k];  // Get row, col, and box information of the same value as the current value\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// check current value is validated with sdoku rules\\n                    if(row === i || col === j) return false;  \\n                    else if(calculateBox(i,j) === box) return false;\\n                }\\n                hash[board[i][j]].push([i, j, calculateBox(i,j)]); // if it is valitated sudoku rules, push to hashmap  for example hash {\\'5\\': [ [ 2, 0, 1 ], [ 3, 3, 5 ] ] }\\n            }\\n        }\\n    }\\n    return true;\\n};\\n\\n\\nfunction calculateBox(row, col) { //calculate box number with row and col\\n return Math.floor(row/3) * 3 + Math.floor(col/3);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918864,
                "title": "java-easy-solution-2-lines-of-logic",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> seen = new HashSet();\\n        \\n        for (int i =0 ; i < 9; i++) {\\n            \\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    if (!seen.add(\"row\" + i + board[i][j]) || !seen.add(\"col\" + j + board[i][j])) {\\n                        return false;\\n                    }\\n                    if (!seen.add(\"box\" + (i / 3) * 3 + j / 3 + board[i][j])) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> seen = new HashSet();\\n        \\n        for (int i =0 ; i < 9; i++) {\\n            \\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    if (!seen.add(\"row\" + i + board[i][j]) || !seen.add(\"col\" + j + board[i][j])) {\\n                        return false;\\n                    }\\n                    if (!seen.add(\"box\" + (i / 3) * 3 + j / 3 + board[i][j])) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822522,
                "title": "using-unordered-set-with-comments-c",
                "content": "Implementation\\n\\n**Using Unordered Set\\nTime Complexity = O(N^2)\\nSpace Complexity = O(N^2)**\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // store the row index and value of that particular row index\\n        // store the col index and value of that particular col index\\n        // store the particular box index and value in the particular box index\\n        // we will store the row, col & box index and their value into this visited unordered set\\n        unordered_set<string> visited;\\n        \\n        for(int row = 0; row < 9; row++){\\n            for(int col = 0; col < 9; col++){\\n                \\n                // if the current index value is dot(.) then we don\\'t need to do anything \\n                if(board[row][col] != \\'.\\'){\\n                    \\n                    // if any particular (row index with value) or (col index with value) or (box index with value) already visited it means that is not a valid sudoku, so we will directly return false\\n                    if(visited.find(\"Row\" + to_string(row) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Col\" + to_string(col) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Box\" + to_string(((row/3) * 3 + (col/3))) + to_string(board[row][col])) != visited.end()){\\n                        return false;\\n                    }\\n                    \\n                    // if not visited yet, then add (row index & value) and (col index & value) and (box index & value) into the visited unordered set\\n                    visited.insert(\"Row\" + to_string(row) + to_string(board[row][col]));\\n                    visited.insert(\"Col\" + to_string(col) + to_string(board[row][col]));\\n                    visited.insert(\"Box\" + to_string((row/3)*3 + (col/3)) + to_string(board[row][col]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // store the row index and value of that particular row index\\n        // store the col index and value of that particular col index\\n        // store the particular box index and value in the particular box index\\n        // we will store the row, col & box index and their value into this visited unordered set\\n        unordered_set<string> visited;\\n        \\n        for(int row = 0; row < 9; row++){\\n            for(int col = 0; col < 9; col++){\\n                \\n                // if the current index value is dot(.) then we don\\'t need to do anything \\n                if(board[row][col] != \\'.\\'){\\n                    \\n                    // if any particular (row index with value) or (col index with value) or (box index with value) already visited it means that is not a valid sudoku, so we will directly return false\\n                    if(visited.find(\"Row\" + to_string(row) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Col\" + to_string(col) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Box\" + to_string(((row/3) * 3 + (col/3))) + to_string(board[row][col])) != visited.end()){\\n                        return false;\\n                    }\\n                    \\n                    // if not visited yet, then add (row index & value) and (col index & value) and (box index & value) into the visited unordered set\\n                    visited.insert(\"Row\" + to_string(row) + to_string(board[row][col]));\\n                    visited.insert(\"Col\" + to_string(col) + to_string(board[row][col]));\\n                    visited.insert(\"Box\" + to_string((row/3)*3 + (col/3)) + to_string(board[row][col]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777939,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string toStr(int k)\\n    {\\n        stringstream ss;\\n        ss << k;\\n        string s;\\n        ss >> s;\\n        return s;\\n    }\\n    bool isValidSudoku(vector<vector<char>> &board)\\n    {\\n        map<string, int> mp;\\n        string temp;\\n        int n = board.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (board[i][j] != \\'.\\')\\n                {\\n                    //-------------------Inserting for ROW and value in its cell\\n                    //-------------------In case the same row contains the duplicate values, we can find it by map/ set or any DS.\\n                    temp = \"ROW\";\\n                    temp += toStr(i) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for COL and value in its cell\\n                    temp = \"COL\";\\n                    temp += toStr(j) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for BOX \\n                    //-------------------There are 9 boxes of size 3x3 in sudoku\\n                    //-------------------and every value in box should be unique\\n                    temp = \"BOX\";\\n                    temp += toStr((i / 3) * 3 + (j / 3)) + (board[i][j]);\\n                    // cout<<temp<<endl;\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string toStr(int k)\\n    {\\n        stringstream ss;\\n        ss << k;\\n        string s;\\n        ss >> s;\\n        return s;\\n    }\\n    bool isValidSudoku(vector<vector<char>> &board)\\n    {\\n        map<string, int> mp;\\n        string temp;\\n        int n = board.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (board[i][j] != \\'.\\')\\n                {\\n                    //-------------------Inserting for ROW and value in its cell\\n                    //-------------------In case the same row contains the duplicate values, we can find it by map/ set or any DS.\\n                    temp = \"ROW\";\\n                    temp += toStr(i) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for COL and value in its cell\\n                    temp = \"COL\";\\n                    temp += toStr(j) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for BOX \\n                    //-------------------There are 9 boxes of size 3x3 in sudoku\\n                    //-------------------and every value in box should be unique\\n                    temp = \"BOX\";\\n                    temp += toStr((i / 3) * 3 + (j / 3)) + (board[i][j]);\\n                    // cout<<temp<<endl;\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1714485,
                "title": "python-3-using-hash-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [{} for _ in range(9)] # check which value exists in each row\\n        cols = [{} for _ in range(9)] # check which value exists in each column\\n        boxes = [{} for _ in range(9)] # check which value exists in each box\\n        for row in range(9):\\n            for col in range(9):\\n                bIdx =(row//3)*3 + col//3 # convert cell location to box location\\n                v = board[row][col]\\n                if v!=\\'.\\':\\n                    if v in rows[row] or v in cols[col] or v in boxes[bIdx]: # if exist in either rows/cols/boxes\\n                        return False\\n                    else: # add them in\\n                        rows[row][v] = True\\n                        cols[col][v] = True\\n                        boxes[bIdx][v] = True\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [{} for _ in range(9)] # check which value exists in each row\\n        cols = [{} for _ in range(9)] # check which value exists in each column\\n        boxes = [{} for _ in range(9)] # check which value exists in each box\\n        for row in range(9):\\n            for col in range(9):\\n                bIdx =(row//3)*3 + col//3 # convert cell location to box location\\n                v = board[row][col]\\n                if v!=\\'.\\':\\n                    if v in rows[row] or v in cols[col] or v in boxes[bIdx]: # if exist in either rows/cols/boxes\\n                        return False\\n                    else: # add them in\\n                        rows[row][v] = True\\n                        cols[col][v] = True\\n                        boxes[bIdx][v] = True\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442272,
                "title": "c-using-set",
                "content": "**Please Upvote if you like!**\\n\\n     bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\t// Create vectors of unordered sets to keep track of numbers in rows, columns, and boxes\\n\\t\\tvector<unordered_set<int>> rows(9);\\n\\t\\tvector<unordered_set<int>> columns(9);\\n\\t\\tvector<unordered_set<int>> boxes(9);\\n\\n\\t\\t// Iterate through each cell in the Sudoku board\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\t// If the cell is empty, continue to the next cell\\n\\t\\t\\t\\tif (board[i][j] == \\'.\\') {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Convert the character to an integer to get the number in the cell\\n\\t\\t\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current row\\n\\t\\t\\t\\tif (rows[i].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current column\\n\\t\\t\\t\\tif (columns[j].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Calculate the index of the box the current cell belongs to\\n\\t\\t\\t\\tint index = (i / 3) * 3 + j / 3;\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current box\\n\\t\\t\\t\\tif (boxes[index].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the number doesn\\'t violate any rules, insert it into the sets\\n\\t\\t\\t\\trows[i].insert(num);\\n\\t\\t\\t\\tcolumns[j].insert(num);\\n\\t\\t\\t\\tboxes[index].insert(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If the Sudoku has been checked and no violations were found, it\\'s valid\\n\\t\\treturn true;\\n\\t}\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "**Please Upvote if you like!**\\n\\n     bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\t// Create vectors of unordered sets to keep track of numbers in rows, columns, and boxes\\n\\t\\tvector<unordered_set<int>> rows(9);\\n\\t\\tvector<unordered_set<int>> columns(9);\\n\\t\\tvector<unordered_set<int>> boxes(9);\\n\\n\\t\\t// Iterate through each cell in the Sudoku board\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\t// If the cell is empty, continue to the next cell\\n\\t\\t\\t\\tif (board[i][j] == \\'.\\') {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Convert the character to an integer to get the number in the cell\\n\\t\\t\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current row\\n\\t\\t\\t\\tif (rows[i].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current column\\n\\t\\t\\t\\tif (columns[j].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Calculate the index of the box the current cell belongs to\\n\\t\\t\\t\\tint index = (i / 3) * 3 + j / 3;\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current box\\n\\t\\t\\t\\tif (boxes[index].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the number doesn\\'t violate any rules, insert it into the sets\\n\\t\\t\\t\\trows[i].insert(num);\\n\\t\\t\\t\\tcolumns[j].insert(num);\\n\\t\\t\\t\\tboxes[index].insert(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If the Sudoku has been checked and no violations were found, it\\'s valid\\n\\t\\treturn true;\\n\\t}\\n",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566470,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1568854,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572579,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1711763,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1565592,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1567818,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1798774,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1576771,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572483,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1921338,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1566470,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1568854,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572579,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1711763,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1565592,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1567818,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1798774,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1576771,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572483,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1921338,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1683701,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1569508,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1567730,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1862520,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1809889,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1884629,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1770423,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1694929,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1571088,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 2076453,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 2071938,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2052835,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2051907,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2050119,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2040084,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2038730,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1879995,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1806063,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1575839,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1574493,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1574352,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1574267,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1573556,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1573156,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1573029,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1572416,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1572116,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1571089,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1571090,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1574892,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1571885,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2059206,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2058299,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2025457,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2020432,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1984607,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1973127,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1949150,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1946320,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1910695,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1891660,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1890091,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1866863,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1852501,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1842159,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1804528,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1801860,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1793480,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1793287,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1792556,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1768442,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1767626,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1766850,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1762149,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1757021,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1753314,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1752608,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1749110,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1737683,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1729151,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1728953,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1728092,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1726273,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1721325,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1720748,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1699178,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1695612,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1694022,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1693586,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1686551,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            }
        ]
    },
    {
        "title": "Single Number",
        "question_content": "<p>Given a <strong>non-empty</strong>&nbsp;array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p>\n\n<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,1]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,1,2,1,2]\n<strong>Output:</strong> 4\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li>Each element in the array appears twice except for one element which appears only once.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1771720,
                "title": "c-easy-solutions-sorting-xor-maps-or-frequency-array",
                "content": "Hi , everybody . This question is quite easy. I am quite confident that most of you would have reached atleast 1 of the following approaches to solve this question. But , incase you missed any of them , do give this a read.\\n### EXPLANATION :\\n**The question simply asks us to find an element in the given array whose frequency is 1.All the other elements have a frequency=2. \\nWe have to do so in :**\\n* **Linear Time**\\n* **Using Constant Space**\\n\\n\\n\\n##### METHOD 1 : USING MAPS (NOT USING CONSTANT SPACE ) \\nThe question states that we have to find an element in the array with frequency=1. \\nSo , the first idea that pops in the mind is to store the frequency of each element in a map (or a frequency array) and then traverse that map/array and return the element with frequency=1. \\n\\n1. Map the given array\\'s elements to their frequency. ( KEY : ELEMENT , VALUE : FREQUENCY )\\n2. Traverse that map and return the key whose value =1. \\n\\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};\\n```\\n\\n**TC: O(N)**\\n**SC: O(N)**\\n\\n\\nNow , if we see the above method uses variable extra space, which is why it can\\'t be our answer. \\n(Although it is an approach to solve this problem). \\nThen how do we solve this ?? \\nImagine you have blocks with the array elements inscribed on them. Now , if I sort the array for you and now ask you to find the element , CAN YOU DO SO ?? \\n\\nYes , upon sorting , every element will have a similar element adjacent to it , if it has the frequency of 2.\\n\\n##### METHOD 2 : USING SORTING (USING CONSTANT SPACE ) \\nAs explained above , we do the following :\\n1. Sort the array. \\n2. Traverse the array and check if one of the adjacent elements is equal to the current element or not. \\n3. If yes , move ahead. Else return the current element. \\n\\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\\n\\n**TC: O(NlogN)**\\n**SC: O(1)**\\n\\nThe above approach can be used to solve the problem . But what if we can improve the time complexity ??\\nWhat if we don\\'t have to sort the array ?? \\nThe following method deals with that approach. \\n##### METHOD 3 : USING BITWISE XOR OPERATOR (USING CONSTANT SPACE ) \\nTo use this approach you first need to understand about Bitwise XOR operator. \\nMost of us who have a background in physics ( highschool level ) , are aware of the LOGIC GATES. \\nOne of such gates is the XOR Gate : \\nAccording to this gate , the output is true , only if both the inputs are of opposite kind . \\nThat is , \\n\\t\\t\\t\\t\\t **A             B                   Y**\\n\\t\\t\\t\\t\\t **0             0                    0**\\n\\t\\t\\t\\t\\t **0             1                    1**\\n\\t\\t\\t\\t\\t **1             0                    1**\\n\\t\\t\\t\\t\\t **1             1                    0**\\n\\t\\t\\t\\t\\t \\nWe apply the extended version of this gate in our bitwise XOR operator. \\nIf we do \"a^b\" , it means that we are applying the XOR gate on the 2 numbers in a bitwise fashion ( on each of the corresponding bits of the numbers). \\nSimilarly , if we observe , \\n1.  ***A^A=0***\\n2.  ***A^B^A=B***\\n3.  ***(A^A^B) = (B^A^A) = (A^B^A) = B***  This shows that position doesn\\'t matter. \\n4.  Similarly , if we see , ***a^a^a......... (even times)=0 and a^a^a........(odd times)=a***\\n\\nGoogle It for more details. \\n\\nWe apply the above observations : \\n1. Traverse the array and take the Bitwise XOR of each element. \\n2. Return the value. \\n\\n**Why does this work ??**\\nBecause , the elements with frequency=2 will result in 0. And then the only element with frequency=1 will generate the answer. \\n\\t\\t\\t\\t\\t \\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       int ans=0;\\n\\t   for(auto x:nums)\\n\\t   ans^=x;\\n\\t   return ans;\\n    }\\n};\\n```\\n\\n**TC: O(N)**\\n**SC: O(1)**\\n\\n\\n### PS : METHOD 4: SUM OF ELEMENTS \\nAll the unique elements , in the array have a frequency of 2 , except one element. \\n\\n1. Store all the unique elements in set. \\n2. Add the elements of the set and multiply by 2 (SUM_1). \\n3. Add all the elements of the array(ARRAY_SUM). \\n4. Return (SUM_1 - ARRAY_SUM) . \\n\\n**Why does this work ??**\\nARRAY_SUM = 2*(a1+a2+a3...+ak) + a(k+1)\\nSUM_1 = 2*(a1+a2+a3+....+ak+ a(k+1)) \\n\\n*a(x) represents the xth unique element in the array. \\na(k+1) represents the element with frequency=1.*\\n\\nHope you found this post useful . If so , then do upvote and comment below.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       int ans=0;\\n\\t   for(auto x:nums)\\n\\t   ans^=x;\\n\\t   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771771,
                "title": "think-it-through-time-o-n-space-o-1-python-explained",
                "content": "\\n### Edge Cases:\\n1. No element appears twice; it is a constraint so not possible\\n2. Single length array; return the only element already present in the array\\n3. len(nums) > 1; find the single element that does not appear twice\\n\\n### Approaches:\\n1. **Brute Force**\\nIntuition:\\nIterate through every element in the nums and check if any of the element does not appear twice, in that case return the element.\\n*Time: O(n^2)\\nSpace: O(1)*\\n\\n2. **Use Sorting**\\nIntuition:\\nIf the elements of the nums array are sorted/when we sort it, we can compare the neighbours to find the single element. It is already mentioned that all other elements appear twice except one.\\n*Time: O(nlogn) for sorting then O(n) to check neighbouring elements\\nSpace: O(1)*\\n\\n3. **Use Hashing/Set**\\nIntuition:\\ni) As we iterate through the nums array we store the elements encountered and check if we find them again while iteration continues. While checking if we find them again, we maintain a single_element object/variable which stores that single element, eventually returning the single_element.\\nii) The other way is to maintain a num_frequency hashmap/dictionary and iterate over it to find which has exactly 1 frequency and return that key/num.\\n*Time: O(n) for iterating over the nums array\\nSpace: O(n) for hashing*\\n\\n4. **Use Xor/Bit Manipulation**\\nIntuition:\\nXor of any two num gives the difference of bit as 1 and same bit as 0.\\nThus, using this we get 1 ^ 1 == 0 because the same numbers have same bits.\\nSo, we will always get the single element because all the same ones will evaluate to 0 and 0^single_number = single_number.\\n*Time: O(n)\\nSpace: O(1)*\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        \\n        return xor\\n\\n```\\n\\n**Updated**:\\n*You can find more of my solutions like this in discuss forums by searching through either **satyamsinha93** or **Think it through**.*\\n\\nThanks for all the love and upvoting!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        \\n        return xor\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772139,
                "title": "c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run",
                "content": "***Brief note about Question-***\\n* We have to return the number which is *appears single time* in the array.\\n```\\nLet\\'s take an example not given in question -\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\nSo, our answer should be \\'7\\' as it appears only single time in the array. \\n```\\n_________________\\n***Solution - I (using unorderd map, Accepted)-***\\n* Since we are very obedient person and don\\'t want to do anything extra from our side.\\n* So, on seeing the question, the first idea that clicks to our mind is to ***store frequency*** of all over the elements.\\n* After storing frequency, we will simply ***find the element whose frequency is 1***.\\n* The element whose frequency is 1, that is our answer.\\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(n) // we will store the frequency of every element\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\\n***So, How we will implement that?***\\n* Whenever we heard the name *frequency*, we will call our one and only superhero i.e `unordered_map`.\\n* We will store frequency of each element in our unorderd map.\\n* After that, we **traverse from the map**, and for every element we check whether it\\'s **frequency is 1** or not.\\n* If it\\'s frequency is 1, then we will simply store the answer and break the loop.\\n* See, an example.\\n```\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nso, after storing frequency of each element in our map, our map looks like -\\n5 -> 2\\n1 -> 2\\n3 -> 2\\n4 -> 2\\n7 -> 1     On traversing, we will see that it\\'s frequency is 1, so this should be our answer.\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // taking the size of the array \\n        \\n        unordered_map<int, int> mp; // unordered map to store the frequency\\n        \\n        // storing frequency in the map\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int ans; // variable to store our answer\\n        for(auto x: mp) // traverse from the map\\n        {\\n            if(x.second == 1) //if frequency of any elemennt is 1\\n            {\\n                ans = x.first; // store in our answer\\n                break; // break the loop, as we got our answer now\\n            }\\n        }\\n        \\n        return ans; // return ans\\n    }\\n};\\n```\\n____\\n***Solution - II (using property of xor, Accepted)-***\\n* Now, the question arises, is their any way so that we do not need to store frequency, i.e \\n**can we space optimized our answer**?\\n* Since, we want not to use map, so we will see our map that where is the problem?\\n* We observe a very basic thing that other than our answer, **frequency of each element is 2**, that means our question wants to say that, ***every element appears twice except the single one and we have to find that particular single element.***\\n* So, if every element appears twice, *do we really need to store the frequency of each element*?\\n* Answer is **No**, we do not need to store the frequency of each element because we already know that, for each element their is only two ways, **either it\\'s frequency is 1 or it\\'s frequency is 2**. Their is not any third option other than that.\\n* In this way, we can think of ***the property of XOR-***\\n```\\n0 ^ 0 --> 0\\n0 ^ 1 --> 1\\n1 ^ 0 --> 1\\n1 ^ 1 --> 0\\n```\\n* If we see, we will find out that ***xor of two same number is zero***.\\n* Can we use this property here?\\n* Answer is ***Yes***. But how? \\n* We will run a loop from all over the array, and simply start taking xor of two.\\n* We do xor between prev answer of xor and current element.\\n* See dry run for more clarification.\\n* But, Question is **WHY**? why this works?\\n```\\nWe know every number is appears twice except a single number which appears only single time.\\n\\nSee, we already discuss a thing a that xor of a same number with itself is zero, i.e A ^ A = 0\\nNow, we will look some more property of xor-\\n\\n1) xor of a same number with itself is zero, i.e A ^ A = 0\\n2) xor is commutative that means a ^ b = b ^ a.\\n3) xor of any number with zero is the number itself i.e A ^ 0 = A.\\n\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nwe will rearrange the array, and take all the numbers together, then our array looks like\\n                     arr[]: [1, 1, 3, 3, 4, 4, 5, 5, 7]\\n\\t\\t\\t\\t\\t now, take xor of all numbers -\\n\\t\\t\\t\\t\\t 1 ^ 1 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 7   (rearrange the array)\\n\\t\\t\\t\\t\\t   0   ^   0   ^   0   ^   0   ^ 7   (see point number 1)\\n\\t\\t\\t\\t\\t               7                     (see point number 3) \\n\\n```\\n* Now, The question again arises, **do we really need to rearrange the array ?**\\n* Answer is ***NO***.\\n* We already know a property of xor, that says we don\\'t need to rearrange the array. But wait, where?\\n* `xor is commutative that means a ^ b = b ^ a. (see above point number 2)`  \\n* Okay, if this is ? **Can you do this without rearaanging the array?**\\n* Answer is **Yes**, see below-\\n```\\nSo, our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4] \\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n \\u2191  \\u2191\\n 5 ^ 1 = 4\\n \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n       \\u2191                       \\n\\t   4 ^ 3 = 7 (prev answer xor current index)\\n\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\t      \\u2191\\n\\t\\t  7 ^ 1 = 6 (prev answer xor current index)\\n\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n             \\u2191\\n\\t\\t\\t 6 ^ 3 = 5 (prev answer xor current index)\\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                \\u2191\\n\\t\\t\\t\\t5 ^ 4 = 1  (prev answer xor current index)\\n\\t\\t\\t\\t\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                   \\u2191\\n\\t\\t\\t\\t   1 ^ 5 = 4 (prev answer xor current index)\\n\\t\\t\\t\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                      \\u2191\\n\\t\\t\\t\\t\\t  4 ^ 7 = 3 (prev answer xor current index)\\n\\t\\t\\t\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                         \\u2191\\n\\t\\t\\t\\t\\t\\t 3 ^ 4 = 7 (prev answer xor current index)\\n\\t\\t\\t\\t\\t\\t \\nSo, the element which we got as left should be our answer, so the answer is \\'7\\'\\n```\\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(1) // we are not using anything extra from our side\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        // traverse from the array\\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            arr[i + 1] = arr[i] ^ arr[i + 1]; // (prev answer xor current index)\\n        }\\n        \\n        return arr[n- 1]; // return left over element\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\nSo, our answer should be \\'7\\' as it appears only single time in the array. \\n```\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(n) // we will store the frequency of every element\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\n```\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nso, after storing frequency of each element in our map, our map looks like -\\n5 -> 2\\n1 -> 2\\n3 -> 2\\n4 -> 2\\n7 -> 1     On traversing, we will see that it\\'s frequency is 1, so this should be our answer.\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // taking the size of the array \\n        \\n        unordered_map<int, int> mp; // unordered map to store the frequency\\n        \\n        // storing frequency in the map\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int ans; // variable to store our answer\\n        for(auto x: mp) // traverse from the map\\n        {\\n            if(x.second == 1) //if frequency of any elemennt is 1\\n            {\\n                ans = x.first; // store in our answer\\n                break; // break the loop, as we got our answer now\\n            }\\n        }\\n        \\n        return ans; // return ans\\n    }\\n};\\n```\n```\\n0 ^ 0 --> 0\\n0 ^ 1 --> 1\\n1 ^ 0 --> 1\\n1 ^ 1 --> 0\\n```\n```\\nWe know every number is appears twice except a single number which appears only single time.\\n\\nSee, we already discuss a thing a that xor of a same number with itself is zero, i.e A ^ A = 0\\nNow, we will look some more property of xor-\\n\\n1) xor of a same number with itself is zero, i.e A ^ A = 0\\n2) xor is commutative that means a ^ b = b ^ a.\\n3) xor of any number with zero is the number itself i.e A ^ 0 = A.\\n\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nwe will rearrange the array, and take all the numbers together, then our array looks like\\n                     arr[]: [1, 1, 3, 3, 4, 4, 5, 5, 7]\\n\\t\\t\\t\\t\\t now, take xor of all numbers -\\n\\t\\t\\t\\t\\t 1 ^ 1 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 7   (rearrange the array)\\n\\t\\t\\t\\t\\t   0   ^   0   ^   0   ^   0   ^ 7   (see point number 1)\\n\\t\\t\\t\\t\\t               7                     (see point number 3) \\n\\n```\n```\\nSo, our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4] \\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n \\u2191  \\u2191\\n 5 ^ 1 = 4\\n \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n       \\u2191                       \\n\\t   4 ^ 3 = 7 (prev answer xor current index)\\n\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\t      \\u2191\\n\\t\\t  7 ^ 1 = 6 (prev answer xor current index)\\n\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n             \\u2191\\n\\t\\t\\t 6 ^ 3 = 5 (prev answer xor current index)\\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                \\u2191\\n\\t\\t\\t\\t5 ^ 4 = 1  (prev answer xor current index)\\n\\t\\t\\t\\t\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                   \\u2191\\n\\t\\t\\t\\t   1 ^ 5 = 4 (prev answer xor current index)\\n\\t\\t\\t\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                      \\u2191\\n\\t\\t\\t\\t\\t  4 ^ 7 = 3 (prev answer xor current index)\\n\\t\\t\\t\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                         \\u2191\\n\\t\\t\\t\\t\\t\\t 3 ^ 4 = 7 (prev answer xor current index)\\n\\t\\t\\t\\t\\t\\t \\nSo, the element which we got as left should be our answer, so the answer is \\'7\\'\\n```\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(1) // we are not using anything extra from our side\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        // traverse from the array\\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            arr[i + 1] = arr[i] ^ arr[i + 1]; // (prev answer xor current index)\\n        }\\n        \\n        return arr[n- 1]; // return left over element\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771791,
                "title": "python3-one-liner-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nWe use the nice property of XOR operation which is if you XOR same numbers it will return zero. Since the `nums` contains just one non-repeating number, we can just XOR all numbers together and the final result will be our answer.\\n\\n*For reference about `reduce`: https://thepythonguru.com/python-builtin-functions/reduce/*\\n\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn reduce(lambda total, el: total ^ el, nums)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn reduce(lambda total, el: total ^ el, nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 42997,
                "title": "my-o-n-solution-using-xor",
                "content": "known that A XOR A = 0 and the XOR operator is commutative, the solution will be very straightforward.\\n`\\n\\n    int singleNumber(int A[], int n) {\\n        int result = 0;\\n        for (int i = 0; i<n; i++)\\n        {\\n\\t\\t\\tresult ^=A[i];\\n        }\\n\\t\\treturn result;\\n    }\\n`",
                "solutionTags": [],
                "code": "known that A XOR A = 0 and the XOR operator is commutative, the solution will be very straightforward.\\n`\\n\\n    int singleNumber(int A[], int n) {\\n        int result = 0;\\n        for (int i = 0; i<n; i++)\\n        {\\n\\t\\t\\tresult ^=A[i];\\n        }\\n\\t\\treturn result;\\n    }\\n`",
                "codeTag": "Unknown"
            },
            {
                "id": 43000,
                "title": "python-different-solutions",
                "content": "   \\n    def singleNumber1(self, nums):\\n        dic = {}\\n        for num in nums:\\n            dic[num] = dic.get(num, 0)+1\\n        for key, val in dic.items():\\n            if val == 1:\\n                return key\\n    \\n    def singleNumber2(self, nums):\\n        res = 0\\n        for num in nums:\\n            res ^= num\\n        return res\\n        \\n    def singleNumber3(self, nums):\\n        return 2*sum(set(nums))-sum(nums)\\n        \\n    def singleNumber4(self, nums):\\n        return reduce(lambda x, y: x ^ y, nums)\\n        \\n    def singleNumber(self, nums):\\n        return reduce(operator.xor, nums)",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "   \\n    def singleNumber1(self, nums):\\n        dic = {}\\n        for num in nums:\\n            dic[num] = dic.get(num, 0)+1\\n        for key, val in dic.items():\\n            if val == 1:\\n                return key\\n    \\n    def singleNumber2(self, nums):\\n        res = 0\\n        for num in nums:\\n            res ^= num\\n        return res\\n        \\n    def singleNumber3(self, nums):\\n        return 2*sum(set(nums))-sum(nums)\\n        \\n    def singleNumber4(self, nums):\\n        return reduce(lambda x, y: x ^ y, nums)\\n        \\n    def singleNumber(self, nums):\\n        return reduce(operator.xor, nums)",
                "codeTag": "Python3"
            },
            {
                "id": 3171261,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = nums[0];\\n\\n        for(int i = 1 ; i < nums.size() ; i++){\\n            ans = ans ^ nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> int:\\n    return functools.reduce(lambda x, y: x ^ y, nums, 0)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result=0;\\n        for(int i=0; i<nums.length; i++) {\\n            result = result^nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = nums[0];\\n\\n        for(int i = 1 ; i < nums.size() ; i++){\\n            ans = ans ^ nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> int:\\n    return functools.reduce(lambda x, y: x ^ y, nums, 0)\\n```\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result=0;\\n        for(int i=0; i<nums.length; i++) {\\n            result = result^nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43201,
                "title": "easy-java-solution-tell-you-why-using-bitwise-xor",
                "content": "  \\nwe use bitwise XOR to solve this problem : \\n\\nfirst , we have to know the bitwise XOR in java\\n\\n 1. **0 ^ N = N**\\n 2. **N ^ N = 0**\\n\\n\\nSo..... if N is the single number\\n\\nN1 ^ N1 ^ N2 ^ N2 ^..............^ Nx ^ Nx ^ N  \\n\\n  = (N1^N1) ^ (N2^N2) ^..............^ (Nx^Nx) ^ N\\n\\n  = 0 ^ 0 ^ ..........^ 0 ^ N\\n\\n  = N  \\n\\n\\n  \\n \\n\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ans =0;\\n        \\n        int len = nums.length;\\n        for(int i=0;i!=len;i++)\\n            ans ^= nums[i];\\n        \\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "  \\nwe use bitwise XOR to solve this problem : \\n\\nfirst , we have to know the bitwise XOR in java\\n\\n 1. **0 ^ N = N**\\n 2. **N ^ N = 0**\\n\\n\\nSo..... if N is the single number\\n\\nN1 ^ N1 ^ N2 ^ N2 ^..............^ Nx ^ Nx ^ N  \\n\\n  = (N1^N1) ^ (N2^N2) ^..............^ (Nx^Nx) ^ N\\n\\n  = 0 ^ 0 ^ ..........^ 0 ^ N\\n\\n  = N  \\n\\n\\n  \\n \\n\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ans =0;\\n        \\n        int len = nums.length;\\n        for(int i=0;i!=len;i++)\\n            ans ^= nums[i];\\n        \\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3021354,
                "title": "java-easy-solution-beats-100-runtime-1ms-bit-manipulation",
                "content": "\\n# Approach\\nUsing Bit Manipulation - \\n\\n1) As we know XOR operation with 0 gives the same number \\ni.e,  a XOR 0 = a\\neg, for decimal no. 2=>  2 XOR 0 = 2\\nin binary, 010 XOR 000 = 010 \\n\\n2) Also we know that , XOR operation with same number gives 0\\ni.e, a XOR a = 0 \\neg, 2 XOR 2 = 0\\nin binary, 010 XOR 010 = 000 \\n\\n3) XOR is associative (like sum)\\ni.e, (2 XOR 3) XOR 4 = 2 XOR (3 XOR 4), So the order doesn\\'t matter in performing XOR operation. \\neg, 2^3^4^6 = 3^2^6^4 = 4^2^6^3 ......\\n\\nSo, using these three properties of XOR , we will solve the question. we will take ans variable with 0 as initial value. And then for each element i in array, we will perform the XOR operation of the element  with 0, ans will become 0 if the same number is found (as a XOR a = 0) and so after the completion of the loop, only element with no duplicate number will remain and will be returned as ans.\\n\\n\\nHope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0; //since XOR with 0 returns same number \\n        for(int i=0; i<nums.length; i++){\\n            ans ^= nums[i];  // ans = (ans) XOR (array element at i) \\n        }\\n        return ans;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0; //since XOR with 0 returns same number \\n        for(int i=0; i<nums.length; i++){\\n            ans ^= nums[i];  // ans = (ans) XOR (array element at i) \\n        }\\n        return ans;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43228,
                "title": "easiest-way-to-solve-by-using-bit-manipulation",
                "content": "\\n**Logic:** XOR will return 1 only on two different bits. So if two numbers are the same, XOR will return 0. Finally only one number left.\\nA ^ A = 0 and A ^ B ^ A = B.\\n\\n\\n\\n\\n\\n    class Solution {\\n        public:\\n            int singleNumber(int A[], int n) {\\n                int result=A[0];\\n                for(int i=1;i<n;i++)\\n                {\\n                    result= result^A[i];  /* Get the xor of all elements */\\n                }\\n                return result;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int singleNumber(int A[], int n) {\\n                int result=A[0];\\n                for(int i=1;i<n;i++)\\n                {\\n                    result= result^A[i];  /* Get the xor of all elements */\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 43171,
                "title": "1ms-java-solution",
                "content": "public class Solution {\\n    \\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums) {\\n            result ^= i;\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums) {\\n            result ^= i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2438883,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "**Problem:**\\nGiven a non-empty array of integers nums, every element appears twice except for one. Find that single one.\\n**Input:**   nums = [ 4, 1, 2, 1, 2 ]\\n**Output:**  4\\n**Explanation:**   1\\u2019s and 2\\u2019s appear twice, only 4 appears exactly once. So the answer is 4.\\n**Concept of XOR:**\\nXOR of zero and some bit returns that bit i.e. x^0 = x...\\nXOR of two same bits returns 0 i.e. x^x = 0...\\nAnd,  x^y^x = (x^x)^y = 0^y = y...\\nXOR all bits together to find the unique number.\\n\\n\\n# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Single Number.\\nMemory Usage: 46.2 MB, less than 89.95% of Java online submissions for Single Number.\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 6 ms, faster than 98.77% of C++ online submissions for Single Number.\\nMemory Usage: 11.8 MB, less than 98.93% of C++ online submissions for Single Number.\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar singleNumber = function(nums) {\\n    // Initialize the unique number...\\n    let uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n};\\n```\\n\\n# **C Language:**\\n```\\nint singleNumber(int* nums, int numsSize){\\n    // Initialize the unique number...\\n    int uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (int idx = 0; idx < numsSize; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```\n```\\nvar singleNumber = function(nums) {\\n    // Initialize the unique number...\\n    let uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n};\\n```\n```\\nint singleNumber(int* nums, int numsSize){\\n    // Initialize the unique number...\\n    int uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (int idx = 0; idx < numsSize; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n}\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264959,
                "title": "well-expalined-code-in-java",
                "content": "\\n\\n# Approach\\nThe code is a Java implementation of a function that takes an integer array nums as input and returns the single integer in the array that appears only once. The function assumes that all other integers in the array appear exactly twice.\\n\\nThe implementation sorts the input array using the Arrays.sort() method. Sorting the array ensures that all duplicate integers are adjacent to each other. Then, the implementation iterates through the sorted array using a loop that increments the index by 2 in each iteration. Inside the loop, the implementation checks if the current integer and the next integer are not equal. If they are not equal, the implementation returns the current integer as the single integer that appears only once.\\n\\nIf the loop completes without finding a single integer that appears only once, the implementation returns the last element of the sorted array. This is because the last element is the only remaining element in the array, and it must be the single integer that appears only once.\\n\\n# Complexity\\n- Time complexity:\\nThe Arrays.sort method used at the beginning of the function has a time complexity of O(n log n), where n is the length of the input array. This is because it uses a variant of the quicksort algorithm, which has an average time complexity of O(nlogn).\\n\\n- Space complexity:\\nThe space complexity of the function is O(1), as it uses only a constant amount of additional memory to store the loop variable and some temporary variables for the sorting operation. The sorting operation is performed in-place, so it does not require any additional memory allocation.\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length-1;i+=2){\\n            if(nums[i]!=nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n       return nums[nums.length-1];\\n    }\\n    \\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/02c5a619-d6fa-418b-b177-8b523fc2b30f_1678114992.5292022.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length-1;i+=2){\\n            if(nums[i]!=nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n       return nums[nums.length-1];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43237,
                "title": "4-lines-of-c-solution",
                "content": "    nt singleNumber(int a[], int n) {\\n         //xor all numbers, the left over number would be the non repeated one\\n         // since the equl numbers cancel out each others bits\\n         int num = 0;\\n         for (int i = 0; i < n; ++i) {\\n             num ^= a[i];\\n         }\\n         return num;\\n        }",
                "solutionTags": [],
                "code": "    nt singleNumber(int a[], int n) {\\n         //xor all numbers, the left over number would be the non repeated one\\n         // since the equl numbers cancel out each others bits\\n         int num = 0;\\n         for (int i = 0; i < n; ++i) {\\n             num ^= a[i];\\n         }\\n         return num;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 558767,
                "title": "python-space-o-1-xor-reduce-very-simple-one-liner-with-explanation",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```\\n\\n**Explanation**\\nI will try to explain this solution by walking through the initial solution that I wrote:\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n\\t\\tfor n in nums:\\n\\t\\t\\tresult ^= n\\n\\t\\treturn result\\n```\\nThe most crucial trick here is to recognize that if you XOR any same number together, you cancel it out (=0).\\nFor example:\\nnums = [2,4,5,4,3,5,2]\\nXORing everything together\\n= 2 ^ 4 ^ 5 ^ 4 ^ 3 ^ 5 ^ 2\\n= (2^2) ^ (4^4) ^ (5^5) ^ 3\\n= 0 ^ 0 ^0 ^ 3\\n= 3\\n\\n(If you are unfamiliar with the XOR operation, you can check out [this stackoverflow post](https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do))\\n\\nNow, let\\'s go back to the one liner:\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```\\n- The `reduce` here just simplifies the previous `for` loop into one line, it\\'s not doing anything different. \\n- The initializer `0` is put there to prevent the the scenerio where `nums` is an empty list (I didn\\'t realize that the question statement explicitly mentioned that it would be non-empty).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n\\t\\tfor n in nums:\\n\\t\\t\\tresult ^= n\\n\\t\\treturn result\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43193,
                "title": "javascript-solution",
                "content": "```js\\nfunction singleNumber(nums) {\\n\\treturn nums.reduce((prev, curr) => prev ^ curr);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction singleNumber(nums) {\\n\\treturn nums.reduce((prev, curr) => prev ^ curr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174407,
                "title": "easy-c-solution-beginner-friendly",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED**\\n\\n**Optimised Approach**\\n* Since in XOR Operations 0^0 = 0 and 1^1 = 0.\\n* Hence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            ans = ans^nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Bruteforce Approach**\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        if(nums.size() < 1) {\\n            return 0;\\n        }\\n        \\n        else if(nums.size() > 1) {\\n            \\n            sort(nums.begin(), nums.end());\\n            \\n            for(int i=0; i<nums.size(); i++) {\\n                if(nums[i] != nums[i+1]) {\\n                    return nums[i];\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        //else for nums.size() == 1\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            ans = ans^nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        if(nums.size() < 1) {\\n            return 0;\\n        }\\n        \\n        else if(nums.size() > 1) {\\n            \\n            sort(nums.begin(), nums.end());\\n            \\n            for(int i=0; i<nums.size(); i++) {\\n                if(nums[i] != nums[i+1]) {\\n                    return nums[i];\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        //else for nums.size() == 1\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43216,
                "title": "my-very-simple-solution-linear-time-no-extra-memory",
                "content": "\\nXOR of two equal numbers is 0 : a^a=0. This is the main idea of the algorithm.\\n\\n    class Solution { \\n        public:\\n            int singleNumber(int A[], int n) {\\n                for (int i = 1; i < n; ++i)\\n                    A[0] ^= A[i];\\n                 return A[0];\\n            } \\n        };",
                "solutionTags": [],
                "code": "class Solution { \\n        public:\\n            int singleNumber(int A[], int n) {\\n                for (int i = 1; i < n; ++i)\\n                    A[0] ^= A[i];\\n                 return A[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 43019,
                "title": "1-line-simple-python-solution",
                "content": "    class Solution(object):\\n    def singleNumber(self, nums):\\n        return sum(list(set(nums)))*2 - sum(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def singleNumber(self, nums):\\n        return sum(list(set(nums)))*2 - sum(nums)",
                "codeTag": "Java"
            },
            {
                "id": 43153,
                "title": "my-java-solution-in-o-n-time-complexity-and-o-1-space-complexity-using-xor",
                "content": "    public class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = 0;\\n            for(int num : nums) {\\n                res ^= num;\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = 0;\\n            for(int num : nums) {\\n                res ^= num;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1428325,
                "title": "all-c-solutions-100-faster-99-26-less-space",
                "content": "***1. O(NLog N) Time and O(1) Space solution: [99.26% less space]***\\n```\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1;){\\n            if(nums[i+1] != nums[i])\\n                return nums[i];\\n            else\\n                i+=2;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\\n\\n***2. Using Unordered Maps (Hash Tables)***\\n```\\n    int singleNumber(vector<int>& nums) {        \\n        unordered_map<int, int> um;\\n        for(int a: nums)\\n            um[a]++;\\n        for(auto it = um.begin(); it!=um.end(); it++){\\n            if(it->second==1)\\n                return it->first;\\n        }\\n        return 0;\\n    }\\n```\\n\\n***3. Using XOR(^) bitwise operator to find unique number*** (Fastest)\\nBitwise XOR Operator(^) has three properties: \\n1. a^a = 0\\n2. 0^a = a\\n3. XOR is associative just like addition, multiplication, etc which means that -> a^b^c = a^(b^c) = (a^b)^c = (a^c)^b\\nSo, when we XOR all the numbers in the list, all the numbers that occur 2 times become 0 as a^a = 0. At the end, we will be left with an expression like 0^n, where n is the only number occurring once. Using second property 0^a = a :-  0^n = n. Hence, we get the unique number.\\n```\\n    int singleNumber(vector<int>& nums) {        \\n        \\n        // Using XOR property for Unique number\\n        int resultXOR = 0;                \\n        for(int a: nums)\\n            resultXOR ^= a;        \\n        return resultXOR;            \\n    }\\n```\\n***Please Upvote if found useful!***",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1;){\\n            if(nums[i+1] != nums[i])\\n                return nums[i];\\n            else\\n                i+=2;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\n```\\n    int singleNumber(vector<int>& nums) {        \\n        unordered_map<int, int> um;\\n        for(int a: nums)\\n            um[a]++;\\n        for(auto it = um.begin(); it!=um.end(); it++){\\n            if(it->second==1)\\n                return it->first;\\n        }\\n        return 0;\\n    }\\n```\n```\\n    int singleNumber(vector<int>& nums) {        \\n        \\n        // Using XOR property for Unique number\\n        int resultXOR = 0;                \\n        for(int a: nums)\\n            resultXOR ^= a;        \\n        return resultXOR;            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43232,
                "title": "simple-c-solution",
                "content": "The trick is: A^B^A=B\\n\\n    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            if(nums.empty()) return 0;\\n            int first = nums[0];\\n            for(int i = 1; i<nums.size();i++) {\\n                first = first ^ nums[i];\\n            }\\n            return first;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            if(nums.empty()) return 0;\\n            int first = nums[0];\\n            for(int i = 1; i<nums.size();i++) {\\n                first = first ^ nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1184007,
                "title": "3-different-java-solutions-with-explanations",
                "content": "First Approach by using hashMap  :-\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer, Integer> hash = new<Integer, Integer> HashMap();\\n        \\n        for(int x : nums){\\n            if(hash.containsKey(x)){       //if hashmap contains \\'element\\', then increase correspoding val\\n                int count = hash.get(x);\\n                hash.put(x, ++count);\\n            }\\n            else\\n                hash.put(x, 1);           //if hashmap does not contain  \\'element\\', then put it in hashmap\\n        }\\n        \\n        for(int x : hash.keySet()){       //Iterate through \\'keys\\' of HashMap\\n            if(hash.get(x)==1)            //if \\'value\\' for \\'key\\' is \\'1\\', then return that \\'key\\' element\\n                return x;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\nTime Complexity : O(nlogn) , as there is a for loop and inside for loop \\'hash.containsKey\\' \\nSpace Complexity : O(n)  ,  as HashMap of size nearly \\'n/2\\' is used.\\n\\n\\nSecond Approach by using \\'Sort()\\' method :-\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);                          //Sort the array\\n        for(int i=0 ; i<nums.length-1; i+=2){       \\n            if(nums[i]!=nums[i+1])                  //Check pairwise values in array\\n                return nums[i];                     //if any pairwise values are different, then it is answer\\n        }\\n        return nums[nums.length - 1];       //if answer is largest value, then it will not be detected in above loop hence return it here\\n   }\\n}\\n```\\nTime Complexity : O(nlogn) , as \\'sort()\\' method is used \\nSpace Complexity : O(1)  ,  as No extra space is used other than some constant\\n\\n\\n\\nOptimal Approach by using \\'XOR\\'  :-\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int x: nums){\\n            result = result ^ x;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nBitwise \\'XOR\\' gives zero when both inputs are same. And if we apply XOR for \\'zero\\' and \\'any number\\', it will give output as that number itself. So if the array is {4,1,2,1,2} then \\'XOR\\' operation is\\n        ((2^2)^(1^1)^(4)) => (0^0^4) => 4\\n\\t\\t\\nTime Complexity : O(n) , as only one \\'for\\'loop\\nSpace Complexity : O(1)  , as No extra space is used other than some constant\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer, Integer> hash = new<Integer, Integer> HashMap();\\n        \\n        for(int x : nums){\\n            if(hash.containsKey(x)){       //if hashmap contains \\'element\\', then increase correspoding val\\n                int count = hash.get(x);\\n                hash.put(x, ++count);\\n            }\\n            else\\n                hash.put(x, 1);           //if hashmap does not contain  \\'element\\', then put it in hashmap\\n        }\\n        \\n        for(int x : hash.keySet()){       //Iterate through \\'keys\\' of HashMap\\n            if(hash.get(x)==1)            //if \\'value\\' for \\'key\\' is \\'1\\', then return that \\'key\\' element\\n                return x;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);                          //Sort the array\\n        for(int i=0 ; i<nums.length-1; i+=2){       \\n            if(nums[i]!=nums[i+1])                  //Check pairwise values in array\\n                return nums[i];                     //if any pairwise values are different, then it is answer\\n        }\\n        return nums[nums.length - 1];       //if answer is largest value, then it will not be detected in above loop hence return it here\\n   }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int x: nums){\\n            result = result ^ x;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558787,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        r=nums[0]\\n        for i in range(1,n):\\n            r = r ^ nums[i] \\n\\n        return r\\n```\\n\\t\\t\\n\\t\\nexplanation:-\\nLet ^ be xor operator as in python 3\\n\\nr = 7 ^ 3 ^ 5 ^ 4 ^ 5 ^ 3 ^ 4\\n\\nSince XOR is associative and commutative, above \\nexpression can be written as:\\nr = 7 ^ (3 ^ 3) ^ (4 ^ 4) ^ (5 ^ 5)  \\n    = 7 ^ 0 ^ 0 ^ 0\\n    = 7 ^ 0\\n    = 7",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        r=nums[0]\\n        for i in range(1,n):\\n            r = r ^ nums[i] \\n\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43209,
                "title": "non-bitwise-java-solution-using-set",
                "content": "    public int singleNumber(int[] A) {\\n            \\n           Set<Integer> s = new HashSet<Integer>();\\n    \\t    for (int i: A){\\n    \\t    \\tif(!s.add(i)){\\n    \\t    \\t\\ts.remove(i);\\n    \\t    \\t}\\n    \\t    }\\n    \\t    return s.iterator().next();\\n            \\n        }",
                "solutionTags": [],
                "code": "    public int singleNumber(int[] A) {\\n            \\n           Set<Integer> s = new HashSet<Integer>();\\n    \\t    for (int i: A){\\n    \\t    \\tif(!s.add(i)){\\n    \\t    \\t\\ts.remove(i);\\n    \\t    \\t}\\n    \\t    }\\n    \\t    return s.iterator().next();\\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 43217,
                "title": "java-solution-with-explanation",
                "content": "    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res = res^nums[i];\\n        }\\n        return res;\\n    }\\n\\n\\n----------\\nidea: for every bit, use bit manipulation. 0^0^0 = 0, 1^1^1 = 1, 0^0^1 = 1, 1^1^0 = 0. Thus, after the bit manipulation of XOR, the every bit of result is the bit of single number.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res = res^nums[i];\\n        }\\n        return res;\\n    }\\n\\n\\n----------\\nidea: for every bit, use bit manipulation. 0^0^0 = 0, 1^1^1 = 1, 0^0^1 = 1, 1^1^0 = 0. Thus, after the bit manipulation of XOR, the every bit of result is the bit of single number.",
                "codeTag": "Unknown"
            },
            {
                "id": 690738,
                "title": "python-o-1-space-simple-solution-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : XOR ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        # If we take XOR of zero and some bit, it will return that bit\\n        # a XOR 0 = a, a XOR 0=a\\n        # If we take XOR of two same bits, it will return 0\\n        # a XOR a = 0 a XOR a=0\\n        # a XOR b XOR a = (a XOR a) XOR b = 0 XOR b = b \\n        # a\\u2295b\\u2295a=(a\\u2295a)\\u2295b=0\\u2295b=b\\n        # So we can XOR all bits together to find the unique number.\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : XOR ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        # If we take XOR of zero and some bit, it will return that bit\\n        # a XOR 0 = a, a XOR 0=a\\n        # If we take XOR of two same bits, it will return 0\\n        # a XOR a = 0 a XOR a=0\\n        # a XOR b XOR a = (a XOR a) XOR b = 0 XOR b = b \\n        # a\\u2295b\\u2295a=(a\\u2295a)\\u2295b=0\\u2295b=b\\n        # So we can XOR all bits together to find the unique number.\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387175,
                "title": "python-3-xor-explanation",
                "content": "This problem asks us to solve it in **O(n) time** and **O(1) space**. \\n\\nThe best way to do this is to use **XOR (\\u2295)** operations (`^` in Python), because there are two benefits from XOR operation:\\n\\n1. **The XOR of any two identical numbers is 0.** For example, `0101 ^ 0101 = 0000`.\\n2. **The XOR of any number and 0 is the number itself.** For example, `0101 ^ 0000 = 0101`\\n\\nIn addition, XOR operations are associative and commutative; therefore, the operations can be written in the following form:\\n\\n```\\n    4 ^ 1 ^ 2 ^ 1 ^ 2\\n=   4 ^ 1 ^ 1 ^ 2 ^ 2      (commutativity)\\n=   4 ^ (1 ^ 1) ^ (2 ^ 2)  (associativity)\\n=   4 ^ 0 ^ 0\\n=   4\\n```\\n\\n\\n``` py\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        z = nums[0]\\n        for num in nums[1:]:\\n            z^= num\\n        return z\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n    4 ^ 1 ^ 2 ^ 1 ^ 2\\n=   4 ^ 1 ^ 1 ^ 2 ^ 2      (commutativity)\\n=   4 ^ (1 ^ 1) ^ (2 ^ 2)  (associativity)\\n=   4 ^ 0 ^ 0\\n=   4\\n```\n``` py\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        z = nums[0]\\n        for num in nums[1:]:\\n            z^= num\\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43028,
                "title": "one-line-python-solution-with-o-n-time",
                "content": "    return reduce(lambda x, y: x ^ y, nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    return reduce(lambda x, y: x ^ y, nums)",
                "codeTag": "Unknown"
            },
            {
                "id": 3197054,
                "title": "very-simple-and-easy-solution",
                "content": "# Intuition\\nThe sort method is called on the nums array, which modifies the original array in place to sort it in ascending order. This is not necessary for the solution, but it does make it easier to find the single number by grouping all of the duplicate numbers together.\\n\\nThe for loop iterates over the arr array by 2, comparing each pair of adjacent elements.\\n\\nIf a non-matching pair of adjacent elements is found, the first element in the pair is returned as the single number.\\n\\nIf no non-matching pair is found, the last element in the array is returned as the single number, since it must be the only element that does not have a matching pair.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function (nums) {\\n  let arr = nums.sort((a, b) => a - b); // Create a copy of the array and sort it\\n\\n  for (let i = 0; i <= nums.length - 1; i += 2) { // Iterate by 2\\n    if (arr[i] !== arr[i + 1]) {\\n      return arr[i];\\n    }\\n  }\\n\\n  return arr[arr.length - 1];  // Return the first non-matching pair\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/19f45496-d52e-4b20-928b-3e16c79afc98_1676631777.988186.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function (nums) {\\n  let arr = nums.sort((a, b) => a - b); // Create a copy of the array and sort it\\n\\n  for (let i = 0; i <= nums.length - 1; i += 2) { // Iterate by 2\\n    if (arr[i] !== arr[i + 1]) {\\n      return arr[i];\\n    }\\n  }\\n\\n  return arr[arr.length - 1];  // Return the first non-matching pair\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2641351,
                "title": "python-3-easy-solution-in-one-line-without-using-xor",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(list(set(nums)) * 2) - sum(nums)\\n```\\n\\nIf you find XOR hard to understand, then maybe use this solution instead.\\n\\nGive me some upvote if you like the solution! Cheers!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(list(set(nums)) * 2) - sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396584,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n)\\n// space O(n)\\nfunction singleNumber(nums) {\\n  const map = {};\\n  for (let n of nums) {\\n    if (map[n] == null) map[n] = 0;\\n    map[n]++;\\n  }\\n\\n  for (let n in map) {\\n    if (map[n] === 1) return Number(n);\\n  }\\n}\\n```\\n\\n```\\n// time O(n)\\n// space O(1)\\nfunction singleNumber(nums) {\\n  let num = 0;\\n  for (let n of nums) {\\n    num ^= n;\\n  }\\n  return num;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n)\\n// space O(n)\\nfunction singleNumber(nums) {\\n  const map = {};\\n  for (let n of nums) {\\n    if (map[n] == null) map[n] = 0;\\n    map[n]++;\\n  }\\n\\n  for (let n in map) {\\n    if (map[n] === 1) return Number(n);\\n  }\\n}\\n```\n```\\n// time O(n)\\n// space O(1)\\nfunction singleNumber(nums) {\\n  let num = 0;\\n  for (let n of nums) {\\n    num ^= n;\\n  }\\n  return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1771869,
                "title": "python-simple-python-solution-with-two-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 with XOR Operation :-\\n# Runtime: 144 ms, faster than 64.43% of Python3 online submissions for Single Number.\\n# Memory Usage: 18.9 MB, less than 76.74% of Python3 online submissions for Single Number.\\n\\n# XOR Concept : -\\n\\t0 ^ 0 = 0\\n\\t0 ^ 1 = 1\\n\\t1 ^ 0 = 1\\n\\t1 ^ 1 = 0\\n\\n\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tresult = result ^ num\\n\\n\\t\\t\\treturn result \\n\\n# Approach 2 with Counting Frequency :-\\n# Runtime: 140 ms, faster than 79.48% of Python3 online submissions for Single Number.\\n# Memory Usage: 19 MB, less than 54.30% of Python3 online submissions for Single Number.\\n\\n\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tfrequency = {}\\n\\n\\t\\t\\tfor num in nums:\\n\\n\\t\\t\\t\\tif num not in frequency:\\n\\n\\t\\t\\t\\t\\tfrequency[num] = 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfrequency[num] = frequency[num] + 1\\n\\n\\t\\t\\tfor key in frequency:\\n\\n\\t\\t\\t\\tif frequency[key] == 1:\\n\\n\\t\\t\\t\\t\\treturn key\\t\\t\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tresult = result ^ num\\n\\n\\t\\t\\treturn result \\n\\n# Approach 2 with Counting Frequency :-\\n# Runtime: 140 ms, faster than 79.48% of Python3 online submissions for Single Number.\\n# Memory Usage: 19 MB, less than 54.30% of Python3 online submissions for Single Number.\\n\\n\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tfrequency = {}",
                "codeTag": "Java"
            },
            {
                "id": 43229,
                "title": "maybe-the-shortest-java-solution",
                "content": "    public class Solution {\\n        public int singleNumber(int[] A) {\\n            int a=0;\\n            for(int i:A)\\n                a^=i;\\n            return a;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int singleNumber(int[] A) {\\n            int a=0;\\n            for(int i:A)\\n                a^=i;\\n            return a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43154,
                "title": "easy-c-solution",
                "content": "\\n     int singleNumber(int* nums, int numsSize) {\\n     int x = 0;\\n     int i = 0;\\n     for (i = 0; i<numsSize;i++)\\n     {\\n       x=x^nums[i];\\n     }\\n     return x;\\n    }",
                "solutionTags": [],
                "code": "\\n     int singleNumber(int* nums, int numsSize) {\\n     int x = 0;\\n     int i = 0;\\n     for (i = 0; i<numsSize;i++)\\n     {\\n       x=x^nums[i];\\n     }\\n     return x;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43052,
                "title": "strongly-recommended-support-scala-language",
                "content": "and here is the code for solve the single number, and using scala language is just only one line of code. With now, functional programming is very popular in big data area. So, I strongly recommended the leecode support the compiler compatible with scala. \\n\\n     def singleNumber(nums:Array[Int]): Int = {\\n        nums.foldLeft(0)(_^_)\\n      }\\n    \\n      val arr = Array(1,2,2,3,3,4,5,6,6,5,4,1,9)\\n      println(singleNumber(arr))\\n\\nAnd another example can directly show more message , and just needs a tuple. I show you with this is wish to tell you that scala can support more message and expressive.\\n\\n    def hummingWeight(n: Int): (Int, ArrayBuffer[Int]) = {\\n        val arrBuffer = ArrayBuffer[Int]()\\n        var alt_n = n\\n        var count = 0\\n        while (alt_n > 0) {\\n          if ((alt_n & 1) == 1){\\n            count+=1\\n            arrBuffer += 1\\n          } else {\\n            arrBuffer += 0\\n          }\\n          alt_n >>= 1\\n        }\\n        (count, arrBuffer.reverse)\\n      }\\n      println (hummingWeight(2147483647))\\n    }\\n\\nAnd the output like following\\n\\n    (31,ArrayBuffer(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1))",
                "solutionTags": [],
                "code": "and here is the code for solve the single number, and using scala language is just only one line of code. With now, functional programming is very popular in big data area. So, I strongly recommended the leecode support the compiler compatible with scala. \\n\\n     def singleNumber(nums:Array[Int]): Int = {\\n        nums.foldLeft(0)(_^_)\\n      }\\n    \\n      val arr = Array(1,2,2,3,3,4,5,6,6,5,4,1,9)\\n      println(singleNumber(arr))\\n\\nAnd another example can directly show more message , and just needs a tuple. I show you with this is wish to tell you that scala can support more message and expressive.\\n\\n    def hummingWeight(n: Int): (Int, ArrayBuffer[Int]) = {\\n        val arrBuffer = ArrayBuffer[Int]()\\n        var alt_n = n\\n        var count = 0\\n        while (alt_n > 0) {\\n          if ((alt_n & 1) == 1){\\n            count+=1\\n            arrBuffer += 1\\n          } else {\\n            arrBuffer += 0\\n          }\\n          alt_n >>= 1\\n        }\\n        (count, arrBuffer.reverse)\\n      }\\n      println (hummingWeight(2147483647))\\n    }\\n\\nAnd the output like following\\n\\n    (31,ArrayBuffer(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1))",
                "codeTag": "Python3"
            },
            {
                "id": 509005,
                "title": "my-javascript-solution-56ms",
                "content": "```\\nvar singleNumber = function(nums) {\\n    let hash = {}\\n    for(let val of nums){\\n        hash[val]?delete hash[val]:hash[val]=1;\\n    }\\n    return Object.keys(hash)[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar singleNumber = function(nums) {\\n    let hash = {}\\n    for(let val of nums){\\n        hash[val]?delete hash[val]:hash[val]=1;\\n    }\\n    return Object.keys(hash)[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43114,
                "title": "one-liner-in-js",
                "content": "```\\nvar singleNumber = function(nums) {\\n    return nums.reduce((a, b) => a^b);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar singleNumber = function(nums) {\\n    return nums.reduce((a, b) => a^b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43197,
                "title": "o-n-using-xor-in-java-for-single-number-problem",
                "content": "    public class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = nums[0];\\n            for (int i = 1; i < nums.length; i++)\\n                res = res ^ nums[i];\\n    \\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = nums[0];\\n            for (int i = 1; i < nums.length; i++)\\n                res = res ^ nums[i];\\n    \\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1771956,
                "title": "simple-3-approaches-easy-to-understand",
                "content": "**Approach 1 = Using HashSet  ==>   TC = O(n)   SC=O(n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tHashSet<Integer> set = new HashSet<Integer>();\\n\\t\\t\\tfor(int i : nums) {\\n\\t\\t\\t\\tif(set.contains(i)) {\\n\\t\\t\\t\\t\\tset.remove(i);\\n\\t\\t\\t\\t} else{\\n\\t\\t\\t\\t\\tset.add(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i:set) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\n**Approach 2 = Using Sorting  ==> TC: O(NlogN)    SC: O(1)** \\n\\n\\tclass Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tfor(int i = 1; i < nums.length; i+=2) {\\n\\t\\t\\t\\tif(nums[i] != nums[i-1]) {\\n\\t\\t\\t\\t\\treturn nums[i-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn nums[nums.length-1];\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\n**Approach 3 = Using XOR  ==>  TC: O(N)   SC: O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int x : nums)\\n\\t\\t\\t\\tans^=x;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0\\uD83C\\uDF38), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tHashSet<Integer> set = new HashSet<Integer>();\\n\\t\\t\\tfor(int i : nums) {\\n\\t\\t\\t\\tif(set.contains(i)) {\\n\\t\\t\\t\\t\\tset.remove(i);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 43081,
                "title": "simple-c-solution",
                "content": "class Solution \\n{public:\\n\\n    int singleNumber(vector<int>& nums) {\\n        \\n        for(int i = 1; i < nums.size(); ++i) nums[0] ^= nums[i];\\n        \\n        return nums[0];\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{public:\\n\\n    int singleNumber(vector<int>& nums) {\\n        \\n        for(int i = 1; i < nums.size(); ++i) nums[0] ^= nums[i];\\n        \\n        return nums[0];\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 43196,
                "title": "c-implementation-using-xor",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            // XOR (^) is both commutative and associative \\n            // The numbers which appear twice will be cancelled\\n            // Only the number that appear twice survive \\n            int value = 0;\\n            int i, n;\\n            n = nums.size();\\n            for(i=0; i<n; i++)\\n                value = value ^ nums[i];\\n            return value;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            // XOR (^) is both commutative and associative \\n            // The numbers which appear twice will be cancelled\\n            // Only the number that appear twice survive \\n            int value = 0;\\n            int i, n;\\n            n = nums.size();\\n            for(i=0; i<n; i++)\\n                value = value ^ nums[i];\\n            return value;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43215,
                "title": "o-n-solution-using-bit-operation-only-22-characters",
                "content": "    def singleNumber(self, A):\\n        r = 0\\n        for i in A:\\n            r ^= i\\n        return r",
                "solutionTags": [],
                "code": "    def singleNumber(self, A):\\n        r = 0\\n        for i in A:\\n            r ^= i\\n        return r",
                "codeTag": "Python3"
            },
            {
                "id": 899031,
                "title": "easy-python-solution-o-n-time-and-o-1-space-explanation",
                "content": "The idea is when you XOR a number with itself (since it will appear TWICE only )it will result in a 0, so when you XOR all the elements the end result will be the element that is appearing once only\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res=0\\n        for n in nums:\\n            res^=n\\n        return res    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res=0\\n        for n in nums:\\n            res^=n\\n        return res    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 43185,
                "title": "my-c-solution-using-unordered-set-int",
                "content": "\\n        unordered_set<int> mySet;\\n        for(int i = 0;i < nums.size();++i){\\n            if(mySet.find(nums[i]) == mySet.end()) mySet.insert(nums[i]);\\n            else mySet.erase(nums[i]);\\n        }\\n        auto it = mySet.begin();\\n        return *it;",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n        unordered_set<int> mySet;\\n        for(int i = 0;i < nums.size();++i){\\n            if(mySet.find(nums[i]) == mySet.end()) mySet.insert(nums[i]);\\n            else mySet.erase(nums[i]);\\n        }\\n        auto it = mySet.begin();\\n        return *it;",
                "codeTag": "Unknown"
            },
            {
                "id": 43060,
                "title": "only-one-line-python-solution",
                "content": "reduce(func, A) means: func(func(A[0], A[1]), A[2])...\\n\\nSo the reduce function below just return all elements' XOR value, that is our single number.\\n\\n    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n    def singleNumber(self, A):\\n        return reduce(lambda x, y: x ^ y, A)",
                "solutionTags": [],
                "code": "reduce(func, A) means: func(func(A[0], A[1]), A[2])...\\n\\nSo the reduce function below just return all elements' XOR value, that is our single number.\\n\\n    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n    def singleNumber(self, A):\\n        return reduce(lambda x, y: x ^ y, A)",
                "codeTag": "Java"
            },
            {
                "id": 1938482,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ans = 0\\n        for num in nums { ans ^= num }\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ans = 0\\n        for num in nums { ans ^= num }\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075088,
                "title": "simplest-solution-for-beginners",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if(nums.count(i) == 1):\\n                return(i)\\n```\\n**Please upvote if you like it**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if(nums.count(i) == 1):\\n                return(i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43049,
                "title": "javascript-solution",
                "content": "Javascript Solution / 102ms Runtime\\n```\\nvar singleNumber = function(nums) {\\n    var result = nums[0];\\n    for(var i = 1; i < nums.length; i++) {\\n        result = result^nums[i];\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar singleNumber = function(nums) {\\n    var result = nums[0];\\n    for(var i = 1; i < nums.length; i++) {\\n        result = result^nums[i];\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43140,
                "title": "xor-java-solution",
                "content": "    public class Solution {\\n        public int singleNumber(int[] nums) {\\n            int result = 0;\\n            for(int i = 0;i<nums.length;i++){\\n            result = result ^ nums[i];\\n            }\\n            return result;\\n    }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int singleNumber(int[] nums) {\\n            int result = 0;\\n            for(int i = 0;i<nums.length;i++){\\n            result = result ^ nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 43222,
                "title": "java-solution-using-xor",
                "content": "    public int singleNumber(int[] nums) {\\n      int ans = 0;\\n            \\n      for (int i = 0; i < nums.length; i++)\\n        ans ^= nums[i];\\n            \\n      return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int singleNumber(int[] nums) {\\n      int ans = 0;\\n            \\n      for (int i = 0; i < nums.length; i++)\\n        ans ^= nums[i];\\n            \\n      return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1772428,
                "title": "c-3-approaches-beginner-friendly-easy-and-intuitive-well-explained",
                "content": "## **Approach 1: Frequency Counting + Linear Traversal (Hashmap or Frequency Array)**\\nSo the very first brute force approach that comes to our mind after reading this question is that we can count the frequency of each element in the array and then find the element with frequency as 1.\\n\\n#### Example: \\n\\n![image](https://assets.leetcode.com/users/images/44b16506-49ab-4a4c-aeca-736b8b3c2f34_1644902604.556138.jpeg)\\n\\n\\n#### Code:\\n```cpp\\nint singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> elementToFreqMap; //key=element of nums array, value=freq of that element in the nums array\\n        \\n        for(int num: nums){\\n            elementToFreqMap[num]++;\\n        }\\n        \\n        for(auto it: elementToFreqMap){\\n            if(it.second==1) return it.first;\\n        }\\n        \\n        return -1;\\n    }\\n```\\n\\n#### Complexity:\\n***TC* = O(n)**[traversal of whole array] **+ O(n/2 + 1)**[traversal of map, as all elements appear twice except 1, so there will be (n/2)+1 distinct keys int the map to traverse]  **=  O(n)**\\n***SC* = O(n/2 +1)**[space taken by the map] **= O(n)**\\n\\n**************************************************************************************\\n\\n## **Approach 2: Sorting + Linear traversal**\\nIt is essentially kind of counting for the frequency only, but here we will not be using extra space.\\n1. The idea is to sort the elements and then start traversing the array in a way that we check `every second element` in the array starting from index 1.\\n\\n2. If that element is similar to its previous element, then that is not our answer, so continue finding the answer.\\n\\n3. Else if the element if not equal to its previous element, then that means, the frequency of this element is 1 in the array, so this element is our ans. Therefore return this element.\\n\\n4. As the `array will always be odd` (let there be k elements in the array which occur twice and 1 element which occurs only once, that means the length of array will be 2k+1, which is always odd) therefore the `indices will range from 0 to 2k` (last index being even), and we are traversing every other element starting from index 1. So the indices we are looking at are 1, 3, 5, 7... (all odd indices). Now if we come out of loop with no answer as of now, then we can clearly say that the element at the last index is our answer because it is the only index we didnot look at and as it is sure that there is exactly one element which is our answer. So return the last element of the sorted array, if you didnot find the ans inside the loop. **[Hope you got this]**\\n\\n#### Example (Dry Run):\\n\\n![image](https://assets.leetcode.com/users/images/1cf30585-0e07-43a4-82fb-f7e8aaed7752_1644904686.652919.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/24510508-d5f5-4d42-b406-0b6f56e7d3ac_1644904700.7419345.jpeg)\\n\\n#### Code:\\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       sort(nums.begin() ,nums.end());\\n        \\n        for(int i=1; i<nums.size(); i+=2){ //i+=2 as we want to check every other element\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1]; //if we didnot find answer in the loop, so return the last element.\\n    }\\n```\\n\\n#### Complexity:\\n***TC*** **= O(nlogn)**[because of sorting] **+ O(n/2)**[traversing every other element of array] **= O(nlogn)**\\n***SC*** **= O(1)** [no extra space being used]\\n\\n*************************************************************************************\\n\\n## **Approach 3: Bit Manipulation (XOR)**\\nFirst let us look at the truth table for XOR :-\\n\\n![image](https://assets.leetcode.com/users/images/c15fc714-37a8-4c8d-9eb2-f7ad7ac5f37b_1644905576.1700804.jpeg)\\n\\nFrom the table we can conclude 2 things \\n`OBS1: If both the bits are same (either both 1 or both 0) then the result of XOR is 0, and if both the bits are different (one of them is 1 and other is 0) then the result of XOR is 1`\\n\\n`OBS2: Any bit \\'a\\' when xored with 0, gives the original bit itself. That means a^0 = 0^a = a.`\\n\\nAlso from OBS1 we can conclude one more thing that\\n\\n`OBS3: For any number \\'a\\', its xor with itself will result in 0. That means, a^a=0.`\\nWhy?? Look at this example\\n\\n![image](https://assets.leetcode.com/users/images/42916f13-104b-4643-90c2-9244f2b9b3e2_1644906064.9595697.jpeg)\\n\\nAs we can see that xoring a number with itself will result in same bits at every place, because of which in the ans there will be 0s at every place, making the answer as 0.\\n\\nSo till now we have made 2 observations which will help us building the logic for this approach:\\n\\n`a^a = 0      ...(i)`\\n`0^a = a^0 = a      ...(ii)`\\n\\nNow, let\\'s come to the question...\\nWe know that in the array all the elements appear twice except one element.\\n`So, if we xor all the elements of the array then the result will be the element which occurs only once!`\\nWhy??\\n\\nLook at this example:\\n\\n#### Example:\\n![image](https://assets.leetcode.com/users/images/ebbacfc8-57de-408e-a9c9-91c6e5246edd_1644908267.6280568.jpeg)\\n\\n`So, in simple layman terms we can say that all the elements which occur twice will cancel each other out, and hence we will be left with the element which doesn\\'t have its counter to cancel it. That means we will be left with the element which occurs only once. And this will be our answer.`\\n\\n#### Code:\\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       int xorOfAllElements = 0;\\n        \\n        for(int num: nums)\\n            xorOfAllElements ^= num;\\n        \\n        return xorOfAllElements; //At the end this xor will be containing our answer.\\n    }\\n```\\n\\n#### Complexity:\\n***TC*** **= O(n)** [traversing all the elements of the array]\\n***SC*** **= O(1)** [no extra space used]\\n\\n\\n***Plz upvote the post, if you found it useful***\\n\\n\\n \\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```cpp\\nint singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> elementToFreqMap; //key=element of nums array, value=freq of that element in the nums array\\n        \\n        for(int num: nums){\\n            elementToFreqMap[num]++;\\n        }\\n        \\n        for(auto it: elementToFreqMap){\\n            if(it.second==1) return it.first;\\n        }\\n        \\n        return -1;\\n    }\\n```\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       sort(nums.begin() ,nums.end());\\n        \\n        for(int i=1; i<nums.size(); i+=2){ //i+=2 as we want to check every other element\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1]; //if we didnot find answer in the loop, so return the last element.\\n    }\\n```\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       int xorOfAllElements = 0;\\n        \\n        for(int num: nums)\\n            xorOfAllElements ^= num;\\n        \\n        return xorOfAllElements; //At the end this xor will be containing our answer.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 834955,
                "title": "2-different-approach-xor-map-3-lines-code",
                "content": "Property of XOR (exclusive or) a^a=0 and a^0=a , based on this we can say XOR of any number which is occuring even number of times will give zero and after this if any number which is occuring single time will be the answer.\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto i : nums) ans = ans ^ i;\\n        return ans;\\n    }\\n};\\n```\\n* Using unordered map\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i : nums) mp[i]++;\\n        \\n        for(auto i : mp)\\n            if(i.second == 1) return i.first;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto i : nums) ans = ans ^ i;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i : nums) mp[i]++;\\n        \\n        for(auto i : mp)\\n            if(i.second == 1) return i.first;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114402,
                "title": "hashmap-in-java",
                "content": "XOR is cool. I solved this question with HashMap in JAVA.\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!map.containsKey(nums[i])) {\\n                map.put(nums[i],1);\\n            }\\n            else {\\n                map.put(nums[i],map.get(nums[i]) + 1);\\n            }\\n        }\\n        for ( Map.Entry<Integer,Integer> entry : map.entrySet()) {\\n            Integer key = entry.getKey();\\n            Integer value = entry.getValue();\\n            if (map.get(key) == 1) {\\n                return key;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!map.containsKey(nums[i])) {\\n                map.put(nums[i],1);\\n            }\\n            else {\\n                map.put(nums[i],map.get(nums[i]) + 1);\\n            }\\n        }\\n        for ( Map.Entry<Integer,Integer> entry : map.entrySet()) {\\n            Integer key = entry.getKey();\\n            Integer value = entry.getValue();\\n            if (map.get(key) == 1) {\\n                return key;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103877,
                "title": "java-simple-solution",
                "content": "> Please Upvote if this Solution Helps You\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            count = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    count++;\\n                }\\n            }\\n            if (count == 1) {\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            count = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    count++;\\n                }\\n            }\\n            if (count == 1) {\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474244,
                "title": "c-o-1-space-o-n-time-easiest-explanation-3-lines-of-code",
                "content": "# **Logic ( XOR OPERATION )**\\n\\n- Before going into the solution, let\\'s recall some facts about the XOR operation. If you don\\'t understand any point down below, try to callibrate that point by yourself, and still don\\'t tell me in the comments section. I will try to help you out there. :)\\n- XOR operation of any number with 0 gives the number itself.\\n- XOR operation of same numbers appearing even number of times gives 0.\\n- Now let\\'s move to the solution part\\n    - As every number comes twice in the array the XOR of all those duplicates will boil down to 0.\\n    - As the result of all those duplicates values is 0, XOR of the result (0) with the only single element will give that number itself (SEE THE POINT Number 2 FROM TOP)\\n    - Bingo, you get that number, SEE it\\'s peaceful man :)\\n\\n```cpp\\nint singleNumber(vector<int>& nums) {\\n    int num=0;\\n    for(auto &i : nums) num ^= i;\\n    return num;\\n}\\n\\n```\\n\\n\\n\\n**Like it? please upvote...\\nHave any comments? I\\'d love to hear!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nint singleNumber(vector<int>& nums) {\\n    int num=0;\\n    for(auto &i : nums) num ^= i;\\n    return num;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3353219,
                "title": "java-code-that-beat-100-of-the-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n        This can be easily solved with XOR. \\n        When a number is XORed by the same number, the result is 0. \\n        We can leverage this to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        We just need loop through the elements, XOR them one by one \\n        and add them.\\n        At the end, only the non repeating number remains because it is \\n        the only non duplicate number.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // easily solved with XOR; when the same number is XORed, the result is 0. \\n        // just loop through the elements and XOR them; the non repeating number remains.\\n        int ans =0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // easily solved with XOR; when the same number is XORed, the result is 0. \\n        // just loop through the elements and XOR them; the non repeating number remains.\\n        int ans =0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43089,
                "title": "java-solution-in-3-lines-o-n-and-without-extra-space",
                "content": "A simple solution, using 2 properties of XOR: **A \\u2295 A = 0** and **B \\u2295 0 = B**\\nIn other words, **A \\u2295 A \\u2295 B = B**\\n\\n```\\npublic int singleNumber(int[] nums) {\\n  for(int i=0;i<nums.length-1;i++){\\n    nums[i+1] ^= nums[i];\\n  }\\n  return nums[nums.length-1];\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "A simple solution, using 2 properties of XOR: **A \\u2295 A = 0** and **B \\u2295 0 = B**\\nIn other words, **A \\u2295 A \\u2295 B = B**\\n\\n```\\npublic int singleNumber(int[] nums) {\\n  for(int i=0;i<nums.length-1;i++){\\n    nums[i+1] ^= nums[i];\\n  }\\n  return nums[nums.length-1];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 43200,
                "title": "c-solution-using-xor",
                "content": "Duplicates will be 0 with xor operations. res xor num is num. The one left in the end is the unique one.\\n\\n    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res = 0;\\n            for (int n : nums) res ^= n;\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res = 0;\\n            for (int n : nums) res ^= n;\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43290,
                "title": "linear-but-uses-extra-spaces-accepted-but-needs-improvement-welcome-suggestions",
                "content": "Below is my code. I used a set to record a new element and add it to the sum; if the element shows up again, delete it from the set and subtract it from the sum. At the end, the sum will be the single element.\\nThanks for comments and suggestions.\\n\\n    public class Solution {\\n      public static int singleNumber(int[] A) {\\n        int single = 0;\\n        Set<Integer> s = new TreeSet<Integer>();\\n        for (int i : A) {\\n          if (s.contains(i)) {\\n            single = single - i;\\n            s.remove(i);\\n          } else {\\n            s.add(i);\\n            single = single + i;\\n          }\\n        }\\n      return single;\\n      }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n      public static int singleNumber(int[] A) {\\n        int single = 0;\\n        Set<Integer> s = new TreeSet<Integer>();\\n        for (int i : A) {\\n          if (s.contains(i)) {\\n            single = single - i;\\n            s.remove(i);\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 3524018,
                "title": "c-java-python-javascript-fully-explained-easy-to-understand",
                "content": "# Intuition:\\nThe given problem asks us to find the number that appears only once in the given vector of integers. We can solve this problem using the bitwise XOR operation.\\n\\n# Approach:\\n1. Initialize a variable `c` to 0. This variable will store the XOR of all the elements in the vector.\\n2. Iterate through each element `num` in the vector.\\n   - Update `c` by performing `c = c ^ num`. This XOR operation will cancel out the duplicate occurrences of the numbers, leaving only the number that appears only once.\\n3. After the loop, the value of `c` will be the number that appears only once.\\n4. Return `c` as the result.\\n\\n# Complexity:\\n- Time Complexity: O(n), where n is the size of the input vector `nums`. We iterate through each element once.\\n- Space Complexity: O(1), as we are using a constant amount of extra space.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            c= c^nums[i];\\n        }\\n            return c;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for (int i = 0; i < n; i++) {\\n            c = c ^ nums[i];\\n        }\\n        return c;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        n = len(nums)\\n        c = 0\\n        for i in range(n):\\n            c = c ^ nums[i]\\n        return c\\n\\n```\\n---\\n# JavaScript\\n```\\nvar singleNumber = function(nums) {\\n    let n = nums.length;\\n    let c = 0;\\n    for (let i = 0; i < n; i++) {\\n        c = c ^ nums[i];\\n    }\\n    return c; \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            c= c^nums[i];\\n        }\\n            return c;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for (int i = 0; i < n; i++) {\\n            c = c ^ nums[i];\\n        }\\n        return c;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        n = len(nums)\\n        c = 0\\n        for i in range(n):\\n            c = c ^ nums[i]\\n        return c\\n\\n```\n```\\nvar singleNumber = function(nums) {\\n    let n = nums.length;\\n    let c = 0;\\n    for (let i = 0; i < n; i++) {\\n        c = c ^ nums[i];\\n    }\\n    return c; \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795592,
                "title": "java-1-problem-5-solutions-easy",
                "content": "# Please Upvote :D\\n---\\n##### 1. Sorting:\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n\\n        for (int i = 1; i < nums.length; i += 2) {\\n            if (nums[i] != nums[i - 1]) {\\n                return nums[i - 1];\\n            }\\n        }\\n\\n        return nums[nums.length - 1];\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```\\n---\\n##### 2. Bit-Manipulation (XOR):\\n* `0^a = a`\\n* `a^b`\\n* `a^b^a = (a^a)^b = 0^b`\\n* In this way only the number which is unique (lets say b) remains till the end.\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for (int n : nums) ans ^= n;\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n---\\n\\n##### 3. Using HashMap:\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        for (int n : map.keySet()) {\\n            if (map.get(n) == 1) {\\n                return n;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n---\\n##### 4. Using HashSet:\\nKeep removing elements when found to be already existing in the set.\\nThe one which is not duplicate will never be removed from the set.\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : nums) {\\n            if (set.contains(n)) {\\n                set.remove(n);\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n\\n        return set.iterator().next();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n---\\n##### 5. Using ArrayList:\\nKeep removing elements when found to be already existing in the list.\\nThe one which is not duplicate will never be removed from the list.\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int n : nums) {\\n            if (list.contains(n)) {\\n                list.remove(Integer.valueOf(n));\\n            } else {\\n                list.add(n);\\n            }\\n        }\\n\\n        return list.get(0);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n\\n        for (int i = 1; i < nums.length; i += 2) {\\n            if (nums[i] != nums[i - 1]) {\\n                return nums[i - 1];\\n            }\\n        }\\n\\n        return nums[nums.length - 1];\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for (int n : nums) ans ^= n;\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        for (int n : map.keySet()) {\\n            if (map.get(n) == 1) {\\n                return n;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : nums) {\\n            if (set.contains(n)) {\\n                set.remove(n);\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n\\n        return set.iterator().next();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int n : nums) {\\n            if (list.contains(n)) {\\n                list.remove(Integer.valueOf(n));\\n            } else {\\n                list.add(n);\\n            }\\n        }\\n\\n        return list.get(0);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772481,
                "title": "python-oneliner-solution-explained",
                "content": "There is straightforward hash-table solution with `O(n)` memory and time. We can also use bit manipulation trick to evaluate XOR of all numbers, which is what we need.\\n\\n#### Complexity\\nTime is `O(n)`, space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(xor, nums)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(xor, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43164,
                "title": "java-solution-using-hashset-instead-of-xor",
                "content": "    public int singleNumber(int[] nums) {\\n        HashSet<Integer> check = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++)\\n            if(!check.remove(nums[i]))\\n                check.add(nums[i]);\\n        return check.iterator().next();\\n    }",
                "solutionTags": [],
                "code": "    public int singleNumber(int[] nums) {\\n        HashSet<Integer> check = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++)\\n            if(!check.remove(nums[i]))\\n                check.add(nums[i]);\\n        return check.iterator().next();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43240,
                "title": "four-lines-of-code-for-java",
                "content": "public class Solution {\\n    public int singleNumber(int[] A) {\\n        int result = 0;\\n        for (int i : A)\\n            result ^= i ;\\n        return result ;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] A) {\\n        int result = 0;\\n        for (int i : A)\\n            result ^= i ;\\n        return result ;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1771894,
                "title": "c-3-lines-memory-99-time-92-3-in-place",
                "content": "We all know a solution using XOR operation, maintaining the answer in a varible and returning it, but do we even need to use that one extra variable? \\n\\nWell no, and here\\'s how we can acheive it:\\n\\n```\\nclass Solution {\\npublic:\\n  int singleNumber(vector<int>& nums) {\\n    for(int i=1;i<nums.size();i++)\\n      nums[i] = nums[i]^nums[i-1];\\n    return nums[nums.size()-1];\\n  }\\n};\\n```\\n\\nHave a good day :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int singleNumber(vector<int>& nums) {\\n    for(int i=1;i<nums.size();i++)\\n      nums[i] = nums[i]^nums[i-1];\\n    return nums[nums.size()-1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570604,
                "title": "c-xor-solution-16-ms-17-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            ans ^= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            ans ^= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133245,
                "title": "javascript-o-n-speed-and-o-n-space-solution-easy-to-read",
                "content": "```\\nfunction singleNumber (nums) {\\n  const memo = new Set();\\n\\n  for (let num of nums) {\\n    if (memo.has(num)) {\\n      memo.delete(num);\\n    } else {\\n      memo.add(num);\\n    }\\n  }\\n\\n  return [...memo][0];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction singleNumber (nums) {\\n  const memo = new Set();\\n\\n  for (let num of nums) {\\n    if (memo.has(num)) {\\n      memo.delete(num);\\n    } else {\\n      memo.add(num);\\n    }\\n  }\\n\\n  return [...memo][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559971,
                "title": "python-js-java-go-c-o-n-by-xor-w-hint",
                "content": "[\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/651110b2fd89780001cb6c1d)\\n\\nPython O(n) sol by XOR. \\n\\n---\\n\\n**Hint**:\\n\\nUtilize the property of XOR, **A \\u2295 A = 0**, to cancel those elements which appeared twice.\\n\\n---\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        xor_result = 0\\n        for x in nums:\\n            xor_result ^= x\\n            \\n        return xor_result\\n```\\n\\nor\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( lambda x, y: x^y, nums, 0)\\n```\\n\\nor\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( operator.xor, nums, 0)\\n```\\n\\n---\\n\\nJava:\\n\\n```\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        int xorResult = 0;\\n        \\n        for( int number : nums ){\\n            xorResult ^= number;\\n        }\\n        \\n        return xorResult;\\n    }\\n}\\n\\n```\\n\\nor\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        // Java supports reduce in data stream\\n        return Arrays.stream( nums ).reduce( 0, (x, y) -> (x^y) );\\n    }\\n}\\n```\\n\\n---\\n\\nJavaScript:\\n\\n```\\nvar singleNumber = function(nums) {\\n    \\n    let xor_result = 0; \\n\\t\\n    for(let number of nums){\\n        \\n        xor_result ^= number;    \\n    }\\n    \\n    return xor_result;\\n};\\n```\\n\\nor\\n\\n\\n```\\nvar singleNumber = function(nums) {\\n        \\n    return nums.reduce( (x, y,) =>( x ^ y ), 0 );\\n};\\n```\\n\\n---\\n\\nGolang:\\n\\n```\\nfunc singleNumber(nums []int) int {\\n    \\n    xor_result := 0\\n    \\n    for _, number := range nums{\\n        \\n        xor_result ^= number\\n    }\\n    \\n    return xor_result\\n}\\n```\\n\\n---\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int result = 0;\\n        \\n        for( const int& number : nums){\\n            result ^= number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nor\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        //C++ supports native bitwise xor operator \\n        return std::accumulate( nums.cbegin(), nums.cend(),0, std::bit_xor<int>() );\\n    }\\n};\\n```\\n\\nor\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n         \\n        return std::accumulate( nums.cbegin(), nums.cend(),0,  [](int x, int y){return x^y ;} );\\n    }\\n};\\n```\\n\\n---\\n\\n[Wiki: XOR operator](https://en.wikipedia.org/wiki/Exclusive_or)\\n\\n[Python official docs about XOR operator](https://docs.python.org/3/reference/expressions.html#binary-bitwise-operations)\\n\\n[MDN official doscs about JavaScript XOR operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR)\\n\\n[Golang offical docs about XOR operator](https://go.dev/ref/spec#Arithmetic_operators)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        xor_result = 0\\n        for x in nums:\\n            xor_result ^= x\\n            \\n        return xor_result\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( lambda x, y: x^y, nums, 0)\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( operator.xor, nums, 0)\\n```\n```\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        int xorResult = 0;\\n        \\n        for( int number : nums ){\\n            xorResult ^= number;\\n        }\\n        \\n        return xorResult;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        // Java supports reduce in data stream\\n        return Arrays.stream( nums ).reduce( 0, (x, y) -> (x^y) );\\n    }\\n}\\n```\n```\\nvar singleNumber = function(nums) {\\n    \\n    let xor_result = 0; \\n\\t\\n    for(let number of nums){\\n        \\n        xor_result ^= number;    \\n    }\\n    \\n    return xor_result;\\n};\\n```\n```\\nvar singleNumber = function(nums) {\\n        \\n    return nums.reduce( (x, y,) =>( x ^ y ), 0 );\\n};\\n```\n```\\nfunc singleNumber(nums []int) int {\\n    \\n    xor_result := 0\\n    \\n    for _, number := range nums{\\n        \\n        xor_result ^= number\\n    }\\n    \\n    return xor_result\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int result = 0;\\n        \\n        for( const int& number : nums){\\n            result ^= number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        //C++ supports native bitwise xor operator \\n        return std::accumulate( nums.cbegin(), nums.cend(),0, std::bit_xor<int>() );\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n         \\n        return std::accumulate( nums.cbegin(), nums.cend(),0,  [](int x, int y){return x^y ;} );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288612,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var singleNumber = 0;\\n        foreach (var num in nums) {\\n            singleNumber ^= num;\\n        }\\n        return singleNumber;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var singleNumber = 0;\\n        foreach (var num in nums) {\\n            singleNumber ^= num;\\n        }\\n        return singleNumber;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43190,
                "title": "4-simple-lines-of-java",
                "content": "    public class Solution {\\n    public int singleNumber(int[] nums) {\\n        int r = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            r ^= nums[i];\\n        return r;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int r = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            r ^= nums[i];\\n        return r;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3436371,
                "title": "easy-xor-soultion",
                "content": "# Intuition\\nI solved it via XOR bit operator\\n\\n# Approach\\nFor instance, I have an array [12, 1, 13, 1, 12]\\n1010\\n0001\\n\\n1011\\n1011\\n\\n0000\\n0001\\n\\n0001\\n1010\\n\\n1011 (bin) = 13 (dec)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int mask = 0;\\n\\n        for(int num : nums) {\\n            mask ^= num;\\n        }\\n\\n        return mask;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int mask = 0;\\n\\n        for(int num : nums) {\\n            mask ^= num;\\n        }\\n\\n        return mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500050,
                "title": "golang-without-auxiliary-variables",
                "content": "```\\nfunc singleNumber(nums []int) int {\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tnums[0] ^= nums[i]\\n\\t}\\n\\treturn nums[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc singleNumber(nums []int) int {\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tnums[0] ^= nums[i]\\n\\t}\\n\\treturn nums[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541621,
                "title": "updated-python-xor-explained-resources",
                "content": "At first, recommend you to skim through the following resources:\\n1. https://www.interviewcake.com/table-of-contents#section_bit-manipulation_concept_not\\n2. https://leetcode.com/discuss/general-discussion/1073221/All-about-Bitwise-Operations-Beginner-Intermediate\\n\\n**Steps:**\\n\\ntake `[4,1,2,1,2]` as an example\\n\\n1. ^ will do addition in bitwise manner.\\n2. But why do we need `result=0`? Why not simply `result=nums[0]` and start iteration from the second? => As I mentioned in the beginning, it is an addition. So, taking 4 and 1, it will give 5. But with `result=0` it\\'ll give 4 at first,\\nthen we add 1 and 2.\\n3. But then, we find duplicates of 1 and 2 which will be subtracted. Why? ^ gives 0 when 2 similar numbers are applied:\\n* 8 ^ 8 = 0\\n\\nOkay, let me explain everything in more details.\\nTake binary representation: \\n0000: 0\\n0001: 1\\n0010: 2\\n0011: 3\\n0100: 4\\n0101: 5\\n0110: 6\\n0111: 7\\n1000: 8\\n1001: 9\\n1010: 10\\n\\nSo, let\\'s iterate over that array:\\n1. 0 ^ 4: we check bit by bit: 0 ^ 0 is 0 and 0 ^ 1 is 1, 1 ^ 1 is 0\\n\\t=> we get 0100 from it. To put it simply, 4\\n\\n2. 4 ^ 1: 0100 ^ 0001 => 0101 which is 5\\n3. 5 ^ 2:  0101 ^ 0010 => 0111 which is 7\\n4. 7 ^ 1: 0111 ^ 0001 => 0110 which is 6\\n5.  6 ^ 2: 0110 ^ 0010 => 0100 which is 4\\n\\nAnd 4 is our answer\\n\\t\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n        for num in nums:\\n            result ^= num\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n        for num in nums:\\n            result ^= num\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434725,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        //even occurence will nullify\\n        for(int i=0;i<nums.length;i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        //even occurence will nullify\\n        for(int i=0;i<nums.length;i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279451,
                "title": "faster-than-100-00-bit-manipulation-explained",
                "content": "XOR operator is cumulative in nature i.e., say 5 ^ 3 ^ 5 is same as 5 ^ 5 ^ 3.\\nAlso XOR operation it return 0 for same operands : 1 ^ 1 = 0 and 0 ^ 0 = 0 then 5 ^ 5 = 0101 ^ 0101 = 0000.\\nEvery number repeats twice except the single number ,  so if we take the XOR of the entire array then all the duplicates would get cancelled out to 0 and the one that will be remaining will be our desired result. \\n\\n\\n```\\n public int singleNumber(int[] nums) {\\n    int single=0;\\n    for(int i=0;i<nums.length;i++)\\n        single=single^nums[i];\\n    return single;   \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n public int singleNumber(int[] nums) {\\n    int single=0;\\n    for(int i=0;i<nums.length;i++)\\n        single=single^nums[i];\\n    return single;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643075,
                "title": "3-swift-implementations",
                "content": "I wrote a blog post on how to solve this problem in Swift in 3 different ways: https://cocoaswiftly.com/leetcode-solutions/136-single-number/\\n\\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    var numsSeen = Set<Int>()\\n\\n    for num in nums {\\n        // the insert operation returns a tuple, the first value of which is a bool,\\n        // indicating whether the insertion is successful\\n        if !numsSeen.insert(num).0 {\\n            numsSeen.remove(num)\\n        }\\n    }\\n    \\n    // it\\'s ok to force unwrap as a valid answer is guaranteed\\n    return numsSeen.first!\\n}\\n```\\n\\nor \\n\\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    let distinctNums = Set(nums)\\n\\n    return distinctNums.reduce(0, +) * 2 - nums.reduce(0, +)\\n}\\n```\\n\\nor\\n\\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    return nums.reduce(0, ^)\\n}\\n```\\n\\nCheckout the post for detailed explanations : https://cocoaswiftly.com/leetcode-solutions/136-single-number/",
                "solutionTags": [],
                "code": "```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    var numsSeen = Set<Int>()\\n\\n    for num in nums {\\n        // the insert operation returns a tuple, the first value of which is a bool,\\n        // indicating whether the insertion is successful\\n        if !numsSeen.insert(num).0 {\\n            numsSeen.remove(num)\\n        }\\n    }\\n    \\n    // it\\'s ok to force unwrap as a valid answer is guaranteed\\n    return numsSeen.first!\\n}\\n```\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    let distinctNums = Set(nums)\\n\\n    return distinctNums.reduce(0, +) * 2 - nums.reduce(0, +)\\n}\\n```\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    return nums.reduce(0, ^)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43144,
                "title": "1-line-javascript-solution",
                "content": "    var singleNumber = function(nums) {\\n        return nums.reduce((a,b) => a^b);\\n    };",
                "solutionTags": [],
                "code": "    var singleNumber = function(nums) {\\n        return nums.reduce((a,b) => a^b);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3224500,
                "title": "explanation-of-thought-process-and-bitmask-solution-one-liner-solution",
                "content": "# Intuition\\nThe question stated some key things, my initial thoughts were:\\n1. Non-empty array of integers, -3 * 10^4 <= nums[i] <= 3 * 10^4, therefore numbers can be negative.\\n2. Every number appears 2 times, except one number. Maybe this piece of info has the key?\\n3. Time Complexity must be O(N).\\n4. Space Complexity must be O(1).\\n5. Therefore, Brute force solution (time complexity -> O(n^2)). Maps (space complexity -> O(n)) won\\'t cut it.\\n6. However, there must be something I can use to \\'**memorize**\\' or \\'**remember**\\' where each element is, or else, how will I identify/track my count of numbers.\\n\\n# Approach\\n1. I\\'m not gonna lie, the only reason I knew how to do this was because I read a similar solution before. The answer was using a bit manipulation of the numbers.\\n2. On a high level we can think of bits or bitmasks as able to \"store/remember\" information using the position of the bits.\\n3. In this case whenever 2 same numbers are XOR\\'ed with each other, they cancel out to form 0, on the other hand if 0 and any number are XOR\\'ed the output is the number itself. So,\\n\\n    7^7 = 0, simple?\\n\\n    7^7^7 =  what will this be? Well XOR\\'s are associative so let\\'s break it down.\\n\\n    7^7 will be 0\\n\\n    111 (7)\\n    111 (7)\\n    ^__\\n    000 (0)\\n\\n    so now it\\'s 0 ^ 7, which is\\n\\n    000 (0)\\n    111 (7)\\n    ^__\\n    111 (7)\\n\\n    So therefore 7^7^7 = 7, similarly 1^1^2 = 2, \\n\\n    4^1^2^1^2 = will be what?\\n\\n    In this case, the 1\\'s and 2\\'s cancel out and we\\'re left with 4^0 = 4, which is the only number with 1 occurrence and our answer in this case.\\n\\n# Complexity\\n- Time complexity: O(n), we\\'re iterating through the array once.\\n\\n- Space complexity: O(1), no extra space is used, we\\'re using the initial bitmask which is `0` and using XORs with the subsequent numbers/calculations.\\n\\n# Code\\n\\nTo anyone who doesn\\'t understand this code(JavaScript) when we use the `reduce` method of an array we pass a `function(callback)` to it, as the 1st argument and an `accumulator` as the 2nd argument(in this case 0).\\n\\nInside the callback, the first argument being passed is the `accumulator` and in the first iteration this will be `0` that we passed to `reduce`, for all subsequent iterations it will be the value passed by the `callback function`. The function is called for each element of the array and we also get the previous return value as `prev` to the function.\\n\\nSo, for nums = [4, 1, 2, 1, 2]. The function will calculate 0^4^1^2^1^2.\\n\\n```\\nfunction singleNumber(nums: number[]): number {\\n    return nums.reduce((prev, val) => prev ^ val, 0)\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction singleNumber(nums: number[]): number {\\n    return nums.reduce((prev, val) => prev ^ val, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626069,
                "title": "easy-java-sol-by-xor-operation",
                "content": "//Xor operation\\n```\\n int res=0;\\n        for(int i : nums){\\n            res =res ^ i;\\n        }\\n        return res;\\n```\\n**Kindly upvote if you like sol**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n int res=0;\\n        for(int i : nums){\\n            res =res ^ i;\\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753472,
                "title": "easiest-java-solution-using-hashmap",
                "content": "```\\n#**Please upvote if you like the Solution\\nclass Solution {\\n    public int singleNumber(int[] nums) \\n    {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                map.put(nums[i],1);\\n            }\\n        }\\n        int ans=0;\\n        for(int i:map.keySet())\\n        {\\n            if(map.get(i)==1)\\n            {\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) \\n    {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1682200,
                "title": "python-solution-using-xor-bits-116-ms-faster-than-99-54-with-comments",
                "content": "\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# This approach uses XOR bit operation\\n        # XOR with 0 will give that bit\\n        # XOR with same number will give 0\\n        # Hence in the end we will get the number which just occurs once in the array\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n![image](https://assets.leetcode.com/users/images/36e97307-7867-4ac5-9bab-6c780ed39fe2_1641884096.3620715.png)\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# This approach uses XOR bit operation\\n        # XOR with 0 will give that bit\\n        # XOR with same number will give 0\\n        # Hence in the end we will get the number which just occurs once in the array\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n![image](https://assets.leetcode.com/users/images/36e97307-7867-4ac5-9bab-6c780ed39fe2_1641884096.3620715.png)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1547325,
                "title": "2-easy-approaches-explained-xor-and-hash-set-explained-with-example",
                "content": "*upvote and comment if you find this helpful*  <3\\n**Approach 1:**\\nThe function of XOR is to detect the presence of duplicate elements. XOR returns 0 if the elements are same else returns 1. \\nAccordingly,  \\n5^5 = 0, \\n5^0 = 5;\\n5^1 = negation(5)\\n\\nWhile traversing the array if the same element is encountered, the statement result = result ^ element will make dissolve the repeating element into zero. At the end of this iteration, only the unique element remains.\\nFor example,\\nnums = [2,3,1,1,2]\\nres = 0^2 \\nres =2^3^1^1 = 2^3^0 = 2^3\\nres =2^3^2 = 3^0 = 3\\nres =3 (answer)\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        \\n        //      1.\\n        /* USING BIT MANIPULATION - Constant space, optimized linear time */\\n       int result = 0;\\n        \\n        for (int element: nums)\\n        {\\n            result = result ^ element;\\n        }\\n        return result;\\n\\t\\t}\\n\\t}\\n```\\n\\n**Approach 2:**\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n    \\n        //      2.\\n        //USING COLLECTION FRAMEWORK- Linear time but extra space\\n    \\n        Set<Integer> setobj = new HashSet<Integer>();\\n        if (nums.length == 1)\\n            return nums[0];\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for (int element: nums)\\n        {\\n            if (setobj.contains(element) == true)\\n            {\\n                setobj.remove(element);\\n            }\\n            \\n            else\\n                setobj.add(element);\\n        }\\n        \\n        for (int element: setobj)\\n        ans = element;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        \\n        //      1.\\n        /* USING BIT MANIPULATION - Constant space, optimized linear time */\\n       int result = 0;\\n        \\n        for (int element: nums)\\n        {\\n            result = result ^ element;\\n        }\\n        return result;\\n\\t\\t}\\n\\t}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n    \\n        //      2.\\n        //USING COLLECTION FRAMEWORK- Linear time but extra space\\n    \\n        Set<Integer> setobj = new HashSet<Integer>();\\n        if (nums.length == 1)\\n            return nums[0];\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for (int element: nums)\\n        {\\n            if (setobj.contains(element) == true)\\n            {\\n                setobj.remove(element);\\n            }\\n            \\n            else\\n                setobj.add(element);\\n        }\\n        \\n        for (int element: setobj)\\n        ans = element;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558955,
                "title": "java-100-runtime-no-extra-space-and-o-n-complexity-using-xor-with-explaination",
                "content": "**XOR Properties**:\\n\\t\\t1.  n^n = 0 \\n\\t\\t2.  n^0 = n\\n\\nNow we use this property to iterate over the complete array and store it in the 0th index to save space\\neverything that is duplicated turns into 0 (using first property) and the single number left, that is unique is\\nremaining at 0 index because it has no duplicat, it is left.\\nTo understand this further try XOR over an array with all members having a pair. You would see that the final result would be 0. Therfore as the problem says there is one unique number which does not have a pair, remains as it is at the 0th index here.\\n\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n      for(int i = 1; i < nums.length; i++) {\\n        nums[0] = nums[0] ^ nums[i];\\n      }\\n      return nums[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n      for(int i = 1; i < nums.length; i++) {\\n        nums[0] = nums[0] ^ nums[i];\\n      }\\n      return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323132,
                "title": "c-code-12ms-faster-than-98-using-xor-vote-up-plz",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int single_num = nums.at(0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            single_num = single_num ^ nums.at(i);\\n        }\\n        return single_num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int single_num = nums.at(0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            single_num = single_num ^ nums.at(i);\\n        }\\n        return single_num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212520,
                "title": "xor-python",
                "content": "A number XOR itself will get result 0. And a number XOR 0 will get itself. For example,\\n```\\n>>> 1 ^ 1\\n0\\n>>> 0 ^ 2\\n2\\n```\\nIn this way, if we XOR numbers with each other: two identical numbers XOR to 0, the `standard` will be the single number finally.\\n> Version 1\\n```\\n    def singleNumber(self, nums):\\n        standard = 0\\n        for num in nums:\\n            standard = num ^ standard\\n        \\n        return standard\\n```\\n> Version 2\\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(lambda a, b : a ^ b, nums)\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n>>> 1 ^ 1\\n0\\n>>> 0 ^ 2\\n2\\n```\n```\\n    def singleNumber(self, nums):\\n        standard = 0\\n        for num in nums:\\n            standard = num ^ standard\\n        \\n        return standard\\n```\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(lambda a, b : a ^ b, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43062,
                "title": "o-n-time-without-extra-space-java",
                "content": "```\\npublic int singleNumber(int[] nums) {\\n    if(nums.length == 1) {\\n        return nums[0];\\n    }\\n    for(int i = 1; i < nums.length; i++) {\\n        nums[0] ^= nums[i]; \\n    }\\n    return nums[0]; \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n    if(nums.length == 1) {\\n        return nums[0];\\n    }\\n    for(int i = 1; i < nums.length; i++) {\\n        nums[0] ^= nums[i]; \\n    }\\n    return nums[0]; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43211,
                "title": "simple-20ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size();\\n            int ans = 0;\\n            for(int i=0;i<n;i++){\\n                ans ^= nums[i];\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size();\\n            int ans = 0;\\n            for(int i=0;i<n;i++){\\n                ans ^= nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3448433,
                "title": "best-three-solutions-in-java-in-runtime-6ms-and-beats-45-7",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code1\\nin Runtime 6ms and Beats 45.7%\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n    for(int i=0; i<nums.length-1;i++)\\n    {\\n        if(nums[i]==nums[i+1]){\\n            i++;\\n        }else{\\n            return nums[i];\\n        }             \\n    }\\n        return nums[nums.length-1];\\n    }\\n}\\n```\\n\\n# Code2 \\nin Runtime 7ms and Beats 31.57%\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == nums.length-1 ) return nums[i];\\n\\n                if (  nums[i] != nums[i+1]){\\n                    if (i == 0)\\n                    return nums[i];\\n                    \\n                    if (nums[i-1] != nums[i])\\n                        return nums[i];\\n\\n                }\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\\n\\n\\n# Code3\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n         boolean cond = false;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            test1:for (int j = 0; j < nums.length; j++)\\n            {\\n                if (i != j && nums[i] == nums[j]){\\n                    cond = false;\\n                    break test1;\\n                }\\n                cond = true;\\n            }\\n\\n                if (cond)\\n                    return nums[i];\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\\n\\n\\n\\n![b0e5afaa-48ec-4dcc-bd96-e39aa7a524f8_1681948924.2890832.png](https://assets.leetcode.com/users/images/8b272e6c-3dd9-44e1-92d1-87a9a34fd04a_1682279216.3808486.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n    for(int i=0; i<nums.length-1;i++)\\n    {\\n        if(nums[i]==nums[i+1]){\\n            i++;\\n        }else{\\n            return nums[i];\\n        }             \\n    }\\n        return nums[nums.length-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == nums.length-1 ) return nums[i];\\n\\n                if (  nums[i] != nums[i+1]){\\n                    if (i == 0)\\n                    return nums[i];\\n                    \\n                    if (nums[i-1] != nums[i])\\n                        return nums[i];\\n\\n                }\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n         boolean cond = false;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            test1:for (int j = 0; j < nums.length; j++)\\n            {\\n                if (i != j && nums[i] == nums[j]){\\n                    cond = false;\\n                    break test1;\\n                }\\n                cond = true;\\n            }\\n\\n                if (cond)\\n                    return nums[i];\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040043,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPick the odd one using XOR operator\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne line solution\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLinear Time Complexity\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant Space Complexity\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(arr) {\\n\\n// SOLUTION I \\n\\n//    const count = arr.reduce((obj, curr)=>{\\n//        if(obj[curr] == undefined)\\n//        obj[curr] = 1\\n//        else\\n//        obj[curr]++\\n\\n//        return obj\\n//    }, {})\\n\\n\\n//     for(const[key, value] of Object.entries(count)){\\n//         if(value === 1){\\n//         return key;\\n//         }\\n//     }\\n    \\n// SOLUTION II\\n\\n    // let res = 0, i, n = arr.length;\\n    // for (i = 0; i < n; i++)\\n    //     res ^= arr[i];\\n    // return res;\\n\\n// SOLUTION III\\n\\n    return arr.reduce((prev, curr) => prev^curr)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(arr) {\\n\\n// SOLUTION I \\n\\n//    const count = arr.reduce((obj, curr)=>{\\n//        if(obj[curr] == undefined)\\n//        obj[curr] = 1\\n//        else\\n//        obj[curr]++\\n\\n//        return obj\\n//    }, {})\\n\\n\\n//     for(const[key, value] of Object.entries(count)){\\n//         if(value === 1){\\n//         return key;\\n//         }\\n//     }\\n    \\n// SOLUTION II\\n\\n    // let res = 0, i, n = arr.length;\\n    // for (i = 0; i < n; i++)\\n    //     res ^= arr[i];\\n    // return res;\\n\\n// SOLUTION III\\n\\n    return arr.reduce((prev, curr) => prev^curr)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3035192,
                "title": "beats-99-31-memory-beginner-friendly-using-indexof-and-lastindexof",
                "content": "# Code\\n```\\nfunction singleNumber(nums: number[]): number {\\n   if(nums.length === 1) return nums[0];\\n   \\n   for(let i = 0; i < nums.length; i++){\\n       if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])){\\n           return nums[i]\\n       }\\n   }\\n   return null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction singleNumber(nums: number[]): number {\\n   if(nums.length === 1) return nums[0];\\n   \\n   for(let i = 0; i < nums.length; i++){\\n       if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])){\\n           return nums[i]\\n       }\\n   }\\n   return null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812149,
                "title": "java-easy-fast-2-approaches-bit-manipulation-xor",
                "content": "**Approach 1 -Using hashmap**\\nMaintain Hashmap and check the count against array and return the elements if we found the one as a value, \\nSince there is only one unique element as soon as we get value as 1 we return that element.\\nTC - O(N)\\nSC- O(Min(n,m)) \\n\\n\\n    class Solution{\\n\\t\\tpublic int singleNumber(int[] nums){\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\n\\t\\tfor (int i : nums) {\\n\\t\\t  map.put(i, map.getOrDefault(i, 0) + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i : nums) {\\n\\t\\t\\t  if (map.get(i) == 1) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t  }\\n\\t\\t}\\n    return 0;\\n  }\\n}\\n\\n\\n**Approach 2 -Using BitManipulation**\\nProperties of XOR:\\n1. It returns the same number if weXOR with zero.\\n2. It return zero if we take XOR of two same numbers.\\n\\nSo We can XOR all the numbers in the given input, as per XOR properties; all the duplicate number will zero out each other and we will be left with single number.\\nTC - O(N)\\nSC- O(1) \\n\\n\\tclass Solution { \\n\\tpublic int singleNumber(int[] nums) {\\n\\t\\tint num = 0;\\n \\n\\t\\tfor (int i : nums) {\\n\\t\\t  num =num ^ i;\\n\\t\\t}\\n\\t\\treturn num;\\n\\t}\\n}\\n\\n\\n\\n\\t\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution{\\n\\t\\tpublic int singleNumber(int[] nums){\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\n\\t\\tfor (int i : nums) {\\n\\t\\t  map.put(i, map.getOrDefault(i, 0) + 1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1771850,
                "title": "easy-python-solution",
                "content": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n        c=Counter(nums)\\n        for i in nums:\\n            if c[i]==1:\\n                return i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n        c=Counter(nums)\\n        for i in nums:\\n            if c[i]==1:\\n                return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1753083,
                "title": "c-fastest-3-line-solution",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED**\\n\\n****Optimised Approach**\\n*  Since in XOR Operations 0^0 = 0 and 1^1 = 0.\\n* Hence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int c=0;\\n        for(auto cc:nums)c^=cc;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int c=0;\\n        for(auto cc:nums)c^=cc;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423042,
                "title": "java-solution-o-n",
                "content": "Try to dry run the code for a sample input to understand what goes beneath! \\nRemember, \\n1. 0 XOR num = num\\n2. num XOR num = 0\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n     return ans;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n     return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092980,
                "title": "2-simple-way-solution-with-explanation-cpp",
                "content": "First solution (by comparing elements):\\n```\\nint singleNumber(vector<int>& nums) {\\n        if (nums.size() > 1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            for(int i = 0; i < nums.size()-1; i+=2)\\n            {\\n                if(nums[i] != nums[i+1])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\\n\\nSecond solution (using bitwise XOR):\\n```\\nint singleNumber(vector<int>& nums) {\\n        int result = 0;\\n        for(int i : nums)\\n        {\\n            result ^= i;\\n        }\\n        return result;\\n    }\\n```\\nHow does it work? \\nfor example, we have input vector {4,1,2,1,2}\\nres = 0, next element = 4\\nres = 000 ^ 100 = 100\\n\\nres = 4, next element = 1\\nres = 100 ^ 001 = 101\\n\\nres = 5, next element = 2\\nres = 101 ^ 010 = 111\\n\\nres = 7, next element = 1\\nres = 111 ^ 001 = 110\\n\\nres = 6, next element = 2\\nres = 110 ^ 010 = 100\\n\\nfinally res = 4, as expected =)\\n\\n\\n**Please, upvote, if it was useful for you..**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint singleNumber(vector<int>& nums) {\\n        if (nums.size() > 1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            for(int i = 0; i < nums.size()-1; i+=2)\\n            {\\n                if(nums[i] != nums[i+1])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\n```\\nint singleNumber(vector<int>& nums) {\\n        int result = 0;\\n        for(int i : nums)\\n        {\\n            result ^= i;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 225006,
                "title": "java-solutions",
                "content": "**Solution 1: Bit Manipulation - Using XOR**\\n\\n- If we take XOR of zero and some bit, it will return that bit\\n`a ^ 0 = a`\\n\\n- If we take XOR of two same bits, it will return 0\\n`a ^ a = 0`\\n\\n- XOR operator is commutative\\n`a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b`\\n\\nSo we can XOR all bits together to find the unique number.\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        int result = 0;\\n        \\n        for(int n : A)\\n            result ^= n;\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 2: General Solution for K**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic int singleNumber(int[] A)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\tint K = 2;\\t\\t\\t\\t\\t\\t// Every element appears twice except for one\\n\\t\\t\\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor(int n: A)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((n >> i & 1) == 1)\\n\\t\\t\\t\\t\\tsum++;\\n\\t\\t\\t}\\n\\t\\t\\tsum %= K;\\n\\t\\t\\tresult |= sum << i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```\\n\\n**Solution 3: Using Set**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`\\n\\n```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int n : A)\\n        {\\n            if(set.contains(n))\\n                set.remove(n);\\n            else\\n                set.add(n);\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        int result = 0;\\n        \\n        for(int n : A)\\n            result ^= n;\\n        \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic int singleNumber(int[] A)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\tint K = 2;\\t\\t\\t\\t\\t\\t// Every element appears twice except for one\\n\\t\\t\\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor(int n: A)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((n >> i & 1) == 1)\\n\\t\\t\\t\\t\\tsum++;\\n\\t\\t\\t}\\n\\t\\t\\tsum %= K;\\n\\t\\t\\tresult |= sum << i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```\n```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int n : A)\\n        {\\n            if(set.contains(n))\\n                set.remove(n);\\n            else\\n                set.add(n);\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43169,
                "title": "c-solution-using-xor",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res=0;\\n            for(auto num : nums)\\n                res ^= num;\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res=0;\\n            for(auto num : nums)\\n                res ^= num;\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43181,
                "title": "share-my-c-solution-using-xor",
                "content": "***We can verify the associative law and the commutative law for XOR,and x^x = 0, x^0 = x***\\n\\n    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size(), i = 0, ret = 0;\\n            \\n            for (i = 0; i < n; ++i)\\n                ret ^= nums[i];\\n                \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size(), i = 0, ret = 0;\\n            \\n            for (i = 0; i < n; ++i)\\n                ret ^= nums[i];\\n                \\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43226,
                "title": "1-line-c-shortest-solution",
                "content": "The whole idea is to XOR all the elements and the value that we get after XORing all the elements is the element which appears only once in the array. \\n\\nBy default, accumulate adds up every element in the range. Since, we want to XOR all the elements int he range and not add them, we can specify bit_xor function. This can be done in 1 line in C++ :\\n\\n    int singleNumber(vector<int>& nums) {\\n            \\n        return nums.size() == 0 ? 0 : accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n            \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "The whole idea is to XOR all the elements and the value that we get after XORing all the elements is the element which appears only once in the array. \\n\\nBy default, accumulate adds up every element in the range. Since, we want to XOR all the elements int he range and not add them, we can specify bit_xor function. This can be done in 1 line in C++ :\\n\\n    int singleNumber(vector<int>& nums) {\\n            \\n        return nums.size() == 0 ? 0 : accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n            \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43230,
                "title": "very-concise-java-solution-using-xor",
                "content": "    public class Solution {\\n        public int singleNumber(int[] A) {\\n            int result = 0;\\n            for (int i=0; i<A.length; i++){\\n                result = result ^ A[i];\\n            }\\n            return result;    \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int singleNumber(int[] A) {\\n            int result = 0;\\n            for (int i=0; i<A.length; i++){\\n                result = result ^ A[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3205701,
                "title": "136-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(n), where n is the length of the input array, since we loop through the entire array once.\\n\\n- Space complexity:\\nThe space complexity is O(1), since we only use a constant amount of extra space to store the result variable.\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Given a non-empty array of integers nums, every element appears twice except for one.\\n        Find that single one.\\n        \"\"\"\\n        # We\\'ll use the XOR operator to find the single number that appears only once\\n        # XORing a number with itself gives 0, so all the pairs will cancel each other out\\n        # The result will be the number that appears only once\\n        result = 0\\n    \\n        # XOR all the numbers in the list\\n        for num in nums:\\n            result ^= num\\n    \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Given a non-empty array of integers nums, every element appears twice except for one.\\n        Find that single one.\\n        \"\"\"\\n        # We\\'ll use the XOR operator to find the single number that appears only once\\n        # XORing a number with itself gives 0, so all the pairs will cancel each other out\\n        # The result will be the number that appears only once\\n        result = 0\\n    \\n        # XOR all the numbers in the list\\n        for num in nums:\\n            result ^= num\\n    \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538019,
                "title": "java-xor-solution-explained",
                "content": "-If we use XOR operator between two same values , it will return zero.\\n-If one of the value is zero, and the other is non-zero, it returns the non-zero value.\\n\\n***XOR\\nX^X = 0\\n0^X = X***\\n\\nConsider an array [1,2,1,3,3] -\\n-> (1^2^1^3^3) = 2, it doesn\\'t matter what the order is.\\n\\n```\\npublic int singleNumber(int[] nums) {\\n\\n        int n = nums.length;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            ans ^= nums[i]; \\n        }\\n        return ans;\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "-If we use XOR operator between two same values , it will return zero.\\n-If one of the value is zero, and the other is non-zero, it returns the non-zero value.\\n\\n***XOR\\nX^X = 0\\n0^X = X***\\n\\nConsider an array [1,2,1,3,3] -\\n-> (1^2^1^3^3) = 2, it doesn\\'t matter what the order is.\\n\\n```\\npublic int singleNumber(int[] nums) {\\n\\n        int n = nums.length;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            ans ^= nums[i]; \\n        }\\n        return ans;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2441785,
                "title": "solved-using-bitwise-xor-with-full-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/605f0c08-55a9-4446-a149-167a47bd69b7_1660786303.7149374.png)\\n\\nXOR Rules in simple terms:\\n\\t1. It returns zero if we take XOR of two same numbers.\\n\\t2. It returns the same number if we XOR with zero.\\n\\n```\\n// check for valid input\\nif (nums.length < 1) return 0;\\n\\t// initialize variable\\n    let num = 0;\\n\\t\\n\\t// iterate through the nums array and XOR all the numbers in the input, \\n\\t// As stated in the rule above, duplicate numbers will zero out each other and we will be left with the single number.\\n    for (let i = 0; i < nums.length; i++) {\\n        num ^= nums[i];\\n    }\\n\\n    return num;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// check for valid input\\nif (nums.length < 1) return 0;\\n\\t// initialize variable\\n    let num = 0;\\n\\t\\n\\t// iterate through the nums array and XOR all the numbers in the input, \\n\\t// As stated in the rule above, duplicate numbers will zero out each other and we will be left with the single number.\\n    for (let i = 0; i < nums.length; i++) {\\n        num ^= nums[i];\\n    }\\n\\n    return num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675221,
                "title": "c-accepted-100-more-xor-based-tricks",
                "content": "This post includes the solution to this problem and one more XOR based trick that you might find useful in future. \\nFirst things first, XOR can be a useful bitwise operation given the range of properties it offers. This question exploits 2 such properties, i.e, XOR of any 2 similar numbers will give us a 0 value and XOR of any number with 0 gives us the same number. \\n\\na^a =0;\\n0^a=a;\\n\\nSo, the very first thing that comes into our minds if we know these properties is we can simply XOR all elements in the array and store the value as we loop through, in an integer ans. \\nAs we find a copy of any value, our ans variable will be initialized back to 0 (a^a=0) and at last the only unique element will be left with us which we can return. \\n\\nCode: \\n```\\nint singleNumber(vector<int>& nums) {\\n        int ans=0; \\n        for(int x: nums){\\n            ans^=x;\\n        }\\n        return ans;\\n    }\\n```\\n\\nNow for another XOR property that might come in handy:\\n\\n- In-place swapping of 2 numbers:  We can swap 2 numbers in place by just 3 lines of a XOR code, that goes:\\n\\n```\\nvoid swapInplace(int x, int y){\\n\\tx ^= y\\n\\ty ^= x\\n\\tx ^= y\\n}\\n```\\n\\nThe logical explaination of the code aforementioned is something like:\\n```\\nx ^= y # =>                      (x ^ y, y)\\ny ^= x # => (x ^ y, y ^ x ^ y) = (x ^ y, x)\\nx ^= y # => (x ^ y ^ x, x)     = (y, x)\\n```\\n\\nAlthough all this can be done the conventional ways too, I think it is good to know how to solve a particular problem a few different ways. Hope it helps. \\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint singleNumber(vector<int>& nums) {\\n        int ans=0; \\n        for(int x: nums){\\n            ans^=x;\\n        }\\n        return ans;\\n    }\\n```\n```\\nvoid swapInplace(int x, int y){\\n\\tx ^= y\\n\\ty ^= x\\n\\tx ^= y\\n}\\n```\n```\\nx ^= y # =>                      (x ^ y, y)\\ny ^= x # => (x ^ y, y ^ x ^ y) = (x ^ y, x)\\nx ^= y # => (x ^ y ^ x, x)     = (y, x)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1360149,
                "title": "c-xor-o-1-space-time-explained",
                "content": "we use bitwise XOR to solve this problem :\\n\\nfirst , we have to know the bitwise XOR in java\\n\\n0 ^ N = N\\nN ^ N = 0\\nSo..... if N is the single number\\n\\nN1 ^ N1 ^ N2 ^ N2 ^..............^ Nx ^ Nx ^ N\\n(since XOR is associative thus the order doesn\\'t matter )\\n\\n= (N1^N1) ^ (N2^N2) ^..............^ (Nx^Nx) ^ N\\n\\n= 0 ^ 0 ^ ..........^ 0 ^ N\\n\\n= N\\n\\n\\n```\\n    int singleNumber(vector<int>& nums)\\n    {\\n        int temp=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp=temp^nums[i];\\n        }\\n        return temp;\\n    }\\n\\t\\n\\t\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int singleNumber(vector<int>& nums)\\n    {\\n        int temp=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp=temp^nums[i];\\n        }\\n        return temp;\\n    }\\n\\t\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1346064,
                "title": "python-2-solutions-in-o-n-with-explanation-faster-than-94",
                "content": "# Solution 1:\\n# Using Map:-\\n\\nUsing map which will store the count of each element in the hashmap.\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n         mp = [0]*100000\\n         for i in range(len(nums)):\\n             nums[i] += 30000\\n        \\n         for i in range(len(nums)):\\n             mp[nums[i]]+=1\\n            \\n         for j in range(len(mp)):\\n             if mp[j] ==1:\\n                 return j - 30000\\n         return -1\\n```\\n\\n# Solution2:\\n# Using maths :- \\nFormula: 2*(a+b+c) - (a+a+b+b+c) = c\\n\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(set(nums)) - sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n         mp = [0]*100000\\n         for i in range(len(nums)):\\n             nums[i] += 30000\\n        \\n         for i in range(len(nums)):\\n             mp[nums[i]]+=1\\n            \\n         for j in range(len(mp)):\\n             if mp[j] ==1:\\n                 return j - 30000\\n         return -1\\n```\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(set(nums)) - sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1216856,
                "title": "python-solutions",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version 2.0, Using python library to build dictionary\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = Counter(nums)\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Bitwise operation\\n        # 1 xor 1 gives 0. 2 xor 2 gives 0\\n        # what it means 1 xor 1, 2 xor 2, 3 xor 3 will always give you 0\\n        # [4,1,2,1,2] - > [4] will stay as 4 [1,2,1,2] will cancel each other. \\n        # T: O(N)\\n        # S: O(1)\\n        \\n        combined = 0\\n        for i in nums:\\n            combined ^= i\\n        \\n        return combined\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version 2.0, Using python library to build dictionary\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = Counter(nums)\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Bitwise operation\\n        # 1 xor 1 gives 0. 2 xor 2 gives 0\\n        # what it means 1 xor 1, 2 xor 2, 3 xor 3 will always give you 0\\n        # [4,1,2,1,2] - > [4] will stay as 4 [1,2,1,2] will cancel each other. \\n        # T: O(N)\\n        # S: O(1)\\n        \\n        combined = 0\\n        for i in nums:\\n            combined ^= i\\n        \\n        return combined\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834478,
                "title": "java-c-c-super-simple-solution-0-ms-100-faster",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579498,
                "title": "java-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ret = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            ret ^= nums[i];\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ret = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            ret ^= nums[i];\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428189,
                "title": "php-1-line-beats-100-time-and-space",
                "content": "Independent bitwise xor function:\\n\\n\\tfunction singleNumber($A) {\\n\\t\\tfunction bitwise_xor($x, $y){\\n\\t\\t\\treturn $x ^ $y;\\n\\t\\t}\\n        return array_reduce($A, \"bitwise_xor\");\\n    }\\n\\nIn-line anonymous function:\\n\\n\\tfunction singleNumber($A) {\\n        return array_reduce($A, function($x, $y){ return $x ^ $y; });\\n    }",
                "solutionTags": [
                    "PHP"
                ],
                "code": "Independent bitwise xor function:\\n\\n\\tfunction singleNumber($A) {\\n\\t\\tfunction bitwise_xor($x, $y){\\n\\t\\t\\treturn $x ^ $y;\\n\\t\\t}\\n        return array_reduce($A, \"bitwise_xor\");\\n    }\\n\\nIn-line anonymous function:\\n\\n\\tfunction singleNumber($A) {\\n        return array_reduce($A, function($x, $y){ return $x ^ $y; });\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 314884,
                "title": "my-4-swift-solutions",
                "content": "```\\n\\n// Bit manipulation solution\\nfunc findSingleNumber(_ nums: [Int]) -> Int {\\n    var result = 0\\n    for number in nums {\\n        result ^= number\\n    }\\n    return result\\n}\\n\\nassert(findSingleNumber([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Time Limit Exceeded - Array Solution - O(n\\u02C62)\\nfunc findSingleNumber2(_ nums: [Int]) -> Int {\\n    var array: [Int] = []\\n    for number in nums {\\n        if let index = array.firstIndex(of: number) {\\n            array.remove(at: index)\\n        } else {\\n            array.append(number)\\n        }\\n    }\\n    return array.first ?? 0\\n}\\n\\nassert(findSingleNumber2([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber2([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Hash Table Solution\\nfunc findSingleNumber3(_ nums: [Int]) -> Int {\\n    var table: [Int: Int] = [:]\\n    for number in nums {\\n        if table[number] != nil {\\n            table[number] = nil\\n        } else {\\n            table[number, default: 0] += 1\\n        }\\n    }\\n    return table.first?.key ?? 0\\n}\\n\\nassert(findSingleNumber3([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber3([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Math Solution\\n// 1. Sum of all numbers: a + a + b + c + c = 2a + 2c + b\\n// 2. Sum of unique numbers: a + b + c\\n// 3. Multiply by 2 unique sum: 2a + 2b + 2c\\n// 4. Subtract: 2a + 2b + 2c - (2a + 2c + b) = b\\n// 5 Formula: singleNumber = 2 * Sum(Set(nums)) - sum(nums)\\n\\nfunc findSingleNumber4(_ nums: [Int]) -> Int {\\n    let setSum2 = 2 * Set(nums).reduce(0, +)\\n    let numsSum = nums.reduce(0, +)\\n    return setSum2 - numsSum\\n}\\n\\nassert(findSingleNumber4([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber4([4,1,2,1,2]) == 4, \"Failed\")\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\n// Bit manipulation solution\\nfunc findSingleNumber(_ nums: [Int]) -> Int {\\n    var result = 0\\n    for number in nums {\\n        result ^= number\\n    }\\n    return result\\n}\\n\\nassert(findSingleNumber([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Time Limit Exceeded - Array Solution - O(n\\u02C62)\\nfunc findSingleNumber2(_ nums: [Int]) -> Int {\\n    var array: [Int] = []\\n    for number in nums {\\n        if let index = array.firstIndex(of: number) {\\n            array.remove(at: index)\\n        } else {\\n            array.append(number)\\n        }\\n    }\\n    return array.first ?? 0\\n}\\n\\nassert(findSingleNumber2([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber2([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Hash Table Solution\\nfunc findSingleNumber3(_ nums: [Int]) -> Int {\\n    var table: [Int: Int] = [:]\\n    for number in nums {\\n        if table[number] != nil {\\n            table[number] = nil\\n        } else {\\n            table[number, default: 0] += 1\\n        }\\n    }\\n    return table.first?.key ?? 0\\n}\\n\\nassert(findSingleNumber3([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber3([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Math Solution\\n// 1. Sum of all numbers: a + a + b + c + c = 2a + 2c + b\\n// 2. Sum of unique numbers: a + b + c\\n// 3. Multiply by 2 unique sum: 2a + 2b + 2c\\n// 4. Subtract: 2a + 2b + 2c - (2a + 2c + b) = b\\n// 5 Formula: singleNumber = 2 * Sum(Set(nums)) - sum(nums)\\n\\nfunc findSingleNumber4(_ nums: [Int]) -> Int {\\n    let setSum2 = 2 * Set(nums).reduce(0, +)\\n    let numsSum = nums.reduce(0, +)\\n    return setSum2 - numsSum\\n}\\n\\nassert(findSingleNumber4([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber4([4,1,2,1,2]) == 4, \"Failed\")\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 154920,
                "title": "five-line-javascript-solution",
                "content": "Compare indexOf and lastIndexOf each element, if equal, the number is single.\\n```\\nvar singleNumber = function(nums) {\\n    for(var i=0;i<nums.length;i++) {\\n        if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])) return nums[i];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar singleNumber = function(nums) {\\n    for(var i=0;i<nums.length;i++) {\\n        if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])) return nums[i];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43244,
                "title": "shortest-solution-with-c",
                "content": "     while (--n)\\n\\tA[n - 1] ^= A[n];\\n    return A[0];",
                "solutionTags": [],
                "code": "     while (--n)\\n\\tA[n - 1] ^= A[n];\\n    return A[0];",
                "codeTag": "Unknown"
            },
            {
                "id": 43275,
                "title": "my-linear-complexity-without-using-extra-memory-solution",
                "content": "Hi all,\\n\\nI have a different solution here which take no extra memory. This algorithm is based on the three way partition method. First, choose a element in the array as pivot. Second, split this array to three partition, less than pivot, equal to pivot and greater than pivot. Now we have three partitions and we also know the size of these three partitions too. If the single number in any partition, the size of this partition must be 2*n+1, and should not be divisible by 2. Last, we just recursively find the single number in the partition which size can not be divisible by 2.\\n\\nThis method can be easily modified to solve the single number 2 problem.\\n\\n\\n    void swap(int A[], int a, int b)\\n    {\\n        int t = A[a];\\n        A[a] = A[b];\\n        A[b] = t;\\n    }\\n    \\n    void threeWayPartition(int A[], int n, int&l, int&h)\\n    {\\n        int pivot = A[0];\\n        int j = -1;\\n        int k = n;\\n        \\n        for (int i=0; i<k;)\\n        {\\n            if (A[i] < pivot)\\n            {\\n                swap(A, i, ++j);\\n                i++;\\n            }\\n            else if (A[i] > pivot)\\n            {\\n                swap(A, i, --k);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        \\n        l = j;\\n        h = k;\\n    }\\n    \\n    #define APPEAR_NUMBER (2)\\n    \\n    class Solution {\\n    public:\\n        int singleNumber(int A[], int n) {\\n            if (n==1)\\n            {\\n                return A[0];\\n            }\\n    \\n            int l=0;\\n            int h=0;\\n            threeWayPartition(A, n, l, h);\\n            \\n            int p = l+1;\\n    \\n            if (A[p] != A[p+1])\\n            {\\n                return A[p];\\n            }\\n            else if(p%APPEAR_NUMBER == 0)\\n            {\\n                return singleNumber(A+(p+APPEAR_NUMBER), n-(p+APPEAR_NUMBER));\\n            }\\n            else\\n            {\\n                return singleNumber(A, p);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(int A[], int n) {\\n            if (n==1)\\n            {\\n                return A[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3349420,
                "title": "c-solution-using-maps-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we have an array, where every single element is repeated twice, but there is one element which is occuring only one. we will need to count it and then print it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt can be solved using the bit manipulation technique as well as using the mapping technique. Here we have used the mapping technique. To keep track of the count of the number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n          unordered_map<int,int> mp;\\n          for(int i=0;i<nums.size();i++){\\n              mp[nums[i]]++;\\n          }\\n\\n        //   for(auto it: mp){\\n        //       cout<<it.first<<\" \"<<it.second<<endl;\\n        //   }\\n          \\n          for(auto it: mp){\\n              if(it.second==1){ return it.first; break;}\\n          }\\n          return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n          unordered_map<int,int> mp;\\n          for(int i=0;i<nums.size();i++){\\n              mp[nums[i]]++;\\n          }\\n\\n        //   for(auto it: mp){\\n        //       cout<<it.first<<\" \"<<it.second<<endl;\\n        //   }\\n          \\n          for(auto it: mp){\\n              if(it.second==1){ return it.first; break;}\\n          }\\n          return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2788653,
                "title": "pythonic",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        stack=[]\\n        if len(nums)==1:\\n            return nums[0]\\n        for i in range(len(nums)):\\n            if nums[i] not  in stack :\\n                stack.append(nums[i])\\n            else:\\n                stack.pop()\\n        return stack[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        stack=[]\\n        if len(nums)==1:\\n            return nums[0]\\n        for i in range(len(nums)):\\n            if nums[i] not  in stack :\\n                stack.append(nums[i])\\n            else:\\n                stack.pop()\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678049,
                "title": "python-3-fastest-solution-faster-than-96-of-submissions",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def singleNumber(self, nums):\\n      a = dict(Counter(nums))\\n      b = [k for k, v in a.items() if v==1]\\n      return b[0]\\n\\t  \\n```\\n\\nUpvote if you like the solution. Feel free to ask any question",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def singleNumber(self, nums):\\n      a = dict(Counter(nums))\\n      b = [k for k, v in a.items() if v==1]\\n      return b[0]\\n\\t  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547758,
                "title": "easy-python3-solution",
                "content": "if it is helpful please ***upvote*** me\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        return xor\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        return xor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773553,
                "title": "java-simple-short-and-easy-solution-bit-manipulation-xor",
                "content": "```\\n//logic is very simple -> xor of two same number cancel each other( in simple word ) \\n//because xor of two same number equals zero\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums)\\n            result ^= i;\\n        \\n        return result;\\n    }\\n}\\n\\n//please upvote",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums)\\n            result ^= i;\\n        \\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1739614,
                "title": "solution-swift-single-number-test-cases",
                "content": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var result = nums[0]\\n        for n in nums[1...] { result ^= n }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.017 (0.019) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.singleNumber([2,2,1])\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.singleNumber([4,1,2,1,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test2() {\\n        let value = solution.singleNumber([1])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var result = nums[0]\\n        for n in nums[1...] { result ^= n }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.singleNumber([2,2,1])\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.singleNumber([4,1,2,1,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test2() {\\n        let value = solution.singleNumber([1])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523589,
                "title": "all-possible-solutions-by-ashay-nayak-best-solution-o-n",
                "content": "Please **upvote** if you find it helpful. Thank You.\\n**Purpose** - Practice of thinking all possible solution which help you in **interviews**.\\nFeel free to comment below if you don\\'t get anything. I will surely reply back **within 12 hours**.\\npossible solutions,\\nSee read the question twice that **every element appears twice except for one.**\\n1.) Using 2 for loops - TC - O(n^2) and SC - O(1)  -  please try to think by yourself and if you don\\'t get it then comment below.\\n\\n2.) Using HashMap - two iteration required - TC - O(n) and SC - O(n)  - Iterate through each element of nums array and increment it\\'s count in map. Here, key will be element present in nums and value will be the count. Now, iterate through map and return the element with count value 1. - please try to code by yourself and if you don\\'t get it then comment below\\n\\n3.) Using HashSet - one iteration required - TC - O(n) and SC - O(n) -  Iterate through each element of nums array. While iterating, check if element is present in set or not. If it is already present then remove that element from set and if it is not present then add the element to the set. Element which has appeared only for single time will remain in set and it will be the answer. - please try to code by yourself and if you don\\'t get it then comment below.\\n\\n4.) Using XOR - TC - O(n) and SC - O(1) -**best solution** - keep these two things in mind for xor. (a.) 0^x = x and (b.) x^x = 0 . Now initialize a variable say ans = 0 and iterate through nums elements. While iterate** take xor of all elements with ans**. Finally value of ans will be the element which appears only once. See this example, 3,4,3,1,1 - what I said that intitialize ans=0 and  **take xor of all elements with ans** so I will write - ans^3^4^3^1^1 - replace ans with 0 - 0^3^4^3^1^1 - same elements will become 0 as per x^x=0. So we will left with 0^4 which becomes 4 as per 0^x = x.\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans^=nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans^=nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190791,
                "title": "faster-than-99-95",
                "content": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(list(set(nums))) - sum(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(list(set(nums))) - sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 643220,
                "title": "cpp-using-hash-table",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint singleNumber(vector<int>& nums) {\\n\\t\\t\\tunordered_map<int, int> hash;\\n\\t\\t\\tfor (auto num : nums) {\\n\\t\\t\\t\\tif (!hash[num])\\n\\t\\t\\t\\t\\thash[num] = 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thash.erase(num);\\n\\t\\t\\t}\\n\\t\\t\\treturn hash.begin()->first;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint singleNumber(vector<int>& nums) {\\n\\t\\t\\tunordered_map<int, int> hash;\\n\\t\\t\\tfor (auto num : nums) {\\n\\t\\t\\t\\tif (!hash[num])\\n\\t\\t\\t\\t\\thash[num] = 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thash.erase(num);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 515893,
                "title": "c-code-3-lines-solution-99-optimal-code",
                "content": "```\\nint singleNumber(int* nums, int numsSize){\\n    int val = 0;\\n    while(numsSize--) val ^= nums[numsSize];\\n    return val;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint singleNumber(int* nums, int numsSize){\\n    int val = 0;\\n    while(numsSize--) val ^= nums[numsSize];\\n    return val;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515023,
                "title": "javascript-xor-linear-time-no-extra-space",
                "content": "```\\n// XOR is commutative, means- 1^2^1 = 1^1^2 (since a^a =0 hence 2 will be left)\\nvar singleNumber = function(nums) {\\n    let res = nums[0];\\n    for(let i = 1; i < nums.length; i++){\\n        res = res ^ nums[i]\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// XOR is commutative, means- 1^2^1 = 1^1^2 (since a^a =0 hence 2 will be left)\\nvar singleNumber = function(nums) {\\n    let res = nums[0];\\n    for(let i = 1; i < nums.length; i++){\\n        res = res ^ nums[i]\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468420,
                "title": "python3-bitwise-and-non-bitwise-solutions-w-explanation",
                "content": "\\n# **Bitwise**\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tsol = 0\\n\\tfor n in nums:\\n\\t\\tsol ^= n\\n\\n\\treturn sol\\n```\\nExplanation:\\nThe key to this bitwise solution is understanding how XOR works. In this case we use this operator as a sort of do and undo. Let\\'s look at an example to see what I mean by that. \\n\\n```\\n>> x = 2  // 0010 in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n...\\n``` \\nAs you see in the example, when we XOR `2` with `3` we get `1`, but if we do the operation again then we end up with our original `2`, essentially undoing what we just did. The same is true if we do this operation any even number of times. \\n\\nFor this problem since each number comes in pairs other than solution, XOR-ing our result by each number in our list will ultimately leave us with the the only number that occurs once which is the solution.\\n\\n# **Non Bitwise**\\n```\\n# Note this is not fast or memory efficient but it is readable\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tref = {}\\n\\tfor i in nums:\\n\\t\\tif i not in ref:\\n\\t\\t\\tref[i] = 1\\n\\t\\telse:\\n\\t\\t\\tref[i] += 1\\n\\n\\tfor k, v in ref.items():\\n\\t\\tif v == 1 :\\n\\t\\t\\treturn k\\n```\\n*Explanation:*\\nFor the non bitwise solution we are just using a map (dictionary in python terminology) to keep track of how many times each number occurs in the list. We iterate through and add the number to the map if it doesn\\'t exist and if it does we increment it by one. In the end we just go through each key value pair in the map and if any value is `1` (meaning there is only one instance of it) then we return the key to that value.\\n\\n**P.S** Feedback is always appreciated. Let me know what you think in the comments :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tsol = 0\\n\\tfor n in nums:\\n\\t\\tsol ^= n\\n\\n\\treturn sol\\n```\n```\\n>> x = 2  // 0010 in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n...\\n```\n```\\n# Note this is not fast or memory efficient but it is readable\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tref = {}\\n\\tfor i in nums:\\n\\t\\tif i not in ref:\\n\\t\\t\\tref[i] = 1\\n\\t\\telse:\\n\\t\\t\\tref[i] += 1\\n\\n\\tfor k, v in ref.items():\\n\\t\\tif v == 1 :\\n\\t\\t\\treturn k\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 444555,
                "title": "4-different-solutions-in-go",
                "content": "### 1. Using a HashMap (Set) to find the single number\\n\\n> Runtime: 8 ms, faster than 95.97%\\n> Memory Usage: 5.4 MB, less than 14.29%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  for _, num := range nums {\\n    if _, found := m[num]; found {\\n      delete(m, num)\\n    } else {\\n      m[num] = struct{}{}\\n    }\\n  }\\n  for k := range m {\\n    return k\\n  }\\n  return -1\\n}\\n```\\n\\n### 2. Using a HashMap (Set) to create a Set of numbers\\n\\n> Runtime: 8 ms, faster than 95.97%\\n> Memory Usage: 5.4 MB, less than 14.29%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  var wholeSum int\\n  for _, num := range nums {\\n    m[num] = struct{}{}\\n    wholeSum += num\\n  }\\n  var uniqueSum int\\n  for num := range m {\\n    uniqueSum += num\\n  }\\n  return uniqueSum*2 - wholeSum\\n}\\n```\\n\\n### 3. Sorting the array\\n\\n> Runtime: 16 ms, faster than 15.99%\\n> Memory Usage: 4.7 MB, less than 100.00%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  sort.Ints(nums)\\n  lastIndex := len(nums) - 1\\n  for i := 0; i < lastIndex; i += 2 {\\n    if nums[i] != nums[i+1] {\\n      return nums[i]\\n    }\\n  }\\n  return nums[lastIndex]\\n}\\n```\\n\\n### 4. Bit manipulation (XOR)\\n\\n> Runtime: 8 ms, faster than 95.94%\\n> Memory Usage: 4.7 MB, less than 100.00%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  var result int\\n  for _, num := range nums {\\n    result ^= num\\n  }\\n  return result\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  for _, num := range nums {\\n    if _, found := m[num]; found {\\n      delete(m, num)\\n    } else {\\n      m[num] = struct{}{}\\n    }\\n  }\\n  for k := range m {\\n    return k\\n  }\\n  return -1\\n}\\n```\n```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  var wholeSum int\\n  for _, num := range nums {\\n    m[num] = struct{}{}\\n    wholeSum += num\\n  }\\n  var uniqueSum int\\n  for num := range m {\\n    uniqueSum += num\\n  }\\n  return uniqueSum*2 - wholeSum\\n}\\n```\n```go\\nfunc singleNumber(nums []int) int {\\n  sort.Ints(nums)\\n  lastIndex := len(nums) - 1\\n  for i := 0; i < lastIndex; i += 2 {\\n    if nums[i] != nums[i+1] {\\n      return nums[i]\\n    }\\n  }\\n  return nums[lastIndex]\\n}\\n```\n```go\\nfunc singleNumber(nums []int) int {\\n  var result int\\n  for _, num := range nums {\\n    result ^= num\\n  }\\n  return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 254014,
                "title": "java-no-extra-memory",
                "content": "My solution, no extra memory.\\n```\\npublic int singleNumber(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[0] = nums[0] ^ nums[i];\\n        }\\n        return nums[0];\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[0] = nums[0] ^ nums[i];\\n        }\\n        return nums[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132680,
                "title": "kotlin-reduce-and-xor-1-line",
                "content": "```fun singleNumber(data: IntArray) = data.reduce { acc, i -> acc.xor(i) }```",
                "solutionTags": [],
                "code": "```fun singleNumber(data: IntArray) = data.reduce { acc, i -> acc.xor(i) }```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367818,
                "title": "beginner-friendly-javascript-bitwise-explanation-47ms-99-83-beats-6-lines-code",
                "content": "![Screenshot 2023-04-02 at 01.21.19.png](https://assets.leetcode.com/users/images/5f6d740d-c4be-4a28-b060-7f38fa574e1a_1680391459.988997.png)\\n\\n# What is XOR operation and how it works:\\n\\nXOR (Exclusive OR) is a logical operation that takes two operands and returns a result based on their boolean values. The operation returns true if and only if exactly one of the operands is true.\\n\\nIn the context of binary numbers, the XOR operation is applied bitwise to each pair of corresponding bits, and the result is a new binary number. The operation returns a 1 in each bit position where the corresponding bits of the operands are different, and a 0 where they are the same.\\n\\nHere\\'s an example of how XOR works on two binary numbers, *1010* and *1101*:\\n```\\n  1010\\nX 1101\\n-----\\n  0111\\n```\\nIn this example, the XOR operation was applied bitwise to each pair of bits in the two operands. The result is a new binary number, 0111, which is the XOR of 1010 and 1101.\\n\\nIn the context of the code we have been discussing, the XOR operation is used to find the single number in an array of numbers that does not have a duplicate. The properties of the XOR operation ensure that when the same number is XORed twice, it results in 0, effectively cancelling out any duplicates. The remaining number that is not cancelled out is the single number that we are looking for.\\n# Explanation\\n1. Check if the input array nums is empty. If it is empty, the function immediately returns 0.\\n2. Initialize a variable called num to 0.\\n3. Iterate through each element of the input array nums.\\n4. For each element, apply the XOR operation between the current value of num and the value of the element. Store the result back in num.\\n5. After all elements have been processed, return the value of num.\\n\\n\\n# Complexity\\n- Time complexity:\\nIt is O(n), where n is the length of the input array. This is because the code iterates through each element of the array exactly once to perform the XOR operation.\\n\\n- Space complexity:\\nIt is O(1), as it only uses a constant amount of extra space to store the num variable. This means that the space required by the code does not depend on the size of the input array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(nums) {\\n    if(nums.length<0){\\n        return 0\\n    }\\n    let num = 0 ;\\n    for (let i = 0; i<nums.length; i++ ){\\n        num^=nums[i]\\n    }\\n    return num\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n  1010\\nX 1101\\n-----\\n  0111\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(nums) {\\n    if(nums.length<0){\\n        return 0\\n    }\\n    let num = 0 ;\\n    for (let i = 0; i<nums.length; i++ ){\\n        num^=nums[i]\\n    }\\n    return num\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3125796,
                "title": "python-simple-solution-linear-runtime-constant-space-explained",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        #go through each numbers\\n        for i in nums:\\n            #Using count method to check how many times current number appear in array\\n            if nums.count(i) == 1:\\n            #IF the current number appear 1 so return the answer\\n                return i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        #go through each numbers\\n        for i in nums:\\n            #Using count method to check how many times current number appear in array\\n            if nums.count(i) == 1:\\n            #IF the current number appear 1 so return the answer\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045415,
                "title": "c-and-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var result = 0;\\n        for (int i = 0; i < nums.Length; i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var result = 0;\\n        for (int i = 0; i < nums.Length; i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041411,
                "title": "swift-solution-using-xor-with-comments-beats-93",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we use the property of XOR operation, that is a^b^b = a. \\nSo, if we take XOR of all the elements, the duplicated ones will cancel out each other and we will be left with the single element.\\n\\n# Code\\n```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        \\n        var result = 0\\n\\n        for num in nums {\\n            result ^= num\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n# A little theory\\nThe XOR (exclusive OR) operation is a logical operation that compares two binary digits and returns 1 if they are different and 0 if they are the same. It is represented by the symbol \"^\".\\n\\nThe XOR operation has several properties that make it useful in various algorithms and problems. Some of the most important properties of XOR are:\\n\\nCommutative: The order of the operands does not affect the result, so a^b = b^a\\nAssociative: The grouping of the operands does not affect the result, so (a^b)^c = a^(b^c)\\nIdentity: a^0 = a\\nInverse: a^a = 0",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        \\n        var result = 0\\n\\n        for num in nums {\\n            result ^= num\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007305,
                "title": "java-easy-solution-beginner-friendly-beat-100",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n            \\n        }\\n    \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n            \\n        }\\n    \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765242,
                "title": "simple-fast",
                "content": "```\\nclass Solution:\\n\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\tresult = 0\\n\\n\\t\\tfor i in nums:\\n\\t\\t\\tresult = result ^ i\\n\\n\\t\\treturn result \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\tresult = 0\\n\\n\\t\\tfor i in nums:\\n\\t\\t\\tresult = result ^ i\\n\\n\\t\\treturn result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522877,
                "title": "java-solution-time-o-n-space-o-1-xor-explained",
                "content": "The property of XOR :-\\n\\n0 ^ 0 --> 0\\n0 ^ 1 --> 1\\n1 ^ 0 --> 1\\n1 ^ 1 --> 0\\nWe know every number is appears twice except a single number which appears only single time.\\n\\nSee, we already discuss a thing a that xor of a same number with itself is zero, i.e A ^ A = 0\\nNow, we will look some more property of xor-\\n\\n1) xor of a same number with itself is zero, i.e A ^ A = 0.\\n2) xor of any number with zero is the number itself i.e A ^ 0 = A.\\n\\nOur array is : {4,1,2,1,2}\\n                      4^1  \\n\\t\\t\\t\\t\\t  4^1^2\\n\\t\\t\\t\\t\\t  4^1^2^1   ->[1^1=0]\\n\\t\\t\\t\\t\\t  4^2\\n\\t\\t\\t\\t\\t  4^2^2    -> [2^2=0]\\n\\t\\t\\t\\t\\t  4\\n\\t\\t\\t\\t\\t  So, the element which we got as left should be our answer, so the answer is  \\'4\\'\\n\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t  Time complexicity -> O(n)\\n\\t\\t\\t\\t\\t  Space complexicity -> O(1)\\n\\t\\t\\t\\tcode :-\\t  \\n\\t\\t\\t\\t\\t  class Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0; \\n      for(int i=0; i<nums.length; i++) {\\n          res = res ^ nums[i]; \\n      }\\n        return res;\\n    }\\n}\\nIf you find this useful, kindly consider to upvote.\\n\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0; \\n      for(int i=0; i<nums.length; i++) {\\n          res = res ^ nums[i]; \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1645511,
                "title": "python-3-faster-than-92-98-one-liner",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(set(nums))*2 - sum(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(set(nums))*2 - sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491449,
                "title": "js-xor-solution",
                "content": "```\\nvar singleNumber = function(nums) {\\n    let single = 0;\\n    for (let num of nums) {\\n        single ^= num\\n    }\\n    return single\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar singleNumber = function(nums) {\\n    let single = 0;\\n    for (let num of nums) {\\n        single ^= num\\n    }\\n    return single\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468062,
                "title": "c-super-straight-forward-solution-using-xor",
                "content": "```\\n/*\\n    https://leetcode.com/problems/single-number/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int unique = 0;\\n        // XOR of A XOR A = 0, so all duplicates will cancel each other, \\n        // leaving the non duplicate \\n        for(int &num: nums)\\n            unique ^= num;\\n        return unique;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/single-number/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int unique = 0;\\n        // XOR of A XOR A = 0, so all duplicates will cancel each other, \\n        // leaving the non duplicate \\n        for(int &num: nums)\\n            unique ^= num;\\n        return unique;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998258,
                "title": "rust-fold-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Single Number.\\nMemory Usage: 2.2 MB, less than 80.77% of Rust online submissions for Single Number.\\n```\\nimpl Solution {\\n    pub fn single_number(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(0, |acc, x| acc ^ x)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn single_number(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(0, |acc, x| acc ^ x)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955161,
                "title": "python-1-liner-maths-logic-without-using-libraries-beats-97",
                "content": "![image](https://assets.leetcode.com/users/images/05f7734e-e9d1-48d7-9075-b3e307bb55af_1606775426.1568828.png)\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        return ((2*(sum(set(nums))))-(sum(nums)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        return ((2*(sum(set(nums))))-(sum(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813225,
                "title": "simple-typescript-math-solution",
                "content": "```\\nconst singleNumber = (nums: number[]): number => {\\n  const set = new Set(nums);\\n  const setSum = [...set].reduce((acc, elem) => acc + elem);\\n  const numsSum = nums.reduce((acc, elem) => acc + elem);\\n\\n  return 2 * setSum - numsSum;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst singleNumber = (nums: number[]): number => {\\n  const set = new Set(nums);\\n  const setSum = [...set].reduce((acc, elem) => acc + elem);\\n  const numsSum = nums.reduce((acc, elem) => acc + elem);\\n\\n  return 2 * setSum - numsSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 562515,
                "title": "136-single-number-java-100-speed-with-notes-explaining-solution",
                "content": "```\\npublic int singleNumber(int[] nums) {\\n        // Count the number of integers in the array\\n        int size = nums.length;\\n        // Isolate the first number in the array\\n        int result = nums[0];\\n        \\n        // Traverse through the entire array starting from the second number\\n        for (int i = 1; i < size; i++)\\n            /**\\n             * Use an XOR gate to find the number without a match.\\n             *\\n             * XOR or Exclusive Or is a  logical operation that outputs\\n             * true only when inputs differ (one is true, the other is\\n             * false).\\n             *\\n             * In this case, the program will traverse through the array\\n             * adding each number to the result until it comes to a number\\n             * it has already added. Instead of adding a number again, the\\n             * program will subtract the number from result. When the\\n             * for-loop has completed, the result will be the number\\n             * that was added but not subtracted.\\n             * */\\n            result = result ^ nums[i];\\n            \\n        // Return the \"true\" integer that does not appear twice\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n        // Count the number of integers in the array\\n        int size = nums.length;\\n        // Isolate the first number in the array\\n        int result = nums[0];\\n        \\n        // Traverse through the entire array starting from the second number\\n        for (int i = 1; i < size; i++)\\n            /**\\n             * Use an XOR gate to find the number without a match.\\n             *\\n             * XOR or Exclusive Or is a  logical operation that outputs\\n             * true only when inputs differ (one is true, the other is\\n             * false).\\n             *\\n             * In this case, the program will traverse through the array\\n             * adding each number to the result until it comes to a number\\n             * it has already added. Instead of adding a number again, the\\n             * program will subtract the number from result. When the\\n             * for-loop has completed, the result will be the number\\n             * that was added but not subtracted.\\n             * */\\n            result = result ^ nums[i];\\n            \\n        // Return the \"true\" integer that does not appear twice\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378036,
                "title": "java-hashset-solution",
                "content": "Time complexity: O(n)\\nSpace complexity: O(n)\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        //Sanity check\\n        if (nums == null || nums.length < 1) {\\n            return 0;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num)) {\\n                set.remove(num);\\n            } else {\\n                set.add(num);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        //Sanity check\\n        if (nums == null || nums.length < 1) {\\n            return 0;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num)) {\\n                set.remove(num);\\n            } else {\\n                set.add(num);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43085,
                "title": "my-simple-javascript-solution",
                "content": "var singleNumber = function(nums) {\\n            nums.sort();\\n            for (var i = 0; i < nums.length; i += 2) {\\n                if (nums[i] != nums[i + 1]) {\\n                    return nums[i];\\n                }\\n            }\\n        };",
                "solutionTags": [],
                "code": "var singleNumber = function(nums) {\\n            nums.sort();\\n            for (var i = 0; i < nums.length; i += 2) {\\n                if (nums[i] != nums[i + 1]) {\\n                    return nums[i];\\n                }\\n            }\\n        };",
                "codeTag": "Unknown"
            },
            {
                "id": 3545995,
                "title": "python-o-n-with-mathematical-explanation-and-comparison-xor",
                "content": "# Simple Math Explanation \\n\\nThis problem involves mathematics application to solve the problem. We are given a list of numbers which has single occurence of a number and the rest numbers occur twice.\\n\\nThe XOR (^) comes into picture to solve the problem.\\nThe XOR truth table:\\nA | B | A ^ B\\n ---| --- | ---\\n1 | 1 | 0\\n0 | 1 | 1\\n1 | 0 | 1\\n0 | 0 | 0\\n\\nTherefore, if an element(A) occurs twice, then A ^ A = 0\\nAlso, since, 0 ^ B = B, we reach the final stage where we get the odd one out.\\nWe also have to take in consideration on more math law([Rule of Association](https://www.javatpoint.com/laws-and-rules-of-boolean-algebra-in-digital-electronics)):\\n> (A ^ B) ^ C = A ^ (B ^ C)\\n\\n</br>\\nConsider the below number list:\\n> [1,2,1]\\nWe begin the operations from the left side (according to precedence of operations) <br>\\n\\n> (1 ^ 2) ^ 1\\n= 2 ^ (1 ^ 1)\\n=  2 ^ (False)\\n=  2\\n\\nThere, we have the single occuring element, 2.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\nI have implemented the approach using loops and lambda for both beginner and advanced implementations.\\n\\n``` Python_Simple_Approach []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res = nums[0]\\n        for val in nums[1:]:\\n            res ^= val\\n        return res\\n```\\n```Python_Using_Reduce_and_Lambda []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```\\nExecution time and memory for simple approach\\n![Image of Execution time and memory for simple approach](https://assets.leetcode.com/users/images/45ca0279-267d-493a-9213-cbed24396c0a_1679894667.6784487.png)\\n\\n<hr></hr>\\nExecution time and memory for simple approach\\n\\n![Image of Execution time and memory for simple approach](https://assets.leetcode.com/users/images/448edc17-d2bf-4991-b2bf-b4e74d495b8c_1679894709.117987.png)\\n\\n### Please upvote if you find it helpful",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "``` Python_Simple_Approach []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res = nums[0]\\n        for val in nums[1:]:\\n            res ^= val\\n        return res\\n```\n```Python_Using_Reduce_and_Lambda []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464164,
                "title": "c-python-o-1-space",
                "content": "\\n# Using bitwise XOR\\na ^ 0 = a\\na ^ a = 0 , so every duplicate will become 0 and only the single no. will remain\\n\\neg : [ -1, 2, 3, -2, -1] now if we add all elements of this array then only 3 will remain , that\\'s how XOR also works ,order doesn\\'t matter, like 2 ^ 3 ^ 2 ^ 1 ^ 3 = 3 ^ 2 ^ 2 ^ 3 ^ 1 =  and so on ..\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int once = 0;\\n        for(auto i : nums) {\\n            once ^= i;\\n        }\\n        return once;\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        once = 0\\n        for i in nums:\\n            once ^= i\\n        return once\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int once = 0;\\n        for(auto i : nums) {\\n            once ^= i;\\n        }\\n        return once;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        once = 0\\n        for i in nums:\\n            once ^= i\\n        return once\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166006,
                "title": "best-c-solutions-bit-manipulation-xor-sorting-hash-table-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using multiple approaches.\\n\\n1. Using Sorting.\\n2. Using Hash Table.\\n3. Using Bit Manipulation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(NlogN). Since we are using sorting.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i+=2){\\n            if(nums[i-1] != nums[i]){\\n                return nums[i-1];\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of nums. Here loop creates the times complexity.\\n    Space Complexity : O(N), Unordered map space.\\n\\n    Using Array + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto it : nums){\\n            map[it]++;\\n        }\\n        for(auto it : map){\\n            if(it.second == 1){\\n                return it.first;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of Array(nums). Here loop creates the times complexity.\\n\\n    Space complexity: O(1), Constant Space.\\n\\n    Solved using Array + Bit Manipulation(Xor).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int res = 0;\\n        for(auto it : nums){\\n            res ^= it;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(NlogN). Since we are using sorting.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i+=2){\\n            if(nums[i-1] != nums[i]){\\n                return nums[i-1];\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of nums. Here loop creates the times complexity.\\n    Space Complexity : O(N), Unordered map space.\\n\\n    Using Array + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto it : nums){\\n            map[it]++;\\n        }\\n        for(auto it : map){\\n            if(it.second == 1){\\n                return it.first;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of Array(nums). Here loop creates the times complexity.\\n\\n    Space complexity: O(1), Constant Space.\\n\\n    Solved using Array + Bit Manipulation(Xor).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int res = 0;\\n        for(auto it : nums){\\n            res ^= it;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080343,
                "title": "3-easy-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        bool flag;\\n        int i, j;\\n        int ans = 0;\\n        for (i = 0; i < nums.size(); i++) {\\n            flag = false;\\n            for (j = 0; j < nums.size(); j++) {\\n                if (nums[i] == nums[j] && i != j) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag == false) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```\\n# Approach 2\\nHashmap\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map <int, int> mp;\\n        int ans;\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]]++;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (mp[nums[i]] == 1) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;      \\n    }\\n};\\n```\\n\\n# Approach 3\\nBit Magic\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        bool flag;\\n        int i, j;\\n        int ans = 0;\\n        for (i = 0; i < nums.size(); i++) {\\n            flag = false;\\n            for (j = 0; j < nums.size(); j++) {\\n                if (nums[i] == nums[j] && i != j) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag == false) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map <int, int> mp;\\n        int ans;\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]]++;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (mp[nums[i]] == 1) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;      \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567884,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1720470,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1572607,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565663,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1569469,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1938174,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1573009,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1566345,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565420,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565834,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1567884,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1720470,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1572607,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565663,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1569469,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1938174,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1573009,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1566345,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565420,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565834,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1568956,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1568606,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1825606,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1767548,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1574573,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1572235,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1572058,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1571294,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1574851,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1571293,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1571295,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 1575362,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 1571928,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2074267,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2072776,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2069067,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2065678,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2064320,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2055747,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2046328,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2017201,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2015335,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2010807,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2010338,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2005921,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2005890,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1998202,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1996606,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1992220,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1988819,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1943007,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1941832,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1940387,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1937163,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1927862,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1927126,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1920226,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1907192,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1907190,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1878150,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1840988,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1826599,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1824907,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1805259,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1805248,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1803246,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1803217,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1794956,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1786805,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1785569,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1783051,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1781246,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1774418,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1768168,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1767664,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1764748,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1760643,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1758411,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1757341,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1756357,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1754996,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1746239,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1739414,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1736284,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1736277,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1728891,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1727538,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1726490,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1726224,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1724071,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1723961,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1715611,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1711607,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1710369,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1708943,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1706927,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1684179,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1680317,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1671026,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1670516,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            }
        ]
    }
]