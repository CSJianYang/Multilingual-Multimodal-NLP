[
    {
        "title": "Sum of Root To Leaf Binary Numbers",
        "question_content": "You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.\n\tFor example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.\nFor all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.\nThe test cases are generated so that the answer fits in a 32-bits integer.\n&nbsp;\nExample 1:\nInput: root = [1,0,1,0,1,0,1]\nOutput: 22\nExplanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\nExample 2:\nInput: root = [0]\nOutput: 0\n&nbsp;\nConstraints:\n\tThe number of nodes in the tree is in the range [1, 1000].\n\tNode.val is 0 or 1.",
        "solutions": [
            {
                "id": 270025,
                "title": "java-c-python-recursive-solution",
                "content": "## **Intuition**\\nEasily decompose this problem into 2 sub-problem:\\n1. Find all path from root to leaves. DFS recursion should help do that.\\n2. Transform a path from base to base 10.\\n\\nYou can do this separately, and it will be a `O(N^2)` solution.\\nIn my solution, I combine them together.\\n\\n\\n## **Explanation**:\\nWe recursively pass the current value of path to the children.\\nIf `root == null`, no value, return 0.\\nIf `root != null`,\\nwe double the value from its parent and add the node\\'s value,\\nlike the process of transforming base 2 to base 10.\\n\\nIn the end of recursion,\\nif `root.left == root.right == null`,\\nreturn the current `val`.\\n<br>\\n\\n## **Complexity**:\\nTime `O(N)`\\nSpace `O(H)` for recursion.\\n<br>\\n\\n**Java:**\\n```\\n    public int sumRootToLeaf(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    public int dfs(TreeNode root, int val) {\\n        if (root == null) return 0;\\n        val = val * 2 + root.val;\\n        return root.left == root.right ? val : dfs(root.left, val) + dfs(root.right, val);\\n    }\\n```\\n\\n**C++:**\\n```\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n    }\\n```\\n\\n**Python:**\\n```\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0\\n        val = val * 2 + root.val\\n        if root.left == root.right: return val\\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val)\\n```\\n\\n**Update 2019-04-08**\\nIn the previous version of problem,\\nthe length of path may exceed 32 and it will be a huge integer.\\nSo it request to return the number mod by 10^9+7.\\nNow it notes that The \"answer will not exceed 2^31 - 1.\"\\nNow it removes this condition to keep this problem as a easy one.",
                "solutionTags": [],
                "code": "```\\n    public int sumRootToLeaf(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    public int dfs(TreeNode root, int val) {\\n        if (root == null) return 0;\\n        val = val * 2 + root.val;\\n        return root.left == root.right ? val : dfs(root.left, val) + dfs(root.right, val);\\n    }\\n```\n```\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n    }\\n```\n```\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0\\n        val = val * 2 + root.val\\n        if root.left == root.right: return val\\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1681682,
                "title": "well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it",
                "content": "Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\n\\n\\n\\n**So Ladies n Gentlemen without any further due let\\'s start,**\\nSo, here in this problem what we have to do all the nodes will have either **0** or **1**. So, starting from **root node** and traverse the tree, when you traverse the tree and you reach **leaf node** return the **sum** in binary from root to leaf in & return in **decimal numbers**\\n\\n**Approach Explained :**\\n\\n**Summary :**\\nLet us traverse our tree and change values of nodes, so when we reach leaf we will have in this leaf exactly the number we need to add to total sum. Imagine, we have path 10110, then let us look at sequence: 1, 10, 101, 1011, 10110, which is equivalent to 1, 2, 5, 11, 22.\\n\\n* If we reached leaf, add value of this leaf to total sum.\\n* Check left and right children and if they exist, update their values; run dfs for these children.\\n\\n**Detailed Explanation :**\\nLet\\'s understand with an example tree,\\n\\n![image](https://assets.leetcode.com/users/images/29584bd5-5449-4147-92d3-18ec1067f27a_1641864447.0021555.png)\\n\\n\\nIf we go from **1 to 0** i.e **left child** & similar for **1 to 1** i.e. **right child** and similar till leaf node. Overall there are 4 leafs path. So, we will have **4 root to leaf path**. So, one is **1 -> 0 -> 0** this left most path, second is **1 -> 0 -> 1** this is 2nd path, then **1 -> 1 -> 0** this is 3rd path & the last **1 -> 1 -> 1** 4th path. \\nSo, these all are the root to leaf path we have and these are **binary representation**. So, if we **convert** them to **decimal** they will become **4, 5, 6, 7**. And **sum** them up which is **22**. and we have to **return 22** as the answer.\\n\\nSo,  first of all when we are converting **binary** no **to** the **decimal**, what we will do we will start from the least significant bit & multiply it with **2^0** with **whatever** **no**. present there, then **2^1 with whatever no**. there & then **2^2** **with whatever no** and **add** them. So, this is how it become **1 * 4 + 2 * 0 + 1 * 0** which is equals to **4** and similar for other as well. So, this is the basic idea what we  have & we use this idea over here.\\n`Let me show you in a diagram, what i mean`\\n![image](https://assets.leetcode.com/users/images/29517c99-2b04-4ebc-b707-89a37c56e335_1641865327.2959735.png)\\n\\n\\nOne of the **brute force idea to solve this** is like, 1st generate all the binary representation root to leaf path. Either store it as a list of list of integer or list of string & then convert after finding all the root to leaf path & convert each path to the decimal and then accumulate the sum and return. So, this is like a brute force solution.\\n\\nBut, we will make use of **recursion** to solve this problem.\\nAnd for traversing on each nodes we will use help of **PreOrder traversal**. Which states **\"n l r\"** i.e. **node - left - right**\\n\\nI hope all point\\'s are clear,\\n**Now let\\'s code it:**\\n\\n*code each n every line explain :* `Similar for C++. Java. Python` **{Only Syntax Difference}** approach same\\n\\nStep 1 :\\n```\\n{// call to a preorder traversal function & passing the value root node & sum variable intialize with 0;\\n        return sumRootToLeaf(root, 0); \\n```\\nStep 2 :\\n```\\nint sumRootToLeaf(TreeNode root, int sum){ // calling the helper method\\n        // base condition\\n        if(root == null) return 0; // first we will check if root is null, then there is no node, simply return 0;\\n        sum = (2 * sum) + root.val; // calculate sum of binary no.s into decimal no.s\\n        // checking if, current node we are processing is leaf & both left & right child node are null, if that\\'s the case return sum;\\n        if(root.left == null && root.right == null) return sum;\\n        // and finally we will call both left subtree & right subtree and add them up\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n```\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    public int sumRootToLeaf(TreeNode root, int sum){\\n        if(root == null) return 0;\\n        sum = (2 * sum) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\n    int sumRootToLeaf(TreeNode* root, int sum){\\n        if(!root) return 0;\\n        sum = (2 * sum) + root->val;\\n        if(!root->left && !root->right) return sum;\\n        return sumRootToLeaf(root->left, sum) + sumRootToLeaf(root->right, sum);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    \\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def sumRootToLeaf(root, res): # here; \"res\" is \"sum\"\\n            if root == None: return 0\\n            res = (2 * res) + root.val\\n            if root.left == None and root.right == None: return res\\n            return sumRootToLeaf(root.left, res) + sumRootToLeaf(root.right, res)\\n        \\n        return sumRootToLeaf(root, 0)\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N) where N is a number of nodes, since one has to visit each node.\\n\\n* **Space Complexity :-** BigO(H) where H is height of tree, Considering recursion stack it in O(H), if we dont consider it. Then O(1)\\n\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n{// call to a preorder traversal function & passing the value root node & sum variable intialize with 0;\\n        return sumRootToLeaf(root, 0); \\n```\n```\\nint sumRootToLeaf(TreeNode root, int sum){ // calling the helper method\\n        // base condition\\n        if(root == null) return 0; // first we will check if root is null, then there is no node, simply return 0;\\n        sum = (2 * sum) + root.val; // calculate sum of binary no.s into decimal no.s\\n        // checking if, current node we are processing is leaf & both left & right child node are null, if that\\'s the case return sum;\\n        if(root.left == null && root.right == null) return sum;\\n        // and finally we will call both left subtree & right subtree and add them up\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n```\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    public int sumRootToLeaf(TreeNode root, int sum){\\n        if(root == null) return 0;\\n        sum = (2 * sum) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int sumRootToLeaf(TreeNode* root, int sum){\\n        if(!root) return 0;\\n        sum = (2 * sum) + root->val;\\n        if(!root->left && !root->right) return sum;\\n        return sumRootToLeaf(root->left, sum) + sumRootToLeaf(root->right, sum);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    \\n};\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def sumRootToLeaf(root, res): # here; \"res\" is \"sum\"\\n            if root == None: return 0\\n            res = (2 * res) + root.val\\n            if root.left == None and root.right == None: return res\\n            return sumRootToLeaf(root.left, res) + sumRootToLeaf(root.right, res)\\n        \\n        return sumRootToLeaf(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270600,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        dfs(root, 0);\\n        return ans;\\n    }\\n    \\n    int ans = 0;\\n    void dfs(TreeNode root, int val){\\n        if(root == null) return;\\n        val = val << 1 | root.val;\\n        if(root.left == null && root.right == null) ans += val;\\n        dfs(root.left, val);\\n        dfs(root.right, val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        dfs(root, 0);\\n        return ans;\\n    }\\n    \\n    int ans = 0;\\n    void dfs(TreeNode root, int val){\\n        if(root == null) return;\\n        val = val << 1 | root.val;\\n        if(root.left == null && root.right == null) ans += val;\\n        dfs(root.left, val);\\n        dfs(root.right, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835906,
                "title": "c-2-solutions-recursive-iterative-dfs-explained-left-shift-and-simple-math",
                "content": "**Explanation**\\nThe key here is tree traversal and generating the numbers as we go from the root towards the leaves.\\nUsing shift operators, we can always keep the current value, `cur_val` in base 10 and as soon as we reach any leaf, we add this current value to the running answer.\\n\\n`cur_val = (cur_val << 1) | rt->val;`\\n`cur_val << 1` means we\\'re shifting the bits of `cur_val` to the left by 1 place, which is equivalent to multiplying `cur_val` by 2 (in base 10). Bitwise OR is used to set a particular bit. Let\\'s take an example!\\nSuppose, the root-to-leaf path is `1->0->1`.\\nThen, at the root, initially `cur_val` is 0. We multiply it by 2 and perform bitwise OR with 1 which makes `cur_val` 1.\\nNext, `cur_val` is 1. We multiply it by 2 and perform bitwise OR with 0 which makes `cur_val` 2.\\nLast, at the leaf, `cur_val` is 2. We multiply it by 2 and perform bitwise OR with 1 which makes `cur_val` 5.\\n101 (base 2) is 5 (base 10).\\n\\n----------------------------------------------\\n\\n**Recursive Code (using Left Shift operator)**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeafHelper(TreeNode* rt, int cur_val) {\\n        if(! rt) return 0;\\n        \\n        cur_val = (cur_val << 1) | rt->val;\\n        \\n        if(!rt->left && !rt->right)\\n\\t\\t\\treturn cur_val;\\n\\t\\t\\t\\n        return sumRootToLeafHelper(rt->left, cur_val) + sumRootToLeafHelper(rt->right, cur_val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* rt) {\\n        return sumRootToLeafHelper(rt, 0);\\n    }\\n};\\n```\\n\\n-------------\\n\\nWe can also combine these two functions in the same given function using a default argument to get an even more compact solution (Credits to [@guybrush2323](https://leetcode.com/guybrush2323/ )):\\n\\n```\\nstatic int sumRootToLeaf(const TreeNode* r, uint32_t sum = 0) {\\n        if (!r) return 0;\\n        sum |= r->val;\\n        if (!r->left && !r->right) return sum; // leaf\\n        sum <<= 1;\\n        return sumRootToLeaf(r->left, sum) + sumRootToLeaf(r->right, sum);\\n}\\n```\\n\\n------------------------------------------------------\\n\\n**Iterative Code (using Simple Math)**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* rt) {\\n        if(! rt) return 0;\\n        \\n        int ans = 0;\\n        stack<pair<TreeNode*,int>> st;\\n        st.push({rt,0});\\n        \\n        while(! st.empty()) {\\n            auto curp = st.top(); st.pop();\\n            TreeNode* cur = curp.first;\\n            int cur_val = curp.second;\\n            \\n            // Equivalent to left shift by 1 and then ORing by cur->val.\\n            cur_val = cur_val*2 + cur->val;\\n            \\n            if(!cur->left && !cur->right)\\n                ans += cur_val;\\n            \\n            if(cur->left) st.push({cur->left, cur_val});\\n            if(cur->right) st.push({cur->right, cur_val});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n----------------------------------------\\nPlease feel free to ask your doubts in the comments. Please **Upvote** to help others!\\nHave a great day!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeafHelper(TreeNode* rt, int cur_val) {\\n        if(! rt) return 0;\\n        \\n        cur_val = (cur_val << 1) | rt->val;\\n        \\n        if(!rt->left && !rt->right)\\n\\t\\t\\treturn cur_val;\\n\\t\\t\\t\\n        return sumRootToLeafHelper(rt->left, cur_val) + sumRootToLeafHelper(rt->right, cur_val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* rt) {\\n        return sumRootToLeafHelper(rt, 0);\\n    }\\n};\\n```\n```\\nstatic int sumRootToLeaf(const TreeNode* r, uint32_t sum = 0) {\\n        if (!r) return 0;\\n        sum |= r->val;\\n        if (!r->left && !r->right) return sum; // leaf\\n        sum <<= 1;\\n        return sumRootToLeaf(r->left, sum) + sumRootToLeaf(r->right, sum);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* rt) {\\n        if(! rt) return 0;\\n        \\n        int ans = 0;\\n        stack<pair<TreeNode*,int>> st;\\n        st.push({rt,0});\\n        \\n        while(! st.empty()) {\\n            auto curp = st.top(); st.pop();\\n            TreeNode* cur = curp.first;\\n            int cur_val = curp.second;\\n            \\n            // Equivalent to left shift by 1 and then ORing by cur->val.\\n            cur_val = cur_val*2 + cur->val;\\n            \\n            if(!cur->left && !cur->right)\\n                ans += cur_val;\\n            \\n            if(cur->left) st.push({cur->left, cur_val});\\n            if(cur->right) st.push({cur->right, cur_val});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681811,
                "title": "c-simple-intuitive-dfs-solution-w-explanation",
                "content": "* We are given a binary tree with all node values as ```0```s and ```1```s.\\n* For all leaves in the tree, we need to sum the numbers represented by the path from the root to that leaf and return the sum of these numbers.\\n\\n**Explanation :**\\nIf we\\'re given a binary number, say ```num = 11010```, we know how to convert it into decimal form while traversing from right to left.\\nWe can do this while traversing from left to right also. \\nWe start with  x=0, as long as we have bits left, repeat the following : \\n      1. Double the number  x . Remove the first bit (most significant) and add it to x . \\n      2. When this ends, return  x .\\nExample : \\n```\\nn = \\'100110\\',    x = 0\\nn =  \\'00110\\',    x = 0*2 + 1 = 1\\nn =   \\'0110\\',    x = 1*2 + 0 = 2\\nn =    \\'110\\',    x = 2*2 + 0 = 4\\nn =     \\'10\\',    x = 4*2 + 1 = 9\\nn =      \\'0\\',    x = 9*2 + 1 = 19\\nn =      \\' \\',    x = 19*2 +0 = 38\\n```\\n\\nKnowing this, this problem can be solved using simple DFS.\\n\\n**ALGORITHM :**\\n* Initialize ```ans = 0``` and ```buff=0```.\\n* The integer ```buff``` is passed as an argument to the function ```bfs(root, buff)``` and whenever we reach a leaf node, the decimal number stored by buffer is added to ```ans``` and we traverse for the next node (ie., parent\\'s right node).\\n* After we\\'ve traversed the whole tree, we return the ```ans```.\\n\\nTime Complexity : O(N) (Each node is visited at most 3 times, one while calling the method on the root and 2 visits when returning from the root\\u2019s left and right recursion calls. So overall time complexity will be linear only.)\\n\\nSpace Complexity : O(1) (Exclusing the recursive stack space)\\n\\n**Code :**\\n```\\nclass Solution {\\n    int ans=0;\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int buff = 0;\\n        dfs(root, buff);\\n        return ans;    \\n    }\\n    \\n    void dfs(TreeNode *root, int buff){\\n        buff = buff*2 + root->val;\\n        if(!root->left && !root->right){\\n            ans += buff;\\n            return;\\n        }\\n        if(root->left) dfs(root->left, buff);\\n        if(root->right) dfs(root->right, buff);\\n    }\\n};\\n```\\n\\n**If you like my solution & explanation, please upvote my post :)**\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```0```\n```1```\n```num = 11010```\n```\\nn = \\'100110\\',    x = 0\\nn =  \\'00110\\',    x = 0*2 + 1 = 1\\nn =   \\'0110\\',    x = 1*2 + 0 = 2\\nn =    \\'110\\',    x = 2*2 + 0 = 4\\nn =     \\'10\\',    x = 4*2 + 1 = 9\\nn =      \\'0\\',    x = 9*2 + 1 = 19\\nn =      \\' \\',    x = 19*2 +0 = 38\\n```\n```ans = 0```\n```buff=0```\n```buff```\n```bfs(root, buff)```\n```ans```\n```ans```\n```\\nclass Solution {\\n    int ans=0;\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int buff = 0;\\n        dfs(root, buff);\\n        return ans;    \\n    }\\n    \\n    void dfs(TreeNode *root, int buff){\\n        buff = buff*2 + root->val;\\n        if(!root->left && !root->right){\\n            ans += buff;\\n            return;\\n        }\\n        if(root->left) dfs(root->left, buff);\\n        if(root->right) dfs(root->right, buff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339306,
                "title": "python-iterative-and-recursive-with-comments",
                "content": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Logic 1: Recursive traverse - 100 pass 63% faster\\n        \\n        # Collect all the path in binary in a list\\n        self.path_to_leaf = []\\n        # Track total binary sum and return result\\n        self.total_binary_sum = 0\\n        \\n        # Traverse tree function\\n        def traverse(node, path):\\n            # If not leaf node, record the path left or right\\n            if node.left:\\n                traverse(node.left, path+str(node.val))\\n            if node.right:\\n                traverse(node.right, path+str(node.val))\\n            \\n            # Leaf node detect and record path\\n            if not node.left and not node.right:\\n                path += str(node.val)\\n                self.path_to_leaf.append(path)\\n                self.total_binary_sum += int(path, 2)\\n        \\n        traverse(root, \"\")\\n        print(self.path_to_leaf)\\n        return self.total_binary_sum\\n```\\n\\n```python\\n        # Logic 2: Iterative method - 100 pass 83 percent faster\\n        # * Each element of the list has the node and the path to it\\n        \\n        stack = [[root, \"\"]] # iteration to keep track\\n        result = 0 # result holder\\n        \\n        # Traverse nodes by stacking them\\n        while stack:\\n            # current node and path tracking\\n            current, path = stack.pop(0)\\n            \\n            # traverse with path \\n            if current.left:\\n                stack.append([current.left, path+str(current.val)])\\n            if current.right:\\n                stack.append([current.right, path+str(current.val)])\\n            \\n            # leaf node condition when we update result\\n            if not current.left and not current.right:\\n                path += str(current.val)\\n                result += int(path, 2)\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Logic 1: Recursive traverse - 100 pass 63% faster\\n        \\n        # Collect all the path in binary in a list\\n        self.path_to_leaf = []\\n        # Track total binary sum and return result\\n        self.total_binary_sum = 0\\n        \\n        # Traverse tree function\\n        def traverse(node, path):\\n            # If not leaf node, record the path left or right\\n            if node.left:\\n                traverse(node.left, path+str(node.val))\\n            if node.right:\\n                traverse(node.right, path+str(node.val))\\n            \\n            # Leaf node detect and record path\\n            if not node.left and not node.right:\\n                path += str(node.val)\\n                self.path_to_leaf.append(path)\\n                self.total_binary_sum += int(path, 2)\\n        \\n        traverse(root, \"\")\\n        print(self.path_to_leaf)\\n        return self.total_binary_sum\\n```\n```python\\n        # Logic 2: Iterative method - 100 pass 83 percent faster\\n        # * Each element of the list has the node and the path to it\\n        \\n        stack = [[root, \"\"]] # iteration to keep track\\n        result = 0 # result holder\\n        \\n        # Traverse nodes by stacking them\\n        while stack:\\n            # current node and path tracking\\n            current, path = stack.pop(0)\\n            \\n            # traverse with path \\n            if current.left:\\n                stack.append([current.left, path+str(current.val)])\\n            if current.right:\\n                stack.append([current.right, path+str(current.val)])\\n            \\n            # leaf node condition when we update result\\n            if not current.left and not current.right:\\n                path += str(current.val)\\n                result += int(path, 2)\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628160,
                "title": "c-solution-with-detailed-explanation",
                "content": "```\\nFirst for this question u should be able to print all paths from root to leaf\\nCuz only after this do we convert it to decimal and proceed\\nI would suggest u guys to solve this first and then jump into gfg and try print root to leaf paths\\n\\nSo instead of printing the solution we call a funcion called convert to decimal.\\nNote that when u have been pushing elements into ur array the one with 0 index is ur most significant bit.\\n\\nSo to covert it all we have to do is n=n*2+v[i] where i is from 0 to v.size()-1\\n\\nCode:-\\n\\n    int ans=0;\\n    int convert_decimal(vector<int> v)\\n    {\\n        int n=0;\\n        for(int i=0;i<v.size();i++)\\n            n=n*2+v[i];\\n        return n;\\n    }\\n    void findpath(TreeNode* root,vector<int> t)\\n    {\\n        if(!root)return;\\n        t.push_back(root->val);\\n        if(!root->left && !root->right)ans+=convert_decimal(t);\\n        findpath(root->left,t);\\n        findpath(root->right,t);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)return 0;\\n        vector<int> t;\\n        findpath(root,t);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nFirst for this question u should be able to print all paths from root to leaf\\nCuz only after this do we convert it to decimal and proceed\\nI would suggest u guys to solve this first and then jump into gfg and try print root to leaf paths\\n\\nSo instead of printing the solution we call a funcion called convert to decimal.\\nNote that when u have been pushing elements into ur array the one with 0 index is ur most significant bit.\\n\\nSo to covert it all we have to do is n=n*2+v[i] where i is from 0 to v.size()-1\\n\\nCode:-\\n\\n    int ans=0;\\n    int convert_decimal(vector<int> v)\\n    {\\n        int n=0;\\n        for(int i=0;i<v.size();i++)\\n            n=n*2+v[i];\\n        return n;\\n    }\\n    void findpath(TreeNode* root,vector<int> t)\\n    {\\n        if(!root)return;\\n        t.push_back(root->val);\\n        if(!root->left && !root->right)ans+=convert_decimal(t);\\n        findpath(root->left,t);\\n        findpath(root->right,t);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)return 0;\\n        vector<int> t;\\n        findpath(root,t);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681647,
                "title": "python3-5-lines-explained",
                "content": "We use the recursive Depth First Search here to build all binary numbers from the root-to-leaf path and sum them together. When a leaf node is reached, the function returns the built number. For the rest of the nodes, the function simply sums results from recursive calls. For building the binary number in the path we use a binary operation `(path << 1)` which shifts all bits to the left by one bit to free space for the current bit which we simply add to the path. Example:\\n\\n`path=0  => (path<<1) + 1 = 01`\\n`path=01 => (path<<1) + 1 = 11`\\n`path=11 => (path<<1) + 0 = 110`\\n`path=110 => (path<<1) + 1 = 1101`\\n\\nTime: **O(N)** - for DFS\\nSpace: **O(N)** - recursive stack for binary tree is equal to the tree height\\n\\nRuntime: 36 ms, faster than **80.51%** of Python3 online submissions for Sum of Root To Leaf Binary Numbers.\\nMemory Usage: 14.4 MB, less than **96.20%** of Python3 online submissions for Sum of Root To Leaf Binary Numbers.\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, path):\\n            if not node: return 0\\n\\n            path = (path << 1) + node.val\\n\\t\\t\\t\\n            if not node.left and not node.right:\\n                return path\\n            \\n            return dfs(node.left, path) + dfs(node.right, path)\\n            \\n        return dfs(root, 0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, path):\\n            if not node: return 0\\n\\n            path = (path << 1) + node.val\\n\\t\\t\\t\\n            if not node.left and not node.right:\\n                return path\\n            \\n            return dfs(node.left, path) + dfs(node.right, path)\\n            \\n        return dfs(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835958,
                "title": "python-2-easy-recursion-solutions-explained",
                "content": "Let us traverse our tree and change values of nodes, so when we reach leaf we will have in this leaf exactly the number we need to add to total sum. Imagine, we have path `10110`, then let us look at sequence: `1, 10, 101, 1011, 10110`, which is equivalent to `1, 2, 5, 11, 22`. \\n\\n1. If we reached leaf, add value of this leaf to total sum.\\n2. Check left and right children and if they exist, update their values; run dfs for these children.\\n\\n**Complexity**: time complexity is `O(n)`: to traverse our tree. Space complexity is `O(h)` for dfs stack. Note, that we change our tree in process, but it can be easily avoided: instead of changing values we can return value for `dfs` function.\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node):\\n            if not node.left and not node.right: self.sum += node.val\\n            for child in filter(None, [node.left, node.right]):\\n                child.val += node.val * 2\\n                dfs(child)\\n          \\n        self.sum = 0\\n        dfs(root)\\n        return self.sum\\n```\\n\\n### Solution 2: without changing tree\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node, Q):\\n            if not node.left and not node.right: self.sum += Q\\n            for child in filter(None, [node.left, node.right]):\\n                dfs(child, Q*2 + child.val)\\n          \\n        self.sum = 0\\n        dfs(root, root.val)\\n        return self.sum\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node):\\n            if not node.left and not node.right: self.sum += node.val\\n            for child in filter(None, [node.left, node.right]):\\n                child.val += node.val * 2\\n                dfs(child)\\n          \\n        self.sum = 0\\n        dfs(root)\\n        return self.sum\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node, Q):\\n            if not node.left and not node.right: self.sum += Q\\n            for child in filter(None, [node.left, node.right]):\\n                dfs(child, Q*2 + child.val)\\n          \\n        self.sum = 0\\n        dfs(root, root.val)\\n        return self.sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387149,
                "title": "java-100-beats-time-and-space-detailed-explanation",
                "content": "The key insight (or the AHA moment!) to this problem lies in the fact that the path shares nodes and so computation required to calculate the sum can be shared. By avoiding repeated computation, we can significantly bring down the runtime *O(n)* and space time *O(h)* complexity of this solution, where n is the number of total nodes in the tree and h is the height of the tree.\\n\\nThe computation we are optimizing is the conversion of base-2 number to base-10 number. The way you would usually convert a base-2 to base-10 number is with the formula below:\\n\\n` \\n2^n * nth bit + 2^n-1 * n-1th bit + ... + 2^0 * 0th bit\\n`\\n\\nSo in a brute force solution, we would calculate the path from root to leaf and then apply the formula above. Then we would sum up all the results to reach the final sum. BUT WE ARE SMARTER THAN THAT, SO WE CAN DO BETTER!\\n\\nIf you observe the formula above, we are multiplying the Most Significant Bit, i.e. n, n times by 2 and the Least Significant Bit 0 times by 2. If we are to share this computation as we iterate through the tree paths from Most Significant Bit to the Least Significant Bit, we can multiply each bit by 2 on every call of this function. This means that when we have reached a leaf, which will contain the 0th bit, we would\\'ve have multiplied each preceding bit (n,n-1,n-2)th times by 2, respectively. The result will be equivalent to the formula we have described above. \\n\\n**VOILA**! We have optimized the solution!\\n\\nThe code below uses `parentNodeSum` to keep track of the sum calculated until the `nth node` and then multiplies that sum by 2. Then it adds the value of the current node (i.e. `n-1th node` ) to the product of that.\\n\\nIn conclusion:\\n\\n` \\n2^n * nth bit + 2^n-1 * n-1th bit + ... + 2^0 * 0th bit\\n`\\n\\nWill be equivalent to \\n\\n`[2 * (parentSumNode) + Current Bit] //executed every time the function iterates from root to leaf.`\\n\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return pathSumRootToLeaf(root, 0);\\n    }\\n    \\n    private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        \\n        return pathSumRootToLeaf(root.left, parentNodeSum) + pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return pathSumRootToLeaf(root, 0);\\n    }\\n    \\n    private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        \\n        return pathSumRootToLeaf(root.left, parentNodeSum) + pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420459,
                "title": "java-simple-dfs-solution",
                "content": "```\\nint sum = 0;\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tdfs(root,\"\");\\n\\treturn sum;\\n}\\n\\npublic void dfs(TreeNode root, String curr) {\\n\\tif(root==null) return;\\n\\tif(root.right==null && root.left==null)\\n\\t\\tsum += Integer.parseInt(curr+root.val,2);\\n\\tdfs(root.right, curr+root.val);\\n\\tdfs(root.left, curr+root.val);    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint sum = 0;\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tdfs(root,\"\");\\n\\treturn sum;\\n}\\n\\npublic void dfs(TreeNode root, String curr) {\\n\\tif(root==null) return;\\n\\tif(root.right==null && root.left==null)\\n\\t\\tsum += Integer.parseInt(curr+root.val,2);\\n\\tdfs(root.right, curr+root.val);\\n\\tdfs(root.left, curr+root.val);    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681710,
                "title": "c-java-python-1-line-2-solutions-image-explanation-top-down-and-bottom-up",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* Key Point\\n\\t* `pre` is the sum of prefix of path from root to current node **NOT Inclusive**\\n* Top-Down\\n\\t* DFS Traverse the tree from root to every leaf, once we arrived at a leaf, add the sum of path from root to leaf to the final answer\\n* Bottom-Up\\n\\t* After arriving at a leaf, return the sum of path bottom-up to the root.\\n\\n![image](https://assets.leetcode.com/users/images/2686b5d7-bc15-42c6-96ac-55d95119c67e_1641884337.480884.png)\\n\\n\\n\\n**Top-Down**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void search(TreeNode* node, int pre=0) {    \\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // this->ans += pre << 1 | node->val; // also work\\n            this->ans += pre * 2 + node->val;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // search(node->left, pre << 1 | node->val); // also work\\n            search(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // search(node->right, pre << 1 | node->val); // also work\\n            search(node->right, pre * 2 + node->val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        search(root);\\n        return this->ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.ans = 0\\n\\n    def search(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, add the path sum to final answer\\n            # self.ans += pre << 1 | node.val  # also work\\n            self.ans += pre * 2 + node.val\\n            \\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # self.search(node.left, pre << 1 | node.val)  # also work\\n            self.search(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # self.search(node.right, pre << 1 | node.val)  # also work\\n            self.search(node.right, pre * 2 + node.val)\\n\\n    def sumRootToLeaf(self, root):\\n        self.search(root, 0)\\n        return self.ans\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int ans = 0;\\n    \\n    public void search(TreeNode node, int pre) {\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // this.ans += pre << 1 | node.val; // also work\\n            this.ans += pre * 2 + node.val; \\n            \\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // search(node.left, pre << 1 | node.val); // also work\\n            search(node.left, pre * 2 + node.val);\\n        \\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // search(node.right, pre << 1 | node.val); // also work\\n            search(node.right, pre * 2 + node.val);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        search(root, 0);\\n        return this.ans;\\n    }\\n}\\n```\\n**Bottom-Up**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* node, int pre=0) { // pre is sum of path from root to parent of node\\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node->val; // also work\\n\\t\\t\\treturn pre * 2 + node->val;\\n        int ans = 0;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->left, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->right, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->right, pre * 2 + node->val);\\n        return ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, return the sum of path from root to node\\n            # return pre << 1 | node.val  # also work\\n\\t\\t\\treturn pre * 2 + node.val\\n        ans = 0\\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.left, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.right, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.right, pre * 2 + node.val) \\n        return ans\\n```\\n\\n**Python One-liner**\\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # modified from the above one, don\\'t take it seriously\\n        return pre * 2 + node.val if node.left is None and node.right is None else (\\n                    self.sumRootToLeaf(node.left, pre * 2 + node.val) if node.left else 0\\n                                                                                   ) + (\\n                            self.sumRootToLeaf(node.right, pre * 2 + node.val) if node.right else 0\\n                                                                                       )\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode node, int pre) { // pre is sum of path from root to parent of node\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node.val; // also work\\n            return pre * 2 + node.val;\\n        int ans = 0;\\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.left, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.left, pre * 2 + node.val);\\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.right, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.right, pre * 2 + node.val);\\n        return ans;\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void search(TreeNode* node, int pre=0) {    \\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // this->ans += pre << 1 | node->val; // also work\\n            this->ans += pre * 2 + node->val;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // search(node->left, pre << 1 | node->val); // also work\\n            search(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // search(node->right, pre << 1 | node->val); // also work\\n            search(node->right, pre * 2 + node->val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        search(root);\\n        return this->ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.ans = 0\\n\\n    def search(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, add the path sum to final answer\\n            # self.ans += pre << 1 | node.val  # also work\\n            self.ans += pre * 2 + node.val\\n            \\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # self.search(node.left, pre << 1 | node.val)  # also work\\n            self.search(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # self.search(node.right, pre << 1 | node.val)  # also work\\n            self.search(node.right, pre * 2 + node.val)\\n\\n    def sumRootToLeaf(self, root):\\n        self.search(root, 0)\\n        return self.ans\\n```\n```\\nclass Solution {\\n    public int ans = 0;\\n    \\n    public void search(TreeNode node, int pre) {\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // this.ans += pre << 1 | node.val; // also work\\n            this.ans += pre * 2 + node.val; \\n            \\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // search(node.left, pre << 1 | node.val); // also work\\n            search(node.left, pre * 2 + node.val);\\n        \\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // search(node.right, pre << 1 | node.val); // also work\\n            search(node.right, pre * 2 + node.val);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        search(root, 0);\\n        return this.ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* node, int pre=0) { // pre is sum of path from root to parent of node\\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node->val; // also work\\n\\t\\t\\treturn pre * 2 + node->val;\\n        int ans = 0;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->left, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->right, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->right, pre * 2 + node->val);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, return the sum of path from root to node\\n            # return pre << 1 | node.val  # also work\\n\\t\\t\\treturn pre * 2 + node.val\\n        ans = 0\\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.left, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.right, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.right, pre * 2 + node.val) \\n        return ans\\n```\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # modified from the above one, don\\'t take it seriously\\n        return pre * 2 + node.val if node.left is None and node.right is None else (\\n                    self.sumRootToLeaf(node.left, pre * 2 + node.val) if node.left else 0\\n                                                                                   ) + (\\n                            self.sumRootToLeaf(node.right, pre * 2 + node.val) if node.right else 0\\n                                                                                       )\\n```\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode node, int pre) { // pre is sum of path from root to parent of node\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node.val; // also work\\n            return pre * 2 + node.val;\\n        int ans = 0;\\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.left, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.left, pre * 2 + node.val);\\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.right, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.right, pre * 2 + node.val);\\n        return ans;\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500851,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\n    const binaries = [];\\n    const traverse = (node, str) => {\\n        if (node === null) {\\n            return;\\n        }\\n        // compose the binary string for the next node\\n        const binary = `${str}${node.val}`;\\n        // when visiting a leaf, add binary string to the array\\n        if (node.left === null && node.right === null) {\\n            binaries.push(binary);\\n        }\\n        \\n        traverse(node.left, binary);\\n        traverse(node.right, binary);\\n    }\\n    \\n    traverse(root, \\'\\');\\n    \\n    return binaries.reduce((sum, binary) => {\\n        sum += parseInt(binary, 2);\\n        return sum;\\n    }, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\n    const binaries = [];\\n    const traverse = (node, str) => {\\n        if (node === null) {\\n            return;\\n        }\\n        // compose the binary string for the next node\\n        const binary = `${str}${node.val}`;\\n        // when visiting a leaf, add binary string to the array\\n        if (node.left === null && node.right === null) {\\n            binaries.push(binary);\\n        }\\n        \\n        traverse(node.left, binary);\\n        traverse(node.right, binary);\\n    }\\n    \\n    traverse(root, \\'\\');\\n    \\n    return binaries.reduce((sum, binary) => {\\n        sum += parseInt(binary, 2);\\n        return sum;\\n    }, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681770,
                "title": "c-python-easy-to-solve-with-different-approaches",
                "content": "Hello Everyone !! \\n**let\\'s get the question rolling ...**\\n***\\nSo we are given the root of a binary tree where every node has a value of `0 or 1`. We need to travel each path from root to leaf and convert it to decimal from binary and do summation of all paths .\\n\\n* Just a small detail given in the question **we all should remember :)**\\n> Each root-to-leaf path represents a binary number **starting with the most significant bit.**\\n***\\n**Intuition:-**\\n* So the majority of us got the intuition to find every path of binary tree by dfs and convert that path to decimal base from binary base but wait, is that a feasible way ?\\n* Nope, don\\'t thinks so. why ? Becuase, To make so many travels to find path and then take separate time to convert to Binary. Hence we are *compromsing both time and space* i.e `time complexity will be O(n^2) and space O(n) !!!!!`\\n**So lesss go and understand an optimal solution :)**\\n* So what if we traverse each node... convert..... and at the same time form its binary! While you are making a recursive call when traversing each node, You form the binary number by adding to previously found binary of that number and at the end which is when the node is a leaf node i.e both left and right are NULL then we know that our number has successfully formed and we add it to our ans. Booom!!! we got the optimization.\\n* **Let\\'s see how the space and time is reduced ^_^ :-** The recursion call is done for all nodes in `O(n)` both number formation and binary conversion are done in `O(1)`. and the space used will be `O(h)` for recursion ,where `h` is the height of the tree. \\n***\\n**Code:-**\\n*DFS call will be like :0*\\n```\\nif(root->left == root->right) \\n    val ;\\nelse\\n    sumRootToLeaf(root->left, val) + sumRootToleaf(root->right, val) ;\\n```\\n*Wan\\'t to do some fun?!! let\\'s do this using ternary operator ~0~*\\n```\\nreturn (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n```\\n\\n**C++ Final Code:-**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;//base condition\\n        //val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        val = (val * 2 + root->val); //using Normal math\\n        return (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));//dfs call\\n    }\\n};\\n```\\n**Python Final Code:-**\\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0  #base case\\n        val = val * 2 + root.val  #val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        if not root.left and not root.right: return val \\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val) #dfs call\\n```\\n**Time Complexity :** *`O(n)`*\\n**Space Complexity:** *`O(1)`*\\n***\\n***\\n**Not a pro in coding just doing it for the fun because I like it ;)) , If I can improve anywhere please comment below or if you have any doubt feel free to ask.**\\n***",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nif(root->left == root->right) \\n    val ;\\nelse\\n    sumRootToLeaf(root->left, val) + sumRootToleaf(root->right, val) ;\\n```\n```\\nreturn (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n```\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;//base condition\\n        //val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        val = (val * 2 + root->val); //using Normal math\\n        return (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));//dfs call\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0  #base case\\n        val = val * 2 + root.val  #val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        if not root.left and not root.right: return val \\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val) #dfs call\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340184,
                "title": "c-dfs-solution-super-op-to-understand-descriptive",
                "content": "\\uD83D\\uDC49 Most solutions have directly done using BITS, Which makes it more difficult to understand. So, I will explain simply using Maths both logic and code. \\n\\n\\u274C Someone can simply think to first find the path and make a string to form the number and then convert it to Binary, **But is it feasible ? No !** Becuase, To make so many travels to find path and then take separate time to convert to Binary. Compromsing both time and space !\\n\\n\\u2714 What if we traverse each node covert and at the same time form its binary! While you are making a recursive call when traversing each node, You form the binary number by adding to previously found binary of that number and at the end which is when the **node is a leaf node** i.e both left and right are NULL then we know that our number **has successfully formed and we add it to our ans**.\\n\\n\\u2716\\u2795 Refer to below diagram for reference. At each level you pass the binary formed. But how is it formed ?\\nSee, Imagine a path 1->0->0 , Its decimal equivalent is 4. So you just take that digit multiply it with 2 and add the previous known bit, Since we dont know thw prev. bit here we add 0 *(Passed in func call)*. Once, we get the digit we add to our next digit and keep it doing recursively and once its a leaf node, **We add it our number. \\nAnd the same in recursion call is done for all nodes in O(n) both number formation and binary conversion are done in O(1).**\\n\\n![image](https://assets.leetcode.com/users/images/d2b292f7-7e8b-48c0-9ad9-0a831301ea51_1626371835.6485362.png)\\n\\n**\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Now here is the code, For the sake of explanation I have made another function and done some extra work. You can just optimise a little more like combining statements, etc**\\n\\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void readTree(TreeNode* root, int val)\\n    {\\n        if(!root)\\n            return;\\n\\n        // val = val^2 + root->val;     // Normal Math\\n        val = val << 1 | root->val;     // Same thing in BITS\\n\\t\\t\\n\\t\\t// You can study this concept of bits from GFG ! Internal working of bitwise shift left and OR Operator.\\n        \\n        readTree(root->left, val);\\n        readTree(root->right, val);\\n        \\n        if(root->left == NULL && root->right == NULL)   //When leaf Node then add to Sum\\n            sum += val;\\n    }\\n\\n    int sumRootToLeaf(TreeNode* root) \\n    {\\n        readTree(root, 0);\\n        return sum;\\n    }\\n};\\n```\\n\\n\\u2728 I am not a pro just a begineer, If I can improve anywhere please comment below or if you have any doubt feel free to ask.\\n\\n[Github](http://github.com/winoffrg) \\u2022 Jai Shree Ram !",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void readTree(TreeNode* root, int val)\\n    {\\n        if(!root)\\n            return;\\n\\n        // val = val^2 + root->val;     // Normal Math\\n        val = val << 1 | root->val;     // Same thing in BITS\\n\\t\\t\\n\\t\\t// You can study this concept of bits from GFG ! Internal working of bitwise shift left and OR Operator.\\n        \\n        readTree(root->left, val);\\n        readTree(root->right, val);\\n        \\n        if(root->left == NULL && root->right == NULL)   //When leaf Node then add to Sum\\n            sum += val;\\n    }\\n\\n    int sumRootToLeaf(TreeNode* root) \\n    {\\n        readTree(root, 0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332712,
                "title": "java-easy-approach-with-explanation-recursive",
                "content": "```\\nclass Solution \\n{//Revise left and right shift operator from GFG (recommended)\\n    public int sumRootToLeaf(TreeNode root)\\n    {\\n        if(root == null)//base case for null graph \\n            return 0;\\n        \\n        return sum(root, 0);//sum is passed because it has a cyclic dependency  in Recursion for calculating the sum \\n    }\\n    public int sum(TreeNode root, int sum)\\n    {\\n        if(root == null)//base case 1//we we reach an null node we return 0, no shifting operation is done \\n            return 0;\\n        \\n        sum= (sum<<1) + root.val;//in binary addition 0 + 1= 1 && 0 + 0= 0, so only the last place will change by 0 or 1//doing left shift will append zero at the end \\n        \\n        if(root.left == null && root.right == null)//base case 2\\n            return sum;//when we got the desired result(Binary Number in integer) at the leaf node returning it to get the total sum and the traverse if any subtree is left \\n        return sum(root.left, sum) + sum(root.right, sum);//calculating the left and right sum recursively //bactracking helps a lot in leaf node sum \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{//Revise left and right shift operator from GFG (recommended)\\n    public int sumRootToLeaf(TreeNode root)\\n    {\\n        if(root == null)//base case for null graph \\n            return 0;\\n        \\n        return sum(root, 0);//sum is passed because it has a cyclic dependency  in Recursion for calculating the sum \\n    }\\n    public int sum(TreeNode root, int sum)\\n    {\\n        if(root == null)//base case 1//we we reach an null node we return 0, no shifting operation is done \\n            return 0;\\n        \\n        sum= (sum<<1) + root.val;//in binary addition 0 + 1= 1 && 0 + 0= 0, so only the last place will change by 0 or 1//doing left shift will append zero at the end \\n        \\n        if(root.left == null && root.right == null)//base case 2\\n            return sum;//when we got the desired result(Binary Number in integer) at the leaf node returning it to get the total sum and the traverse if any subtree is left \\n        return sum(root.left, sum) + sum(root.right, sum);//calculating the left and right sum recursively //bactracking helps a lot in leaf node sum \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552531,
                "title": "c-simple-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int sol=0;\\n    int sumRootToLeaf(TreeNode* root,int num=0) {\\n        if(!root)return 0;\\n        num *= 2;\\n        num+=root->val;\\n        if(!root->left&&!root->right)sol+=num;\\n        sumRootToLeaf(root->left,num);\\n        sumRootToLeaf(root->right,num);\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sol=0;\\n    int sumRootToLeaf(TreeNode* root,int num=0) {\\n        if(!root)return 0;\\n        num *= 2;\\n        num+=root->val;\\n        if(!root->left&&!root->right)sol+=num;\\n        sumRootToLeaf(root->left,num);\\n        sumRootToLeaf(root->right,num);\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836946,
                "title": "very-easy-dfs-python-solution",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        total=0\\n        \\n        stack=[(root,str(root.val))]\\n        \\n        while stack:\\n            node,binVal=stack.pop()\\n            \\n            if node.left:\\n                stack.append((node.left,binVal+str(node.left.val)))\\n                \\n            if node.right:\\n                stack.append((node.right,binVal+str(node.right.val)))\\n\\n            if not node.left and not node.right:\\n                total+=int(binVal,2)\\n        return total     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        total=0\\n        \\n        stack=[(root,str(root.val))]\\n        \\n        while stack:\\n            node,binVal=stack.pop()\\n            \\n            if node.left:\\n                stack.append((node.left,binVal+str(node.left.val)))\\n                \\n            if node.right:\\n                stack.append((node.right,binVal+str(node.right.val)))\\n\\n            if not node.left and not node.right:\\n                total+=int(binVal,2)\\n        return total     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 328033,
                "title": "simple-python-solution-top-down-dfs",
                "content": "Please see and vote for my solutions for these similar problems.\\n\\n[257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/discuss/309004/Different-DFS-Python-solutions)\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\\n\\n[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/328123/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/328033/Top-down-Python-DFS-Solution)\\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/328119/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/discuss/328124/Simple-Python-Solution%3A-top-down-DFS)\\n\\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\\n\\n[113. Path Sum II](https://leetcode.com/problems/path-sum-ii/discuss/328125/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\\n\\n[437. Path Sum III](https://leetcode.com/problems/path-sum-iii/discuss/328128/Simple-Python-Solution%3A-top-down-DFS-%2B-DP) (Similar problem: 560. Subarray Sum Equals K)\\n\\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1681890,
                "title": "c-recursive-solution-with-backtracking",
                "content": "The main idea of Backtracting:\\n\\n**1. choose\\n2. explore\\n3. unchoose**\\n\\nThe approach is almost straight forward.  Just explore the nodes using dfs, we choosing the current node and push to the BinaryVector.  After processing(while returning back) we unchoose the node by poping from the BinaryVector.\\n\\nWhen we reach the leaf node, we get a BinaryVector(from root to leaf) then we convert the BinaryVector to an Decimal Equivalent and adding to the Total, then we backtract again, and repeat the same process.\\n\\n**C++:**\\n```\\nclass Solution {\\nprivate:\\n    int binaToDeci(vector<int> s){\\n        int res = 0, p = 1;\\n        for (int i = s.size()-1; i >= 0; i--)\\n        {\\n            int c = s[i];\\n            if(c == 1) res += p;\\n            p <<= 1;\\n        }\\n        return res;\\n    }\\n    void dfs(TreeNode* root, vector<int>&BinaryVector, int& Total){\\n        if(root == NULL) return;\\n        if(root->left == NULL && root-> right == NULL){ // left node\\n            BinaryVector.push_back(root->val);  // choose\\n            Total += binaToDeci(BinaryVector); // Converts the Binary to Decimal and add it. \\n            BinaryVector.pop_back();  // unchoose\\n            return ;\\n        }\\n\\n        BinaryVector.push_back(root->val);   // choose \\n        dfs(root->left, BinaryVector, Total); // explore\\n        dfs(root->right, BinaryVector, Total);\\n        BinaryVector.pop_back();             // unchoose\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int Total = 0;\\n        vector<int> BinaryVector;\\n        dfs(root, BinaryVector, Total);\\n        return Total;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int binaToDeci(vector<int> s){\\n        int res = 0, p = 1;\\n        for (int i = s.size()-1; i >= 0; i--)\\n        {\\n            int c = s[i];\\n            if(c == 1) res += p;\\n            p <<= 1;\\n        }\\n        return res;\\n    }\\n    void dfs(TreeNode* root, vector<int>&BinaryVector, int& Total){\\n        if(root == NULL) return;\\n        if(root->left == NULL && root-> right == NULL){ // left node\\n            BinaryVector.push_back(root->val);  // choose\\n            Total += binaToDeci(BinaryVector); // Converts the Binary to Decimal and add it. \\n            BinaryVector.pop_back();  // unchoose\\n            return ;\\n        }\\n\\n        BinaryVector.push_back(root->val);   // choose \\n        dfs(root->left, BinaryVector, Total); // explore\\n        dfs(root->right, BinaryVector, Total);\\n        BinaryVector.pop_back();             // unchoose\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int Total = 0;\\n        vector<int> BinaryVector;\\n        dfs(root, BinaryVector, Total);\\n        return Total;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936585,
                "title": "dfs-easy-js-solution",
                "content": "```\\n/*\\nUse DFS to find every possible path\\nKeep track of binary number in path. When leaf is reached, convert it to an integer and add it\\nto a global variable.\\n*/\\nvar sumRootToLeaf = function(root) {\\n    let sum = 0;\\n    dfs(root, \"\");\\n    return sum;\\n    function dfs(root, path) {\\n        if (!root) {\\n            return;\\n        }\\n        if (!root.left && !root.right) {\\n            sum += parseInt(path + root.val, 2);\\n            return;\\n        }\\n        dfs(root.left, path + root.val);\\n        dfs(root.right, path + root.val);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nUse DFS to find every possible path\\nKeep track of binary number in path. When leaf is reached, convert it to an integer and add it\\nto a global variable.\\n*/\\nvar sumRootToLeaf = function(root) {\\n    let sum = 0;\\n    dfs(root, \"\");\\n    return sum;\\n    function dfs(root, path) {\\n        if (!root) {\\n            return;\\n        }\\n        if (!root.left && !root.right) {\\n            sum += parseInt(path + root.val, 2);\\n            return;\\n        }\\n        dfs(root.left, path + root.val);\\n        dfs(root.right, path + root.val);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681998,
                "title": "java-0ms-with-explanation",
                "content": "We declare sum=0 as global variable.\\n\\nNow in main method we make a check method which computes sumRoottoLeaf calculation.\\n\\nHere preorder traversal will work. As we need root first.\\n\\nMy logic is that if root.val==0 then the computed value earlier will become`` x * 2 else x*2+1;\\n\\nHow???\\nlike first take example with 110=6;\\nNow if next node is 0 which make (1100) =12\\nAnd if next node is 1 which make (1101)=13\\n\\nUsing this approach i recursive called root.left and root.right .\\nAnd included one condtion which is if it is leaf Node then add in global variable sum.\\n\\n**Please Upvote if found UsefuL**\\nComments if any doubts or any more good approach.**Thank You!!**\\n\\n```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        check(root,0);\\n        return sum;\\n    }\\n    void check(TreeNode root,int x)\\n    {\\n        if(root==null)\\n        {\\n            return;\\n        }\\n        if(root.left==null && root.right==null)\\n        {\\n            sum+=root.val==0?x*2:x*2+1;\\n            return;\\n        }\\n        check(root.left,root.val==0?x*2:x*2+1);\\n        check(root.right,root.val==0?x*2:x*2+1);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        check(root,0);\\n        return sum;\\n    }\\n    void check(TreeNode root,int x)\\n    {\\n        if(root==null)\\n        {\\n            return;\\n        }\\n        if(root.left==null && root.right==null)\\n        {\\n            sum+=root.val==0?x*2:x*2+1;\\n            return;\\n        }\\n        check(root.left,root.val==0?x*2:x*2+1);\\n        check(root.right,root.val==0?x*2:x*2+1);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836834,
                "title": "python-easy-to-understand-dfs",
                "content": "\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def helper(root,nums):\\n            if not root.left and not root.right:\\n                nums += str(root.val)\\n                self.total += int(nums,2)\\n                return    \\n            \\n            nums += str(root.val)\\n            if root.left:\\n                helper(root.left,nums)\\n            if root.right:\\n                helper(root.right,nums)\\n\\n        helper(root, \"\")\\n        return self.total",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def helper(root,nums):\\n            if not root.left and not root.right:\\n                nums += str(root.val)\\n                self.total += int(nums,2)\\n                return    \\n            \\n            nums += str(root.val)\\n            if root.left:\\n                helper(root.left,nums)\\n            if root.right:\\n                helper(root.right,nums)\\n\\n        helper(root, \"\")\\n        return self.total",
                "codeTag": "Python3"
            },
            {
                "id": 836179,
                "title": "java-easy-to-understand-w-explanation-dfs-solution-beats-100",
                "content": "Every level of the tree describes the weight as we do in the Base-10.\\nFor example, 123 can be represented as 123 = 1 * 100 + 2 * 10 + 3\\nSimilarly\\n\\n              1 ----- Level 0 represents weight 2 raise to power 0\\n             / \\\\\\n           0    1 ----- Level 1 represents weight 2 raise to power 1\\n         /  \\\\\\n        1    0 ----- Level 2 represents weight 2 raise to power 2\\nRoot to Leaf Paths - 1 0 1 = 1 * (2^2) + 0 * (2^1) + 1 * (2^0) = 4 + 0 + 1 = 5,\\nSimilarly for 1 0 0 and 1 1.\\n\\nIn Short words, with every level down, we are shifting bits to the left and thereby increasing their weight by k (where k is the base in which we\\'re in, in this case k = 2)\\n\\nFor Path -> 1 0 1\\nAt Level 0, curr = 0 + 1 = 1\\nAt Level 1, curr = (0 + 1) * 2 + 0 = 2\\nAt Level 2, curr = ((0 + 1) * 2 + 0) * 2 + 1 = 2 * 2 + 1 = 5\\n\\nHope it helps!!\\n\\n\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    \\n    private void dfs(TreeNode root, int curr) {\\n        if (root == null) return;\\n        \\n        curr = curr * 2 + root.val;\\n        \\n        if (root.left == null && root.right == null) {\\n            sum += curr;\\n        }\\n        \\n        dfs(root.left, curr);\\n        dfs(root.right, curr);\\n        \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root, 0);\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    \\n    private void dfs(TreeNode root, int curr) {\\n        if (root == null) return;\\n        \\n        curr = curr * 2 + root.val;\\n        \\n        if (root.left == null && root.right == null) {\\n            sum += curr;\\n        }\\n        \\n        dfs(root.left, curr);\\n        dfs(root.right, curr);\\n        \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root, 0);\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835894,
                "title": "c-simple-recursive-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\npublic:\\n    // recursive helper function to add to vector all binary numbers\\n    void traverse(TreeNode* node, string sum) {\\n        if (!node)\\n            return;\\n        sum = sum + to_string(node->val);\\n        if (!node->left && !node->right)\\n        {\\n            vec.push_back(sum);\\n        }\\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n        \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        int res = 0;\\n        for(auto x:vec)\\n            res += stoi(x, nullptr, 2);\\n        return res;\\n    }\\n    vector<string> vec;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // recursive helper function to add to vector all binary numbers\\n    void traverse(TreeNode* node, string sum) {\\n        if (!node)\\n            return;\\n        sum = sum + to_string(node->val);\\n        if (!node->left && !node->right)\\n        {\\n            vec.push_back(sum);\\n        }\\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n        \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        int res = 0;\\n        for(auto x:vec)\\n            res += stoi(x, nullptr, 2);\\n        return res;\\n    }\\n    vector<string> vec;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270895,
                "title": "python-happy-dfs-solution",
                "content": "DFS with preorder trasvering\\n# method 1\\n        # it\\'s quite similar to find and return all the root-to-leaf paths\\n        # But this time we just need to return the decimal\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(n) for additional space\\n        def dfs(node, path=None):\\n            if path == None:\\n                path = \\'\\'\\n            if node:\\n                path += str(node.val)\\n                if node.left or node.right:\\n                    return dfs(node.left, path) + dfs(node.right, path)\\n                else:\\n                    return int(path, 2)\\n            else:\\n                return 0\\n\\t\\t\\t\\t\\n# method 2 (recommended)\\n        # very similar to the implementation of method 1\\n\\t\\t# but this time, we directly pass the parent sum instead of \\n\\t\\t# only calculate the decimal presentation in the leaf\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(1) for additional space\\n        def dfs2(node, parent_sum=None):\\n            if parent_sum == None:\\n                parent_sum = 0\\n            if node:\\n                parent_sum = parent_sum * 2 + node.val\\n                if node.left or node.right:\\n                    return dfs2(node.left, parent_sum) + dfs2(node.right, parent_sum)\\n                else:\\n                    return parent_sum\\n            else:\\n                return 0",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "DFS with preorder trasvering\\n# method 1\\n        # it\\'s quite similar to find and return all the root-to-leaf paths\\n        # But this time we just need to return the decimal\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(n) for additional space\\n        def dfs(node, path=None):\\n            if path == None:\\n                path = \\'\\'\\n            if node:\\n                path += str(node.val)\\n                if node.left or node.right:\\n                    return dfs(node.left, path) + dfs(node.right, path)\\n                else:\\n                    return int(path, 2)\\n            else:\\n                return 0\\n\\t\\t\\t\\t\\n# method 2 (recommended)\\n        # very similar to the implementation of method 1\\n\\t\\t# but this time, we directly pass the parent sum instead of \\n\\t\\t# only calculate the decimal presentation in the leaf\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(1) for additional space\\n        def dfs2(node, parent_sum=None):\\n            if parent_sum == None:\\n                parent_sum = 0\\n            if node:\\n                parent_sum = parent_sum * 2 + node.val\\n                if node.left or node.right:\\n                    return dfs2(node.left, parent_sum) + dfs2(node.right, parent_sum)\\n                else:\\n                    return parent_sum\\n            else:\\n                return 0",
                "codeTag": "Python3"
            },
            {
                "id": 695744,
                "title": "simplest-recursive-solution-o-n-and-100-time-with-explaination",
                "content": "Idea is simple, do normal traversal, at every step just store the value from previous to current node,\\nexample : traversing 1->0->1 :-\\nwhen we start with 1(1 is root), then value 1 to binary is 2^0 * 1 === 1,\\nwhen we traverses to 1->0 (from 1 to 0), then it is 2^1 * 1 + 2^0 * 0 == 2   note : the previous node value just get doubled and we just the current node since 2\\'s power 0 is 1 only, so 1*2 + 1 * 0 = 2\\nwhen we traverses to 1->0->1, then ->  2 * (value of 1->0) + 1 = (2 * 2 )+ 1\\nso 1->0->1 = 5\\n we uses same thing in our logic\\n\\n```\\nint sum = 0;  // final sum\\n    public int sumRootToLeaf(TreeNode root) {\\n        recur(root,0);\\n        return sum;\\n    }\\n   void recur(TreeNode root, int num) {\\n        if(root == null) {\\n            return;\\n        }\\n        num = num*2 + root.val;  // at every node it will return the value of binary in decimal from root \\n        recur(root.left,num);  \\n        recur(root.right,num);\\n        if(root.left == null && root.right == null) {\\n            sum +=num;   // when every time we reaches the leaf node, we add the num to sum\\n        }\\n    }\\n```\\n\\n**I hope this helps!!**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nint sum = 0;  // final sum\\n    public int sumRootToLeaf(TreeNode root) {\\n        recur(root,0);\\n        return sum;\\n    }\\n   void recur(TreeNode root, int num) {\\n        if(root == null) {\\n            return;\\n        }\\n        num = num*2 + root.val;  // at every node it will return the value of binary in decimal from root \\n        recur(root.left,num);  \\n        recur(root.right,num);\\n        if(root.left == null && root.right == null) {\\n            sum +=num;   // when every time we reaches the leaf node, we add the num to sum\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308071,
                "title": "python-99-depth-first-search",
                "content": "\\n\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def dfs(node, prefix):\\n            if node:\\n                new_prefix = node.val + (prefix << 1)\\n                \\n                if node.left or node.right:\\n                    return dfs(node.left, new_prefix) + dfs(node.right, new_prefix)\\n                else:\\n                    return new_prefix\\n            else:\\n                return 0\\n            \\n        return dfs(root, 0)",
                "solutionTags": [],
                "code": "\\n\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def dfs(node, prefix):\\n            if node:\\n                new_prefix = node.val + (prefix << 1)\\n                \\n                if node.left or node.right:\\n                    return dfs(node.left, new_prefix) + dfs(node.right, new_prefix)\\n                else:\\n                    return new_prefix\\n            else:\\n                return 0\\n            \\n        return dfs(root, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 269967,
                "title": "c-3-lines",
                "content": "# Solution\\nCalculate the number top-to-bottom, stop at the leaf and return the result.\\n\\nSum results for all leaves; make sure we handle parents with only one child (return 0 for the missing child).\\n```\\nint sumRootToLeaf(TreeNode* r, int val = 0) {\\n  if (r == nullptr) return 0;\\n  val = ((val << 1) + r->val) % 1000000007;\\n  return (r->left == r->right ? val : sumRootToLeaf(r->left, val) + sumRootToLeaf(r->right, val)) % 1000000007;\\n}\\n```\\n# Complexity Analysis\\nRuntime: *O(n)*; we process each node once. \\nMemory: *O(h)*, where *h* is the height of the tree.",
                "solutionTags": [],
                "code": "```\\nint sumRootToLeaf(TreeNode* r, int val = 0) {\\n  if (r == nullptr) return 0;\\n  val = ((val << 1) + r->val) % 1000000007;\\n  return (r->left == r->right ? val : sumRootToLeaf(r->left, val) + sumRootToLeaf(r->right, val)) % 1000000007;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682476,
                "title": "c-java-simple-and-clean-recursive-solutions-explained",
                "content": "**Idea:**\\nWe treaverse the tree, and concatenate the binary numbers to one string in `sum`.\\nWhen we reach a leaf node, we calculate the value of the binary string and add to `res`.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1) without considering recursive stack, O(height) with recursive call stack.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    \\n    void traverse(TreeNode* node, string sum) {\\n        if (!node) return;\\n        \\n        sum = sum + to_string(node->val);\\n        \\n        if (!node->left && !node->right) res += stoi(sum, nullptr, 2);\\n        \\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n};\\n```\\n****\\n**Java:**\\n```\\nclass Solution {\\n    int res = 0;\\n    \\n    void traverse(TreeNode node, String sum) {\\n        if (node == null) return;\\n        \\n        sum = sum + String.valueOf(node.val);\\n        \\n        if (node.left == null && node.right == null) \\n            res += Integer.parseInt(sum, 2);\\n   \\n        traverse(node.left, sum);\\n        traverse(node.right, sum); \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    \\n    void traverse(TreeNode* node, string sum) {\\n        if (!node) return;\\n        \\n        sum = sum + to_string(node->val);\\n        \\n        if (!node->left && !node->right) res += stoi(sum, nullptr, 2);\\n        \\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int res = 0;\\n    \\n    void traverse(TreeNode node, String sum) {\\n        if (node == null) return;\\n        \\n        sum = sum + String.valueOf(node.val);\\n        \\n        if (node.left == null && node.right == null) \\n            res += Integer.parseInt(sum, 2);\\n   \\n        traverse(node.left, sum);\\n        traverse(node.right, sum); \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481832,
                "title": "recursive-dfs-soln-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void helper(TreeNode* root , int num = 0)\\n    {\\n        num = num*2 + root->val;\\n        if(root->left)helper(root->left , num);\\n        if(root->right)helper(root->right , num);\\n        \\n        if(!root->left && !root->right)\\n        {  sum += num;\\n           return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```\\n\\nsimilar question https://leetcode.com/problems/sum-root-to-leaf-numbers/\\nwith answer https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/1481784/c%2B%2B-soln-faster-than-100",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void helper(TreeNode* root , int num = 0)\\n    {\\n        num = num*2 + root->val;\\n        if(root->left)helper(root->left , num);\\n        if(root->right)helper(root->right , num);\\n        \\n        if(!root->left && !root->right)\\n        {  sum += num;\\n           return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990406,
                "title": "c-no-bitwise-operators-recursive-simple",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, ll num){\\n        if(!root)\\n            return 0;\\n        if(!root->left && !root->right)\\n            return num + root->val;\\n        num += root->val;\\n        return solve(root->left, num * 2) + solve(root->right, num * 2);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return solve(root,0);\\n    }\\n};\\n```\\n\\nThe reason for using long long instead of int is there could be a potential overflow since I am multiplying the numbers rather than shifting bits.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, ll num){\\n        if(!root)\\n            return 0;\\n        if(!root->left && !root->right)\\n            return num + root->val;\\n        num += root->val;\\n        return solve(root->left, num * 2) + solve(root->right, num * 2);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return solve(root,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843907,
                "title": "java-recursion-dfs-and-iteration-morris-traversal-with-video-explaination",
                "content": "DFS version\\n[https://www.youtube.com/watch?v=HBAJqf5cRis](https://www.youtube.com/watch?v=HBAJqf5cRis)\\n```java\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return helper(root, 0);\\n    }\\n    \\n    private int helper(TreeNode node, int value){\\n        if(node == null) return 0;\\n        \\n        value = value * 2 + node.val;\\n        if(node.left == null && node.right == null){\\n            return value;\\n        }\\n        return helper(node.left, value) + helper(node.right, value);\\n    }\\n}\\n\\n```\\n\\nMorris Traversal Version\\n[https://www.youtube.com/watch?v=2zGxbvIqDGI](https://www.youtube.com/watch?v=2zGxbvIqDGI)\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        int result = 0;\\n        int carry = 0;\\n        while(root != null){\\n            if(root.left != null){\\n                TreeNode predecessor = root.left;\\n                int level = 1;\\n                \\n                while(predecessor.right != null && predecessor.right != root){\\n                    predecessor = predecessor.right;\\n                    level++;\\n                }\\n                \\n                if(predecessor.right == null){\\n                    carry = carry * 2 + root.val;\\n                    predecessor.right = root;\\n                    root = root.left;\\n                }else{\\n                    if(predecessor.left == null){\\n                        result += carry;\\n                    }\\n                    \\n                    for(int i = 0; i < level; i++){\\n                        carry = carry / 2;\\n                    }\\n                    \\n                    predecessor.right = null;\\n                    root = root.right;\\n                }\\n            }else{\\n                // root.left == null\\n                carry = carry * 2 + root.val;\\n                \\n                // right-most leaf node\\n                if(root.right == null){\\n                    result += carry;\\n                }\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return helper(root, 0);\\n    }\\n    \\n    private int helper(TreeNode node, int value){\\n        if(node == null) return 0;\\n        \\n        value = value * 2 + node.val;\\n        if(node.left == null && node.right == null){\\n            return value;\\n        }\\n        return helper(node.left, value) + helper(node.right, value);\\n    }\\n}\\n\\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        int result = 0;\\n        int carry = 0;\\n        while(root != null){\\n            if(root.left != null){\\n                TreeNode predecessor = root.left;\\n                int level = 1;\\n                \\n                while(predecessor.right != null && predecessor.right != root){\\n                    predecessor = predecessor.right;\\n                    level++;\\n                }\\n                \\n                if(predecessor.right == null){\\n                    carry = carry * 2 + root.val;\\n                    predecessor.right = root;\\n                    root = root.left;\\n                }else{\\n                    if(predecessor.left == null){\\n                        result += carry;\\n                    }\\n                    \\n                    for(int i = 0; i < level; i++){\\n                        carry = carry / 2;\\n                    }\\n                    \\n                    predecessor.right = null;\\n                    root = root.right;\\n                }\\n            }else{\\n                // root.left == null\\n                carry = carry * 2 + root.val;\\n                \\n                // right-most leaf node\\n                if(root.right == null){\\n                    result += carry;\\n                }\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836211,
                "title": "javascript-clean-recursive-solution",
                "content": "```javascript\\nvar sumRootToLeaf = function(root) {\\n    \\n    function callDFS(node, str) {\\n        if(!node) return 0;\\n        str += node.val\\n        if(!node.left && !node.right) return parseInt(str, 2);\\n        return callDFS(node.right, str) + callDFS(node.left, str);\\n    }\\n    return callDFS(root, \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar sumRootToLeaf = function(root) {\\n    \\n    function callDFS(node, str) {\\n        if(!node) return 0;\\n        str += node.val\\n        if(!node.left && !node.right) return parseInt(str, 2);\\n        return callDFS(node.right, str) + callDFS(node.left, str);\\n    }\\n    return callDFS(root, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836047,
                "title": "java-dfs-video-solution-with-complexity-as-o-n",
                "content": "<iframe width=\"650\" height=\"450\" src=\"https://www.youtube.com/embed/7zNNdbeSz-I\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\nLink https://www.youtube.com/embed/7zNNdbeSz-I\\n\\nAlgorithm DFS /Post order traversal\\n1) At each level multiply the running sum with 2 and add the node val. \\n2) At leaves add running sum to your result\\n\\nclass Solution { \\nint totalSum = 0; // For storing the result\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        \\n        preOrderTraversal(root, 0);\\n        return totalSum;\\n    }\\n    // O(n), where n is the no of nodes in the tree\\n    private void preOrderTraversal(TreeNode root, int currVal){\\n        if(root==null){\\n            return ;\\n        }\\n        currVal = currVal + root.val;\\n        \\n        // leaf node or not\\n        if(root.left == null && root.right==null){\\n            totalSum += currVal;\\n            return ;\\n        }\\n        preOrderTraversal(root.left , currVal* 2);\\n        preOrderTraversal(root.right , currVal* 2);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nLink https://www.youtube.com/embed/7zNNdbeSz-I\\n\\nAlgorithm DFS /Post order traversal\\n1) At each level multiply the running sum with 2 and add the node val. \\n2) At leaves add running sum to your result\\n\\nclass Solution { \\nint totalSum = 0; // For storing the result\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        \\n        preOrderTraversal(root, 0);\\n        return totalSum;\\n    }\\n    // O(n), where n is the no of nodes in the tree\\n    private void preOrderTraversal(TreeNode root, int currVal){\\n        if(root==null){\\n            return ;\\n        }\\n        currVal = currVal + root.val;\\n        \\n        // leaf node or not\\n        if(root.left == null && root.right==null){\\n            totalSum += currVal;\\n            return ;\\n        }\\n        preOrderTraversal(root.left , currVal* 2);\\n        preOrderTraversal(root.right , currVal* 2);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835950,
                "title": "sum-of-root-to-leaf-binary-numbers-c-o-n-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    static int count(TreeNode* node, int path = 0) { // save path as bits in int\\n        if (!node) return 0;\\n\\t\\t// update path by adding new point to the right to get answer quickly\\n        path <<= 1;\\n \\xA0 \\xA0 \\xA0 \\xA0path += node->val;\\n\\t\\t// if leaf return answer\\n        if (!node->left && !node->right) {\\n            return path;\\n        } else { // if not leaf continue pathing\\n            return count(node->left, path) + count(node->right, path);\\n        }\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return count(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int count(TreeNode* node, int path = 0) { // save path as bits in int\\n        if (!node) return 0;\\n\\t\\t// update path by adding new point to the right to get answer quickly\\n        path <<= 1;\\n \\xA0 \\xA0 \\xA0 \\xA0path += node->val;\\n\\t\\t// if leaf return answer\\n        if (!node->left && !node->right) {\\n            return path;\\n        } else { // if not leaf continue pathing\\n            return count(node->left, path) + count(node->right, path);\\n        }\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return count(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760466,
                "title": "go-recursive-solution",
                "content": "You\\'ve got to press it on you, you\\'ve just been thinking.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc sumRootToLeaf(root *TreeNode) int {\\n    return dfs(root, 0)\\n}\\n\\nfunc dfs(root *TreeNode, currSum int) int {\\n    currSum = (currSum << 1) | root.Val\\n    \\n    if root.Left == nil && root.Right == nil {\\n        return currSum\\n    }\\n    \\n    total := 0\\n    if root.Left != nil {\\n        total += dfs(root.Left, currSum)\\n    }\\n    \\n    if root.Right != nil {\\n        total += dfs(root.Right, currSum)\\n    }\\n    \\n    return total\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc sumRootToLeaf(root *TreeNode) int {\\n    return dfs(root, 0)\\n}\\n\\nfunc dfs(root *TreeNode, currSum int) int {\\n    currSum = (currSum << 1) | root.Val\\n    \\n    if root.Left == nil && root.Right == nil {\\n        return currSum\\n    }\\n    \\n    total := 0\\n    if root.Left != nil {\\n        total += dfs(root.Left, currSum)\\n    }\\n    \\n    if root.Right != nil {\\n        total += dfs(root.Right, currSum)\\n    }\\n    \\n    return total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455682,
                "title": "java-100-time-and-memory-bit-operations-concise",
                "content": "``` \\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        return dfs(root, 0);\\n    }\\n    \\n    public int dfs(TreeNode n, int x) {\\n        if (n == null) return 0;\\n        x = (x << 1) | n.val;\\n        if (n.left == null && n.right == null) return x;\\n        return dfs(n.left, x) + dfs(n.right, x);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        return dfs(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2246488,
                "title": "fast-and-easy-c-solution-using-preorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    void getsum(TreeNode* root,long long data){\\n        if(root==NULL){\\n            return;\\n        }\\n        data=2*data+root->val;\\n        if(root->left==NULL && root->right==NULL){\\n            ans+=data;\\n        }\\n        getsum(root->left,data);\\n        getsum(root->right,data);\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        getsum(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    void getsum(TreeNode* root,long long data){\\n        if(root==NULL){\\n            return;\\n        }\\n        data=2*data+root->val;\\n        if(root->left==NULL && root->right==NULL){\\n            ans+=data;\\n        }\\n        getsum(root->left,data);\\n        getsum(root->right,data);\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        getsum(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737312,
                "title": "simple-beginner-friendly-approach",
                "content": "```\\nclass Solution {\\n    int sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        findRootToLeaf(root,\"\");\\n        return sum;\\n    }\\n    void findRootToLeaf(TreeNode root,String prev){\\n        if(root==null)\\n            return;\\n            prev=prev+String.valueOf(root.val);\\n        if(root.left==null && root.right==null)\\n            sum+=Integer.parseInt(prev,2);\\n        findRootToLeaf(root.left,prev);\\n        findRootToLeaf(root.right,prev);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        findRootToLeaf(root,\"\");\\n        return sum;\\n    }\\n    void findRootToLeaf(TreeNode root,String prev){\\n        if(root==null)\\n            return;\\n            prev=prev+String.valueOf(root.val);\\n        if(root.left==null && root.right==null)\\n            sum+=Integer.parseInt(prev,2);\\n        findRootToLeaf(root.left,prev);\\n        findRootToLeaf(root.right,prev);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682840,
                "title": "c-recursion-backtracking-using-string-o-n-time",
                "content": "```\\nclass Solution {\\nprivate:\\n    void dfs(TreeNode* root, string &s, int &ans){\\n        if(!root) return;\\n        s+=to_string(root->val);\\n        if(!root->left && !root->right) ans+=stoi(s, 0, 2);\\n        dfs(root->left, s, ans);\\n        dfs(root->right, s, ans);\\n        s.pop_back();\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s = \"\";\\n        int ans = 0;\\n        dfs(root, s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(TreeNode* root, string &s, int &ans){\\n        if(!root) return;\\n        s+=to_string(root->val);\\n        if(!root->left && !root->right) ans+=stoi(s, 0, 2);\\n        dfs(root->left, s, ans);\\n        dfs(root->right, s, ans);\\n        s.pop_back();\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s = \"\";\\n        int ans = 0;\\n        dfs(root, s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681921,
                "title": "c-short-code-8-lines-fast-easy-to-understand-recursion",
                "content": "**Please Upvote If You Like**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (root==NULL) return 0;//base case\\n        val=val*2+(root->val);\\n        if(root->left==root->right)  return val;\\n        return sumRootToLeaf(root->left,val)+sumRootToLeaf(root->right,val); //DFS Calls\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (root==NULL) return 0;//base case\\n        val=val*2+(root->val);\\n        if(root->left==root->right)  return val;\\n        return sumRootToLeaf(root->left,val)+sumRootToLeaf(root->right,val); //DFS Calls\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681814,
                "title": "python-simple-dfs-approach",
                "content": "This problem is pretty straight forward. Do a Depth first search (DFS) traversal and keep track of the pervious bits values. \\n\\n**Approach  1: Conversion on the go**\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar = soFar * 2 + node.val\\n            if not node.left and not node.right: self.ans += soFar\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, 0)\\n        return self.ans\\n```\\n\\n**Approach 2: Convert when you reach the leaf**\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar += str(node.val)\\n            if not node.left and not node.right: self.ans += int(soFar, 2)\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, \"\")\\n        return self.ans\\n```\\n\\n***Time Complexity: O(N) \\nSpace Complexity: O(H)  - for recursive stack***",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar = soFar * 2 + node.val\\n            if not node.left and not node.right: self.ans += soFar\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, 0)\\n        return self.ans\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar += str(node.val)\\n            if not node.left and not node.right: self.ans += int(soFar, 2)\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, \"\")\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681609,
                "title": "c-simple-and-sweet",
                "content": "Simple Recursion:\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    void Ans(TreeNode *R, int cur, int &ret)\\n    {\\n            cur=cur*2+R->val;\\n            if(R->left!=NULL) Ans(R->left,cur,ret);\\n            if(R->right!=NULL) Ans(R->right,cur,ret);\\n            if(R->left==NULL && R->right==NULL) ret+=cur;\\n    }        \\n    int sumRootToLeaf(TreeNode* R) {\\n        int ret=0,cur=0;\\n        Ans(R,cur,ret);\\n        return(ret);\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void Ans(TreeNode *R, int cur, int &ret)\\n    {\\n            cur=cur*2+R->val;\\n            if(R->left!=NULL) Ans(R->left,cur,ret);\\n            if(R->right!=NULL) Ans(R->right,cur,ret);\\n            if(R->left==NULL && R->right==NULL) ret+=cur;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1399748,
                "title": "c-recursion-well-commented",
                "content": "**Do upvote if found useful**\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void topdown(TreeNode* node,int path){\\n        if(!node)\\n            return;\\n        path*=2;    //multiplying with 2 adds 0 to the binary number\\n        path+=node->val;    //adding whatever value is there in node ie, 0 or 1\\n        if(!node->left && !node->right){    //node is a leaf node\\n            sum+=path;  //add path to the sum\\n        }\\n        if(node->left)  //if left subtree exists\\n            topdown(node->left,path);\\n        \\n        if(node->right)  //if right subtree exists\\n            topdown(node->right,path);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        topdown(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void topdown(TreeNode* node,int path){\\n        if(!node)\\n            return;\\n        path*=2;    //multiplying with 2 adds 0 to the binary number\\n        path+=node->val;    //adding whatever value is there in node ie, 0 or 1\\n        if(!node->left && !node->right){    //node is a leaf node\\n            sum+=path;  //add path to the sum\\n        }\\n        if(node->left)  //if left subtree exists\\n            topdown(node->left,path);\\n        \\n        if(node->right)  //if right subtree exists\\n            topdown(node->right,path);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        topdown(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043156,
                "title": "python3-simple-solution-using-bfs-traversal",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        bfs = [root]\\n        l = []\\n        while bfs:\\n            node = bfs.pop(0)\\n            if node.left:\\n                x = node.left.val\\n                node.left.val = str(node.val) + str(x)\\n                bfs.append(node.left)\\n            if node.right:\\n                x = node.right.val\\n                node.right.val = str(node.val) + str(x)\\n                bfs.append(node.right)\\n            if not node.left and not node.right:\\n                l.append(str(node.val))\\n        return sum([int(i,2) for i in l])\\n```\\nIf you like the solution, please vote for this.",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        bfs = [root]\\n        l = []\\n        while bfs:\\n            node = bfs.pop(0)\\n            if node.left:\\n                x = node.left.val\\n                node.left.val = str(node.val) + str(x)\\n                bfs.append(node.left)\\n            if node.right:\\n                x = node.right.val\\n                node.right.val = str(node.val) + str(x)\\n                bfs.append(node.right)\\n            if not node.left and not node.right:\\n                l.append(str(node.val))\\n        return sum([int(i,2) for i in l])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837027,
                "title": "python-w-explanation",
                "content": "This question is identical to [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/). The only difference is that we construct a decimal number while traversing the tree while here, we construct a binary number. \\n([Solution](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/706013/Python-Recursion-w-Explanation) to  [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/))\\n\\nThe idea is to recurse in a somewhat \\'preorder\\' manner such that at each valid node, we update the value and then recurse on left subtree and then on right.\\n\\n```\\nclass Solution:\\n        \\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self._helper(root, 0)\\n    \\n    def _helper(self, node: TreeNode, val: int):\\n        if node is None:\\n            return 0\\n\\n        # Keep building the \\'binary number\\' along the way\\n        # Identical to building \\'decimal number\\' : number_till_now * 10 + current_number\\n        val = val * 2 + node.val\\n        \\n        if not node.left and not node.right:\\n            return val\\n        \\n        return self._helper(node.left, val) + self._helper(node.right, val)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n        \\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self._helper(root, 0)\\n    \\n    def _helper(self, node: TreeNode, val: int):\\n        if node is None:\\n            return 0\\n\\n        # Keep building the \\'binary number\\' along the way\\n        # Identical to building \\'decimal number\\' : number_till_now * 10 + current_number\\n        val = val * 2 + node.val\\n        \\n        if not node.left and not node.right:\\n            return val\\n        \\n        return self._helper(node.left, val) + self._helper(node.right, val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836978,
                "title": "c-oneliner-dfs-solution-explained-100-time-85-space",
                "content": "And today too I enjoyed giving myself the extra challenge of solving it in one line, recursively.\\n\\nOur function has basically 3 conditions:\\n* empty tree (`!root`) => we return `res` (set to its default value, `0`);\\n* the node is a leaf (`!root->left && !root->right`) => we return the updated value in `res` with the current value in the node (`res * 2 + root->val`);\\n* at least one branch is still present, so we call recursively the function on that branch with updated value of `res` (see above), or return `0` is the branch is not there.\\n\\nThe code, first iteration:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return !root ? res : !root->left && !root->right ? res * 2 + root->val : (root->left ? sumRootToLeaf(root->left, res * 2 + root->val) : 0) + (root->right ? sumRootToLeaf(root->right, res * 2 + root->val) : 0); \\n    }\\n};\\n```\\n\\nFurther ninjaed version, using the comma operator to compute `res` only once:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), !root || !root->left && !root->right ? res : (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0)); \\n    }\\n};\\n```\\n\\nThird iteration, swapping the conditionals from the above, to save at least a couple of boolean negations (would the compiler do that for me?):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), root && (root->left || root->right) ?  (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0) : res); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return !root ? res : !root->left && !root->right ? res * 2 + root->val : (root->left ? sumRootToLeaf(root->left, res * 2 + root->val) : 0) + (root->right ? sumRootToLeaf(root->right, res * 2 + root->val) : 0); \\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), !root || !root->left && !root->right ? res : (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0)); \\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), root && (root->left || root->right) ?  (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0) : res); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450928,
                "title": "python-3-dfs-clean-version",
                "content": "\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n\\t\\t\\tdef dfs(node, previous):\\n\\t\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\t\\tyield 2*previous+node.val\\n\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tyield from dfs(node.left, 2*previous+node.val)\\n\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tyield from dfs(node.right, 2*previous+node.val)\\n\\n\\t\\t\\treturn sum(dfs(root, 0))",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n\\t\\t\\tdef dfs(node, previous):\\n\\t\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\t\\tyield 2*previous+node.val\\n\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tyield from dfs(node.left, 2*previous+node.val)\\n\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tyield from dfs(node.right, 2*previous+node.val)\\n\\n\\t\\t\\treturn sum(dfs(root, 0))",
                "codeTag": "Java"
            },
            {
                "id": 270055,
                "title": "easy-to-understand-python",
                "content": "```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def rec(node,cbuf = \"\"):\\n            if not node:\\n                return \\n            if not node.left and not node.right:\\n                cval = cbuf + str(node.val)\\n                self.total+=int(cval,2)\\n            else:\\n                tmp = cbuf + str(node.val)\\n                rec(node.left,tmp)\\n                rec(node.right,tmp)        \\n        rec(root)\\n        return self.total % (10**9 +7)\\n```",
                "solutionTags": [],
                "code": "```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def rec(node,cbuf = \"\"):\\n            if not node:\\n                return \\n            if not node.left and not node.right:\\n                cval = cbuf + str(node.val)\\n                self.total+=int(cval,2)\\n            else:\\n                tmp = cbuf + str(node.val)\\n                rec(node.left,tmp)\\n                rec(node.right,tmp)        \\n        rec(root)\\n        return self.total % (10**9 +7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3209144,
                "title": "simple-easy-to-understand-beat-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, string s, vector<string>&num){\\n        if(root->left==NULL && root->right==NULL){\\n            s.push_back(root->val + \\'0\\');\\n            num.push_back(s);\\n            s.pop_back();\\n            return;\\n        }\\n        s.push_back(root->val + \\'0\\');\\n        if(root->left)\\n            solve(root->left,s,num);\\n        if(root->right)\\n            solve(root->right,s,num);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        vector<string>num;\\n        string s=\"\";\\n        solve(root,s,num);\\n        for(int i=0;i<num.size();i++){\\n            sum+= stoi(num[i],0,2);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, string s, vector<string>&num){\\n        if(root->left==NULL && root->right==NULL){\\n            s.push_back(root->val + \\'0\\');\\n            num.push_back(s);\\n            s.pop_back();\\n            return;\\n        }\\n        s.push_back(root->val + \\'0\\');\\n        if(root->left)\\n            solve(root->left,s,num);\\n        if(root->right)\\n            solve(root->right,s,num);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        vector<string>num;\\n        string s=\"\";\\n        solve(root,s,num);\\n        for(int i=0;i<num.size();i++){\\n            sum+= stoi(num[i],0,2);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031949,
                "title": "c-easy-recursive-approach-dfs",
                "content": "TC: O(N)\\nSC: Auxiliary Stack Space O(N)\\n```\\nclass Solution {\\npublic:\\n    long sum=0;\\n    void solve(TreeNode* &root,long val){\\n        //base case\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            sum+= (val*2 + root->val);\\n            return;\\n        }\\n        solve(root->left,val*2+root->val);\\n        solve(root->right,val*2+root->val);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        solve(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long sum=0;\\n    void solve(TreeNode* &root,long val){\\n        //base case\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            sum+= (val*2 + root->val);\\n            return;\\n        }\\n        solve(root->left,val*2+root->val);\\n        solve(root->right,val*2+root->val);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        solve(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467041,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint ans = 0;\\n\\t\\tvoid solve(TreeNode *root, int buff){\\n\\n\\t\\t\\tbuff = buff*2 + root->val;\\n\\n\\t\\t\\tif(!root->left && !root->right){\\n\\n\\t\\t\\t\\tans += buff;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(root->left) solve(root->left, buff);\\n\\t\\t\\tif(root->right) solve(root->right, buff);\\n\\t\\t}\\n\\n\\t\\tint sumRootToLeaf(TreeNode* root) {\\n\\n\\t\\t\\tint buff = 0;\\n\\t\\t\\tsolve(root, buff);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint ans = 0;\\n\\t\\tvoid solve(TreeNode *root, int buff){\\n\\n\\t\\t\\tbuff = buff*2 + root->val;\\n\\n\\t\\t\\tif(!root->left && !root->right){\\n\\n\\t\\t\\t\\tans += buff;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2345249,
                "title": "dfs",
                "content": "```\\nclass Solution {\\n  int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root,\"\");\\n        return sum;\\n        }\\n    public void traverse(TreeNode root,String prev)\\n    {\\n        if(root==null)\\n            return;\\n        if(root.left==null&&root.right==null)\\n        {\\n             prev=Integer.toString(root.val)+prev;\\n            ANS(prev);\\n            return;\\n        }\\n        prev=Integer.toString(root.val)+prev;\\n        traverse(root.left,prev);\\n        traverse(root.right,prev);\\n        return;\\n        \\n    }\\n    public void ANS(String s)\\n    {\\n        int res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            String s1= Character.toString(s.charAt(i));\\n            res=res+(1<<i)*Integer.parseInt(s1);\\n        }\\n        sum=sum+res;\\n    }\\n    \\n}",
                "solutionTags": [
                    "String",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n  int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root,\"\");\\n        return sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1682249,
                "title": "c-using-vectors",
                "content": "\\n\\t\\tvoid getPath(TreeNode* root,vector<vector<int>> &allpath,vector<int> path){\\n        if(!root) return;\\n        \\n        path.push_back(root->val);\\n\\t\\t\\n        if(root->left==NULL && root->right==NULL){\\n            allpath.push_back(path);\\n        }\\n        getPath(root->left,allpath,path);\\n        getPath(root->right,allpath,path);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<vector<int>> allpath;\\n        vector<int> path;\\n        getPath(root,allpath,path);\\n        int sum=0;\\n        for(int i=0;i<allpath.size();i++){\\n            int cur=0;\\n            int n=allpath[i].size()-1;\\n            for(int j=allpath[i].size()-1;j>=0;j--){\\n                if(allpath[i][j]==0) continue;\\n                cur+=pow(2,n-j);\\n            }\\n            sum+=cur;\\n        }\\n        \\n        return sum;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n\\t\\tvoid getPath(TreeNode* root,vector<vector<int>> &allpath,vector<int> path){\\n        if(!root) return;\\n        \\n        path.push_back(root->val);\\n\\t\\t\\n        if(root->left==NULL && root->right==NULL){\\n            allpath.push_back(path);\\n        }\\n        getPath(root->left,allpath,path);\\n        getPath(root->right,allpath,path);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<vector<int>> allpath;\\n        vector<int> path;\\n        getPath(root,allpath,path);\\n        int sum=0;\\n        for(int i=0;i<allpath.size();i++){\\n            int cur=0;\\n            int n=allpath[i].size()-1;\\n            for(int j=allpath[i].size()-1;j>=0;j--){\\n                if(allpath[i][j]==0) continue;\\n                cur+=pow(2,n-j);\\n            }\\n            sum+=cur;\\n        }\\n        \\n        return sum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1626645,
                "title": "c-single-pass-solution-0-n-less-than-5-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(TreeNode* root,int val){\\n        if(!root)\\n            return(0);\\n        if(!root->right&&!root->left){\\n            return((root->val)+val*2);\\n        }\\n        val=(root->val)+val*2;\\n        return(f(root->left,val)+f(root->right,val));\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n    return(f(root,0));\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(TreeNode* root,int val){\\n        if(!root)\\n            return(0);\\n        if(!root->right&&!root->left){\\n            return((root->val)+val*2);\\n        }\\n        val=(root->val)+val*2;\\n        return(f(root->left,val)+f(root->right,val));\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n    return(f(root,0));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586855,
                "title": "easy-to-learn-for-beginer-c",
                "content": "```\\nclass Solution {\\n    int ri=0; //define a universal   variable\\n\\npublic: \\n    \\n    void util(TreeNode* root,int ans){\\n        if(!root)\\n        {\\n            return;\\n        }\\n        //converting binary to real number\\n        ans=ans*2+root->val;\\n        \\n        if(!root->left && !root->right)\\n        {\\n            ri+=ans;\\n        }\\n        util(root->left,ans);\\n        util(root->right,ans);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans=0;\\n        util(root,ans);\\n        return ri;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int ri=0; //define a universal   variable\\n\\npublic: \\n    \\n    void util(TreeNode* root,int ans){\\n        if(!root)\\n        {\\n            return;\\n        }\\n        //converting binary to real number\\n        ans=ans*2+root->val;\\n        \\n        if(!root->left && !root->right)\\n        {\\n            ri+=ans;\\n        }\\n        util(root->left,ans);\\n        util(root->right,ans);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans=0;\\n        util(root,ans);\\n        return ri;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431470,
                "title": "c-easy-solution-with-explanation",
                "content": "Firstly I am using preOrder traverslal to get the nodes and pushing them in a vector. As a leaf node is reached the vector is being sent to the function \\'add\\' where its bieng converted to the Decimal equivalent. Through backtracking we are storing each value according into the vector. PLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\npublic:\\n   int res;\\n    int add(vector<int>s)\\n    {\\n        int c=0;int k=0;\\n        while(!s.empty())\\n        {\\n            k=k+(s.back()*pow(2,c));\\n            c++;\\n            s.pop_back();\\n        }\\n        return k;\\n    }\\n    void calc(TreeNode *root,vector<int>s,int c)\\n    {\\n      \\n         if(root==nullptr)\\n             return;\\n       // cout<<root->val<<\" \";\\n       s.push_back(root->val);\\n        calc(root->left,s,c);\\n         calc(root->right,s,c);\\n    \\n        if(root->left==nullptr&&root->right==nullptr)\\n        {\\n          int m=add(s);\\n        res=res+m;\\n        }\\n             \\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int>s;\\n        calc(root,s,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int res;\\n    int add(vector<int>s)\\n    {\\n        int c=0;int k=0;\\n        while(!s.empty())\\n        {\\n            k=k+(s.back()*pow(2,c));\\n            c++;\\n            s.pop_back();\\n        }\\n        return k;\\n    }\\n    void calc(TreeNode *root,vector<int>s,int c)\\n    {\\n      \\n         if(root==nullptr)\\n             return;\\n       // cout<<root->val<<\" \";\\n       s.push_back(root->val);\\n        calc(root->left,s,c);\\n         calc(root->right,s,c);\\n    \\n        if(root->left==nullptr&&root->right==nullptr)\\n        {\\n          int m=add(s);\\n        res=res+m;\\n        }\\n             \\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int>s;\\n        calc(root,s,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1191997,
                "title": "python-python3-sum-of-root-to-leaf-binary-numbers",
                "content": "***ShamelessSelfPromotion***: My other leetcode [solutions](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts) to various questions can be found [here](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts)\\n\\nTime: O(N)\\nSpace: O(1)\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def calc(node, temp):\\n            if not node:\\n                return 0\\n            \\n            temp = temp*2 + node.val\\n            if (node.left is None) and (node.right is None):\\n                return temp\\n            \\n            return (calc(node.left, temp) + calc(node.right, temp))\\n        \\n        return calc(root, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def calc(node, temp):\\n            if not node:\\n                return 0\\n            \\n            temp = temp*2 + node.val\\n            if (node.left is None) and (node.right is None):\\n                return temp\\n            \\n            return (calc(node.left, temp) + calc(node.right, temp))\\n        \\n        return calc(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835986,
                "title": "easy-cpp-basic-dfs-o-n-beats-100",
                "content": "The idea is simple, keep adding the current node\\'s value in our temporary sum all the while left shifting it (multiplying by 2).\\nThen we run dfs for its left and right children. When we are done with this node\\'s children, then subtract the node\\'s value from our temporary sum and then right shift it (divide by 2). \\nWhen we reach a leaf node, we add this temporary sum obtained so far to our answer variable. This way, whenever we reach a leaf node, we have found the (temporary) sum of that line of numbers in base 10.\\nTime Complexity - O(N)\\nSpace Complexity - O(1) ~ excluding the recursion stack\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long ans=0;\\n    long sum=0;\\n    void dfs(TreeNode* root){\\n        if(root==NULL){\\n            // ans+=sum;\\n            return;\\n        }\\n        sum=(sum*2)+root->val; //left shift and add current node\\'s value\\n        if(!root->left&&!root->right){ // if leaf add temporary sum in ans\\n            ans+=sum;\\n            \\n            sum-=root->val; //subtract current node\\'s value\\n            sum=sum/2; //right shift\\n            return;\\n        }\\n        //if not leaf then continue dfs for its children\\n        dfs(root->left);\\n        dfs(root->right);\\n        sum-=root->val;\\n        sum=sum/2;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        ans=0;\\n        sum=0;\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long ans=0;\\n    long sum=0;\\n    void dfs(TreeNode* root){\\n        if(root==NULL){\\n            // ans+=sum;\\n            return;\\n        }\\n        sum=(sum*2)+root->val; //left shift and add current node\\'s value\\n        if(!root->left&&!root->right){ // if leaf add temporary sum in ans\\n            ans+=sum;\\n            \\n            sum-=root->val; //subtract current node\\'s value\\n            sum=sum/2; //right shift\\n            return;\\n        }\\n        //if not leaf then continue dfs for its children\\n        dfs(root->left);\\n        dfs(root->right);\\n        sum-=root->val;\\n        sum=sum/2;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        ans=0;\\n        sum=0;\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679980,
                "title": "scala-solution",
                "content": "```\\ndef sumRootToLeaf(root: TreeNode): Int = {\\n        def dfs(root: TreeNode, v: Int):Int = {\\n          if(root == null) return 0;\\n          val ret= v*2 + root.value\\n          if(root.left == null && root.right == null) return ret\\n          return dfs(root.left, ret) + dfs(root.right, ret)\\n        }\\n        return dfs(root, 0)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\ndef sumRootToLeaf(root: TreeNode): Int = {\\n        def dfs(root: TreeNode, v: Int):Int = {\\n          if(root == null) return 0;\\n          val ret= v*2 + root.value\\n          if(root.left == null && root.right == null) return ret\\n          return dfs(root.left, ret) + dfs(root.right, ret)\\n        }\\n        return dfs(root, 0)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 475737,
                "title": "easy-c-dfs",
                "content": "```\\npublic class Solution\\n{\\n    private void Helper(TreeNode node, ref int sum, int current)\\n    {\\n        if (node == null)\\n        {\\n            return;\\n        }\\n\\n        current *= 2;\\n        current += node.val;\\n\\n        if (node.left == null && node.right == null)\\n        {\\n            sum += current;\\n            return;\\n        }\\n\\n        Helper(node.left, ref sum, current);\\n        Helper(node.right, ref sum, current);\\n    }\\n\\n    public int SumRootToLeaf(TreeNode root)\\n    {\\n        int sum = 0;\\n        Helper(root, ref sum, 0);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    private void Helper(TreeNode node, ref int sum, int current)\\n    {\\n        if (node == null)\\n        {\\n            return;\\n        }\\n\\n        current *= 2;\\n        current += node.val;\\n\\n        if (node.left == null && node.right == null)\\n        {\\n            sum += current;\\n            return;\\n        }\\n\\n        Helper(node.left, ref sum, current);\\n        Helper(node.right, ref sum, current);\\n    }\\n\\n    public int SumRootToLeaf(TreeNode root)\\n    {\\n        int sum = 0;\\n        Helper(root, ref sum, 0);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433129,
                "title": "javascript-recursive-99",
                "content": "```\\nvar sumRootToLeaf = function(root) {\\n    const numbers = [];\\n    \\n    const bst = (node, binary) => {\\n        if (!node.left && !node.right) {\\n            numbers.push(binary + node.val);\\n        } else if (!node.left || !node.right) {\\n            if (node.left)\\n                bst(node.left, binary + node.val);\\n            else\\n                bst(node.right, binary + node.val);\\n        } else {\\n            bst(node.left, binary + node.val);\\n            bst(node.right, binary + node.val);\\n        }\\n    };\\n    \\n    bst(root, \\'\\');\\n    \\n    let answer = 0;\\n    for (const num of numbers) {\\n        let parsed = parseInt(num, 2);\\n        answer += parsed;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar sumRootToLeaf = function(root) {\\n    const numbers = [];\\n    \\n    const bst = (node, binary) => {\\n        if (!node.left && !node.right) {\\n            numbers.push(binary + node.val);\\n        } else if (!node.left || !node.right) {\\n            if (node.left)\\n                bst(node.left, binary + node.val);\\n            else\\n                bst(node.right, binary + node.val);\\n        } else {\\n            bst(node.left, binary + node.val);\\n            bst(node.right, binary + node.val);\\n        }\\n    };\\n    \\n    bst(root, \\'\\');\\n    \\n    let answer = 0;\\n    for (const num of numbers) {\\n        let parsed = parseInt(num, 2);\\n        answer += parsed;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350078,
                "title": "c-binary-to-decimal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint res = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n    \\tvector<int> bin;\\n        dfs(root, bin);\\n        return res;\\n    }\\n    \\n    void dfs(TreeNode *curr, vector<int> &bin) {\\n    \\tif(!curr) return;\\n    \\tbin.push_back(curr->val);\\n    \\tif(!curr->left && !curr->right) res += binaryToDecimal(bin);\\n    \\tdfs(curr->left, bin);\\n    \\tdfs(curr->right, bin);\\n\\t\\tbin.pop_back();\\t\\n\\t}\\n\\t\\n\\tint binaryToDecimal(vector<int> &bin) {\\n\\t\\tint sum = 0;\\n\\t\\tfor(int i=0; i<bin.size(); i++) sum += (bin[i])*(pow(2, bin.size()-1-i));\\n\\t\\treturn sum;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint res = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n    \\tvector<int> bin;\\n        dfs(root, bin);\\n        return res;\\n    }\\n    \\n    void dfs(TreeNode *curr, vector<int> &bin) {\\n    \\tif(!curr) return;\\n    \\tbin.push_back(curr->val);\\n    \\tif(!curr->left && !curr->right) res += binaryToDecimal(bin);\\n    \\tdfs(curr->left, bin);\\n    \\tdfs(curr->right, bin);\\n\\t\\tbin.pop_back();\\t\\n\\t}\\n\\t\\n\\tint binaryToDecimal(vector<int> &bin) {\\n\\t\\tint sum = 0;\\n\\t\\tfor(int i=0; i<bin.size(); i++) sum += (bin[i])*(pow(2, bin.size()-1-i));\\n\\t\\treturn sum;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273229,
                "title": "java-runtime-0-ms-faster-than-100-00-memory-usage-37-4-mb-less-than-100-00",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Sum of Root To Leaf Binary Numbers.\\nMemory Usage: 37.4 MB, less than 100.00% of Java online submissions for Sum of Root To Leaf Binary Numbers.\\n```class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSumForAllRootToLeaf(root, 0, 0);\\n\\n    }\\n    public int getSumForAllRootToLeaf(TreeNode root, int total, int curSum) {\\n        if (root == null) return total;\\n\\t\\t\\n        curSum = curSum * 2  + root.val;\\n        if (root.left == null && root.right == null) {\\n            total += curSum;\\n            return total;\\n        }\\n        total = getSumForAllRootToLeaf(root.left, total, curSum);\\n        return getSumForAllRootToLeaf(root.right, total, curSum);\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSumForAllRootToLeaf(root, 0, 0);\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3489755,
                "title": "java-beats-100-recursive-shifting-bits-with-deep-explanation",
                "content": "Dont forget to upvote if you like the content below. \\uD83D\\uDE43\\n\\n# Intuition\\nThe problem asks for the sum of all root-to-leaf binary numbers in a binary tree. A key insight is that the binary number represented by the path from the root to any node is simply the binary number of its parent shifted left by one bit, plus the value of the current node. \\n\\n# Approach\\nWe perform a depth-first search (DFS) traversal on the binary tree, passing the binary number represented by the path from the root to the current node to each recursive call. At each node, we calculate the total sum by shifting the current sum to the left by one bit and adding the value of the current node.\\n\\nIf the current node is a leaf node (both left and right subtrees are `null`), we return the total sum calculated at this node. Otherwise, we return the sum of the sums calculated from the left and right subtrees.\\n\\n# Complexity Analysis\\n- Time complexity: The time complexity is $$O(n)$$, where n is the number of nodes in the binary tree. This is because we visit each node exactly once.\\n- Space complexity: The space complexity is $$O(h)$$, where h is the height of the binary tree. This is because the maximum amount of space is utilized by the recursion stack in the case of a skewed binary tree, which could be $$h$$ levels deep.\\n\\n# Code\\n```java\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return calculateSum(root, 0);\\n    }\\n\\n    private static int calculateSum(TreeNode node, int currentSum) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int totalSum = (currentSum << 1) + node.val;\\n        int leftSubTreeSum = calculateSum(node.left, totalSum);\\n        int rightSubTreeSum = calculateSum(node.right, totalSum);\\n        if (leftSubTreeSum == 0 && rightSubTreeSum == 0) {\\n            return totalSum;\\n        } else {\\n            return leftSubTreeSum + rightSubTreeSum;\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return calculateSum(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3483729,
                "title": "simple-recursive-solution-using-stoi",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root,string a){\\n        if(!root)return;\\n        a.push_back(\\'0\\'+(root->val));\\n        if(!root->left && !root->right) solve(a);\\n        dfs(root->left,a);\\n        dfs(root->right,a);\\n    }\\n    void solve(string a){\\n        int dec = stoi(a, nullptr, 2);\\n        ans=ans+dec;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string a=\"\";\\n        dfs(root,a);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root,string a){\\n        if(!root)return;\\n        a.push_back(\\'0\\'+(root->val));\\n        if(!root->left && !root->right) solve(a);\\n        dfs(root->left,a);\\n        dfs(root->right,a);\\n    }\\n    void solve(string a){\\n        int dec = stoi(a, nullptr, 2);\\n        ans=ans+dec;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string a=\"\";\\n        dfs(root,a);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340817,
                "title": "recursive-preorder-traversal-complexity-analysis",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe traverse the Tree, And keep a Global Answer Variable. We keep a current empty number and traverse the tree, incrementing it accordingly as we traverse the tree. When we reach the leaf node, it indicates end of the current number and needs to be added into the final answer variable. We just do this process for the entire tree and return the answer. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity Analysis\\n# Time Complexity : O(N)\\nHere N is the Number of Nodes in the Binary Tree.\\n(Since we traverse all the Nodes in the Binary Tree)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space Complexity : O(H)\\nHere, H is the height of the Binary Tree.\\n(Since Recursion Stack Space used is of the order of the height of tree).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    long number = 0;\\n    void traverse(TreeNode* root, int curr)\\n    {\\n        if(root==NULL) return;\\n        curr = (curr<<1) | root->val;\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            number += curr;\\n        }\\n        traverse(root->left,curr);\\n        traverse(root->right,curr);\\n    }\\n    long long int sumRootToLeaf(TreeNode* root) \\n    {\\n        if(root == NULL) return 0;\\n        traverse(root,0);\\n        return number;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    long number = 0;\\n    void traverse(TreeNode* root, int curr)\\n    {\\n        if(root==NULL) return;\\n        curr = (curr<<1) | root->val;\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            number += curr;\\n        }\\n        traverse(root->left,curr);\\n        traverse(root->right,curr);\\n    }\\n    long long int sumRootToLeaf(TreeNode* root) \\n    {\\n        if(root == NULL) return 0;\\n        traverse(root,0);\\n        return number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167220,
                "title": "c-backtrack-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, we can always take backTrack solution into consideration while encountering N-ary tree problems.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\neach node would be traversaled only once, so O(n);\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> res;\\n        backTrack(root, res);\\n        return ans;\\n    }\\n    void backTrack(TreeNode* root, vector<int>& res) {\\n        if (!root) return;\\n        // if leaf node now, we calculate the pathSum\\n        if (!root->left && !root->right) {  \\n            res.push_back(root->val);\\n            int N = res.size();\\n            for (int i = N-1; i >= 0; --i) {\\n                ans += res[i] * std::pow(2, N-1-i);\\n            }\\n            res.pop_back();\\n            return;\\n        }\\n        // backTrack\\n        res.push_back(root->val);\\n        backTrack(root->left, res);\\n        backTrack(root->right, res);\\n        res.pop_back();\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> res;\\n        backTrack(root, res);\\n        return ans;\\n    }\\n    void backTrack(TreeNode* root, vector<int>& res) {\\n        if (!root) return;\\n        // if leaf node now, we calculate the pathSum\\n        if (!root->left && !root->right) {  \\n            res.push_back(root->val);\\n            int N = res.size();\\n            for (int i = N-1; i >= 0; --i) {\\n                ans += res[i] * std::pow(2, N-1-i);\\n            }\\n            res.pop_back();\\n            return;\\n        }\\n        // backTrack\\n        res.push_back(root->val);\\n        backTrack(root->left, res);\\n        backTrack(root->right, res);\\n        res.pop_back();\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868440,
                "title": "without-using-mod-20line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust add each path value to the list as we reach at end of path and each value is converted to decimal number and added to total sum;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd each path value to the list as we reach at end of path\\nbut while adding if we reached at root which is null it will add to list value getting from both left and right path as we this will make duplicate addition to tackle this just add value before reaching null which is when left and right is null which avoids duplicates.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        _sum(root, \"\");\\n        int count = 0;\\n        for(String s : res){\\n            System.out.println(s);\\n            count+=Integer.parseInt(s, 2);\\n        }\\n        \\n        return count;\\n    }\\n    private void _sum(TreeNode root, String str){\\n        if(root == null){\\n            \\n            return;\\n        }\\n        if(root.left == null && root.right == null) {\\n            str += root.val;\\n            res.add(str);\\n            return;\\n        }\\n        str += \"\"+ root.val;\\n        _sum(root.left, str);\\n        _sum(root.right, str);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        _sum(root, \"\");\\n        int count = 0;\\n        for(String s : res){\\n            System.out.println(s);\\n            count+=Integer.parseInt(s, 2);\\n        }\\n        \\n        return count;\\n    }\\n    private void _sum(TreeNode root, String str){\\n        if(root == null){\\n            \\n            return;\\n        }\\n        if(root.left == null && root.right == null) {\\n            str += root.val;\\n            res.add(str);\\n            return;\\n        }\\n        str += \"\"+ root.val;\\n        _sum(root.left, str);\\n        _sum(root.right, str);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675357,
                "title": "top-down-approach-dfs-beats-100",
                "content": "//Top down approach, similar to  leetcode problem [https://leetcode.com/problems/sum-root-to-leaf-numbers/]()\\n\\n```\\nclass Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        return dfs(root,0);\\n    }\\n    public int dfs(TreeNode root,int s)\\n    {\\n        if(root==null)\\n            return 0;\\n        if(root.left==null && root.right==null)\\n            return root.val+s*2;\\n        else\\n            return dfs(root.left,root.val+s*2)+\\n                   dfs(root.right,root.val+s*2);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        return dfs(root,0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2666573,
                "title": "c-solution-sum-of-root-to-leaf-binary-numbers",
                "content": "```\\nclass Solution {\\nprivate:\\n    int binarytoInteger(vector<int> bin){\\n        int ans = 0;\\n        int size = bin.size()-1;\\n        for(int i = 0 ; i < bin.size() ; i++){\\n            if(bin[i] == 1){\\n            ans += pow(2,size);\\n            }\\n            size--;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(TreeNode* root , vector<int> path , int &sum){\\n        //base case\\n        if(root == NULL)\\n            return;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            int x = binarytoInteger(path);\\n            sum += x;\\n        }\\n        \\n        solve(root->left , path , sum);\\n        solve(root->right , path , sum);\\n        \\n        path.pop_back();\\n    }\\n    \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> path;\\n        int sum = 0;\\n        solve(root , path , sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int binarytoInteger(vector<int> bin){\\n        int ans = 0;\\n        int size = bin.size()-1;\\n        for(int i = 0 ; i < bin.size() ; i++){\\n            if(bin[i] == 1){\\n            ans += pow(2,size);\\n            }\\n            size--;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(TreeNode* root , vector<int> path , int &sum){\\n        //base case\\n        if(root == NULL)\\n            return;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            int x = binarytoInteger(path);\\n            sum += x;\\n        }\\n        \\n        solve(root->left , path , sum);\\n        solve(root->right , path , sum);\\n        \\n        path.pop_back();\\n    }\\n    \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> path;\\n        int sum = 0;\\n        solve(root , path , sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635118,
                "title": "python-iterative-dfs-solution",
                "content": "\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n  \\n        res  = 0\\n        stack = [(root, \"\")]\\n        \\n        while(stack):\\n            node, path = stack.pop()\\n            if node:\\n                path += str(node.val)\\n\\n                if not(node.left or node.right):\\n                    res += int(path, 2)\\n                else:\\n                    stack.append((node.left, path))\\n                    stack.append((node.right,path))\\n        return res",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n  \\n        res  = 0\\n        stack = [(root, \"\")]\\n        \\n        while(stack):\\n            node, path = stack.pop()\\n            if node:\\n                path += str(node.val)\\n\\n                if not(node.left or node.right):\\n                    res += int(path, 2)\\n                else:\\n                    stack.append((node.left, path))\\n                    stack.append((node.right,path))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2555788,
                "title": "everything-explained-using-comment-java-c-tree",
                "content": "```\\n/* Java Solution */\\nclass Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root,int sum)\\n    {\\n\\t\\t// Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(root == null) return 0;\\n        \\n        sum = (2*sum) + root.val;      // To convert binary to decimal.\\n        \\n        if(root.left == null && root.right == null) return sum;   // If only root is present.\\n        \\n        return sumRootToLeaf(root.left,sum) + sumRootToLeaf(root.right,sum);\\n    }\\n    \\n    \\n    public int sumRootToLeaf(TreeNode root) \\n    {\\n        return sumRootToLeaf(root,0);\\n    }\\n}\\n\\n\\n\\n/* C++ Solution */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode *root,int sum)\\n    {\\n        // Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(!root) return 0;\\n        \\n        sum = (2*sum) + root->val;  // To convert binary to decimal.\\n        \\n        if(!root->left && !root->right) return sum;  // If only root is present.\\n        \\n        return sumRootToLeaf(root->left,sum) + sumRootToLeaf(root->right,sum);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/* Java Solution */\\nclass Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root,int sum)\\n    {\\n\\t\\t// Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(root == null) return 0;\\n        \\n        sum = (2*sum) + root.val;      // To convert binary to decimal.\\n        \\n        if(root.left == null && root.right == null) return sum;   // If only root is present.\\n        \\n        return sumRootToLeaf(root.left,sum) + sumRootToLeaf(root.right,sum);\\n    }\\n    \\n    \\n    public int sumRootToLeaf(TreeNode root) \\n    {\\n        return sumRootToLeaf(root,0);\\n    }\\n}\\n\\n\\n\\n/* C++ Solution */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode *root,int sum)\\n    {\\n        // Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(!root) return 0;\\n        \\n        sum = (2*sum) + root->val;  // To convert binary to decimal.\\n        \\n        if(!root->left && !root->right) return sum;  // If only root is present.\\n        \\n        return sumRootToLeaf(root->left,sum) + sumRootToLeaf(root->right,sum);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549506,
                "title": "100-t-c-90-s-c-easy-short-fast-solutions",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n    public int sumRootToLeaf(TreeNode root) {\\n        sumRootToLeafRecur(root, 0);\\n        return ans;\\n    }\\n    int ans = 0;\\n    private void sumRootToLeafRecur(TreeNode root, int b){\\n        if (root == null) return;\\n        b = (b *= 2) + root.val;\\n        if (root.left == null && root.right == null) ans += b;\\n\\n        sumRootToLeafRecur(root.left, b);\\n        sumRootToLeafRecur(root.right, b);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2317936,
                "title": "beginner-friendly-c-with-simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n  int sum=0;\\n\\n \\n  void rec(TreeNode* root,string s)\\n    \\n  {\\n if(root==NULL )\\n {\\n   return ;\\n }\\n    \\n    if(root->right==NULL && root->left==NULL)\\n      \\n    {\\n     \\n      s+=to_string(root->val);\\n       \\n      //sum=sum+stoi(s);\\n      sum=sum+stoi(s,nullptr,2);\\n  }\\n      \\n      \\n    \\n    s+=to_string(root->val);\\n    rec(root->left,s);\\n    rec(root->right,s);\\n    \\n  }\\n  \\n    \\n    \\n    \\n  \\n    int sumRootToLeaf(TreeNode* root) {\\n      //int n;\\n    string s=\"\";\\n      rec(root,s);\\n      return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int sum=0;\\n\\n \\n  void rec(TreeNode* root,string s)\\n    \\n  {\\n if(root==NULL )\\n {\\n   return ;\\n }\\n    \\n    if(root->right==NULL && root->left==NULL)\\n      \\n    {\\n     \\n      s+=to_string(root->val);\\n       \\n      //sum=sum+stoi(s);\\n      sum=sum+stoi(s,nullptr,2);\\n  }\\n      \\n      \\n    \\n    s+=to_string(root->val);\\n    rec(root->left,s);\\n    rec(root->right,s);\\n    \\n  }\\n  \\n    \\n    \\n    \\n  \\n    int sumRootToLeaf(TreeNode* root) {\\n      //int n;\\n    string s=\"\";\\n      rec(root,s);\\n      return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297499,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        ArrayList<String> arr = new ArrayList<String>();\\n        sumRootToLeafAux(root, \"\", arr);\\n        int ans = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            ans+=Integer.parseInt(arr.get(i), 2);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void sumRootToLeafAux(TreeNode node, String temp, List<String> arr) {\\n        if(node!=null){\\n            temp += node.val;\\n            if(node.left == null && node.right == null){\\n                arr.add(temp);\\n            }\\n            else{\\n                sumRootToLeafAux( node.left,  temp,  arr);\\n                sumRootToLeafAux( node.right,  temp,  arr);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        ArrayList<String> arr = new ArrayList<String>();\\n        sumRootToLeafAux(root, \"\", arr);\\n        int ans = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            ans+=Integer.parseInt(arr.get(i), 2);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void sumRootToLeafAux(TreeNode node, String temp, List<String> arr) {\\n        if(node!=null){\\n            temp += node.val;\\n            if(node.left == null && node.right == null){\\n                arr.add(temp);\\n            }\\n            else{\\n                sumRootToLeafAux( node.left,  temp,  arr);\\n                sumRootToLeafAux( node.right,  temp,  arr);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227161,
                "title": "c-easy-dfs-preorder-approach",
                "content": "**APPROACH :**\\n* In order to track path from root to leaf we ne to transverse using DFS-Preorder method.\\n* And instead of using string we can use shift operator.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t// Recurssive function\\n    void helper(TreeNode*root, int &ans, int p){\\n        // If root is a NULL\\n\\t\\tif(!root) return;\\n        \\n\\t\\t// Update the path value\\n        p = (p<<1)+root->val;\\n\\t\\t\\n\\t\\t// update the ans if the root is a leaf.\\n        if(root->left == NULL && root->right == NULL)\\n            ans += p;\\n        \\n\\t\\t// DFS Preorder transversal\\n        helper(root->left, ans, p);\\n        helper(root->right, ans, p);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n\\t\\tint ans=0;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you  find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t// Recurssive function\\n    void helper(TreeNode*root, int &ans, int p){\\n        // If root is a NULL\\n\\t\\tif(!root) return;\\n        \\n\\t\\t// Update the path value\\n        p = (p<<1)+root->val;\\n\\t\\t\\n\\t\\t// update the ans if the root is a leaf.\\n        if(root->left == NULL && root->right == NULL)\\n            ans += p;\\n        \\n\\t\\t// DFS Preorder transversal\\n        helper(root->left, ans, p);\\n        helper(root->right, ans, p);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n\\t\\tint ans=0;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148522,
                "title": "python-3-easy-solution",
                "content": "```\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        stack = []\\n        def dfs(root, s):\\n            \\n            if not root:\\n                return\\n            each_val = str(root.val)\\n            if not root.left and not root.right:\\n                stack.append(int(s+each_val, 2))\\n                return\\n            \\n            dfs(root.left, s+each_val) \\n            \\n            dfs(root.right, s+each_val) \\n\\n        dfs(root, \"\")\\n        return(sum(stack))\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        stack = []\\n        def dfs(root, s):\\n            \\n            if not root:\\n                return\\n            each_val = str(root.val)\\n            if not root.left and not root.right:\\n                stack.append(int(s+each_val, 2))\\n                return\\n            \\n            dfs(root.left, s+each_val) \\n            \\n            dfs(root.right, s+each_val) \\n\\n        dfs(root, \"\")\\n        return(sum(stack))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2093508,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>>ans=new ArrayList<>();\\n    ArrayList<Integer>temp=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        createlist(root);\\n        int tsum = 0;\\n        for(int i=0;i<ans.size();i++){\\n            tsum= tsum + sum(ans.get(i));\\n        }\\n        return tsum;\\n    }\\n    public static int sum(ArrayList<Integer>temp){\\n        int sum = 0;\\n        int x = 0;\\n        for(int i=temp.size()-1;i>=0;i--){\\n            sum+=temp.get(i)*Math.pow(2,x);\\n            x++;\\n        }\\n        return sum;\\n    }\\n    \\n     public void createlist(TreeNode root){\\n        if(root == null ){\\n            return ;\\n        }\\n        temp.add(root.val);\\n        if(root.left==null && root.right == null){\\n            ans.add(new ArrayList<Integer>(temp));\\n        }\\n        createlist(root.left);\\n        createlist(root.right);\\n        temp.remove(temp.size()-1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>>ans=new ArrayList<>();\\n    ArrayList<Integer>temp=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        createlist(root);\\n        int tsum = 0;\\n        for(int i=0;i<ans.size();i++){\\n            tsum= tsum + sum(ans.get(i));\\n        }\\n        return tsum;\\n    }\\n    public static int sum(ArrayList<Integer>temp){\\n        int sum = 0;\\n        int x = 0;\\n        for(int i=temp.size()-1;i>=0;i--){\\n            sum+=temp.get(i)*Math.pow(2,x);\\n            x++;\\n        }\\n        return sum;\\n    }\\n    \\n     public void createlist(TreeNode root){\\n        if(root == null ){\\n            return ;\\n        }\\n        temp.add(root.val);\\n        if(root.left==null && root.right == null){\\n            ans.add(new ArrayList<Integer>(temp));\\n        }\\n        createlist(root.left);\\n        createlist(root.right);\\n        temp.remove(temp.size()-1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958546,
                "title": "python-eli5-a-solution-that-used-dfs-and-backtracing",
                "content": "A lot of the solutions for this question use something other than DFS or Backtracking. I guarantee that if you pull bitwise operators during an interview in which the interviewer is looking for your knowledge of DFS / Backtracking, you won\\'t get the job. so lets look at how this is supposed to be solved, even if it\\'s not the fastest way to do it.\\n\\nThe problem states that we need to get the binary number from the root to **all** the leaves in the tree. This phrase alone tells us that we need DFS with Backtracking. \\n\\nFor general reference, any problem that needs Backtracking will have a solution that looks like the following pseudocode:\\n\\n```python\\ndef dfs(node, state):\\n\\tif state is a solution:\\n\\t\\trecord(state)\\n\\t\\treturn\\n\\t\\n\\tfor child in children:\\n\\t\\tif child is part of solution:\\n\\t\\t\\tstate.add(child)\\n\\t\\t\\tdfs(child, state)\\n\\t\\t\\tstate.remove(child)\\n```\\n\\nFollow this format for permutation questions.\\n\\nLet\\'s look at the first part: If the current state is a solution. We\\'ll know we\\'ve got a solution for this problem once we\\'ve reached a leaf node. Therefore our if statement should look like this:\\n\\n```python\\n\\tif node.left is None and node.right is None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tanswer.append(\\'\\'.join(path))\\n\\t\\tpath.pop()\\n\\t\\treturn\\n```\\n\\nWe will add the current node to our current state, then save it to our collection of answers, then pop it before backtracking.\\n\\nNow we need to think about what to do if we\\'re not currently at a leaf node. Well, we need to append to the current state and go down both left and right until we reach a leaf node! So the second part of our format will look like this:\\n\\n```python\\n\\tif node.left is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.left, path)\\n\\t\\tpath.pop()\\n\\t\\n\\tif node.right is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.right, path)\\n\\t\\tpath.pop()\\n```\\n\\nNow we just put it all together and add a data structure to keep our potential answers with:\\n\\n```python\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        answer = []\\n        def dfs(node, path):\\n            if node.left is None and node.right is None:\\n                path.append(str(node.val))\\n                answer.append(\\'\\'.join(path))\\n                path.pop()\\n                return\\n\\n            if node.left is not None:\\n                path.append(str(node.val))\\n                dfs(node.left, path)\\n                path.pop()\\n            if node.right is not None:\\n                path.append(str(node.val))\\n                dfs(node.right, path)\\n                path.pop()\\n                \\n        dfs(root, [])\\n```\\n\\nNow our `answer` array has the string representations of each root-to-leaf branch in our tree. It\\'s a simple matter of converting these binary strings to integers and adding them up:\\n\\n```python\\n\\tvalue = 0\\n\\tfor digits in answer:\\n\\t\\tvalue += int(digits, 2)\\n\\treturn value\\n```\\n\\nThis is not the fastest answer, but if you\\'re actually doing an interview, this is at least closer to what they will expect from you, and it is also much easier to explain during your interview.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```python\\ndef dfs(node, state):\\n\\tif state is a solution:\\n\\t\\trecord(state)\\n\\t\\treturn\\n\\t\\n\\tfor child in children:\\n\\t\\tif child is part of solution:\\n\\t\\t\\tstate.add(child)\\n\\t\\t\\tdfs(child, state)\\n\\t\\t\\tstate.remove(child)\\n```\n```python\\n\\tif node.left is None and node.right is None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tanswer.append(\\'\\'.join(path))\\n\\t\\tpath.pop()\\n\\t\\treturn\\n```\n```python\\n\\tif node.left is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.left, path)\\n\\t\\tpath.pop()\\n\\t\\n\\tif node.right is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.right, path)\\n\\t\\tpath.pop()\\n```\n```python\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        answer = []\\n        def dfs(node, path):\\n            if node.left is None and node.right is None:\\n                path.append(str(node.val))\\n                answer.append(\\'\\'.join(path))\\n                path.pop()\\n                return\\n\\n            if node.left is not None:\\n                path.append(str(node.val))\\n                dfs(node.left, path)\\n                path.pop()\\n            if node.right is not None:\\n                path.append(str(node.val))\\n                dfs(node.right, path)\\n                path.pop()\\n                \\n        dfs(root, [])\\n```\n```python\\n\\tvalue = 0\\n\\tfor digits in answer:\\n\\t\\tvalue += int(digits, 2)\\n\\treturn value\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1951065,
                "title": "simplest-solution-easiest-to-understand-0ms-runtime-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        return preorder(root,0);\\n\\n    }\\n    \\n    public int preorder(TreeNode root, int sum) {\\n    \\n        if(root==null)\\n            return 0;\\n        \\n        sum= (2*sum) + root.val;\\n        \\n        if(root.left==null && root.right==null)\\n            return sum;\\n        \\n       return preorder(root.left,sum) + preorder(root.right,sum); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        return preorder(root,0);\\n\\n    }\\n    \\n    public int preorder(TreeNode root, int sum) {\\n    \\n        if(root==null)\\n            return 0;\\n        \\n        sum= (2*sum) + root.val;\\n        \\n        if(root.left==null && root.right==null)\\n            return sum;\\n        \\n       return preorder(root.left,sum) + preorder(root.right,sum); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682872,
                "title": "recursive-approach-o-n-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root , int val = 0) {\\n        // recursive approach\\n        // TC-> O(N)  SC-> O(H)\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root , int val = 0) {\\n        // recursive approach\\n        // TC-> O(N)  SC-> O(H)\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682782,
                "title": "c-solution-beginner-friendly-recursion-backtracking",
                "content": "*Please upvote if you find helpful :)*\\n```\\nclass Solution {\\npublic:\\n    int bintodecimal(string s) {\\n        int len = s.length(), ans=0;\\n        for(int i=0;s[i];i++)\\n            ans += (s[i]-\\'0\\')*pow(2, len-i-1);\\n        return ans;\\n    }\\n    void allPaths(TreeNode* root, string &v1, vector<string> &v) {\\n        if(root==NULL)\\n            return;\\n        if(root->left==NULL && root->right==NULL) {\\n            v1+=(to_string(root->val));\\n            v.push_back(v1);\\n            v1.pop_back();\\n            return;\\n        }\\n        v1+=(to_string(root->val));\\n        allPaths(root->left, v1, v);\\n        allPaths(root->right, v1, v);\\n        v1.pop_back();\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string v1=\"\";\\n        vector<string> v;\\n        allPaths(root, v1, v);\\n        int ans=0;\\n        for(auto x: v) {\\n            int d = bintodecimal(x);\\n            ans += d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bintodecimal(string s) {\\n        int len = s.length(), ans=0;\\n        for(int i=0;s[i];i++)\\n            ans += (s[i]-\\'0\\')*pow(2, len-i-1);\\n        return ans;\\n    }\\n    void allPaths(TreeNode* root, string &v1, vector<string> &v) {\\n        if(root==NULL)\\n            return;\\n        if(root->left==NULL && root->right==NULL) {\\n            v1+=(to_string(root->val));\\n            v.push_back(v1);\\n            v1.pop_back();\\n            return;\\n        }\\n        v1+=(to_string(root->val));\\n        allPaths(root->left, v1, v);\\n        allPaths(root->right, v1, v);\\n        v1.pop_back();\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string v1=\"\";\\n        vector<string> v;\\n        allPaths(root, v1, v);\\n        int ans=0;\\n        for(auto x: v) {\\n            int d = bintodecimal(x);\\n            ans += d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681853,
                "title": "recursion-java-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int sumRootToLeaf(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n        sum = (sum << 1) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root){\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int sumRootToLeaf(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n        sum = (sum << 1) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root){\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681847,
                "title": "javascript-bitwise-operation",
                "content": "```js\\nfunction sumRootToLeaf(node, cur = 0) {\\n  if (!node) {\\n    return 0;\\n  }\\n  cur = (cur << 1) | node.val;\\n  return node.left === node.right ? cur : sumRootToLeaf(node.left, cur) + sumRootToLeaf(node.right, cur);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction sumRootToLeaf(node, cur = 0) {\\n  if (!node) {\\n    return 0;\\n  }\\n  cur = (cur << 1) | node.val;\\n  return node.left === node.right ? cur : sumRootToLeaf(node.left, cur) + sumRootToLeaf(node.right, cur);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681578,
                "title": "python3-dfs-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        # defining a global variable for recursive helper to modify\\n        ret = [0]\\n        def helper(curr, currpath):\\n            if curr is None:\\n                return\\n            \\n            # case where leaf node has been reached\\n            if curr.left is None and curr.right is None:\\n                currpath.append(curr.val)\\n                bin_str = \"\".join(map(str, currpath))\\n                ret[0] += int(bin_str, 2)\\n                currpath.pop()\\n                return\\n            \\n            # append the current node\\'s value to the array before processing children\\n            currpath.append(curr.val)\\n            helper(curr.left, currpath)\\n            helper(curr.right, currpath)\\n            \\n            # remove the current node\\'s value before returning to callee\\n            currpath.pop()\\n            \\n        helper(root, [])\\n        return ret[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        # defining a global variable for recursive helper to modify\\n        ret = [0]\\n        def helper(curr, currpath):\\n            if curr is None:\\n                return\\n            \\n            # case where leaf node has been reached\\n            if curr.left is None and curr.right is None:\\n                currpath.append(curr.val)\\n                bin_str = \"\".join(map(str, currpath))\\n                ret[0] += int(bin_str, 2)\\n                currpath.pop()\\n                return\\n            \\n            # append the current node\\'s value to the array before processing children\\n            currpath.append(curr.val)\\n            helper(curr.left, currpath)\\n            helper(curr.right, currpath)\\n            \\n            # remove the current node\\'s value before returning to callee\\n            currpath.pop()\\n            \\n        helper(root, [])\\n        return ret[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664685,
                "title": "c-recursion",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void fun(TreeNode *root, int sum){\\n        if(!root) return;\\n        if(!root->left && !root->right){\\n            sum=sum*2+root->val;\\n            ans+=sum;\\n            return;\\n        }\\n        if(root) sum=sum*2+(root->val);\\n        fun(root->left, sum);\\n        fun(root->right, sum);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        fun(root, sum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void fun(TreeNode *root, int sum){\\n        if(!root) return;\\n        if(!root->left && !root->right){\\n            sum=sum*2+root->val;\\n            ans+=sum;\\n            return;\\n        }\\n        if(root) sum=sum*2+(root->val);\\n        fun(root->left, sum);\\n        fun(root->right, sum);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        fun(root, sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514309,
                "title": "python-recursive",
                "content": "```\\n\\tdef sumRootToLeaf(self, root):\\n        return self.recursive(root, \"\")\\n        \\n    def recursive(self, root, binary_str):\\n        left = right = 0\\n        binary_str += str(root.val)\\n        \\n        if not root.left and not root.right:\\n            return int(binary_str, 2)\\n        \\n        if root.left:\\n            left = self.recursive(root.left, binary_str)\\n        if root.right:\\n            right = self.recursive(root.right, binary_str)\\n        \\n        return left + right",
                "solutionTags": [],
                "code": "```\\n\\tdef sumRootToLeaf(self, root):\\n        return self.recursive(root, \"\")\\n        \\n    def recursive(self, root, binary_str):\\n        left = right = 0\\n        binary_str += str(root.val)\\n        \\n        if not root.left and not root.right:\\n            return int(binary_str, 2)\\n        \\n        if root.left:\\n            left = self.recursive(root.left, binary_str)\\n        if root.right:\\n            right = self.recursive(root.right, binary_str)\\n        \\n        return left + right",
                "codeTag": "Python3"
            },
            {
                "id": 1506898,
                "title": "java-basic-approach",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        helper(root, new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(TreeNode root, List<Integer> ls) {\\n        if (root == null) return;\\n        ls.add(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            int size = ls.size();\\n            int i = 0;\\n            for (int j = size - 1; j >= 0; j--) {\\n                ans += ls.get(j) * Math.pow(2, i);\\n                i++;\\n            }\\n        } else {\\n            helper(root.left, ls);\\n            helper(root.right, ls);\\n        }\\n        ls.remove(ls.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        helper(root, new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(TreeNode root, List<Integer> ls) {\\n        if (root == null) return;\\n        ls.add(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            int size = ls.size();\\n            int i = 0;\\n            for (int j = size - 1; j >= 0; j--) {\\n                ans += ls.get(j) * Math.pow(2, i);\\n                i++;\\n            }\\n        } else {\\n            helper(root.left, ls);\\n            helper(root.right, ls);\\n        }\\n        ls.remove(ls.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381894,
                "title": "explained-code-c-dfs",
                "content": "we are adding the value of the path in a variable named t. for every new node we are multiplying the **t** with 2 and adding the value of that particular node. (why multiplying it by 2?)\\nlets say we have a number in decimal say :5678\\nwe can write it as num=5 * 10+6;\\nnum+=num * 10+7;\\nnum+=num*10+8\\n\\nin the same way we can write the binary value say \"10110\" as\\nbin=bin * 2+1;\\nbin+=bin * 2+0;\\nbin+=bin * 2+1;\\nbin+=bin * 2+1;\\nbin+=bin * 2+0;\\n\\nand when even i am encountering a leaf node i am just adding the value in sum.\\n\\n**I hope i made you understand my approach.\\nplease upvote if you liked my solution**\\n\\n\\n#happy_coding\\n\\n```\\nint sum=0;\\n    void helper(TreeNode* root,int t)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        t*=2;\\n        t+=root->val;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            sum+=t;\\n        }\\n        if(root->left)\\n        {\\n            helper(root->left,t);\\n        }\\n        if(root->right)\\n        {\\n            helper(root->right,t);\\n        }\\n        return;\\n    }\\n    \\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root,0);\\n        return sum; \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint sum=0;\\n    void helper(TreeNode* root,int t)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        t*=2;\\n        t+=root->val;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            sum+=t;\\n        }\\n        if(root->left)\\n        {\\n            helper(root->left,t);\\n        }\\n        if(root->right)\\n        {\\n            helper(root->right,t);\\n        }\\n        return;\\n    }\\n    \\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root,0);\\n        return sum; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343704,
                "title": "python-solution-using-strings-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\ndef sum_root(root, parent_string):\\n    total = 0\\n    \\n    if root is None:\\n        return total\\n\\n    if root.left is None and root.right is None:\\n        total += int(parent_string + str(root.val), 2)\\n\\n    else:\\n        if root.right:\\n            total += sum_root(root.right, parent_string + str(root.val))\\n\\n        if root.left:\\n            total += sum_root(root.left, parent_string + str(root.val))\\n    \\n    return total\\n    \\n    \\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return sum_root(root, \\'\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\ndef sum_root(root, parent_string):\\n    total = 0\\n    \\n    if root is None:\\n        return total\\n\\n    if root.left is None and root.right is None:\\n        total += int(parent_string + str(root.val), 2)\\n\\n    else:\\n        if root.right:\\n            total += sum_root(root.right, parent_string + str(root.val))\\n\\n        if root.left:\\n            total += sum_root(root.left, parent_string + str(root.val))\\n    \\n    return total\\n    \\n    \\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return sum_root(root, \\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256676,
                "title": "easy-to-understand-c-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int sum=0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        if(!root)\\n            return 0;\\n        inorder(root);\\n        return sum;\\n        \\n    }\\n    \\n    void inorder(TreeNode* node){\\n        if(!node)\\n            return;\\n        \\n        v.push_back(node->val);\\n        \\n        inorder(node->left);\\n        inorder(node->right);\\n        if(!node->left && !node->right){\\n         int r=v.size();\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i]*pow(2,r-1);\\n            r--;\\n          }\\n        }\\n        v.pop_back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int sum=0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        if(!root)\\n            return 0;\\n        inorder(root);\\n        return sum;\\n        \\n    }\\n    \\n    void inorder(TreeNode* node){\\n        if(!node)\\n            return;\\n        \\n        v.push_back(node->val);\\n        \\n        inorder(node->left);\\n        inorder(node->right);\\n        if(!node->left && !node->right){\\n         int r=v.size();\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i]*pow(2,r-1);\\n            r--;\\n          }\\n        }\\n        v.pop_back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230775,
                "title": "c-simple-and-easily-understandable-solution",
                "content": "```\\nstring s=\"\";\\n    int Supersum = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        help(root, 0);\\n        return Supersum;\\n    }\\n    void help(TreeNode* root, int sum)\\n    {\\n        if(root == NULL) { return; }\\n        s += to_string(root->val);\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            Supersum += stoi(s, 0, 2);\\n            // cout<<\"Sum added\"<<endl;\\n        }\\n        if(root->left) { help(root->left, Supersum); }\\n        if(root->right) { help(root->right, Supersum); }\\n        s.erase(s.end()-1);\\n    }\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nstring s=\"\";\\n    int Supersum = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        help(root, 0);\\n        return Supersum;\\n    }\\n    void help(TreeNode* root, int sum)\\n    {\\n        if(root == NULL) { return; }\\n        s += to_string(root->val);\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            Supersum += stoi(s, 0, 2);\\n            // cout<<\"Sum added\"<<endl;\\n        }\\n        if(root->left) { help(root->left, Supersum); }\\n        if(root->right) { help(root->right, Supersum); }\\n        s.erase(s.end()-1);\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1211525,
                "title": "java-recursion-0ms-beats-100-t-c-o-n-s-c-o-n",
                "content": "\\n    // O(n) O(n)\\n\\tpublic int sumRootToLeaf(TreeNode root) {\\n\\t\\treturn sumRootToLeafHelper(root, 0);\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\tpublic int sumRootToLeafHelper(TreeNode root, int dec) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (root.left == null && root.right == null)\\n\\t\\t\\treturn (dec << 1) | root.val;\\n\\n\\t\\tint temp = dec;\\n\\t\\ttemp = (temp << 1) | root.val;\\n\\t\\tint left = sumRootToLeafHelper(root.left, temp);\\n\\t\\tint right = sumRootToLeafHelper(root.right, temp);\\n\\n\\t\\treturn left + right;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(n) O(n)\\n\\tpublic int sumRootToLeaf(TreeNode root) {\\n\\t\\treturn sumRootToLeafHelper(root, 0);\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\tpublic int sumRootToLeafHelper(TreeNode root, int dec) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (root.left == null && root.right == null)\\n\\t\\t\\treturn (dec << 1) | root.val;\\n\\n\\t\\tint temp = dec;\\n\\t\\ttemp = (temp << 1) | root.val;\\n\\t\\tint left = sumRootToLeafHelper(root.left, temp);\\n\\t\\tint right = sumRootToLeafHelper(root.right, temp);\\n\\n\\t\\treturn left + right;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1164720,
                "title": "weeb-does-python-bfs",
                "content": "Step 1: use bfs to get from root to leaf\\nStep 2: use the curpath to get the sum of each binary digit\\n\\nPlease note that my solution requires a basic understanding of how to get the value of a binary digit\\nif u dont know then here is an example:\\n\\nlet curpath == [1, 0, 0]. This means my binary digit is 100 according to my code below\\nSo, to convert it to a value it should be done like this:\\n100 == 2 ** 2 + 0 + 0 == 4  so 100 binary digit is 4 in integer value\\n\\nif binary digit is 0 then we ignore it\\nif binary digit is 1 then we 2 ** of current position of digit(0 indexed btw).\\n\\nanother example: let curpath == [1, 0, 1, 0, 1] so binary digit is 10101\\n10101 == 2 ** 4 + 0 + 2 ** 2 + 0 + 2 ** 0 == 21 so 10101 in binary digit is 21 in integer value\\n\\nhope u understand it cuz if u dont then u probably wont understand my code\\n\\n\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\t\\t\\tqueue, total = deque([(root, [root.val], 0)]), 0\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tcurNode, curpath, length = queue.popleft()\\n\\n\\t\\t\\t\\tif not curNode.left and not curNode.right:\\n\\t\\t\\t\\t\\tfor val in curpath:\\n\\t\\t\\t\\t\\t\\tif val == 1: \\n\\t\\t\\t\\t\\t\\t\\ttotal += 2 ** length \\n\\t\\t\\t\\t\\t\\tlength -= 1\\n\\n\\t\\t\\t\\tif curNode.left:\\n\\t\\t\\t\\t\\tqueue.append((curNode.left, curpath + [curNode.left.val], length + 1))\\n\\n\\t\\t\\t\\tif curNode.right:\\n\\t\\t\\t\\t\\tqueue.append((curNode.right, curpath + [curNode.right.val], length + 1))\\n\\n\\t\\t\\treturn total\\n\\nAnyways, now its time for some anime recommendations\\n# Hurry up and watch ***Golden Time***\\n\\n## Genre: Romantic comedy\\n## Episodes: 24\\n\\n**Best romcom of all time**, The plot was good and the character development in this show is amazing.\\nI highly recommend you to watch it\\nNow stop coding, get a snicker, a sprite and slack off cuz its anime time.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "Step 1: use bfs to get from root to leaf\\nStep 2: use the curpath to get the sum of each binary digit\\n\\nPlease note that my solution requires a basic understanding of how to get the value of a binary digit\\nif u dont know then here is an example:\\n\\nlet curpath == [1, 0, 0]. This means my binary digit is 100 according to my code below\\nSo, to convert it to a value it should be done like this:\\n100 == 2 ** 2 + 0 + 0 == 4  so 100 binary digit is 4 in integer value\\n\\nif binary digit is 0 then we ignore it\\nif binary digit is 1 then we 2 ** of current position of digit(0 indexed btw).\\n\\nanother example: let curpath == [1, 0, 1, 0, 1] so binary digit is 10101\\n10101 == 2 ** 4 + 0 + 2 ** 2 + 0 + 2 ** 0 == 21 so 10101 in binary digit is 21 in integer value\\n\\nhope u understand it cuz if u dont then u probably wont understand my code\\n\\n\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\t\\t\\tqueue, total = deque([(root, [root.val], 0)]), 0\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tcurNode, curpath, length = queue.popleft()\\n\\n\\t\\t\\t\\tif not curNode.left and not curNode.right:\\n\\t\\t\\t\\t\\tfor val in curpath:\\n\\t\\t\\t\\t\\t\\tif val == 1: \\n\\t\\t\\t\\t\\t\\t\\ttotal += 2 ** length \\n\\t\\t\\t\\t\\t\\tlength -= 1\\n\\n\\t\\t\\t\\tif curNode.left:\\n\\t\\t\\t\\t\\tqueue.append((curNode.left, curpath + [curNode.left.val], length + 1))\\n\\n\\t\\t\\t\\tif curNode.right:\\n\\t\\t\\t\\t\\tqueue.append((curNode.right, curpath + [curNode.right.val], length + 1))\\n\\n\\t\\t\\treturn total\\n\\nAnyways, now its time for some anime recommendations\\n# Hurry up and watch ***Golden Time***\\n\\n## Genre: Romantic comedy\\n## Episodes: 24\\n\\n**Best romcom of all time**, The plot was good and the character development in this show is amazing.\\nI highly recommend you to watch it\\nNow stop coding, get a snicker, a sprite and slack off cuz its anime time.\\n",
                "codeTag": "Java"
            },
            {
                "id": 1052127,
                "title": "simple-java-solution-100-recursion",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        List<Integer> nums = new ArrayList<>();\\n        return search(root, 0);\\n    }\\n\\n    public int search(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n\\n        sum = sum*2 + root.val;\\n        if(root.left == null && root.right == null) return sum; // reached out leaf node.\\n        return search(root.left, sum) + search(root.right, sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        List<Integer> nums = new ArrayList<>();\\n        return search(root, 0);\\n    }\\n\\n    public int search(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n\\n        sum = sum*2 + root.val;\\n        if(root.left == null && root.right == null) return sum; // reached out leaf node.\\n        return search(root.left, sum) + search(root.right, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024541,
                "title": "python-recursive-preorder-with-binary-string-to-decimal-conversion",
                "content": "##### Implementing a simple recursive pre-order function with an array for strings made by traversing till each leaf-node.\\nWith each recursion-call check if current-node is a leaf:\\n\\tIf yes, then append currently created string value to the res-array.\\n\\tIf no, then push left and right child nodes onto the stack.\\n\\nFinally just convert your string arrays into decimal using the int function and sum up the res-array.\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(root: TreeNode, res: str):\\n            if root:\\n                if root.left is None and root.right is None:\\n                    arr.append(res+str(root.val))\\n                else:\\n                    dfs(root.left, res+str(root.val))\\n                    dfs(root.right, res+str(root.val))\\n\\n        arr=[]\\n        dfs(root, \\'\\')\\n        return sum([int(i,2) for i in arr])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(root: TreeNode, res: str):\\n            if root:\\n                if root.left is None and root.right is None:\\n                    arr.append(res+str(root.val))\\n                else:\\n                    dfs(root.left, res+str(root.val))\\n                    dfs(root.right, res+str(root.val))\\n\\n        arr=[]\\n        dfs(root, \\'\\')\\n        return sum([int(i,2) for i in arr])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888559,
                "title": "python-a-clear-and-simple-dfs-implementation-time-o-n-space-o-h",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, num):\\n            if not node:\\n                return\\n            \\n            num = 2*num + node.val                        \\n            if not node.left and not node.right:\\n                self.sum_ += num\\n                return            \\n            dfs(node.left, num)                \\n            dfs(node.right, num)\\n            \\n        self.sum_ = 0\\n        dfs(root, 0)\\n        return self.sum_\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, num):\\n            if not node:\\n                return\\n            \\n            num = 2*num + node.val                        \\n            if not node.left and not node.right:\\n                self.sum_ += num\\n                return            \\n            dfs(node.left, num)                \\n            dfs(node.right, num)\\n            \\n        self.sum_ = 0\\n        dfs(root, 0)\\n        return self.sum_\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836878,
                "title": "rust-dfs-100-bitshift-and-bitwise-or",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let int = 0;\\n        let mut sum = 0;\\n        if let Some(n) = root {\\n            Self::dfs(n, int, &mut sum);\\n        }\\n        sum\\n    }\\n    fn dfs(n: Rc<RefCell<TreeNode>>, int: i32, sum: &mut i32) {\\n        let next_int = (int << 1) | n.borrow().val;\\n        if n.borrow().left.is_none() && n.borrow().right.is_none() {\\n            *sum += next_int;\\n        } else {\\n            if let Some(l) = n.borrow().left.clone() {\\n                Self::dfs(l, next_int, sum);\\n            }\\n            if let Some(r) = n.borrow().right.clone() {\\n                Self::dfs(r, next_int, sum);           \\n            }          \\n        }\\n\\n    }\\n}\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let int = 0;\\n        let mut sum = 0;\\n        if let Some(n) = root {\\n            Self::dfs(n, int, &mut sum);\\n        }\\n        sum\\n    }\\n    fn dfs(n: Rc<RefCell<TreeNode>>, int: i32, sum: &mut i32) {\\n        let next_int = (int << 1) | n.borrow().val;\\n        if n.borrow().left.is_none() && n.borrow().right.is_none() {\\n            *sum += next_int;\\n        } else {\\n            if let Some(l) = n.borrow().left.clone() {\\n                Self::dfs(l, next_int, sum);\\n            }\\n            if let Some(r) = n.borrow().right.clone() {\\n                Self::dfs(r, next_int, sum);           \\n            }          \\n        }\\n\\n    }\\n}\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836445,
                "title": "sum-of-root-to-leaf-binary-numbers",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n        def sum_leafs(node, path=[]):\\n            if node is None:\\n                return 0\\n            if node.left is None and node.right is None:\\n                path.append(node.val)\\n                return int(\\'\\'.join(map(str, path)), 2) \\n            return (\\n                sum_leafs(node.right, path + [node.val]) +\\n                sum_leafs(node.left, path + [node.val]))\\n\\n        return sum_leafs(root)\\n```\\n\\nEdit:\\nBasicaly the idea is memoizing path (a list of integers) while travesing the tree and detect when we reach a leaf node and then sum up all of them.\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n        def sum_leafs(node, path=[]):\\n            if node is None:\\n                return 0\\n            if node.left is None and node.right is None:\\n                path.append(node.val)\\n                return int(\\'\\'.join(map(str, path)), 2) \\n            return (\\n                sum_leafs(node.right, path + [node.val]) +\\n                sum_leafs(node.left, path + [node.val]))\\n\\n        return sum_leafs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836385,
                "title": "c-dfs-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int &ans, int k) {\\n        if(root==NULL) {\\n            return ;\\n        }\\n        k = (k<<1)|(root->val);\\n        if(!root->left && !root->right) {\\n            ans+=k;\\n            return;\\n        }\\n        solve(root->left,ans, k);\\n        solve(root->right, ans, k);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int ans=0,k=0;\\n        solve(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int &ans, int k) {\\n        if(root==NULL) {\\n            return ;\\n        }\\n        k = (k<<1)|(root->val);\\n        if(!root->left && !root->right) {\\n            ans+=k;\\n            return;\\n        }\\n        solve(root->left,ans, k);\\n        solve(root->right, ans, k);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int ans=0,k=0;\\n        solve(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836246,
                "title": "python-easy-solution",
                "content": "```\\ndef sumRootToLeaf(self, root):\\n\\t\"\"\"\\n\\t:type root: TreeNode\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tnums = []\\n\\tdef dfs(node, s):\\n\\t\\ts += str(node.val)\\n\\t\\tif node.left:\\n\\t\\t\\tdfs(node.left, s)\\n\\t\\tif node.right:\\n\\t\\t\\tdfs(node.right, s)\\n\\t\\tif not node.left and not node.right:\\n\\t\\t\\tnums.append(s)\\n\\tdfs(root, \\'\\')\\n\\treturn sum(int(s, 2) for s in nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef sumRootToLeaf(self, root):\\n\\t\"\"\"\\n\\t:type root: TreeNode\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tnums = []\\n\\tdef dfs(node, s):\\n\\t\\ts += str(node.val)\\n\\t\\tif node.left:\\n\\t\\t\\tdfs(node.left, s)\\n\\t\\tif node.right:\\n\\t\\t\\tdfs(node.right, s)\\n\\t\\tif not node.left and not node.right:\\n\\t\\t\\tnums.append(s)\\n\\tdfs(root, \\'\\')\\n\\treturn sum(int(s, 2) for s in nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 836224,
                "title": "python-solution-explanation-o-n-4-lines-only",
                "content": "In order to solve the problem we traverse the tree in a **Preorder Traversal** i.e. Root -> Left ->Right. We first calculate sum value calaculate upto the given node and then traverse for the subsequent left and right sub tree and then add them\\n\\n**Basic Formula Used:** \\nn << 1 | root.value\\nWhen we left shift a binary number say 11, the result is 110 and then OR the root value, we get our required sum for the given node. Time Complexity is O(N) since all nodes are visted only once.\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self.calcSum(root, 0)\\n    \\n    def calcSum(self, root: TreeNode, n: int) -> int:\\n        \\n        if(root == None): return 0\\n        n = n << 1 | root.val\\n        if(root.left == None and root.right == None): return n\\n        return ( self.calcSum(root.left,n) + self.calcSum(root.right,n) )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self.calcSum(root, 0)\\n    \\n    def calcSum(self, root: TreeNode, n: int) -> int:\\n        \\n        if(root == None): return 0\\n        n = n << 1 | root.val\\n        if(root.left == None and root.right == None): return n\\n        return ( self.calcSum(root.left,n) + self.calcSum(root.right,n) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835893,
                "title": "python-very-easy-to-understand-runtime-beats-94-python-submissions",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.res = 0\\n        def traverse(root,s):\\n            if root:\\n                s += str(root.val)\\n                if not root.left and not root.right:\\n                    self.res += int(s,2)    #Binary to Decimal Conversion and value addition\\n                    return\\n                traverse(root.left,s)\\n                traverse(root.right,s)\\n            return\\n        traverse(root,\\'\\')\\n        return(self.res)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please Upvote!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.res = 0\\n        def traverse(root,s):\\n            if root:\\n                s += str(root.val)\\n                if not root.left and not root.right:\\n                    self.res += int(s,2)    #Binary to Decimal Conversion and value addition\\n                    return\\n                traverse(root.left,s)\\n                traverse(root.right,s)\\n            return\\n        traverse(root,\\'\\')\\n        return(self.res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754275,
                "title": "kotlin-shift-left-of-bits",
                "content": "```\\n    private var sum = 0\\n    fun sumRootToLeaf(root: TreeNode?): Int {\\n        if (root == null) return sum\\n        paths(root, root.`val`)\\n        return sum\\n    }\\n    \\n    private fun paths(root: TreeNode, path: Int) {\\n        if (root.left == null && root.right == null) { // we have reached a leaf\\n            sum += path\\n            return\\n        }\\n        root.left?.let {\\n            val leftPath = (path shl 1) + it.`val` // shift left the current path and add the left node value\\n            paths(it, leftPath)\\n        }\\n        root.right?.let {\\n            val rightPath = (path shl 1) + it.`val`\\n            paths(it, rightPath)\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    private var sum = 0\\n    fun sumRootToLeaf(root: TreeNode?): Int {\\n        if (root == null) return sum\\n        paths(root, root.`val`)\\n        return sum\\n    }\\n    \\n    private fun paths(root: TreeNode, path: Int) {\\n        if (root.left == null && root.right == null) { // we have reached a leaf\\n            sum += path\\n            return\\n        }\\n        root.left?.let {\\n            val leftPath = (path shl 1) + it.`val` // shift left the current path and add the left node value\\n            paths(it, leftPath)\\n        }\\n        root.right?.let {\\n            val rightPath = (path shl 1) + it.`val`\\n            paths(it, rightPath)\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751960,
                "title": "java-bfs-solution",
                "content": "Not as good as DFS due to space complexity.\\n\\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int sum = 0;\\n        \\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(root, root.val));\\n        int newValue = 0;\\n        while (!q.isEmpty()) {\\n            Pair<TreeNode, Integer> current = q.poll();\\n            TreeNode node = current.getKey();\\n            int value = current.getValue();\\n            if (node.left == null && node.right == null) {\\n                sum = sum + value;\\n                continue;\\n            }\\n            \\n            if (node.left != null) {\\n                newValue = (value << 1) + node.left.val;\\n                q.add(new Pair(node.left, newValue));\\n            }\\n            \\n            if (node.right != null) {\\n                newValue = (value << 1) + node.right.val;\\n                q.add(new Pair(node.right, newValue));\\n            }            \\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int sum = 0;\\n        \\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(root, root.val));\\n        int newValue = 0;\\n        while (!q.isEmpty()) {\\n            Pair<TreeNode, Integer> current = q.poll();\\n            TreeNode node = current.getKey();\\n            int value = current.getValue();\\n            if (node.left == null && node.right == null) {\\n                sum = sum + value;\\n                continue;\\n            }\\n            \\n            if (node.left != null) {\\n                newValue = (value << 1) + node.left.val;\\n                q.add(new Pair(node.left, newValue));\\n            }\\n            \\n            if (node.right != null) {\\n                newValue = (value << 1) + node.right.val;\\n                q.add(new Pair(node.right, newValue));\\n            }            \\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729767,
                "title": "c-simple-n-short-bit-twiddling",
                "content": "```\\nvoid trav(struct TreeNode *root, int *i, int *s){\\n    if (root) {\\n        *i = (*i << 1) | root->val;\\n        !root->left && !root->right ? *s += *i : 0;\\n        trav(root->left, i, s);\\n        trav(root->right, i, s);\\n        *i >>= 1;        \\n    }\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    int i = 0, s = 0;\\n    trav(root, &i, &s);\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid trav(struct TreeNode *root, int *i, int *s){\\n    if (root) {\\n        *i = (*i << 1) | root->val;\\n        !root->left && !root->right ? *s += *i : 0;\\n        trav(root->left, i, s);\\n        trav(root->right, i, s);\\n        *i >>= 1;        \\n    }\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    int i = 0, s = 0;\\n    trav(root, &i, &s);\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 668687,
                "title": "java-100-efficient-solution-and-easy-to-understand",
                "content": "```\\nint sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        sumRootToLeaf(root, 0);\\n        return sum;\\n    }\\n\\n    public void sumRootToLeaf(TreeNode root, int sum) {\\n        if (root == null) return;\\n\\n        sum = (sum * 2) + root.val;\\n        sumRootToLeaf(root.left, sum);\\n        sumRootToLeaf(root.right, sum);\\n        if (root.left == null && root.right == null) {\\n            this.sum += sum;\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\nint sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        sumRootToLeaf(root, 0);\\n        return sum;\\n    }\\n\\n    public void sumRootToLeaf(TreeNode root, int sum) {\\n        if (root == null) return;\\n\\n        sum = (sum * 2) + root.val;\\n        sumRootToLeaf(root.left, sum);\\n        sumRootToLeaf(root.right, sum);\\n        if (root.left == null && root.right == null) {\\n            this.sum += sum;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 640967,
                "title": "python-2-recursive-methods",
                "content": "### Method 1: Build a string of \\'1\\' and \\'0\\' for each root to leaf path\\n\\n1) Start at root node with a string of \\'0b\\' denoting the start of a binary string.  At every node, add the node value to the end of the string.  \\n\\n2) When a leaf node is reached add the path to reach that node (i.e. \\'1010\\') to self.res\\n\\n3) Convert each path from binary to an integer using int(path, 2) and return the sum.  \\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = []\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #2\\n                self.res.append(path + str(node.val))\\n                return\\n            \\n            if node.left: #1\\n                helper(node.left, path + str(node.val))\\n            \\n            if node.right: #1\\n                helper(node.right, path + str(node.val))\\n            \\n        \\n        helper(root, \\'0b\\')\\n        \\n        return sum([int(path,2) for path in self.res]) #3\\n```\\n\\n### Method 2: Manually increase result at at each leaf\\n\\n1) Start with a path of []\\n2) At every node append the node value to the beginning of the path\\n    * So the path (root = 1, to leaf = 0, [1,0,1,0]) looks like [0,1,0,1]\\n3) When a leaf node is reached, increase the result by value * (2 ** index) for each index in the reversed path.  This is equivalent to calculating the integer that the binary number represents.  For the example above this is 0 * 2 ** 0 + 1 * 2 ** 1 + 0 * 2 ** 2 + 1 * 2 ** 3 = 0 + 2 + 0 + 8 = 10\\n4) Once the helper function finishes the final node, res will be the sum of all of the root to leaf paths.  \\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = 0\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #3\\n                self.res += node.val\\n                for idx,val in enumerate(path):\\n                    self.res += val*(2**(idx+1))\\n                return\\n            \\n            if node.left:\\n                helper(node.left, [node.val] + path) #2\\n            \\n            if node.right:\\n                helper(node.right, [node.val] + path) #2 \\n            \\n        \\n        helper(root, []) #1\\n        \\n        return self.res #4\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = []\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #2\\n                self.res.append(path + str(node.val))\\n                return\\n            \\n            if node.left: #1\\n                helper(node.left, path + str(node.val))\\n            \\n            if node.right: #1\\n                helper(node.right, path + str(node.val))\\n            \\n        \\n        helper(root, \\'0b\\')\\n        \\n        return sum([int(path,2) for path in self.res]) #3\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = 0\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #3\\n                self.res += node.val\\n                for idx,val in enumerate(path):\\n                    self.res += val*(2**(idx+1))\\n                return\\n            \\n            if node.left:\\n                helper(node.left, [node.val] + path) #2\\n            \\n            if node.right:\\n                helper(node.right, [node.val] + path) #2 \\n            \\n        \\n        helper(root, []) #1\\n        \\n        return self.res #4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609443,
                "title": "java-iterative-solution",
                "content": "use two stacks pop and push synchronously. one stack store node, another stack store value\\n```java\\npublic int sumRootToLeaf(TreeNode root) {\\n    if (root == null) {\\n        return 0;\\n    }\\n\\n    int result = 0;\\n    Stack<TreeNode> nodeStack = new Stack<TreeNode>();\\n    Stack<Integer> valueStack = new Stack<Integer>();\\n    nodeStack.push(root);\\n    valueStack.push(root.val);\\n    while (!nodeStack.isEmpty()) {\\n        TreeNode node = nodeStack.pop();\\n        int value = valueStack.pop();\\n        if (node.left == null && node.right == null) {\\n            result += value;\\n        }\\n        if (node.left != null) {\\n            nodeStack.push(node.left);\\n            valueStack.push(value * 2 + node.left.val);\\n        } \\n        if (node.right != null) {\\n            nodeStack.push(node.right);\\n            valueStack.push(value * 2 + node.right.val);\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int sumRootToLeaf(TreeNode root) {\\n    if (root == null) {\\n        return 0;\\n    }\\n\\n    int result = 0;\\n    Stack<TreeNode> nodeStack = new Stack<TreeNode>();\\n    Stack<Integer> valueStack = new Stack<Integer>();\\n    nodeStack.push(root);\\n    valueStack.push(root.val);\\n    while (!nodeStack.isEmpty()) {\\n        TreeNode node = nodeStack.pop();\\n        int value = valueStack.pop();\\n        if (node.left == null && node.right == null) {\\n            result += value;\\n        }\\n        if (node.left != null) {\\n            nodeStack.push(node.left);\\n            valueStack.push(value * 2 + node.left.val);\\n        } \\n        if (node.right != null) {\\n            nodeStack.push(node.right);\\n            valueStack.push(value * 2 + node.right.val);\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594779,
                "title": "javascript-99-5-time-100-space",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\nlet sum=[];\\n     sumRoot(root,sum,0);\\n    return sum.reduce((acc,curr)=>acc+ curr,0)\\n};\\n\\n function sumRoot(root,sum,curr){\\n     curr=curr*2+root.val;\\nif(!root.left&&!root.right)sum.push(curr)\\n     \\n     if (root.left)sumRoot(root.left,sum,curr) ;\\n     if (root.right) sumRoot(root.right,sum,curr);\\n     \\n     \\n }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\nlet sum=[];\\n     sumRoot(root,sum,0);\\n    return sum.reduce((acc,curr)=>acc+ curr,0)\\n};\\n\\n function sumRoot(root,sum,curr){\\n     curr=curr*2+root.val;\\nif(!root.left&&!root.right)sum.push(curr)\\n     \\n     if (root.left)sumRoot(root.left,sum,curr) ;\\n     if (root.right) sumRoot(root.right,sum,curr);\\n     \\n     \\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 550735,
                "title": "python-99-32-recursive-explained-with-tips",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:       \\n        self.s = 0\\n        def preOrder(r,v):                      \\n            if r:           \\n                v = (v << 1) + r.val            \\n                if(r.left or r.right):\\n                    preOrder(r.left,v)\\n                    preOrder(r.right,v)\\n                else:\\n                    self.s += v    \\n                \\n        preOrder(root,0)\\n        return self.s \\n```\\n\\nThe idea is simple. We traverse the tree and every time we go lower, we push the current value down. Once we hit a leaf with no childred, we add the current value to a globa variable self.s.\\n\\nSo the tips part.\\n\\nVisually it is easier to see the value as a string with 0s and 1s, but to avoid unnessesary conversion, it\\'s better to keep everything as integers. A simple way to add the current value to the existing number is `v = (v << 1) + r.val ` - we shift bits to the left to free up space for the current bit. If you don\\'t like bit logic, you can do `v = v*2 + r.val` . \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:       \\n        self.s = 0\\n        def preOrder(r,v):                      \\n            if r:           \\n                v = (v << 1) + r.val            \\n                if(r.left or r.right):\\n                    preOrder(r.left,v)\\n                    preOrder(r.right,v)\\n                else:\\n                    self.s += v    \\n                \\n        preOrder(root,0)\\n        return self.s \\n```",
                "codeTag": "Java"
            },
            {
                "id": 543666,
                "title": "100-fast-and-memory",
                "content": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    int ans = 0;\\n\\n    void helper(TreeNode *root, int pSum)\\n    {\\n        if (!root) return;\\n        int t = pSum * 2 + root->val;\\n        if (root->left == nullptr && root->right == nullptr)\\n        {\\n            ans += t;\\n            return;\\n        }\\n        helper(root->left, t);\\n        helper(root->right, t);\\n    }\\n\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root, 0);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    int ans = 0;\\n\\n    void helper(TreeNode *root, int pSum)\\n    {\\n        if (!root) return;\\n        int t = pSum * 2 + root->val;\\n        if (root->left == nullptr && root->right == nullptr)\\n        {\\n            ans += t;\\n            return;\\n        }\\n        helper(root->left, t);\\n        helper(root->right, t);\\n    }\\n\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493622,
                "title": "c-faster-than-94-05-less-than-100-mem-o-n",
                "content": "Runtime: 88 ms\\nMemory Usage: 24.8 MB\\n\\n```\\n    public int SumRootToLeaf(TreeNode root) {        \\n        return Traverse(root, 0);\\n    }\\n    \\n    private int Traverse(TreeNode root, int number)\\n    {\\n        if (root == null) { return 0; }\\n              \\n        number <<= 1; \\n        number += root.val;\\n        \\n        if (root.left == null && root.right == null) {  return number; }\\n        \\n        return Traverse(root.left, number) + Traverse(root.right, number);\\n    }\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    public int SumRootToLeaf(TreeNode root) {        \\n        return Traverse(root, 0);\\n    }\\n    \\n    private int Traverse(TreeNode root, int number)\\n    {\\n        if (root == null) { return 0; }\\n              \\n        number <<= 1; \\n        number += root.val;\\n        \\n        if (root.left == null && root.right == null) {  return number; }\\n        \\n        return Traverse(root.left, number) + Traverse(root.right, number);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 483603,
                "title": "rust",
                "content": "```rust\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut res = 0;\\n        Self::h(&root, &mut res, &mut vec![]);\\n        res\\n    }\\n\\n    fn h(t: &Option<Rc<RefCell<TreeNode>>>, res: &mut i32, p: &mut Vec<i32>) {\\n        if let Some(t) = t {\\n            let t = t.borrow();\\n            p.push(t.val);\\n            if t.left.is_none() && t.right.is_none() {\\n                let mut c = 0;\\n                p.iter().for_each(|x| c = (c << 1) | x);\\n                *res += c;\\n            } else {\\n                Self::h(&t.left, res, &mut p.clone());\\n                Self::h(&t.right, res, &mut p.clone());\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut res = 0;\\n        Self::h(&root, &mut res, &mut vec![]);\\n        res\\n    }\\n\\n    fn h(t: &Option<Rc<RefCell<TreeNode>>>, res: &mut i32, p: &mut Vec<i32>) {\\n        if let Some(t) = t {\\n            let t = t.borrow();\\n            p.push(t.val);\\n            if t.left.is_none() && t.right.is_none() {\\n                let mut c = 0;\\n                p.iter().for_each(|x| c = (c << 1) | x);\\n                *res += c;\\n            } else {\\n                Self::h(&t.left, res, &mut p.clone());\\n                Self::h(&t.right, res, &mut p.clone());\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 460062,
                "title": "c-0ms-dfs",
                "content": "```\\ntypedef struct TreeNode TreeNode;\\n\\nint dfs(TreeNode* root, int val) {\\n    if (root == NULL)\\n        return 0;\\n    \\n    val = (val << 1) + root->val;\\n    \\n    if (root->left == NULL && root->right == NULL) \\n        return val;\\n    \\n    return dfs(root->left,  val) + \\n           dfs(root->right, val);\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    return dfs(root, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct TreeNode TreeNode;\\n\\nint dfs(TreeNode* root, int val) {\\n    if (root == NULL)\\n        return 0;\\n    \\n    val = (val << 1) + root->val;\\n    \\n    if (root->left == NULL && root->right == NULL) \\n        return val;\\n    \\n    return dfs(root->left,  val) + \\n           dfs(root->right, val);\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    return dfs(root, 0);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 443666,
                "title": "java-iterating-method",
                "content": "\\t//   iterating method\\n\\t\\tpublic int sumRootToLeaf(TreeNode root) { \\n\\t\\t\\tif ( root == null ) return 0 ;\\n\\t\\t\\tStack<TreeNode> s = new Stack<>();\\n\\t\\t\\ts.push(root);\\n\\t\\t\\tint res = 0 ;\\n\\t\\t\\twhile( !s.empty() ){\\n\\t\\t\\t\\tTreeNode tmp = s.pop();\\n\\t\\t\\t\\tif (tmp.left != null) {\\n\\t\\t\\t\\t\\ttmp.left.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (tmp.right != null) {\\n\\t\\t\\t\\t\\ttmp.right.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( tmp.left  == null && tmp.right == null ) res += tmp.val;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\t//   iterating method\\n\\t\\tpublic int sumRootToLeaf(TreeNode root) { \\n\\t\\t\\tif ( root == null ) return 0 ;\\n\\t\\t\\tStack<TreeNode> s = new Stack<>();\\n\\t\\t\\ts.push(root);\\n\\t\\t\\tint res = 0 ;\\n\\t\\t\\twhile( !s.empty() ){\\n\\t\\t\\t\\tTreeNode tmp = s.pop();\\n\\t\\t\\t\\tif (tmp.left != null) {\\n\\t\\t\\t\\t\\ttmp.left.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (tmp.right != null) {\\n\\t\\t\\t\\t\\ttmp.right.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( tmp.left  == null && tmp.right == null ) res += tmp.val;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 411429,
                "title": "python-iterative-dfs-98-19",
                "content": "This is a typical tree traversal problem. Both DFS and BFS should work in this setting. The only trick is that one needs to keep track of the value (binary value) up to the node that is being traversed. Below is a iterative implementation of DFS. \\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        stack = [(root, 0)]\\n        while stack: \\n            node, val = stack.pop()\\n            val = 2*val + node.val \\n            if node.left is node.right: ans += val \\n            if node.left: stack.append((node.left, val))\\n            if node.right: stack.append((node.right, val))\\n        return ans \\n```\\n\\nEdited on 9/8/2020\\nAdding a recursive solution \\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node): \\n            \"\"\"Pre-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            nonlocal ans\\n            if not node: return \\n            stack.append(node.val)\\n            if node.left is node.right is None: ans += int(\"\".join(map(str, stack)), 2)\\n            fn(node.left) or fn(node.right)\\n            stack.pop()\\n        \\n        ans, stack = 0, []\\n        fn(root)\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node, x=0): \\n            \"\"\"Post-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            if not node: return 0 \\n            x = 2*x + node.val \\n            if node.left is node.right: return x\\n            return fn(node.left, x) + fn(node.right, x)\\n        \\n        return fn(root)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        stack = [(root, 0)]\\n        while stack: \\n            node, val = stack.pop()\\n            val = 2*val + node.val \\n            if node.left is node.right: ans += val \\n            if node.left: stack.append((node.left, val))\\n            if node.right: stack.append((node.right, val))\\n        return ans \\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node): \\n            \"\"\"Pre-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            nonlocal ans\\n            if not node: return \\n            stack.append(node.val)\\n            if node.left is node.right is None: ans += int(\"\".join(map(str, stack)), 2)\\n            fn(node.left) or fn(node.right)\\n            stack.pop()\\n        \\n        ans, stack = 0, []\\n        fn(root)\\n        return ans \\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node, x=0): \\n            \"\"\"Post-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            if not node: return 0 \\n            x = 2*x + node.val \\n            if node.left is node.right: return x\\n            return fn(node.left, x) + fn(node.right, x)\\n        \\n        return fn(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399469,
                "title": "easy-c-solution-4ms-beats-94",
                "content": "Runtime: 4 ms, faster than 94.22% of C++ online submissions for Sum of Root To Leaf Binary Numbers.\\nMemory Usage: 17 MB, less than 100.00% of C++ online submissions for Sum of Root To Leaf Binary Numbers.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        return sum(root, 0);\\n    }\\n    \\n    int sum(TreeNode* root, int parentSum)\\n    {\\n        int doubleParent = parentSum*2;\\n        \\n        if(root->left == nullptr && root->right == nullptr)\\n            return doubleParent + root->val;\\n        \\n        int leftSum = (root->left != nullptr) ? sum(root->left, doubleParent+root->val) : 0;\\n        int rightSum = (root->right != nullptr) ? sum(root->right, doubleParent+root->val) : 0;\\n        \\n        return leftSum+rightSum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        return sum(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 392519,
                "title": "c-84-ms",
                "content": "\\tpublic class Solution\\n    {\\n        public int SumRootToLeaf(TreeNode root)\\n            => Sum(root, 0);\\n\\n        private int Sum(TreeNode node, int number)\\n        {\\n            if (node == null)\\n            {\\n                return 0;\\n            }\\n            number = number * 2 + node.val;\\n            return\\n                node.left == null && node.right == null ?\\n                number :\\n                Sum(node.left, number) + Sum(node.right, number);\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public int SumRootToLeaf(TreeNode root)\\n            => Sum(root, 0);\\n\\n        private int Sum(TreeNode node, int number)\\n        {\\n            if (node == null)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 367391,
                "title": "java-100-100",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root , int sum){\\n        sum=sum*2+root.val;\\n        if(root.left==null&&root.right==null){\\n            return sum;\\n        }else if(root.left==null){\\n            return sumRootToLeaf(root.right,sum);\\n        }else if(root.right==null){\\n            return sumRootToLeaf(root.left,sum);\\n        }else{\\n            return sumRootToLeaf(root.right,sum)+sumRootToLeaf(root.left,sum);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root , int sum){\\n        sum=sum*2+root.val;\\n        if(root.left==null&&root.right==null){\\n            return sum;\\n        }else if(root.left==null){\\n            return sumRootToLeaf(root.right,sum);\\n        }else if(root.right==null){\\n            return sumRootToLeaf(root.left,sum);\\n        }else{\\n            return sumRootToLeaf(root.right,sum)+sumRootToLeaf(root.left,sum);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354667,
                "title": "python-quick-recursive-1-way-down-no-shifting",
                "content": "```\\ndef sumRootToLeaf(self, root):\\n\\tdef dfe(root, binary):\\n\\t\\tif root == None:\\n\\t\\t\\treturn 0\\n\\t\\tbinary = binary+str(root.val)\\n\\t\\tif root.left == None and root.right == None:\\n\\t\\t\\ta.append(binary)\\n\\t\\t\\treturn 0\\n\\t\\tdfe(root.left, binary)\\n\\t\\tdfe(root.right, binary)\\n\\n\\n\\ta = []\\n\\tbinary = \\'\\'\\n\\tdfe(root, binary)\\n\\tres = 0\\n\\tfor b in a:\\n\\t\\tres = res + int(b, 2)\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\ndef sumRootToLeaf(self, root):\\n\\tdef dfe(root, binary):\\n\\t\\tif root == None:\\n\\t\\t\\treturn 0\\n\\t\\tbinary = binary+str(root.val)\\n\\t\\tif root.left == None and root.right == None:\\n\\t\\t\\ta.append(binary)\\n\\t\\t\\treturn 0\\n\\t\\tdfe(root.left, binary)\\n\\t\\tdfe(root.right, binary)\\n\\n\\n\\ta = []\\n\\tbinary = \\'\\'\\n\\tdfe(root, binary)\\n\\tres = 0\\n\\tfor b in a:\\n\\t\\tres = res + int(b, 2)\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 321139,
                "title": "java-2-methods-reuse-lc-129",
                "content": "**Idea:** Swap 10 with 2 (base of digits) in [LC 129: Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/1555892/Java-or-DFS-or-Time-beats-100)\\n>**T/S:** O(n)/O(d), n = number of nodes, d = depth\\n ```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\treturn sumRootToLeaf(root, 0);\\n}\\n\\npublic int sumRootToLeaf(TreeNode root, int sum) {\\n\\tif (root == null)\\n\\t\\treturn 0;\\n\\t\\t\\n\\tsum = (sum * 2) + root.val;\\n\\t\\n\\treturn (root.left == null && root.right == null) ? \\n\\t\\t\\t   sum : \\n\\t\\t\\t   sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n}\\n```\\n\\n**Method 2:** Build the number\\n>**T/S:** O(n)/O(d), n = number of nodes, d = depth\\n```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tint[] sum = {0};\\n\\tsumRootToLeaf(root, new StringBuffer(), sum);\\n\\treturn sum[0];\\n}\\n\\nprivate void sumRootToLeaf(TreeNode root, StringBuffer sb, int[] sum) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\n\\tsb.append(root.val);\\n\\n\\tif (root.left == null && root.right == null) { // leaf node\\n\\t\\tsum[0] += Integer.parseInt(sb.toString(), 2);\\n\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t} else {\\n\\t\\tsumRootToLeaf(root.left, sb, sum);\\n\\t\\tsumRootToLeaf(root.right, sb, sum);\\n\\t\\tif (sb.length() != 0)\\n\\t\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t}\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\treturn sumRootToLeaf(root, 0);\\n}\\n\\npublic int sumRootToLeaf(TreeNode root, int sum) {\\n\\tif (root == null)\\n\\t\\treturn 0;\\n\\t\\t\\n\\tsum = (sum * 2) + root.val;\\n\\t\\n\\treturn (root.left == null && root.right == null) ? \\n\\t\\t\\t   sum : \\n\\t\\t\\t   sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n}\\n```\n```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tint[] sum = {0};\\n\\tsumRootToLeaf(root, new StringBuffer(), sum);\\n\\treturn sum[0];\\n}\\n\\nprivate void sumRootToLeaf(TreeNode root, StringBuffer sb, int[] sum) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\n\\tsb.append(root.val);\\n\\n\\tif (root.left == null && root.right == null) { // leaf node\\n\\t\\tsum[0] += Integer.parseInt(sb.toString(), 2);\\n\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t} else {\\n\\t\\tsumRootToLeaf(root.left, sb, sum);\\n\\t\\tsumRootToLeaf(root.right, sb, sum);\\n\\t\\tif (sb.length() != 0)\\n\\t\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311653,
                "title": "javascript",
                "content": "```\\nvar sumRootToLeaf = function(root) {\\n    let res = 0;\\n    let DFS = (root, S) => {\\n        if(!root) return;\\n        S += root.val;\\n        if(!root.left && !root.right) {\\n            res += parseInt(S, 2);\\n            return;\\n        }\\n        DFS(root.left, S);\\n        DFS(root.right, S);\\n    }\\n    DFS(root, \\'\\');\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar sumRootToLeaf = function(root) {\\n    let res = 0;\\n    let DFS = (root, S) => {\\n        if(!root) return;\\n        S += root.val;\\n        if(!root.left && !root.right) {\\n            res += parseInt(S, 2);\\n            return;\\n        }\\n        DFS(root.left, S);\\n        DFS(root.right, S);\\n    }\\n    DFS(root, \\'\\');\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271127,
                "title": "java-recursion-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode root, int sum) {\\n        sum = sum * 2 + root.val;\\n        if(root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        int leftSum = root.left != null ? dfs(root.left, sum) : 0;\\n        int rightSum = root.right != null ? dfs(root.right, sum) : 0;\\n        return leftSum + rightSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode root, int sum) {\\n        sum = sum * 2 + root.val;\\n        if(root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        int leftSum = root.left != null ? dfs(root.left, sum) : 0;\\n        int rightSum = root.right != null ? dfs(root.right, sum) : 0;\\n        return leftSum + rightSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680091,
                "title": "easy-java-100-global-variables-method-pre-order-traversal-dfs-explained",
                "content": "# Approach\\n- There are two approaches to this question - one with a numerical variable that stores the current bit values and the other one is a string variable that stores the bit values at a particular leaf node.\\n- The problem with the numerical variable is that, there\\'s a limit to how many bit values it can store and thus gives an error after the critical value. Hence we use the String variable to record the bit values.\\n- The problem is divided into two classes - main and helper\\n\\n# Global Variables\\n- number (String type)\\n- arr (Arraylist String type)\\n\\n# Helper Class\\n- The helper class takes a node as an input\\n- if node is null, returns to the parent node\\n- adds the node bit value to number\\n- checks if the node is leaf node, if yes, the current number value is appended in arr\\n- calls itself on current node left child\\n- calls itself on current node right child\\n- deletes the last character of number\\n\\n# Main class\\n- calls the helper class on root node\\n- arr is created and full of leaf node bit values but in string format\\n- create int variable sum = 0\\n- set a for loop to iterate thorugh the array\\n- convert each string bit value to integer and add it to the sum.\\n- return sum\\n\\n# Complexity\\n- Time complexity: O(V) V  is the number of nodes\\n\\n- Space complexity: O(L) L is the number of leaf nodes\\n\\n# Code\\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public String number = \"\";\\n\\n    public List<String> arr = new ArrayList<>();\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        tree(root);\\n        int sum = 0;\\n        for(String i: arr){\\n            int a = Integer.parseInt(i, 2);\\n            System.out.println(a);\\n            sum += a;\\n        }\\n        return sum;\\n    }\\n\\n    public void tree(TreeNode x){\\n        if(x == null){\\n            return;\\n        }\\n\\n        number = number + String.valueOf(x.val);\\n\\n        if(x.left == null && x.right == null){\\n            arr.add(number);\\n        }\\n\\n        tree(x.left);\\n        tree(x.right);\\n\\n        number = number.substring(0,number.length()-1);\\n\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/4c993713-be95-4251-b6b5-2bfbd911fbac_1687678864.5214777.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public String number = \"\";\\n\\n    public List<String> arr = new ArrayList<>();\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        tree(root);\\n        int sum = 0;\\n        for(String i: arr){\\n            int a = Integer.parseInt(i, 2);\\n            System.out.println(a);\\n            sum += a;\\n        }\\n        return sum;\\n    }\\n\\n    public void tree(TreeNode x){\\n        if(x == null){\\n            return;\\n        }\\n\\n        number = number + String.valueOf(x.val);\\n\\n        if(x.left == null && x.right == null){\\n            arr.add(number);\\n        }\\n\\n        tree(x.left);\\n        tree(x.right);\\n\\n        number = number.substring(0,number.length()-1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594435,
                "title": "c-very-rare-solution-super-easy-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solver(TreeNode* root, int value){\\n        if(root == nullptr) return 0;\\n        \\n        value = value * 2 + root->val;\\n        if(root->left == nullptr && root->right == nullptr){\\n            return value;\\n        }\\n        return solver(root->left,value) + solver(root->right,value);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        return solver(root,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solver(TreeNode* root, int value){\\n        if(root == nullptr) return 0;\\n        \\n        value = value * 2 + root->val;\\n        if(root->left == nullptr && root->right == nullptr){\\n            return value;\\n        }\\n        return solver(root->left,value) + solver(root->right,value);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        return solver(root,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3551124,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nvoid helper(TreeNode* root, int val, int& res){\\n    if(!root) return;\\n\\n    val = val | root->val;\\n    if(!root->left && !root->right){\\n        res+=val;\\n        return;\\n    }\\n    helper(root->left,  val<<1, res);\\n    helper(root->right, val<<1, res);\\n}\\nvoid helper1(TreeNode* root,  int out, int& res){\\n    if(!root) return;\\n\\n    out = (out<<1) + root->val;\\n    if(!root->left && !root->right){\\n        res+=out;\\n        return;\\n    }\\n    helper1(root->left,out,res);\\n    helper1(root->right,out,res);\\n}\\nint sumRootToLeaf(TreeNode* root) {\\n        int res = 0;\\n        helper1(root,0,res);\\n        return res;    \\n}\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        result = 0\\n        if not root:\\n            return 0\\n        def dfs(node, slate):\\n            nonlocal result\\n            if not node.left and not node.right:\\n                slate.append(str(node.val))\\n                result += int(\"\".join(slate), 2)\\n            \\n            if node.left: dfs(node.left, slate + [str(node.val)])\\n            if node.right: dfs(node.right, slate + [str(node.val)])\\n        \\n        dfs(root, [])\\n        return result\\n```\\n\\n```Java []\\nclass Solution {\\n     private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        return pathSumRootToLeaf(root.left, parentNodeSum) +            pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n          return pathSumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nvoid helper(TreeNode* root, int val, int& res){\\n    if(!root) return;\\n\\n    val = val | root->val;\\n    if(!root->left && !root->right){\\n        res+=val;\\n        return;\\n    }\\n    helper(root->left,  val<<1, res);\\n    helper(root->right, val<<1, res);\\n}\\nvoid helper1(TreeNode* root,  int out, int& res){\\n    if(!root) return;\\n\\n    out = (out<<1) + root->val;\\n    if(!root->left && !root->right){\\n        res+=out;\\n        return;\\n    }\\n    helper1(root->left,out,res);\\n    helper1(root->right,out,res);\\n}\\nint sumRootToLeaf(TreeNode* root) {\\n        int res = 0;\\n        helper1(root,0,res);\\n        return res;    \\n}\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        result = 0\\n        if not root:\\n            return 0\\n        def dfs(node, slate):\\n            nonlocal result\\n            if not node.left and not node.right:\\n                slate.append(str(node.val))\\n                result += int(\"\".join(slate), 2)\\n            \\n            if node.left: dfs(node.left, slate + [str(node.val)])\\n            if node.right: dfs(node.right, slate + [str(node.val)])\\n        \\n        dfs(root, [])\\n        return result\\n```\n```Java []\\nclass Solution {\\n     private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        return pathSumRootToLeaf(root.left, parentNodeSum) +            pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n          return pathSumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507123,
                "title": "faster-than-100-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n\\n    void bin(string s) {\\n        int ans = 0;\\n        int n = s.size() - 1;\\n        for (auto i: s) {\\n            ans += (i - 48) * pow(2, n);\\n            n--;\\n        }\\n        sum += ans;\\n    }\\n\\n    void func(TreeNode *root, string s) {\\n        if (root == nullptr) {\\n            return bin(s);\\n        }\\n        s += std::to_string(root->val);\\n        if (root->right == nullptr && root->left == nullptr){\\n            return bin(s);\\n        } else {\\n            if (root->left == nullptr || root->right == nullptr){\\n                if (root->left != nullptr){\\n                    return func(root->left, s);\\n                } else {\\n                    return func(root->right, s);\\n                }\\n            } else {\\n                func(root->left, s);\\n                func(root->right, s);\\n            }\\n        }\\n\\n    }\\n\\n    int sumRootToLeaf(TreeNode *root) {\\n        func(root, \"\");\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n\\n    void bin(string s) {\\n        int ans = 0;\\n        int n = s.size() - 1;\\n        for (auto i: s) {\\n            ans += (i - 48) * pow(2, n);\\n            n--;\\n        }\\n        sum += ans;\\n    }\\n\\n    void func(TreeNode *root, string s) {\\n        if (root == nullptr) {\\n            return bin(s);\\n        }\\n        s += std::to_string(root->val);\\n        if (root->right == nullptr && root->left == nullptr){\\n            return bin(s);\\n        } else {\\n            if (root->left == nullptr || root->right == nullptr){\\n                if (root->left != nullptr){\\n                    return func(root->left, s);\\n                } else {\\n                    return func(root->right, s);\\n                }\\n            } else {\\n                func(root->left, s);\\n                func(root->right, s);\\n            }\\n        }\\n\\n    }\\n\\n    int sumRootToLeaf(TreeNode *root) {\\n        func(root, \"\");\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443812,
                "title": "multiple-cpp-solution-using-preorder-traversal-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void sum(TreeNode* root, int ans, set<int>& s){\\n        if(root == nullptr) {\\n            s.insert(ans);\\n            return;\\n        };\\n        int elem = root -> val;\\n        ans = ans * 10 + elem;\\n\\n        sum(root -> left, ans, s);\\n        sum(root -> right, ans, s);\\n    }\\n\\n    int sumOne(TreeNode* root, int ans){\\n\\n        if(root == nullptr) return 0;\\n\\n        int elem = root -> val;\\n        ans = ans * 2 + elem;\\n\\n        if(root -> left == NULL && root -> right == NULL){\\n            return ans;\\n        }\\n\\n        int leftSum = sumOne(root -> left, ans);\\n        int rightSum = sumOne(root -> right, ans);\\n\\n        return leftSum + rightSum;\\n\\n    }\\n \\n  \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        // set<int> s;\\n        // sum(root, 0, s);\\n\\n        // int ans = 0;\\n\\n        // for(auto& i: s){\\n        //     ans += binaryToDecimal(i);\\n        // }\\n\\n        // return ans;\\n\\n        return sumOne(root, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void sum(TreeNode* root, int ans, set<int>& s){\\n        if(root == nullptr) {\\n            s.insert(ans);\\n            return;\\n        };\\n        int elem = root -> val;\\n        ans = ans * 10 + elem;\\n\\n        sum(root -> left, ans, s);\\n        sum(root -> right, ans, s);\\n    }\\n\\n    int sumOne(TreeNode* root, int ans){\\n\\n        if(root == nullptr) return 0;\\n\\n        int elem = root -> val;\\n        ans = ans * 2 + elem;\\n\\n        if(root -> left == NULL && root -> right == NULL){\\n            return ans;\\n        }\\n\\n        int leftSum = sumOne(root -> left, ans);\\n        int rightSum = sumOne(root -> right, ans);\\n\\n        return leftSum + rightSum;\\n\\n    }\\n \\n  \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        // set<int> s;\\n        // sum(root, 0, s);\\n\\n        // int ans = 0;\\n\\n        // for(auto& i: s){\\n        //     ans += binaryToDecimal(i);\\n        // }\\n\\n        // return ans;\\n\\n        return sumOne(root, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089328,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int solve(string a)\\n    {\\n        int ans=0;\\n        int t=a.length()-1;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a[i]==\\'1\\')\\n            {\\n                ans+=pow(2,t);\\n            }\\n            t--;\\n        }\\n        return ans;\\n    }\\n    void helper(TreeNode* root,string x,vector<string>&s)\\n    {\\n        if(root==NULL)return;\\n        if(root->left==NULL &&root->right==NULL)\\n        {\\n            x+=to_string(root->val);\\n            s.push_back(x);\\n        }\\n        x+=to_string(root->val);\\n        helper(root->left,x,s);\\n        helper(root->right,x,s);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<string>s;\\n        string x=\"\";\\n        helper(root,x,s);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans+=solve(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int solve(string a)\\n    {\\n        int ans=0;\\n        int t=a.length()-1;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a[i]==\\'1\\')\\n            {\\n                ans+=pow(2,t);\\n            }\\n            t--;\\n        }\\n        return ans;\\n    }\\n    void helper(TreeNode* root,string x,vector<string>&s)\\n    {\\n        if(root==NULL)return;\\n        if(root->left==NULL &&root->right==NULL)\\n        {\\n            x+=to_string(root->val);\\n            s.push_back(x);\\n        }\\n        x+=to_string(root->val);\\n        helper(root->left,x,s);\\n        helper(root->right,x,s);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<string>s;\\n        string x=\"\";\\n        helper(root,x,s);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans+=solve(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880444,
                "title": "c-very-easy-to-understand-tree-traversal",
                "content": "\\n\\n       /**\\n     * Definition for a binary tree node.\\n    * struct TreeNode {\\n    *     int val;\\n    *     TreeNode *left;\\n    *     TreeNode *right;\\n    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n    * };\\n    */\\n    class Solution {\\n    public:\\n         void dfs(TreeNode* node, int &ans ,string &str){\\n         \\n            if(node==NULL)\\n                 return;\\n         if(node->left==nullptr && node->right==nullptr){\\n               string s=str+to_string(node->val);\\n                 for(int i=0;i<s.size();++i){\\n                   ans+=pow(2,i)*(s[s.size()-i-1]-\\'0\\');\\n             }\\n                 return;\\n         }\\n         \\n         \\n         str+=to_string(node->val);\\n         dfs(node->left,ans,str);\\n         dfs(node->right,ans,str);\\n          str.pop_back();\\n                \\n     }\\n     \\n    int sumRootToLeaf(TreeNode* root) {\\n         int ans=0; \\n        string str;\\n        dfs(root,ans,str);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "class Solution {\\n    public:\\n         void dfs(TreeNode* node, int &ans ,string &str){\\n         \\n            if(node==NULL)\\n                 return;\\n         if(node->left==nullptr && node->right==nullptr){\\n               string s=str+to_string(node->val);\\n                 for(int i=0;i<s.size();++i){\\n                   ans+=pow(2,i)*(s[s.size()-i-1]-\\'0\\');\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2673967,
                "title": "simple-solution",
                "content": "Here Idea is simple we can write binary 100 to decimal as   (2*(2*1)+0)+0=4.\\n\\nMultiply first digit with base and add the next bit to it and then with the result multiply it with base and add the next bit. Do the same procedure until there is no bit available to add.\\n\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        {\\n           return sum(root,0); \\n        }\\n    }\\n    int sum(TreeNode* root ,int till)\\n    {  \\n        till=till+root->val;\\n        if(!root->left && !root->right)\\n        {\\n            return till;\\n        }\\n        if(root->left && root->right)\\n        {\\n            return sum(root->left,2*till)+sum(root->right,2*till);\\n        }\\n        if(root->right)\\n            return sum(root->right,2*till);\\n        if(root->left)\\n            return sum(root->left,2*till);\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        {\\n           return sum(root,0); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2517156,
                "title": "simple-recursive-solution",
                "content": "```\\nclass Solution {\\n    int total =0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        sumBinary(root, 0);\\n        return total;\\n    }\\n    \\n    public void sumBinary(TreeNode root, int sum){\\n        if(root==null)  return;        \\n        sum = sum * 2 + root.val;\\n        if(root.left==null && root.right==null){   \\n            total += sum;\\n            return;\\n        }             \\n        sumBinary(root.left,sum);\\n        sumBinary(root.right,sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int total =0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        sumBinary(root, 0);\\n        return total;\\n    }\\n    \\n    public void sumBinary(TreeNode root, int sum){\\n        if(root==null)  return;        \\n        sum = sum * 2 + root.val;\\n        if(root.left==null && root.right==null){   \\n            total += sum;\\n            return;\\n        }             \\n        sumBinary(root.left,sum);\\n        sumBinary(root.right,sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428079,
                "title": "no-title-just-kiidding-easy-java-soln",
                "content": "```\\nclass Solution {\\n    int res=0;\\n    void go(TreeNode node,int num){\\n        num=(num<<1)|node.val;\\n        if(node.left==null && node.right==null)res+=num;\\n        else{\\n            if(node. left!=null)go(node.left,num);\\n            if(node.right!=null)go(node.right,num);\\n        }\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n        go(root,0);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res=0;\\n    void go(TreeNode node,int num){\\n        num=(num<<1)|node.val;\\n        if(node.left==null && node.right==null)res+=num;\\n        else{\\n            if(node. left!=null)go(node.left,num);\\n            if(node.right!=null)go(node.right,num);\\n        }\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n        go(root,0);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415522,
                "title": "easy-to-understand-backtracking-cpp",
                "content": "class Solution {\\npublic:\\n    int sum;\\n    void dfs(TreeNode* root , string &s )\\n    {\\n        if(root == NULL)\\n            return ;\\n        \\n        s += to_string(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            sum = sum + stoi(s , 0 , 2);\\n            s.pop_back(); \\n            return ;\\n        }      \\n        \\n        dfs(root->left ,s); \\n        dfs(root->right ,s);\\n        s.pop_back(); \\n        \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        sum = 0;\\n        string s =\"\";\\n        dfs(root , s);\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int sum;\\n    void dfs(TreeNode* root , string &s )\\n    {\\n        if(root == NULL)\\n            return ;\\n        \\n        s += to_string(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            sum = sum + stoi(s , 0 , 2);\\n            s.pop_back(); \\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2353547,
                "title": "c-solution-easy-recursive-solution-tc-o-n-sc-o-1",
                "content": "```\\n// IF it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root,int &ans,int num){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left==NULL && root->right==NULL){\\n           num = (num << 1) + root->val;\\n           ans += num;\\n           return;\\n        }\\n\\n        // preorder traversal\\n        num = (num << 1) + root->val;\\n\\n        solve(root->left,ans,num);\\n        solve(root->right,ans,num);\\n    \\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        int num = 0;\\n        solve(root,ans,num);\\n        return ans;\\n    }\\n};\\n\\n// IF it helps plz upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n// IF it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root,int &ans,int num){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left==NULL && root->right==NULL){\\n           num = (num << 1) + root->val;\\n           ans += num;\\n           return;\\n        }\\n\\n        // preorder traversal\\n        num = (num << 1) + root->val;\\n\\n        solve(root->left,ans,num);\\n        solve(root->right,ans,num);\\n    \\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        int num = 0;\\n        solve(root,ans,num);\\n        return ans;\\n    }\\n};\\n\\n// IF it helps plz upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321687,
                "title": "c-fast-easy-commented-picture",
                "content": "![image](https://assets.leetcode.com/users/images/80abde06-c585-4ec7-be9c-ceca7a054fe3_1658580276.606866.png)\\n![image](https://assets.leetcode.com/users/images/57871122-a0f2-49da-b934-c1658a0f46ee_1658580356.3314888.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/80abde06-c585-4ec7-be9c-ceca7a054fe3_1658580276.606866.png)\\n![image](https://assets.leetcode.com/users/images/57871122-a0f2-49da-b934-c1658a0f46ee_1658580356.3314888.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2281298,
                "title": "java-solution-using-parseint",
                "content": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        helper(root,\"\");\\n        return sum;\\n    }\\n    public void helper(TreeNode root,String s)\\n    {\\n        s=s+Integer.toString(root.val);\\n        if(root.left==null && root.right==null)\\n        {\\n            sum=sum+Integer.parseInt(s,2);\\n            return ;\\n        }\\n        if(root.left!=null)\\n            helper(root.left,s);\\n        if(root.right!=null)\\n            helper(root.right,s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        helper(root,\"\");\\n        return sum;\\n    }\\n    public void helper(TreeNode root,String s)\\n    {\\n        s=s+Integer.toString(root.val);\\n        if(root.left==null && root.right==null)\\n        {\\n            sum=sum+Integer.parseInt(s,2);\\n            return ;\\n        }\\n        if(root.left!=null)\\n            helper(root.left,s);\\n        if(root.right!=null)\\n            helper(root.right,s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245552,
                "title": "easy-python-recursive-solution-beats-95",
                "content": "\\t def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = []\\n        def solve(root, s):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                ans.append(s+str(root.val))\\n                return\\n            s += str(root.val)\\n            solve(root.left, s)\\n            solve(root.right,s)\\n        \\n        solve(root, \"\")\\n        res = 0\\n        for i in ans:\\n            res += int(i,2)\\n        return res",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "\\t def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = []\\n        def solve(root, s):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                ans.append(s+str(root.val))\\n                return\\n            s += str(root.val)\\n            solve(root.left, s)\\n            solve(root.right,s)\\n        \\n        solve(root, \"\")\\n        res = 0\\n        for i in ans:\\n            res += int(i,2)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2222603,
                "title": "1022-sum-of-root-to-leaf-binary-numbers-100-faster-0ms",
                "content": "Simple Solution :-\\n\\n*Just Traverse from root to leaf and store the vale in an int value and use recursive calls to return answer.\\n\\nCODE ------------>\\n\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSum(root, 0);\\n    }\\n    \\n    public int getSum(TreeNode root, int data){\\n        if (root==null) return 0;\\n        \\n        data = root.val+data*2;\\n        \\n        if (root.left==null && root.right==null){\\n            return data;\\n        }\\n        \\n        return getSum(root.left, data) + getSum(root.right, data);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSum(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2220178,
                "title": "94-better-solution",
                "content": "```\\ndef f(root, ans):\\n    if root:\\n        ans = (2*ans) + root.val\\n        if not (root.left or root.right):\\n            return ans\\n        return f(root.left, ans) + f(root.right, ans)\\n    return 0\\n\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        return f(root, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ndef f(root, ans):\\n    if root:\\n        ans = (2*ans) + root.val\\n        if not (root.left or root.right):\\n            return ans\\n        return f(root.left, ans) + f(root.right, ans)\\n    return 0\\n\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        return f(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200281,
                "title": "easy-and-efficient-cpp-solution",
                "content": "//Please Upvote if Like \\n```\\n int sumRootToLeaf(TreeNode* root) {\\n         \\n        return sum_util(root,0);        \\n    }\\n    int sum_util(TreeNode* root,int sum)\\n    {\\n       if(root==nullptr)\\n           return 0;\\n        \\n      sum=2*sum+root->val;\\n      if(root->left==nullptr&&root->right==nullptr)\\n          return sum;\\n      return sum_util(root->left,sum)+sum_util(root->right,sum);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int sumRootToLeaf(TreeNode* root) {\\n         \\n        return sum_util(root,0);        \\n    }\\n    int sum_util(TreeNode* root,int sum)\\n    {\\n       if(root==nullptr)\\n           return 0;\\n        \\n      sum=2*sum+root->val;\\n      if(root->left==nullptr&&root->right==nullptr)\\n          return sum;\\n      return sum_util(root->left,sum)+sum_util(root->right,sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2183880,
                "title": "c-easiest-approach-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>v; //to strore all binary strings\\n    int convert(string s) //function to convert binary string to integer\\n    {\\n        int sum=0;\\n        int n=s.length()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                sum+=pow(2,n-i);\\n        }\\n        return sum;\\n    }\\n    void helper(TreeNode* root,string s)//recursive function to gather all the the binary digits from root to leaf \\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(!root->left and !root->right)\\n        {\\n            v.push_back(s);\\n            s=\"\";\\n        }\\n        \\n        helper(root->left,s);\\n        helper(root->right,s);        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s=\"\";\\n        int ans=0;\\n        helper(root,s);\\n        for(auto x:v)   //converting and adding all binary strings\\n            ans+=convert(x);\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v; //to strore all binary strings\\n    int convert(string s) //function to convert binary string to integer\\n    {\\n        int sum=0;\\n        int n=s.length()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                sum+=pow(2,n-i);\\n        }\\n        return sum;\\n    }\\n    void helper(TreeNode* root,string s)//recursive function to gather all the the binary digits from root to leaf \\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(!root->left and !root->right)\\n        {\\n            v.push_back(s);\\n            s=\"\";\\n        }\\n        \\n        helper(root->left,s);\\n        helper(root->right,s);        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s=\"\";\\n        int ans=0;\\n        helper(root,s);\\n        for(auto x:v)   //converting and adding all binary strings\\n            ans+=convert(x);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175813,
                "title": "easy-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    List<String> list=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        findSumRootToLeaf(root, \"\");\\n        for(String binaryVal: list){\\n            sum+=Integer.parseInt(binaryVal,2);\\n        }\\n        return sum;\\n    }\\n    \\n    void findSumRootToLeaf(TreeNode root, String binaryVal){\\n        if(root.left==null && root.right==null){\\n            binaryVal+=root.val;\\n            list.add(binaryVal);\\n            return;\\n        }\\n        if(root.left!=null)\\n            findSumRootToLeaf(root.left, binaryVal+root.val);\\n        if(root.right!=null)\\n            findSumRootToLeaf(root.right, binaryVal+root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> list=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        findSumRootToLeaf(root, \"\");\\n        for(String binaryVal: list){\\n            sum+=Integer.parseInt(binaryVal,2);\\n        }\\n        return sum;\\n    }\\n    \\n    void findSumRootToLeaf(TreeNode root, String binaryVal){\\n        if(root.left==null && root.right==null){\\n            binaryVal+=root.val;\\n            list.add(binaryVal);\\n            return;\\n        }\\n        if(root.left!=null)\\n            findSumRootToLeaf(root.left, binaryVal+root.val);\\n        if(root.right!=null)\\n            findSumRootToLeaf(root.right, binaryVal+root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168021,
                "title": "python-dfs-stack-list",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        total=0\\n        Q=[]\\n        stack=[]\\n        def DFS(r):\\n            if r:\\n                stack.append(str(r.val))\\n                if r.left:\\n                    DFS(r.left)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if r.right:\\n                    DFS(r.right)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if not (r.left or r.right):\\n                    Q.append(int(\\'\\'.join(stack),2))\\n                    \\n        DFS(root)\\n        return sum(Q)",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        total=0\\n        Q=[]\\n        stack=[]\\n        def DFS(r):\\n            if r:\\n                stack.append(str(r.val))\\n                if r.left:\\n                    DFS(r.left)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if r.right:\\n                    DFS(r.right)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if not (r.left or r.right):\\n                    Q.append(int(\\'\\'.join(stack),2))\\n                    \\n        DFS(root)\\n        return sum(Q)",
                "codeTag": "Java"
            },
            {
                "id": 2158600,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        PreOrder(root,0,ans);\\n        return ans;\\n    }\\n    private:\\n    void PreOrder(TreeNode* root,int sum,int &ans)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        PreOrder(root->left,2*sum+root->val,ans);\\n        PreOrder(root->right,2*sum+root->val,ans);\\n        if(!root->left && !root->right)\\n        {\\n            ans += 2*sum+root->val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        PreOrder(root,0,ans);\\n        return ans;\\n    }\\n    private:\\n    void PreOrder(TreeNode* root,int sum,int &ans)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        PreOrder(root->left,2*sum+root->val,ans);\\n        PreOrder(root->right,2*sum+root->val,ans);\\n        if(!root->left && !root->right)\\n        {\\n            ans += 2*sum+root->val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140175,
                "title": "c-easy-solution",
                "content": "```\\nint sum=0;\\n    void summation(TreeNode*root,int num)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        num=num*2+root->val;\\n        if(!root->left && !root->right)\\n        {\\n            sum+=num;\\n        }\\n        summation(root->left,num);\\n        summation(root->right,num);\\n    \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int num=0;\\n        summation(root,num);\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\nint sum=0;\\n    void summation(TreeNode*root,int num)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        num=num*2+root->val;\\n        if(!root->left && !root->right)\\n        {\\n            sum+=num;\\n        }\\n        summation(root->left,num);\\n        summation(root->right,num);\\n    \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int num=0;\\n        summation(root,num);\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2089995,
                "title": "easy-100-working-c-solution-using-recusrion-with-3-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root,int sum=0) {\\n        //if root is null we return null\\n        if(!root) return 0;\\n        //then here we correspondingly calculate convert the binary to decimal\\n        sum=2*sum+root->val;\\n    //then here we check if we have the leaf nodes its the least significant bit we return the same value  and call the left func and right func\\n        return root->left==root->right?sum : sumRootToLeaf(root->left,sum)+sumRootToLeaf(root->right,sum);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root,int sum=0) {\\n        //if root is null we return null\\n        if(!root) return 0;\\n        //then here we correspondingly calculate convert the binary to decimal\\n        sum=2*sum+root->val;\\n    //then here we check if we have the leaf nodes its the least significant bit we return the same value  and call the left func and right func\\n        return root->left==root->right?sum : sumRootToLeaf(root->left,sum)+sumRootToLeaf(root->right,sum);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565577,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1566694,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1565864,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1574348,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1994738,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1856259,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1728246,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1728244,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1718028,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            }
        ]
    }
]