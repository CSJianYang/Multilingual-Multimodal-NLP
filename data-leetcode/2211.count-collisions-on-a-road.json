[
    {
        "title": "Average Salary: Departments VS Company",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1574961,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 2073332,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 2049872,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 1890405,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 1738119,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 1698319,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 1675487,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            },
            {
                "id": 1643082,
                "content": [
                    {
                        "username": "CharlesLoveStudy",
                        "content": "# Write your MySQL query statement below\\nWITH tb1 AS(SELECT LEFT(pay_date,7) AS pay_month, department_id,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7),department_id) AS dept_avg_amount,\\nAVG(amount) OVER(PARTITION BY LEFT(pay_date,7)) AS company_avg_amount\\nFROM salary s JOIN employee e ON s.employee_id=e.employee_id)\\n\\nSELECT DISTINCT pay_month, department_id,\\n(CASE WHEN dept_avg_amount<company_avg_amount THEN \\'lower\\'\\n      WHEN dept_avg_amount>company_avg_amount THEN \\'higher\\'\\n ELSE \\'same\\'\\n END) AS comparison\\nFROM tb1\\n"
                    },
                    {
                        "username": "pawelofficial",
                        "content": "as always the wording of the question is terrible. The report should contain comparison of monthly salaries per department vs monthly salaries for whole company."
                    },
                    {
                        "username": "zedzogrind",
                        "content": "awfully written question?"
                    },
                    {
                        "username": "Cyue0813",
                        "content": "Question: Why I delete avg1 and avg_d, the output will change to an incorrect answer? But, if I add them, the comparison is correct. \\n\\nCODE:\\n\\nWITH average AS (SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, AVG(amount)OVER(partition by pay_date) AS avg1\\nFROM Salary AS s),\\nunion_all AS(\\n  SELECT DISTINCT DATE_FORMAT(pay_date, \\'%Y-%m\\') AS pay_month, s.employee_id, e.department_id, avg(amount)over(partition by department_id, pay_date) AS avg_d\\n  FROM Salary AS s\\n  JOIN Employee AS e\\n  ON s.employee_id = e.employee_id\\n)\\nSELECT a.pay_month, u.department_id, avg1, avg_d,\\nCASE WHEN avg_d > avg1 THEN \\'higher\\'\\n         WHEN avg_d < avg1 THEN \\'lower\\'\\n         ELSE \\'same\\' \\nEND AS comparison\\nFROM average AS a\\nLEFT JOIN union_all AS u\\nON a.pay_month = u.pay_month \\nGROUP BY  a.pay_month, u.department_id\\nORDER BY  u.department_id, a.pay_month"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Simple Solution Using CTE (SQL SERVER)\\nwith avg_company_salary as\\n(select s.employee_id, department_id, amount, pay_date\\n  ,avg(amount) over (partition by pay_date)avg_company_salary\\n     from salary s\\n       join employee e on s.employee_id = e.employee_id)\\n\\n,avg_dept_salary as\\n(select department_id, pay_date\\n  ,avg(amount) over \\n     (partition by pay_date, department_id)avg_dept_salary,\\n         cast(avg_company_salary as float)avg_company_salary from avg_company_salary)\\n\\nselect distinct \\n  concat(datepart(year, pay_date),\\'-\\', RIGHT(CONCAT(\\'0\\', MONTH([pay_date])), 2))\\n    pay_month,  \\n      department_id,\\n    ( case \\n      when avg_dept_salary > avg_company_salary then \\'higher\\'\\n        when avg_dept_salary < avg_company_salary then \\'lower\\'\\n          else \\'same\\' end) comparison\\n            from avg_dept_salary"
                    },
                    {
                        "username": "Kurt1999",
                        "content": "select distinct date_format(pay_date,\\'%Y-%m\\') as pay_month, department_id, case when avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) > 0 then \\'lower\\'\\nwhen  avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\')) - avg(amount) over (partition by date_format(pay_date,\\'%Y-%m\\'), department_id) < 0 then \\'higher\\'\\nelse \\'same\\' end as comparison\\nfrom Salary S\\nleft join Employee E\\non S.employee_id = E.employee_id;"
                    },
                    {
                        "username": "kjcooper17",
                        "content": "Adding group by elements messes up window function calculation?\\n\\nIf I run this without department_id, pay_date (also remove group by) this calculates the right values, when I add them it screws it up, how come?\\n\\nselect\\ndepartment_id,\\npay_date,\\navg(amount) over (partition by a.pay_date,b.department_id) as dept_salary,\\navg(amount) over (partition by a.pay_date) as salary\\nfrom Salary a \\nleft join Employee b on a.employee_id = b.employee_id\\ngroup by 1,2 @"
                    },
                    {
                        "username": "novicewhistler",
                        "content": "Could anyone help me in debugging this? Not able to see the bug for the life of me -_-.\\n\\nMy code is \\n `\\nwith enhanced_salary_table as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        Employee.department_id,\\n        Salary.amount\\n    from Salary\\n    left join Employee\\n    on Salary.employee_id = Employee.employee_id\\n),\\nmonthly_org_avg as (\\n    select \\n        date_format(pay_date, \\'%Y-%m\\') as pay_month ,\\n        avg(Salary.amount) as org_avg_salary\\n    from Salary\\n    group by pay_month\\n)\\n\\nselect \\n    enhanced_salary_table.pay_month,\\n    enhanced_salary_table.department_id,\\n    case \\n        when avg(enhanced_salary_table.amount) < monthly_org_avg.org_avg_salary then \"lower\"\\n        when avg(enhanced_salary_table.amount) > monthly_org_avg.org_avg_salary then \"higher\"\\n        else \"same\" \\n    end as comparison\\nfrom enhanced_salary_table\\nleft join monthly_org_avg \\non enhanced_salary_table.pay_month = monthly_org_avg.pay_month\\ngroup by enhanced_salary_table.pay_month, enhanced_salary_table.department_id;\\n\\n`\\n\\nI fail the last test case where \\nSalary =\\n| id | employee_id | amount | pay_date   |\\n| -- | ----------- | ------ | ---------- |\\n| 1  | 1           | 9000   | 2017/03/31 |\\n| 2  | 2           | 6000   | 2017/03/31 |\\n| 3  | 3           | 10000  | 2017/03/31 |\\n| 4  | 1           | 7000   | 2017/02/26 |\\n| 5  | 2           | 6000   | 2017/02/27 |\\n| 6  | 3           | 8000   | 2017/02/22 |\\n\\n\\nEmployee =\\n| employee_id | department_id |\\n| ----------- | ------------- |\\n| 1           | 1             |\\n| 2           | 1             |\\n| 3           | 1             |\\n\\n\\nExpected\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-02   | 1             | same       |\\n| 2017-03   | 1             | same       |\\n\\n\\nOutput\\n\\n| pay_month | department_id | comparison |\\n| --------- | ------------- | ---------- |\\n| 2017-03   | 1             | higher     |\\n| 2017-02   | 1             | same       |\\n\\n\\n\\nNo clue why I have higher in the comparison, where it should have been same. "
                    },
                    {
                        "username": "jfmsouza",
                        "content": "[@user1415gR](/user1415gR) round() worked for me! Thanks!"
                    },
                    {
                        "username": "user1415gR",
                        "content": "This is maybe due to the decimals. trying to use round() function in your case when clause, maybe it can help(you don\\'t know what would be showed in the endless decimals, so give a limitation)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Artifacts That Can Be Extracted",
        "question_content": "<p>There is an <code>n x n</code> <strong>0-indexed</strong> grid with some artifacts buried in it. You are given the integer <code>n</code> and a <strong>0-indexed </strong>2D integer array <code>artifacts</code> describing the positions of the rectangular artifacts where <code>artifacts[i] = [r1<sub>i</sub>, c1<sub>i</sub>, r2<sub>i</sub>, c2<sub>i</sub>]</code> denotes that the <code>i<sup>th</sup></code> artifact is buried in the subgrid where:</p>\n\n<ul>\n\t<li><code>(r1<sub>i</sub>, c1<sub>i</sub>)</code> is the coordinate of the <strong>top-left</strong> cell of the <code>i<sup>th</sup></code> artifact and</li>\n\t<li><code>(r2<sub>i</sub>, c2<sub>i</sub>)</code> is the coordinate of the <strong>bottom-right</strong> cell of the <code>i<sup>th</sup></code> artifact.</li>\n</ul>\n\n<p>You will excavate some cells of the grid and remove all the mud from them. If the cell has a part of an artifact buried underneath, it will be uncovered. If all the parts of an artifact are uncovered, you can extract it.</p>\n\n<p>Given a <strong>0-indexed</strong> 2D integer array <code>dig</code> where <code>dig[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> indicates that you will excavate the cell <code>(r<sub>i</sub>, c<sub>i</sub>)</code>, return <em>the number of artifacts that you can extract</em>.</p>\n\n<p>The test cases are generated such that:</p>\n\n<ul>\n\t<li>No two artifacts overlap.</li>\n\t<li>Each artifact only covers at most <code>4</code> cells.</li>\n\t<li>The entries of <code>dig</code> are unique.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram.jpg\" style=\"width: 216px; height: 216px;\" />\n<pre>\n<strong>Input:</strong> n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> \nThe different colors represent different artifacts. Excavated cells are labeled with a &#39;D&#39; in the grid.\nThere is 1 artifact that can be extracted, namely the red artifact.\nThe blue artifact has one part in cell (1,1) which remains uncovered, so we cannot extract it.\nThus, we return 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram-1.jpg\" style=\"width: 216px; height: 216px;\" />\n<pre>\n<strong>Input:</strong> n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Both the red and blue artifacts have all parts uncovered (labeled with a &#39;D&#39;) and can be extracted, so we return 2. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= artifacts.length, dig.length &lt;= min(n<sup>2</sup>, 10<sup>5</sup>)</code></li>\n\t<li><code>artifacts[i].length == 4</code></li>\n\t<li><code>dig[i].length == 2</code></li>\n\t<li><code>0 &lt;= r1<sub>i</sub>, c1<sub>i</sub>, r2<sub>i</sub>, c2<sub>i</sub>, r<sub>i</sub>, c<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>r1<sub>i</sub> &lt;= r2<sub>i</sub></code></li>\n\t<li><code>c1<sub>i</sub> &lt;= c2<sub>i</sub></code></li>\n\t<li>No two artifacts will overlap.</li>\n\t<li>The number of cells covered by an artifact is <strong>at most</strong> <code>4</code>.</li>\n\t<li>The entries of <code>dig</code> are unique.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1844151,
                "title": "java-hashset",
                "content": "* Add all digged cells in set\\n* Loop in every artifacts and if any cell of any artifact is not digged \\n  then that artifact is not completely extracted.\\n* Otherwise increment result.\\n```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        HashSet<String> set = new HashSet<>();\\n        for (int d[] : dig) set.add(d[0] + \" \" + d[1]);\\n        int c = 0;\\n        for (int a[] : artifacts) {\\n            boolean done = true;\\n            for (int i = a[0]; i <= a[2]; i++) {\\n                for (int j = a[1]; j <= a[3]; j++) {\\n                    if (!set.contains(i + \" \" + j)) done = false;\\n                }\\n            }\\n            if (done) c++;\\n        }\\n        return c;\\n    }\\n}\\n//TC = O(DIG + N^2)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        HashSet<String> set = new HashSet<>();\\n        for (int d[] : dig) set.add(d[0] + \" \" + d[1]);\\n        int c = 0;\\n        for (int a[] : artifacts) {\\n            boolean done = true;\\n            for (int i = a[0]; i <= a[2]; i++) {\\n                for (int j = a[1]; j <= a[3]; j++) {\\n                    if (!set.contains(i + \" \" + j)) done = false;\\n                }\\n            }\\n            if (done) c++;\\n        }\\n        return c;\\n    }\\n}\\n//TC = O(DIG + N^2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844654,
                "title": "visual-python-easy-to-understand-o-n-2-time-o-n-2-space",
                "content": "\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?** \\uD83D\\uDD3A\\n\\n**Approach**\\nHere we want to check if each part of an artifact is completely dug up. To do this we check each artifact, comparing it to what has been dug to see if it is completely excavated.\\n\\n**Visual**\\nHere is a visual for the example in the question description where red and blue are two seperate artifacts. In this example:\\nn = 2\\nartifacts = [[0,0,0,0],[0,1,1,1]]\\ndig = [[0,0],[0,1],[1,1]]\\n\\n![image](https://assets.leetcode.com/users/images/ac085db9-7c68-4eea-9cf0-0b39b9ea7c96_1647150402.8707469.png)\\n\\n\\n**Code**\\nSee below for code related to this visual.\\n<iframe src=\"https://leetcode.com/playground/MFdGPhTs/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?** \\uD83D\\uDD3A",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?** \\uD83D\\uDD3A\\n\\n**Approach**\\nHere we want to check if each part of an artifact is completely dug up. To do this we check each artifact, comparing it to what has been dug to see if it is completely excavated.\\n\\n**Visual**\\nHere is a visual for the example in the question description where red and blue are two seperate artifacts. In this example:\\nn = 2\\nartifacts = [[0,0,0,0],[0,1,1,1]]\\ndig = [[0,0],[0,1],[1,1]]\\n\\n![image](https://assets.leetcode.com/users/images/ac085db9-7c68-4eea-9cf0-0b39b9ea7c96_1647150402.8707469.png)\\n\\n\\n**Code**\\nSee below for code related to this visual.\\n<iframe src=\"https://leetcode.com/playground/MFdGPhTs/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\uD83D\\uDD3A**Please UPVOTE: Can we hit 20?** \\uD83D\\uDD3A",
                "codeTag": "Unknown"
            },
            {
                "id": 1844218,
                "title": "c-easy-to-understand-detailed-explanation",
                "content": "Just traverse in dig and mark all the cell visited where we have to dig, and then traverse in the artifacts, if all the cells from start of artifact( r1,c1) to end of artifact( r2,c2) is visited then the whole artifact will be visible, so count it.\\nTime Taken:   It will be  O(n^2), as in the worst case n^2 cells can be there to dig, and the length of artifacts can be n^2,  The inner loops will be constant as the size of artifact is fixed.\\nso, the time complexity will be O(O(n^2) + O(n^2)) = O(2*(n^2)) = O(n^2)\\n\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>>visited(n,vector<bool>(n,0));\\n        for(auto vec:dig){\\n            visited[vec[0]][vec[1]] = 1;\\n        }\\n        \\n        int count = 0;\\n        for(auto artifact:artifacts){\\n            int r1 = artifact[0];\\n            int c1 = artifact[1];\\n            int r2 = artifact[2];\\n            int c2 = artifact[3];\\n            bool flag = true;\\n\\t\\t\\t\\n            for(int i = r1;i<=r2;i++){\\n                for(int j = c1;j<=c2;j++){\\n                    if(!visited[i][j]){\\n                        flag = false;\\n                    }\\n                }\\n            }\\n            \\n            if(flag)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n^2)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>>visited(n,vector<bool>(n,0));\\n        for(auto vec:dig){\\n            visited[vec[0]][vec[1]] = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1844323,
                "title": "c-prefix-sum-solution-2201",
                "content": "\\n1. Create the matrix and initiate it with all 1s\\n2. The points which were dig, mark them as 0\\n3. Create a prefix sum matrix and check if sum of the sub matrix of each artifact is 0\\n Without creating the prefix sum also we can check for each artifact as it is more efficient because artifacts won\\'t overlap so it would be O(n^2). Creating a prefix sum adds one more nested for loop but more understandable\\n4. If the sum is 0 it means every point inside the artifact has been digged and can be extracted\\n\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>>arr(n,vector<int>(n,1));\\n        for(vector<int>& v : dig){\\n            arr[v[0]][v[1]] = 0;\\n        }\\n        int preSum[n+1][n+1];\\n        for(int i=0;i<=n;i++){preSum[i][0] = 0; preSum[0][i] = 0;}\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++){\\n                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] - preSum[i-1][j-1] + arr[i-1][j-1];\\n            }\\n        }\\n        int res = 0,sum,r1,c1,r2,c2;\\n        for(vector<int>& v : artifacts){\\n            r1 = v[0]; c1 = v[1]; r2 = v[2]; c2 = v[3];\\n            sum = preSum[r2+1][c2+1] - preSum[r1][c2+1] - preSum[r2+1][c1] + preSum[r1][c1];\\n            if(sum == 0){res++;}\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFeel free to comment your queries if any\\n**Upvote** if found useful\\n**Thank You :)**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>>arr(n,vector<int>(n,1));\\n        for(vector<int>& v : dig){\\n            arr[v[0]][v[1]] = 0;\\n        }\\n        int preSum[n+1][n+1];\\n        for(int i=0;i<=n;i++){preSum[i][0] = 0; preSum[0][i] = 0;}\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++){\\n                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] - preSum[i-1][j-1] + arr[i-1][j-1];\\n            }\\n        }\\n        int res = 0,sum,r1,c1,r2,c2;\\n        for(vector<int>& v : artifacts){\\n            r1 = v[0]; c1 = v[1]; r2 = v[2]; c2 = v[3];\\n            sum = preSum[r2+1][c2+1] - preSum[r1][c2+1] - preSum[r2+1][c1] + preSum[r1][c1];\\n            if(sum == 0){res++;}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844551,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        \\n        boolean visit[][]=new boolean[n][n];\\n        for(int arr[]:dig){\\n            visit[arr[0]][arr[1]]=true;\\n        }\\n        \\n        int ans=0;\\n        for(int arr[]:artifacts){\\n            \\n            boolean flag=true;\\n            for(int i=arr[0];i<=arr[2];i++){\\n                for(int j=arr[1];j<=arr[3];j++){\\n                    if(!visit[i][j]) flag=false;\\n                }\\n            }\\n            if(flag) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        \\n        boolean visit[][]=new boolean[n][n];\\n        for(int arr[]:dig){\\n            visit[arr[0]][arr[1]]=true;\\n        }\\n        \\n        int ans=0;\\n        for(int arr[]:artifacts){\\n            \\n            boolean flag=true;\\n            for(int i=arr[0];i<=arr[2];i++){\\n                for(int j=arr[1];j<=arr[3];j++){\\n                    if(!visit[i][j]) flag=false;\\n                }\\n            }\\n            if(flag) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845189,
                "title": "c-boolean-array-well-explained-with-comments",
                "content": "***If you find it helpful, please do upvote <3***\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int digArtifacts(int n, vector<vector<int>> &artifacts, vector<vector<int>> &dig)\\n    {\\n        vector<vector<bool>> visited(n, vector<bool>(n, false)); // initialising N x N vector to FALSE\\n        int i = 0;\\n        for (int i = 0; i < dig.size(); i++) // using dig array to make all the positions that can be digged, as TRUE\\n        {\\n            int x = dig[i][0],\\n                y = dig[i][1];\\n            visited[x][y] = true;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < artifacts.size(); i++) // running through artifacts array\\n        {\\n            int x1 = artifacts[i][0],\\n                x2 = artifacts[i][2], // finding X and Y coordinate, based on top-left and bottom-right cell\\n                y1 = artifacts[i][1],\\n                y2 = artifacts[i][3];\\n            bool excavated = true;\\n            for (int x = x1; x <= x2; x++)\\n            {\\n                for (int y = y1; y <= y2; y++)\\n                {\\n                    if (!visited[x][y]) // if any part of the current subgrid can\\'t be excavated, then set excavated as false\\n                    {\\n                        excavated = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (excavated) // if every part of the subgrid can be excavated correctly then we can excavate the current artifact\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Any suggestions are welcome into the comment section\\nThank you !!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int digArtifacts(int n, vector<vector<int>> &artifacts, vector<vector<int>> &dig)\\n    {\\n        vector<vector<bool>> visited(n, vector<bool>(n, false)); // initialising N x N vector to FALSE\\n        int i = 0;\\n        for (int i = 0; i < dig.size(); i++) // using dig array to make all the positions that can be digged, as TRUE\\n        {\\n            int x = dig[i][0],\\n                y = dig[i][1];\\n            visited[x][y] = true;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < artifacts.size(); i++) // running through artifacts array\\n        {\\n            int x1 = artifacts[i][0],\\n                x2 = artifacts[i][2], // finding X and Y coordinate, based on top-left and bottom-right cell\\n                y1 = artifacts[i][1],\\n                y2 = artifacts[i][3];\\n            bool excavated = true;\\n            for (int x = x1; x <= x2; x++)\\n            {\\n                for (int y = y1; y <= y2; y++)\\n                {\\n                    if (!visited[x][y]) // if any part of the current subgrid can\\'t be excavated, then set excavated as false\\n                    {\\n                        excavated = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (excavated) // if every part of the subgrid can be excavated correctly then we can excavate the current artifact\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844131,
                "title": "c-set-solution-goto",
                "content": "- Create a set of pairs in which we will store all points which are dug.\\n- Iterate over each artifact and if at any point some part of artifact is not dug,\\n we will simply jump to the next artifact  \\n ```cpp\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        \\n        set<pair<int, int>> S;\\n        int ansCnt = 0;\\n        for(auto a : dig) {\\n            S.insert({a[0], a[1]});\\n        }\\n        \\n        \\n        for(auto a : artifacts) {\\n            for(int i = a[0]; i <= a[2]; i++) {\\n                for(int j = a[1]; j <= a[3]; j++) {\\n                    if(!S.count({i, j})) goto end;\\n                }\\n            }\\n            ansCnt++;\\n            end:;\\n        }\\n        \\n        return ansCnt;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "- Create a set of pairs in which we will store all points which are dug.\\n- Iterate over each artifact and if at any point some part of artifact is not dug,\\n we will simply jump to the next artifact  \\n ```cpp\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        \\n        set<pair<int, int>> S;\\n        int ansCnt = 0;\\n        for(auto a : dig) {\\n            S.insert({a[0], a[1]});\\n        }\\n        \\n        \\n        for(auto a : artifacts) {\\n            for(int i = a[0]; i <= a[2]; i++) {\\n                for(int j = a[1]; j <= a[3]; j++) {\\n                    if(!S.count({i, j})) goto end;\\n                }\\n            }\\n            ansCnt++;\\n            end:;\\n        }\\n        \\n        return ansCnt;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1877500,
                "title": "set",
                "content": "We track all dig cells in a set. Then, for each artifact, we check all of the artifacts cells are in that set.\\n\\n**C++**\\n```cpp\\nint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n    set<pair<int, int>> s;\\n    auto find = [&](auto &a) {\\n        for (int i = a[0]; i <= a[2]; ++i)\\n            for (int j = a[1]; j <= a[3]; ++j)\\n                if (s.count({i, j}) == 0)\\n                    return 0;\\n        return 1;  \\n    };\\n    for (auto &d : dig)\\n        s.insert({d[0], d[1]});    \\n    return accumulate(begin(artifacts), end(artifacts), 0, [&](int s, auto &a){ return s + find(a);});\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n    set<pair<int, int>> s;\\n    auto find = [&](auto &a) {\\n        for (int i = a[0]; i <= a[2]; ++i)\\n            for (int j = a[1]; j <= a[3]; ++j)\\n                if (s.count({i, j}) == 0)\\n                    return 0;\\n        return 1;  \\n    };\\n    for (auto &d : dig)\\n        s.insert({d[0], d[1]});    \\n    return accumulate(begin(artifacts), end(artifacts), 0, [&](int s, auto &a){ return s + find(a);});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844361,
                "title": "python-elegant-short-and-simple-to-understand-with-explanations",
                "content": "## Solution 1 - Hash dig positions\\n\\n1. Since we know all the dig spots, we add all of them into a set for fast lookup. \\n1. Then we go through each artifact and check if all the positions for that artifact exist in the dig spots set. \\n    - If they do, we increment our results counter, otherwise proceed to the next artifact\\n\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n\\t    # Time: O(max(artifacts, dig)) which is O(N^2) as every position in the grid can be in dig\\n\\t\\t# Space: O(dig) which is O(N^2)\\n        result, dig_pos = 0, set(tuple(pos) for pos in dig)\\n        for pos in artifacts:\\n            if all((x, y) in dig_pos for x in range(pos[0], pos[2] + 1) for y in range(pos[1], pos[3] + 1)):     \\n                result += 1\\n        return result\\n```\\n\\n## Solution 2 - Hash artifact positions\\n\\nWe make use of two hashmaps in this solution. \\n\\n1. The first would be a map of positions to the artifacts, uniquely identified by their index in the `artifacts` array\\n2. The second would be a map of artifact index to how many spots left for artifact that is undug\\n\\nOur first loop would be to go through the artifacts and add their positions to the first hashmap, and add how many positions are there into the second hashmap.\\n\\nThe second loop goes through the dig positions, find the artifact corresponding to each position (if it exists), then update the second hashmap for how many positions left to dig for that artifact. If the remaining count is 0, the artifact is entirely dug up and we can increment our results counter.\\n\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        pos_to_artifacts = {} # (x, y) => artifact unique index\\n        artifacts_to_remaining = {} # artifact unique index to remaining spots for artifact to dig up\\n        results = 0\\n        \\n\\t\\t# Each artifact is identified by a unique index.\\n        for id, artifact in enumerate(artifacts):\\n            start, end = (artifact[0], artifact[1]), (artifact[2], artifact[3])\\n            size = 0\\n            for x in range(start[0], end[0] + 1):\\n                for y in range(start[1], end[1] + 1):\\n                    pos_to_artifacts[(x, y)] = id\\n                    size += 1\\n            artifacts_to_remaining[id] = size\\n        \\n        for pos in dig:\\n            if tuple(pos) not in pos_to_artifacts:\\n                continue\\n            id = pos_to_artifacts[tuple(pos)]\\n            artifacts_to_remaining[id] = artifacts_to_remaining[id] - 1\\n            if artifacts_to_remaining[id] == 0:\\n                results += 1\\n\\n        return results\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n\\t    # Time: O(max(artifacts, dig)) which is O(N^2) as every position in the grid can be in dig\\n\\t\\t# Space: O(dig) which is O(N^2)\\n        result, dig_pos = 0, set(tuple(pos) for pos in dig)\\n        for pos in artifacts:\\n            if all((x, y) in dig_pos for x in range(pos[0], pos[2] + 1) for y in range(pos[1], pos[3] + 1)):     \\n                result += 1\\n        return result\\n```\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        pos_to_artifacts = {} # (x, y) => artifact unique index\\n        artifacts_to_remaining = {} # artifact unique index to remaining spots for artifact to dig up\\n        results = 0\\n        \\n\\t\\t# Each artifact is identified by a unique index.\\n        for id, artifact in enumerate(artifacts):\\n            start, end = (artifact[0], artifact[1]), (artifact[2], artifact[3])\\n            size = 0\\n            for x in range(start[0], end[0] + 1):\\n                for y in range(start[1], end[1] + 1):\\n                    pos_to_artifacts[(x, y)] = id\\n                    size += 1\\n            artifacts_to_remaining[id] = size\\n        \\n        for pos in dig:\\n            if tuple(pos) not in pos_to_artifacts:\\n                continue\\n            id = pos_to_artifacts[tuple(pos)]\\n            artifacts_to_remaining[id] = artifacts_to_remaining[id] - 1\\n            if artifacts_to_remaining[id] == 0:\\n                results += 1\\n\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844352,
                "title": "c-simple-for-beginners-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& art, vector<vector<int>>& dig) {\\n        int res = 0;\\n        bool grid[1000][1000] = {false};\\n        for(int i=0;i<dig.size();i++)\\n        {\\n            grid[dig[i][0]][dig[i][1]]=true;\\n        }\\n        for(int i=0;i<art.size();i++)\\n        {\\n            int startrow = art[i][0];\\n            int endrow = art[i][2];\\n            int startcol = art[i][1];\\n            int endcol = art[i][3];\\n            bool flag = true;\\n            for(int k = startrow;k<=endrow;k++)\\n            {\\n                for(int j = startcol;j<=endcol;j++)\\n                {\\n                    if(grid[k][j]==false)\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& art, vector<vector<int>>& dig) {\\n        int res = 0;\\n        bool grid[1000][1000] = {false};\\n        for(int i=0;i<dig.size();i++)\\n        {\\n            grid[dig[i][0]][dig[i][1]]=true;\\n        }\\n        for(int i=0;i<art.size();i++)\\n        {\\n            int startrow = art[i][0];\\n            int endrow = art[i][2];\\n            int startcol = art[i][1];\\n            int endcol = art[i][3];\\n            bool flag = true;\\n            for(int k = startrow;k<=endrow;k++)\\n            {\\n                for(int j = startcol;j<=endcol;j++)\\n                {\\n                    if(grid[k][j]==false)\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844976,
                "title": "c-just-simulating-the-process-easy-to-understand",
                "content": "Hi, Leetcode Fam,\\nIn this question we have to find the total number of artifacts which can be digged **completly** . According to the question parameters we are given the artifacts and the dig array (**both 2D-integer array**) and the size of the the artifacts array ( **n** ).  \\nFirst let\\'s understand the parameters : \\n1. artifacts[r1, c1, r2, c2] -> Here r1, c1 is the starting cell or top-left cell of the artifact and similarly the r2, c2 is the ending cell or bottom-right cell of the **current artifact**.\\n2. dig[r1,c1] -> Here r1, c1 represents the current cell (of the matrix/artifact matrix) which can be digged.\\n\\n**Approach:** \\nIn this question we just have to **count the total number of artifacts which can be digged completly**, so we can think of an approach where we can mark the cells which can be digged and after that we can traverse the artifacts array and check whether my all cells of current artifact are already digged, if so we will increment our count.\\n\\nSo, firstly we will initialize a matix of size **n x n** with 0 and after that we will **traverse the dig array and mark the cells with -1 (Here -1 will indicate that the current cell will be digged).**\\nAfter that we will traverse the artifact array, and check if my **all cellls of current artifact are marked with -1** ( which means that this current cell will be digged ), and if so we will increment our cnt variable( which stores our answer).\\n\\n**Now let\\'s see the above implementation [ C++ ]:**\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>>mat(n, vector<int>(n, 0)); // initializing the matrix of size n x n with 0.\\n        \\n        for(auto v:dig) {\\n            int r1 = v[0];    \\n            int c1 = v[1];\\n            mat[r1][c1] = -1;     // marking the current cell with -1 ( which means cell will be digged )\\n        }\\n        int cnt = 0;              //  initalizing our count variable with 0 (answer variable).\\n        for(auto v:artifacts) {\\n            int r1 = v[0];\\n            int c1 = v[1];\\n            int r2 = v[2];\\n            int c2 = v[3];\\n            \\n            bool flag  = true;\\n            for(int i=r1; i<=r2; i++) {\\n                for(int j=c1; j<=c2; j++) {\\n                    if(mat[i][j]!=-1) {              // checking if my all cells of artifact are marked with -1\\n                        flag = false;                // if not we will make our flag variable false indicating that we will\\n                    }                               // not count this artifact as digged.\\n                }\\n            }\\n            if(flag == true) cnt++;    // else we will increment our answer variable.\\n        }        \\n        return cnt;          // At last returning our answer variable.\\n        \\n    }\\n};\\n```\\n\\nI hope this article will help you a lot, if so please do upvote.\\nIf you have any question, feel free to ask.\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>>mat(n, vector<int>(n, 0)); // initializing the matrix of size n x n with 0.\\n        \\n        for(auto v:dig) {\\n            int r1 = v[0];    \\n            int c1 = v[1];\\n            mat[r1][c1] = -1;     // marking the current cell with -1 ( which means cell will be digged )\\n        }\\n        int cnt = 0;              //  initalizing our count variable with 0 (answer variable).\\n        for(auto v:artifacts) {\\n            int r1 = v[0];\\n            int c1 = v[1];\\n            int r2 = v[2];\\n            int c2 = v[3];\\n            \\n            bool flag  = true;\\n            for(int i=r1; i<=r2; i++) {\\n                for(int j=c1; j<=c2; j++) {\\n                    if(mat[i][j]!=-1) {              // checking if my all cells of artifact are marked with -1\\n                        flag = false;                // if not we will make our flag variable false indicating that we will\\n                    }                               // not count this artifact as digged.\\n                }\\n            }\\n            if(flag == true) cnt++;    // else we will increment our answer variable.\\n        }        \\n        return cnt;          // At last returning our answer variable.\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844215,
                "title": "c",
                "content": "```\\n#include <unordered_map>\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& art, vector<vector<int>>& dig) {\\n        map<vector<int> , bool> di;\\n                for(vector<int> x : dig){\\n                    di[x] = true; \\n                }\\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < art.size() ; i++){\\n            bool found = true;\\n            for(int j = art[i][0] ; j <= art[i][2] ; j++){\\n                for(int k = art[i][1] ; k <= art[i][3] ; k++){\\n                    if(di[{j,k}] == false){\\n                        found = false;\\n                    }\\n                }\\n            }\\n            if(found) ans++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <unordered_map>\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& art, vector<vector<int>>& dig) {\\n        map<vector<int> , bool> di;\\n                for(vector<int> x : dig){\\n                    di[x] = true; \\n                }\\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < art.size() ; i++){\\n            bool found = true;\\n            for(int j = art[i][0] ; j <= art[i][2] ; j++){\\n                for(int k = art[i][1] ; k <= art[i][3] ; k++){\\n                    if(di[{j,k}] == false){\\n                        found = false;\\n                    }\\n                }\\n            }\\n            if(found) ans++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1844120,
                "title": "simple-python-code-explained",
                "content": "The Idea here is simple :\\n- Add all the digs into a set\\n- iterate over all the artifacts and find all the grids present between each artifact and check whether all of them exits in the set and if yes, increment the pointer\\n\\nCode:\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        s=set()\\n        for i in dig:\\n            s.add((i[0],i[1]))\\n        ans=0\\n        for a in artifacts:\\n            flag=0\\n            for i in range(a[0],a[2]+1):\\n                for j in range(a[1],a[3]+1):\\n                    if((i,j) not in s):\\n                        flag=1\\n                        break\\n            if(flag==0):ans+=1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        s=set()\\n        for i in dig:\\n            s.add((i[0],i[1]))\\n        ans=0\\n        for a in artifacts:\\n            flag=0\\n            for i in range(a[0],a[2]+1):\\n                for j in range(a[1],a[3]+1):\\n                    if((i,j) not in s):\\n                        flag=1\\n                        break\\n            if(flag==0):ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844106,
                "title": "c-easy-loops",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nCreate an `NxN` array `M`. `M[i][j] = true` if the cell `(i, j)` is digged.\\n\\nFor each artifact, traverse all its cells. If all the cells are digged, increment the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-284/problems/count-artifacts-that-can-be-extracted/\\n// Author: github.com/lzl124631x\\n// Time: O(DIG + N^2)\\n// Space: O(N^2)\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& A, vector<vector<int>>& dig) {\\n        vector<vector<bool>> M(n, vector<bool>(n)); // M[i][j] = true if it\\'s digged.\\n        for (auto &d : dig) M[d[0]][d[1]] = true;\\n        int ans = 0;\\n        for (auto &v : A) {\\n            bool good = true;\\n            for (int x = v[0]; x <= v[2] && good; ++x) {\\n                for (int y = v[1]; y <= v[3] && good; ++y) {\\n                    if (!M[x][y]) good = false;\\n                }\\n            }\\n            if (good) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-284/problems/count-artifacts-that-can-be-extracted/\\n// Author: github.com/lzl124631x\\n// Time: O(DIG + N^2)\\n// Space: O(N^2)\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& A, vector<vector<int>>& dig) {\\n        vector<vector<bool>> M(n, vector<bool>(n)); // M[i][j] = true if it\\'s digged.\\n        for (auto &d : dig) M[d[0]][d[1]] = true;\\n        int ans = 0;\\n        for (auto &v : A) {\\n            bool good = true;\\n            for (int x = v[0]; x <= v[2] && good; ++x) {\\n                for (int y = v[1]; y <= v[3] && good; ++y) {\\n                    if (!M[x][y]) good = false;\\n                }\\n            }\\n            if (good) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844168,
                "title": "python-solution-using-matrix-and-simple-counting",
                "content": "We number each artifact differently in a grid matrix of size n * n. Then we set the value of each grid[r][c] for r, c in dig to -1 meaning that they have been dug up. Now traverse the grid matrix finally and see which artifact numbers still remains. Those artifacts are the once which were not fully excavated. Now subrtact the number of total artifacts to the number of artifacts remaining, this gives us the artifacts which were successfully dug up completely.\\n\\n**STEPS:**\\n1. Make a grid matrix of size n * n denoting our ground of operation.\\n2. Now populate each individual artifact (all of its blocks) with a unique number.\\n3. Now traverse the dig array and set grid[r][c] to -1 deonting that that index is now dug up.\\n4. Now traverse the grid completely and check which artifacts number still remains as they were not dug up yet since their value was set to -1 if they were. Add these artifact numbers to a set to avoid redundant values.\\n5. Artifacts Excavated Fully = Total Artifacts - Artifacts that still remain\\n\\n***NOTE: `artifacts_remaining` set contains the artifacts that are not yet dug by their unique number given to each artifact in the first loop.***\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        grid, artifact_id = [[-1] * n for _ in range(n)], 0 # Making the grid\\n        for r1, c1, r2, c2 in artifacts: # Populate the grid matrix\\n            for r in range(r1, r2 + 1):\\n                for c in range(c1, c2 + 1):\\n                    grid[r][c] = artifact_id\\n            artifact_id += 1\\n        for r, c in dig: # Change the grid row, col to -1 by traversing dig array.\\n            if grid[r][c] >= 0:\\n                grid[r][c] = -1\\n        artifacts_remaining = set() \\n        for r in range(n):\\n            for c in range(n):\\n                if grid[r][c] >= 0: # > 0 means that there still remains an artifact underneath, thus add it to the array\\n                    artifacts_remaining.add(grid[r][c])\\n        return artifact_id - len(artifacts_remaining)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        grid, artifact_id = [[-1] * n for _ in range(n)], 0 # Making the grid\\n        for r1, c1, r2, c2 in artifacts: # Populate the grid matrix\\n            for r in range(r1, r2 + 1):\\n                for c in range(c1, c2 + 1):\\n                    grid[r][c] = artifact_id\\n            artifact_id += 1\\n        for r, c in dig: # Change the grid row, col to -1 by traversing dig array.\\n            if grid[r][c] >= 0:\\n                grid[r][c] = -1\\n        artifacts_remaining = set() \\n        for r in range(n):\\n            for c in range(n):\\n                if grid[r][c] >= 0: # > 0 means that there still remains an artifact underneath, thus add it to the array\\n                    artifacts_remaining.add(grid[r][c])\\n        return artifact_id - len(artifacts_remaining)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844093,
                "title": "javascript-simple-and-concise-solution-with-detailed-explanation",
                "content": "```\\nconst canBeExtracted = (grid, artifact) => {\\n    const [r1, c1, r2, c2] = artifact\\n    \\n\\t// An artifact can be extracted only if all the cells are digged\\n\\t// We marked digged cell by 1, so now we can only check if the cell value is not 1\\n    for (let r = r1; r <= r2; r++) {\\n        for (let c = c1; c <= c2; c++) {\\n\\t\\t    // If the cell is not digged the we can not extract the artifact\\n            if (!grid[r][c]) return false\\n        }\\n    }\\n    \\n    return true\\n}\\n\\n\\n/**\\n * @param {number} n\\n * @param {number[][]} artifacts\\n * @param {number[][]} dig\\n * @return {number}\\n */\\nconst digArtifacts = (n, artifacts, dig) => {\\n    // Create a grid with n rows x n columns and set all the cell to 0\\n    let grid = new Array(n).fill().map(_ => new Array(n).fill(0))\\n    \\n\\t// Set all the cell that we gonna dig to 1\\n    for (let [r, c] of dig) {\\n        grid[r][c] = 1\\n    }\\n    \\n    let res = 0\\n\\n    // Iterate over artifacts to check if artifact can be extracted\\n    for (let artifact of artifacts) {\\n        if (canBeExtracted(grid, artifact)) res++\\n    }\\n    \\n    return res\\n};\\n```\\n\\n<br />\\n\\n\\u2139\\uFE0F [My javascript solution collection](https://github.com/toantd90/leetcode-js-solutions)\\n\\n<br />",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst canBeExtracted = (grid, artifact) => {\\n    const [r1, c1, r2, c2] = artifact\\n    \\n\\t// An artifact can be extracted only if all the cells are digged\\n\\t// We marked digged cell by 1, so now we can only check if the cell value is not 1\\n    for (let r = r1; r <= r2; r++) {\\n        for (let c = c1; c <= c2; c++) {\\n\\t\\t    // If the cell is not digged the we can not extract the artifact\\n            if (!grid[r][c]) return false\\n        }\\n    }\\n    \\n    return true\\n}\\n\\n\\n/**\\n * @param {number} n\\n * @param {number[][]} artifacts\\n * @param {number[][]} dig\\n * @return {number}\\n */\\nconst digArtifacts = (n, artifacts, dig) => {\\n    // Create a grid with n rows x n columns and set all the cell to 0\\n    let grid = new Array(n).fill().map(_ => new Array(n).fill(0))\\n    \\n\\t// Set all the cell that we gonna dig to 1\\n    for (let [r, c] of dig) {\\n        grid[r][c] = 1\\n    }\\n    \\n    let res = 0\\n\\n    // Iterate over artifacts to check if artifact can be extracted\\n    for (let artifact of artifacts) {\\n        if (canBeExtracted(grid, artifact)) res++\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1904599,
                "title": "resolve-ambiguity-about-3-0-3-3-test-case-problem",
                "content": "I had problem with this case, so I rechecked problem description then found out it better. \\n\\n```\\n6\\n[[0,2,0,5],[0,1,1,1],[3,0,3,3],[4,4,4,4],[2,1,2,4]]\\n[[0,2],[0,3],[0,4],[2,0],[2,1],[2,2],[2,5],[3,0],[3,1],[3,3],[3,4],[4,0],[4,3],[4,5],[5,0],[5,1],[5,2],[5,4],[5,5]]\\n```\\n\\n.\\n**maybe below image can explain it better than words:**\\n![image](https://assets.leetcode.com/users/images/9d7e33ac-e47e-4737-89fb-1dd8bf15c9ba_1648844757.5945528.png)\\n\\n.\\n**=> so expected output will be: 0**\\n\\nAlso you can see my solution in PHP here:\\n```\\nclass Solution {\\n\\n    function digArtifacts($n, $artifacts, $digs) {\\n        \\n        $dig_matrix = [];\\n        foreach($digs as $dig){\\n            $dig_matrix[ $dig[0] ][ $dig[1] ] = true;\\n        }\\n        \\n        $ans = 0;\\n        foreach($artifacts as $index => $artifact){\\n            \\n            $acceptable = true;\\n            for($i=$artifact[0];$i<=$artifact[2];$i++){\\n                \\n                for($j=$artifact[1];$j<=$artifact[3];$j++){\\n                    \\n                    if( $dig_matrix[$i][$j] !== true ){\\n                        $acceptable = false;\\n                        break 2;\\n                    } \\n                    \\n                }\\n                \\n            }\\n            \\n            if( $acceptable ){\\n                $ans++;\\n            }\\n            \\n        }\\n        \\n        return $ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n6\\n[[0,2,0,5],[0,1,1,1],[3,0,3,3],[4,4,4,4],[2,1,2,4]]\\n[[0,2],[0,3],[0,4],[2,0],[2,1],[2,2],[2,5],[3,0],[3,1],[3,3],[3,4],[4,0],[4,3],[4,5],[5,0],[5,1],[5,2],[5,4],[5,5]]\\n```\n```\\nclass Solution {\\n\\n    function digArtifacts($n, $artifacts, $digs) {\\n        \\n        $dig_matrix = [];\\n        foreach($digs as $dig){\\n            $dig_matrix[ $dig[0] ][ $dig[1] ] = true;\\n        }\\n        \\n        $ans = 0;\\n        foreach($artifacts as $index => $artifact){\\n            \\n            $acceptable = true;\\n            for($i=$artifact[0];$i<=$artifact[2];$i++){\\n                \\n                for($j=$artifact[1];$j<=$artifact[3];$j++){\\n                    \\n                    if( $dig_matrix[$i][$j] !== true ){\\n                        $acceptable = false;\\n                        break 2;\\n                    } \\n                    \\n                }\\n                \\n            }\\n            \\n            if( $acceptable ){\\n                $ans++;\\n            }\\n            \\n        }\\n        \\n        return $ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845281,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int[][] grid = new int[n][n];\\n        int count=0;\\n        for(int[] d: dig)\\n            grid[d[0]][d[1]]=1;\\n        for(int[] artifact: artifacts){\\n            int sum=0;\\n            int r1=artifact[0],c1=artifact[1],r2=artifact[2],c2=artifact[3];\\n            for(int r=r1;r<=r2;r++){\\n                for(int c=c1;c<=c2;c++){\\n                    sum+=grid[r][c];\\n                }\\n            }\\n            if(sum==(r2+1-r1)*(c2+1-c1)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int[][] grid = new int[n][n];\\n        int count=0;\\n        for(int[] d: dig)\\n            grid[d[0]][d[1]]=1;\\n        for(int[] artifact: artifacts){\\n            int sum=0;\\n            int r1=artifact[0],c1=artifact[1],r2=artifact[2],c2=artifact[3];\\n            for(int r=r1;r<=r2;r++){\\n                for(int c=c1;c<=c2;c++){\\n                    sum+=grid[r][c];\\n                }\\n            }\\n            if(sum==(r2+1-r1)*(c2+1-c1)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844464,
                "title": "c-2201-count-artifacts-that-can-be-extracted",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> grid(n, vector<int>(n)); \\n        for (auto& pos : dig) grid[pos[0]][pos[1]] = 1; \\n        int ans = 0; \\n        for (auto& artifact : artifacts) {\\n            int r1 = artifact[0], c1 = artifact[1], r2 = artifact[2], c2 = artifact[3]; \\n            bool okay = true; \\n            for (int r = r1; r <= r2; ++r) \\n                for (int c = c1; c <= c2; ++c) \\n                    if (grid[r][c] == 0) okay = false; \\n            if (okay) ++ans; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> grid(n, vector<int>(n)); \\n        for (auto& pos : dig) grid[pos[0]][pos[1]] = 1; \\n        int ans = 0; \\n        for (auto& artifact : artifacts) {\\n            int r1 = artifact[0], c1 = artifact[1], r2 = artifact[2], c2 = artifact[3]; \\n            bool okay = true; \\n            for (int r = r1; r <= r2; ++r) \\n                for (int c = c1; c <= c2; ++c) \\n                    if (grid[r][c] == 0) okay = false; \\n            if (okay) ++ans; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844345,
                "title": "python-6-lines",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        dig = set((r, c) for r, c in dig)\\n        ans = 0\\n        for r0, c0, r1, c1 in artifacts:\\n            if all((r, c) in dig for r in range(r0, r1 + 1) for c in range(c0, c1 + 1)):\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        dig = set((r, c) for r, c in dig)\\n        ans = 0\\n        for r0, c0, r1, c1 in artifacts:\\n            if all((r, c) in dig for r in range(r0, r1 + 1) for c in range(c0, c1 + 1)):\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844309,
                "title": "java-clean-code-linear",
                "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        \\n        //first we flag thos who are in array dig\\n        boolean flag[][] = new boolean[n][n];\\n        \\n        //flagging grid who has been digged\\n        //O(dig.length)\\n        for (int i = 0; i < dig.length; i++) {\\n            flag[dig[i][0]][dig[i][1]] = true;\\n        }\\n        \\n        //O(artifacts.length)\\n        int count = 0;\\n        for (int i = 0; i < artifacts.length; i++) {\\n            //check weather this artifact is digged or not using flag grid\\n            //count digged ones\\n            if (isDigged(artifacts[i], flag)) {\\n                count++;\\n            }\\n        }\\n        \\n        return count++;\\n    }\\n    \\n    \\n    //O(1)\\n    //as artifact can cover at most 4 cells we can say this method will execute in O(1)\\n    boolean isGood(int artifact[], boolean flag[][]) {\\n        for (int i = artifact[0]; i <= artifact[2]; i++) {\\n            for (int j = artifact[1]; j <= artifact[3]; j++) {\\n                if (!flag[i][j]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\nTC - O(max of(artifacts.length, dig.length))\\nSC - O(N * N) - (boolean flag array is used)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        \\n        //first we flag thos who are in array dig\\n        boolean flag[][] = new boolean[n][n];\\n        \\n        //flagging grid who has been digged\\n        //O(dig.length)\\n        for (int i = 0; i < dig.length; i++) {\\n            flag[dig[i][0]][dig[i][1]] = true;\\n        }\\n        \\n        //O(artifacts.length)\\n        int count = 0;\\n        for (int i = 0; i < artifacts.length; i++) {\\n            //check weather this artifact is digged or not using flag grid\\n            //count digged ones\\n            if (isDigged(artifacts[i], flag)) {\\n                count++;\\n            }\\n        }\\n        \\n        return count++;\\n    }\\n    \\n    \\n    //O(1)\\n    //as artifact can cover at most 4 cells we can say this method will execute in O(1)\\n    boolean isGood(int artifact[], boolean flag[][]) {\\n        for (int i = artifact[0]; i <= artifact[2]; i++) {\\n            for (int j = artifact[1]; j <= artifact[3]; j++) {\\n                if (!flag[i][j]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844197,
                "title": "a-brute-force-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& ar, vector<vector<int>>& dig) {\\n        vector<vector<bool>>v(n, vector<bool>(n, false));\\n        for(auto x:dig){\\n            v[x[0]][x[1]]=true;\\n        }\\n        int c=0;\\n        for(int i=0;i<ar.size();i++){\\n            vector<int>v1;\\n            v1=ar[i];\\n            bool flag=true;\\n            for(int i=v1[0];i<=v1[2];i++){\\n                for(int j=v1[1];j<=v1[3];j++){\\n                    if(v[i][j]!=true){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==true)\\n                c++;\\n            \\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& ar, vector<vector<int>>& dig) {\\n        vector<vector<bool>>v(n, vector<bool>(n, false));\\n        for(auto x:dig){\\n            v[x[0]][x[1]]=true;\\n        }\\n        int c=0;\\n        for(int i=0;i<ar.size();i++){\\n            vector<int>v1;\\n            v1=ar[i];\\n            bool flag=true;\\n            for(int i=v1[0];i<=v1[2];i++){\\n                for(int j=v1[1];j<=v1[3];j++){\\n                    if(v[i][j]!=true){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==true)\\n                c++;\\n            \\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844190,
                "title": "c-easy-to-understand-with-diagrams",
                "content": "\\n![image](https://assets.leetcode.com/users/images/f021b973-47e8-4d06-8227-f3f7a2a7c75b_1647146293.784706.png)\\n***If any +ve numbered artifact left in the matrix then this indicate that kind of artifact is not visited completely***\\n\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>>res(n,vector<int>(n,0)); //for marking the the area that can be\\n        unordered_map<int,int>mp;\\n        int c=1;\\n        for(auto i : artifacts){\\n       for(int k = i[0] ; k <=i[2];k++ ){ //we are marking the artifact area with the artifact number\\n          for(int j=i[1];j<=i[3];j++) {\\n              res[k][j]=c;\\n          }  \\n        }\\n            c++; //with each new artifact the artifact number gets updated\\n        }\\n        for(auto i : dig){\\n           res[i[0]][i[1]]=-1* res[i[0]][i[1]]; //if the area has been visited then we set the artifcat their as -ve which indicate that part is found\\n        }\\n        \\n        for(int i = 0 ; i < n;i++){\\n            for(int j = 0 ;j  < n;j++){\\n              if(res[i][j] > 0){ //if any part is not found then the artifact value will be greater then 0 which indicate that this artifact cant be found completely\\n                  mp[res[i][j]] = 1; //map stores the artifact that cant be found\\n              }\\n            }\\n        }\\n           int count = mp.size();//size of map = number of artifact that cant be found\\n            return (c-1)-count; //artifact found  = total artifacts - artifact not found\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>>res(n,vector<int>(n,0)); //for marking the the area that can be\\n        unordered_map<int,int>mp;\\n        int c=1;\\n        for(auto i : artifacts){\\n       for(int k = i[0] ; k <=i[2];k++ ){ //we are marking the artifact area with the artifact number\\n          for(int j=i[1];j<=i[3];j++) {\\n              res[k][j]=c;\\n          }  \\n        }\\n            c++; //with each new artifact the artifact number gets updated\\n        }\\n        for(auto i : dig){\\n           res[i[0]][i[1]]=-1* res[i[0]][i[1]]; //if the area has been visited then we set the artifcat their as -ve which indicate that part is found\\n        }\\n        \\n        for(int i = 0 ; i < n;i++){\\n            for(int j = 0 ;j  < n;j++){\\n              if(res[i][j] > 0){ //if any part is not found then the artifact value will be greater then 0 which indicate that this artifact cant be found completely\\n                  mp[res[i][j]] = 1; //map stores the artifact that cant be found\\n              }\\n            }\\n        }\\n           int count = mp.size();//size of map = number of artifact that cant be found\\n            return (c-1)-count; //artifact found  = total artifacts - artifact not found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279931,
                "title": "c-easy-approach-hashing",
                "content": "class Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        //create hash array mark all of them as unvisited\\n        vector<vector<int>> hash(n, vector<int>(n,0));\\n        \\n        //go throuh all dig and mark vsiited\\n        for(auto it:dig){\\n            hash[it[0]][it[1]]=1;\\n            \\n        }\\n        int cnt=0;\\n        for(auto it:artifacts){\\n            int x1=it[0];\\n            int y1=it[1];\\n            int x2=it[2];\\n            int y2=it[3];\\n            \\n            bool flag=true;\\n            // traverse from left top to roght bottom\\n            for(int i=x1; i<=x2 && flag;i++){\\n                for(int j=y1; j<=y2; j++){\\n                    if(hash[i][j]==0){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            cnt+=flag;\\n        }\\n        return cnt;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        //create hash array mark all of them as unvisited\\n        vector<vector<int>> hash(n, vector<int>(n,0));\\n        \\n        //go throuh all dig and mark vsiited\\n        for(auto it:dig){\\n            hash[it[0]][it[1]]=1;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1995278,
                "title": "python-only-for-loops-and-set-easy-solution",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        dig_set = set()\\n        for sublist in dig:\\n            dig_set.add(tuple(sublist))\\n        count = 0\\n        for afact in artifacts:\\n            r1, c1 ,r2 ,c2 = afact\\n            flag = 0\\n            for i in range(r1 ,r2+1):\\n                for j in range(c1, c2+1):\\n                    if (i,j) not in dig_set:\\n                        flag = 1\\n                        break\\n                if flag == 1:\\n                    break\\n            if flag == 0:\\n                count += 1\\n        return count \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        dig_set = set()\\n        for sublist in dig:\\n            dig_set.add(tuple(sublist))\\n        count = 0\\n        for afact in artifacts:\\n            r1, c1 ,r2 ,c2 = afact\\n            flag = 0\\n            for i in range(r1 ,r2+1):\\n                for j in range(c1, c2+1):\\n                    if (i,j) not in dig_set:\\n                        flag = 1\\n                        break\\n                if flag == 1:\\n                    break\\n            if flag == 0:\\n                count += 1\\n        return count \\n",
                "codeTag": "Java"
            },
            {
                "id": 1873022,
                "title": "please-help-me-with-this-test-case",
                "content": "```\\n6\\n[[0,2,0,5],[0,1,1,1],[3,0,3,3],[4,4,4,4],[2,1,2,4]]\\n[[0,2],[0,3],[0,4],[2,0],[2,1],[2,2],[2,5],[3,0],[3,1],[3,3],[3,4],[4,0],[4,3],[4,5],[5,0],[5,1],[5,2],[5,4],[5,5]]\\n```\\nhere, for artifact: [3,0,3,3], we have **dig** as [3,0] & [3,3] so the answer should be 1 right? but it is expected to be 0. Please tell me if I am wrong here. Thanks",
                "solutionTags": [],
                "code": "```\\n6\\n[[0,2,0,5],[0,1,1,1],[3,0,3,3],[4,4,4,4],[2,1,2,4]]\\n[[0,2],[0,3],[0,4],[2,0],[2,1],[2,2],[2,5],[3,0],[3,1],[3,3],[3,4],[4,0],[4,3],[4,5],[5,0],[5,1],[5,2],[5,4],[5,5]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862648,
                "title": "c-set-solution",
                "content": "* Add dig indices to the set.\\n* Run a loop on artifacts array.\\n* Check all the points of subgrid.\\n* If all points of subgrid are present then increase the result count else continue\\n\\n\\t\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n\\t\\t\\t\\tset<pair<int,int>>st;\\n\\t\\t\\t\\tfor(auto x:dig) st.insert({x[0],x[1]});\\n\\t\\t\\t\\tint res = 0;\\n\\n\\t\\t\\t\\tfor(auto &x:artifacts){\\n\\t\\t\\t\\t\\tbool is = true;\\n\\t\\t\\t\\t\\tfor(int i=x[0];i<=x[2];i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=x[1];j<=x[3];j++){\\n\\t\\t\\t\\t\\t\\t\\tif(!st.count({i,j})){\\n\\t\\t\\t\\t\\t\\t\\t\\tis = false;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(!is) break;\\n\\t\\t\\t\\t\\t\\t}   \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(is) res++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n\\t\\t\\t\\tset<pair<int,int>>st;\\n\\t\\t\\t\\tfor(auto x:dig) st.insert({x[0],x[1]}",
                "codeTag": "Java"
            },
            {
                "id": 1846781,
                "title": "python3-enumerate",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/66f7e5045d1b91897d8dbb425b6af153e6802c59) for solutions of weekly 284. \\n\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        dig = {(x, y) for x, y in dig}\\n        ans = 0 \\n        for i1, j1, i2, j2 in artifacts: \\n            for i in range(i1, i2+1):\\n                for j in range(j1, j2+1): \\n                    if (i, j) not in dig: break \\n                else: continue \\n                break \\n            else: ans += 1\\n        return ans\\n```\\n\\nAdded prefix sum approach \\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        grid = [[0]*n for _ in range(n)]\\n        for i, j in dig: grid[i][j] = 1\\n        prefix = [[0]*(n+1) for _ in range(n+1)]\\n        for i in range(n):\\n            for j in range(n):\\n                prefix[i+1][j+1] = grid[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j]\\n        ans = 0 \\n        for i1, j1, i2, j2 in artifacts: \\n            area = prefix[i2+1][j2+1] - prefix[i2+1][j1] - prefix[i1][j2+1] + prefix[i1][j1]\\n            if area == (i2-i1+1) * (j2-j1+1): ans += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        dig = {(x, y) for x, y in dig}\\n        ans = 0 \\n        for i1, j1, i2, j2 in artifacts: \\n            for i in range(i1, i2+1):\\n                for j in range(j1, j2+1): \\n                    if (i, j) not in dig: break \\n                else: continue \\n                break \\n            else: ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        grid = [[0]*n for _ in range(n)]\\n        for i, j in dig: grid[i][j] = 1\\n        prefix = [[0]*(n+1) for _ in range(n+1)]\\n        for i in range(n):\\n            for j in range(n):\\n                prefix[i+1][j+1] = grid[i][j] + prefix[i][j+1] + prefix[i+1][j] - prefix[i][j]\\n        ans = 0 \\n        for i1, j1, i2, j2 in artifacts: \\n            area = prefix[i2+1][j2+1] - prefix[i2+1][j1] - prefix[i1][j2+1] + prefix[i1][j1]\\n            if area == (i2-i1+1) * (j2-j1+1): ans += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845835,
                "title": "kotlin-clean-solution",
                "content": "```\\nclass Solution {\\n    fun digArtifacts(n: Int, artifacts: Array<IntArray>, dig: Array<IntArray>): Int {\\n        val isDigged = Array(n) { BooleanArray(n) }\\n        \\n        for ((r, c) in dig) {\\n            isDigged[r][c] = true\\n        }\\n        \\n        // Count how many artifact have all parts uncoverd.\\n        return artifacts.count { (r1, c1, r2, c2) ->\\n            (r1..r2).all { r ->\\n                (c1..c2).all { c ->\\n                     isDigged[r][c]\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun digArtifacts(n: Int, artifacts: Array<IntArray>, dig: Array<IntArray>): Int {\\n        val isDigged = Array(n) { BooleanArray(n) }\\n        \\n        for ((r, c) in dig) {\\n            isDigged[r][c] = true\\n        }\\n        \\n        // Count how many artifact have all parts uncoverd.\\n        return artifacts.count { (r1, c1, r2, c2) ->\\n            (r1..r2).all { r ->\\n                (c1..c2).all { c ->\\n                     isDigged[r][c]\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845640,
                "title": "easy-c-solution-commented-and-readable",
                "content": "```\\nclass Solution {\\n  public:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        //Create a NXN board and fill it with -1s signifying that cell isnt dug up\\n      vector < vector<int> > board(n, vector <int> (n, -1));\\n        \\n        //iterate through the dig and mark the dug up cells with 0 on the board\\n      for (int i = 0; i < dig.size(); i++) {\\n        int digRow = dig[i][0];\\n        int digCol = dig[i][1];\\n        board[digRow][digCol] = 0;\\n      }\\n        \\n        //declare a variable to store the answer\\n      int numberOfArtifacts = 0;\\n        \\n        //now for each artifact, check if there is any cell that isnt dug up\\n      for (int i = 0; i < artifacts.size(); i++) {\\n        int startRow = artifacts[i][0];\\n        int startCol = artifacts[i][1];\\n        int endRow = artifacts[i][2];\\n        int endCol = artifacts[i][3];\\n        bool noObjections = true;\\n        for (int j = startRow; j <= endRow; j++) {\\n          for (int k = startCol; k <= endCol; k++) {\\n              //if there is a cell that isnt dug up, break out of the loop\\n            if (board[j][k] == -1) {\\n              noObjections = false;\\n              break;\\n            }\\n          }\\n          if (!noObjections) break;\\n        }\\n          //if there are no cells which arent dug up for an artifact, increment the number of artifacts\\n        if (noObjections) numberOfArtifacts++;\\n      }\\n        //finally, return the number of artifacts\\n      return numberOfArtifacts;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        //Create a NXN board and fill it with -1s signifying that cell isnt dug up\\n      vector < vector<int> > board(n, vector <int> (n, -1));\\n        \\n        //iterate through the dig and mark the dug up cells with 0 on the board\\n      for (int i = 0; i < dig.size(); i++) {\\n        int digRow = dig[i][0];\\n        int digCol = dig[i][1];\\n        board[digRow][digCol] = 0;\\n      }\\n        \\n        //declare a variable to store the answer\\n      int numberOfArtifacts = 0;\\n        \\n        //now for each artifact, check if there is any cell that isnt dug up\\n      for (int i = 0; i < artifacts.size(); i++) {\\n        int startRow = artifacts[i][0];\\n        int startCol = artifacts[i][1];\\n        int endRow = artifacts[i][2];\\n        int endCol = artifacts[i][3];\\n        bool noObjections = true;\\n        for (int j = startRow; j <= endRow; j++) {\\n          for (int k = startCol; k <= endCol; k++) {\\n              //if there is a cell that isnt dug up, break out of the loop\\n            if (board[j][k] == -1) {\\n              noObjections = false;\\n              break;\\n            }\\n          }\\n          if (!noObjections) break;\\n        }\\n          //if there are no cells which arent dug up for an artifact, increment the number of artifacts\\n        if (noObjections) numberOfArtifacts++;\\n      }\\n        //finally, return the number of artifacts\\n      return numberOfArtifacts;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845495,
                "title": "python-boolean-tc-o-n-sc-o-n-2",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        dug = [[False]*n for i in range(n)]\\n        for i,j in dig:\\n\\t\\t#filling all the coordinates dug with true\\n\\t\\t\\tdug[i][j] = True\\n        ans = 0\\n        for a in artifacts:\\n            \\n            def inner():\\n                nonlocal ans\\n                for i in range(a[0],a[2]+1):\\n                    for j in range(a[1],a[3]+1):\\n\\t\\t\\t\\t\\t#as soon as we are getting any false coordinate we are breaking the loop \\n\\t\\t\\t\\t\\t#as if any part of the artifact is not dug then the artifact won\\'t be counted\\n                        if not dug[i][j]:\\n                            return\\n                ans += 1\\n            inner()\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        dug = [[False]*n for i in range(n)]\\n        for i,j in dig:\\n\\t\\t#filling all the coordinates dug with true\\n\\t\\t\\tdug[i][j] = True\\n        ans = 0\\n        for a in artifacts:\\n            \\n            def inner():\\n                nonlocal ans\\n                for i in range(a[0],a[2]+1):\\n                    for j in range(a[1],a[3]+1):\\n\\t\\t\\t\\t\\t#as soon as we are getting any false coordinate we are breaking the loop \\n\\t\\t\\t\\t\\t#as if any part of the artifact is not dug then the artifact won\\'t be counted\\n                        if not dug[i][j]:\\n                            return\\n                ans += 1\\n            inner()\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845091,
                "title": "100-faster-solution-java-clean-code",
                "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        boolean[][] flag = new boolean[n][n];\\n        for(int i = 0; i<dig.length; i++){\\n            flag[dig[i][0]][dig[i][1]] = true;\\n        }\\n    \\n        int count = 0;\\n        for(int[] check: artifacts)\\n            if(isCovered(check, flag)) count++;\\n        \\n        return count;\\n    }\\n    \\n    public boolean isCovered(int[] check, boolean [][] flag){\\n        for(int i = check[0]; i<=check[2]; i++){\\n            for(int j = check[1]; j <= check[3]; j++){\\n                if(!flag[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        boolean[][] flag = new boolean[n][n];\\n        for(int i = 0; i<dig.length; i++){\\n            flag[dig[i][0]][dig[i][1]] = true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1845031,
                "title": "java-solution-using-bruteforce",
                "content": "In this solution we are first adding all the digs points in a set in a patter-> (x y)\\nThen for each Artifact we are checking all of its points\\nIf all the points for an Aritifact are digged then it can be extracted else not\\n\\n```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] mat, int[][] dig) {\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int i = 0; i < dig.length; i++) set.add(dig[i][0] + \" \" + dig[i][1]);\\n        int c = 0;\\n        for(int i = 0; i < mat.length; i++){\\n            int x1 = Math.min(mat[i][0], mat[i][2]);\\n            int x2 = Math.max(mat[i][0], mat[i][2]);\\n            int y1 = Math.min(mat[i][1], mat[i][3]);\\n            int y2 = Math.max(mat[i][1], mat[i][3]);\\n            \\n            boolean check = true;\\n            for(int x = x1; x <= x2; x++){\\n                for(int y = y1; y <= y2; y++){\\n                    if(!set.contains(x + \" \" + y)){\\n                        check = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if(check) c++;\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] mat, int[][] dig) {\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int i = 0; i < dig.length; i++) set.add(dig[i][0] + \" \" + dig[i][1]);\\n        int c = 0;\\n        for(int i = 0; i < mat.length; i++){\\n            int x1 = Math.min(mat[i][0], mat[i][2]);\\n            int x2 = Math.max(mat[i][0], mat[i][2]);\\n            int y1 = Math.min(mat[i][1], mat[i][3]);\\n            int y2 = Math.max(mat[i][1], mat[i][3]);\\n            \\n            boolean check = true;\\n            for(int x = x1; x <= x2; x++){\\n                for(int y = y1; y <= y2; y++){\\n                    if(!set.contains(x + \" \" + y)){\\n                        check = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if(check) c++;\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844853,
                "title": "simple-javascript-solution",
                "content": "Let\\'s first find out which cell is dug already and then loop through an artifact cell and find out if any of them has remained undug.\\n\\n```\\n  let found = 0;\\n  let digged = {};\\n  for(var b=0;b<dig.length;b++){digged[`${dig[b][0]}-${dig[b][1]}`]=1}\\n  for(var a=0; a<artifacts.length;a++){\\n      let uncovered = true;\\n      for(var i=artifacts[a][0];i<=artifacts[a][2];i++){\\n          for(var j=artifacts[a][1];j<=artifacts[a][3];j++){\\n            if(!digged[`${i}-${j}`])uncovered=false;\\n          }\\n      }\\n      if(uncovered){\\n        found++;\\n      }\\n  }\\n  return found\\n  ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n  let found = 0;\\n  let digged = {};\\n  for(var b=0;b<dig.length;b++){digged[`${dig[b][0]}-${dig[b][1]}`]=1}\\n  for(var a=0; a<artifacts.length;a++){\\n      let uncovered = true;\\n      for(var i=artifacts[a][0];i<=artifacts[a][2];i++){\\n          for(var j=artifacts[a][1];j<=artifacts[a][3];j++){\\n            if(!digged[`${i}-${j}`])uncovered=false;\\n          }\\n      }\\n      if(uncovered){\\n        found++;\\n      }\\n  }\\n  return found\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844709,
                "title": "cpp-begginer-friendly-100-fast-solution",
                "content": "**APPROACH**\\n* Seriously wasted a lot of time by using lots of break statements as I havent clicked about GOTO keyword.\\n* The contest was bad for me even,though I did 3 questions but taking lots of time on B ,I did this question with four different approach,although the result was same,but havent got correct answer,at the time of contest.\\n* Approach is just to check if each and every mud of component is removed or not,only then the ans will be updated.\\n\\n*Implementation -1*\\n```\\n    int mud[2000][2000];\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dig) {\\n        for(int k=0;k<a.size();k++){\\n            int x1=a[k][0];\\n            int y1=a[k][1];\\n            int x2=a[k][2];\\n            int y2=a[k][3];\\n            for(int i=x1;i<=x2;i++){\\n                for(int j=y1;j<=y2;j++){\\n                    mud[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<dig.size();i++){\\n            mud[dig[i][0]][dig[i][1]]=-1;\\n        }\\n        int ans=0;       \\n        for(auto k=0;k<a.size();k++){\\n            int x1=a[k][0];\\n            int y1=a[k][1];\\n            int x2=a[k][2];\\n            int y2=a[k][3];\\n            int f=1;\\n            for(int i=x1;i<=x2;i++){\\n                for(int j=y1;j<=y2;j++){\\n                        if(mud[i][j]==1){\\n                            f=0;\\n                            goto hell;\\n                        }\\n                }\\n            }\\n            hell:\\n                if(f) ans+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n*Implementation -2*\\n```\\nset<string> s;\\n         for(auto i:dig){\\n            string s1=to_string(i[0]);\\n            string s2=to_string(i[1]);\\n            s.insert(s1+\"+\"+s2);\\n        } \\n        int ans=0;\\n        for(auto v:a){\\n            int f=1;\\n            for(int i=v[0];i<=v[2];i++){\\n                for(int j=v[1];j<=v[3];j++){\\n                    string st=to_string(i)+\"+\"+to_string(j);\\n                    if(s.find(st)==s.end()){\\n                        f=0;\\n                        break;\\n                    }\\n                }\\n            }\\n             if(f) ans+=1;\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int mud[2000][2000];\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dig) {\\n        for(int k=0;k<a.size();k++){\\n            int x1=a[k][0];\\n            int y1=a[k][1];\\n            int x2=a[k][2];\\n            int y2=a[k][3];\\n            for(int i=x1;i<=x2;i++){\\n                for(int j=y1;j<=y2;j++){\\n                    mud[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<dig.size();i++){\\n            mud[dig[i][0]][dig[i][1]]=-1;\\n        }\\n        int ans=0;       \\n        for(auto k=0;k<a.size();k++){\\n            int x1=a[k][0];\\n            int y1=a[k][1];\\n            int x2=a[k][2];\\n            int y2=a[k][3];\\n            int f=1;\\n            for(int i=x1;i<=x2;i++){\\n                for(int j=y1;j<=y2;j++){\\n                        if(mud[i][j]==1){\\n                            f=0;\\n                            goto hell;\\n                        }\\n                }\\n            }\\n            hell:\\n                if(f) ans+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nset<string> s;\\n         for(auto i:dig){\\n            string s1=to_string(i[0]);\\n            string s2=to_string(i[1]);\\n            s.insert(s1+\"+\"+s2);\\n        } \\n        int ans=0;\\n        for(auto v:a){\\n            int f=1;\\n            for(int i=v[0];i<=v[2];i++){\\n                for(int j=v[1];j<=v[3];j++){\\n                    string st=to_string(i)+\"+\"+to_string(j);\\n                    if(s.find(st)==s.end()){\\n                        f=0;\\n                        break;\\n                    }\\n                }\\n            }\\n             if(f) ans+=1;\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844661,
                "title": "python-linear-time-in-input-size-due-to-bounds-on-artifact-size-o-n-space-set-linear-pass",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        setDig = set()\\n        for i in dig:\\n            setDig.add(str(i[0])+\"-\"+str(i[1]))\\n        ans = 0\\n        for artifact in artifacts:\\n            r1, c1, r2, c2 = artifact[0], artifact[1], artifact[2], artifact[3]\\n            diggable = True\\n            for x in range(r1,r2+1):\\n                for y in range(c1, c2+1):\\n                    if str(x)+\"-\"+str(y) not in setDig:\\n                        diggable = False\\n            if diggable:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        setDig = set()\\n        for i in dig:\\n            setDig.add(str(i[0])+\"-\"+str(i[1]))\\n        ans = 0\\n        for artifact in artifacts:\\n            r1, c1, r2, c2 = artifact[0], artifact[1], artifact[2], artifact[3]\\n            diggable = True\\n            for x in range(r1,r2+1):\\n                for y in range(c1, c2+1):\\n                    if str(x)+\"-\"+str(y) not in setDig:\\n                        diggable = False\\n            if diggable:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844592,
                "title": "c-easy-approach",
                "content": "```\\n//1st Approach using Hashmap\\n\\nclass Solution {\\npublic:\\n\\n    struct hash_pair {\\n        template <class T1, class T2>\\n        size_t operator()(const pair<T1, T2>& p) const\\n        {\\n            auto hash1 = hash<T1>{}(p.first);\\n            auto hash2 = hash<T2>{}(p.second);\\n            return hash1 ^ hash2;\\n        }\\n    };\\n    \\n    \\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) \\n    {\\n        int count=0;\\n        \\n        unordered_map<pair<int,int>,int,hash_pair> map;  //for storing the pair as key we should have to pass a third argument also i.e hash_pair\\n        \\n        for(int i=0; i<dig.size(); i++)\\n        {\\n            pair<int,int> p;\\n            p.first=dig[i][0];\\n            p.second=dig[i][1];\\n            \\n            map[p]++;\\n        }\\n        \\n        for(int i=0; i<artifacts.size(); i++)\\n        {\\n            int one=artifacts[i][0];\\n            int second=artifacts[i][1];\\n            int third=artifacts[i][2];\\n            int fourth=artifacts[i][3];\\n            \\n            pair<int,int> p;\\n            p.first=one;\\n            p.second=second;\\n            \\n            if(one == second && one == third && one == fourth && map.count(p) == 1)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                bool found=true;\\n                \\n                while(one <= third)\\n                {\\n                    for(int j=second; j <= fourth; j++)\\n                    {\\n                        int x=one;\\n                        int y=j;\\n                        \\n                        pair<int,int> p1{x,y};\\n                        \\n                        if(map.count(p1) == 0)\\n                        {\\n                            found=false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if(found == false)\\n                    {\\n                        break;\\n                    }\\n                    \\n                    one++;\\n                }\\n                \\n                if(found == true)\\n                {\\n                    count++;\\n                }\\n            }\\n\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n\\n\\n//2nd Approach using visited array\\n\\nclass Solution {\\npublic:\\n\\nint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) \\n    {\\n        int count=0;\\n\\t\\t\\n        int visited[n][n];\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                visited[i][j]=false;\\n            }\\n        }\\n        \\n        for(int i=0; i<dig.size(); i++)\\n        {\\n            visited[dig[i][0]][dig[i][1]]=true;\\n        }\\n        \\n        for(int i=0; i<artifacts.size(); i++)\\n        {\\n            int one=artifacts[i][0];\\n            int second=artifacts[i][1];\\n            int third=artifacts[i][2];\\n            int fourth=artifacts[i][3];\\n            \\n            if(one == second && one == third && one == fourth && visited[one][second] == true)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                bool found=true;\\n                \\n                while(one <= third)\\n                {\\n                    for(int j=second; j <= fourth; j++)\\n                    {\\n                        int x=one;\\n                        int y=j;\\n                        \\n                        if(visited[x][y] == false)\\n                        {\\n                            found=false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if(found == false)\\n                    {\\n                        break;\\n                    }\\n                    \\n                    one++;\\n                }\\n                \\n                if(found == true)\\n                {\\n                    count++;\\n                }\\n            }\\n\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//1st Approach using Hashmap\\n\\nclass Solution {\\npublic:\\n\\n    struct hash_pair {\\n        template <class T1, class T2>\\n        size_t operator()(const pair<T1, T2>& p) const\\n        {\\n            auto hash1 = hash<T1>{}(p.first);\\n            auto hash2 = hash<T2>{}(p.second);\\n            return hash1 ^ hash2;\\n        }\\n    };\\n    \\n    \\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) \\n    {\\n        int count=0;\\n        \\n        unordered_map<pair<int,int>,int,hash_pair> map;  //for storing the pair as key we should have to pass a third argument also i.e hash_pair\\n        \\n        for(int i=0; i<dig.size(); i++)\\n        {\\n            pair<int,int> p;\\n            p.first=dig[i][0];\\n            p.second=dig[i][1];\\n            \\n            map[p]++;\\n        }\\n        \\n        for(int i=0; i<artifacts.size(); i++)\\n        {\\n            int one=artifacts[i][0];\\n            int second=artifacts[i][1];\\n            int third=artifacts[i][2];\\n            int fourth=artifacts[i][3];\\n            \\n            pair<int,int> p;\\n            p.first=one;\\n            p.second=second;\\n            \\n            if(one == second && one == third && one == fourth && map.count(p) == 1)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                bool found=true;\\n                \\n                while(one <= third)\\n                {\\n                    for(int j=second; j <= fourth; j++)\\n                    {\\n                        int x=one;\\n                        int y=j;\\n                        \\n                        pair<int,int> p1{x,y};\\n                        \\n                        if(map.count(p1) == 0)\\n                        {\\n                            found=false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if(found == false)\\n                    {\\n                        break;\\n                    }\\n                    \\n                    one++;\\n                }\\n                \\n                if(found == true)\\n                {\\n                    count++;\\n                }\\n            }\\n\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n\\n\\n//2nd Approach using visited array\\n\\nclass Solution {\\npublic:\\n\\nint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) \\n    {\\n        int count=0;\\n\\t\\t\\n        int visited[n][n];\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                visited[i][j]=false;\\n            }\\n        }\\n        \\n        for(int i=0; i<dig.size(); i++)\\n        {\\n            visited[dig[i][0]][dig[i][1]]=true;\\n        }\\n        \\n        for(int i=0; i<artifacts.size(); i++)\\n        {\\n            int one=artifacts[i][0];\\n            int second=artifacts[i][1];\\n            int third=artifacts[i][2];\\n            int fourth=artifacts[i][3];\\n            \\n            if(one == second && one == third && one == fourth && visited[one][second] == true)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                bool found=true;\\n                \\n                while(one <= third)\\n                {\\n                    for(int j=second; j <= fourth; j++)\\n                    {\\n                        int x=one;\\n                        int y=j;\\n                        \\n                        if(visited[x][y] == false)\\n                        {\\n                            found=false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if(found == false)\\n                    {\\n                        break;\\n                    }\\n                    \\n                    one++;\\n                }\\n                \\n                if(found == true)\\n                {\\n                    count++;\\n                }\\n            }\\n\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844554,
                "title": "c-matrix-painting",
                "content": "Simple Painting method (Paint same artifacts with same color)\\n* Take a matrix of size n*n  for i th artifact paint the element as i+1 and maintain a paints array to keep track of how many boxes we have the same artifact , artifact of the same color is the same artifact. \\n* Loop through did and mark the boxes again to 0 means no paint also decrement a box from paints array.\\n* Loop through paints array to find how many artifacts are 0 meaning the whole artifact can be excavated.\\n\\nComment for any queries, I will be happy to reply to them\\n        \\n        int ans = 0;\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        int paint = 1;\\n        vector<int> paints(artifacts.size()+1 , 0);\\n        for(auto i : artifacts){\\n            for(int j = i[0] ; j <= i[2] ; j++){\\n                for(int k = i[1] ; k <= i[3] ; k++){\\n                    mat[j][k] = paint;\\n                    paints[paint]++;\\n            }\\n          }\\n            paint++;\\n        }\\n        \\n        for(auto i : dig){\\n            paints[mat[i[0]][i[1]]]--;\\n            mat[i[0]][i[1]] = 0;\\n        }\\n    \\n        for(int i = 1 ; i < paints.size() ; i++){\\n            if(paints[i] == 0) ans++;\\n        }\\n        \\n        return ans;",
                "solutionTags": [
                    "C++"
                ],
                "code": "Simple Painting method (Paint same artifacts with same color)\\n* Take a matrix of size n*n  for i th artifact paint the element as i+1 and maintain a paints array to keep track of how many boxes we have the same artifact , artifact of the same color is the same artifact. \\n* Loop through did and mark the boxes again to 0 means no paint also decrement a box from paints array.\\n* Loop through paints array to find how many artifacts are 0 meaning the whole artifact can be excavated.\\n\\nComment for any queries, I will be happy to reply to them\\n        \\n        int ans = 0;\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        int paint = 1;\\n        vector<int> paints(artifacts.size()+1 , 0);\\n        for(auto i : artifacts){\\n            for(int j = i[0] ; j <= i[2] ; j++){\\n                for(int k = i[1] ; k <= i[3] ; k++){\\n                    mat[j][k] = paint;\\n                    paints[paint]++;\\n            }\\n          }\\n            paint++;\\n        }\\n        \\n        for(auto i : dig){\\n            paints[mat[i[0]][i[1]]]--;\\n            mat[i[0]][i[1]] = 0;\\n        }\\n    \\n        for(int i = 1 ; i < paints.size() ; i++){\\n            if(paints[i] == 0) ans++;\\n        }\\n        \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1844539,
                "title": "c-hashmap-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& af, vector<vector<int>>& dig) {\\n        \\n        map<pair<int,int>,int>res;\\n        for(auto it:dig)\\n        {\\n            res[{it[0],it[1]}]=1;\\n        }\\n        int count=0;\\n        for(int i=0;i<af.size();i++)\\n        {\\n            int p=af[i][0];\\n            int q=af[i][1];\\n            int r=af[i][2];\\n            int s=af[i][3];\\n            bool rest=true;\\n            for(int j=p;j<=r;j++)\\n            {\\n                for(int k=q;k<=s;k++)\\n                {\\n                    if(!res[{j,k}])\\n                        rest=false;\\n                }\\n            }\\n            if(rest)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& af, vector<vector<int>>& dig) {\\n        \\n        map<pair<int,int>,int>res;\\n        for(auto it:dig)\\n        {\\n            res[{it[0],it[1]}]=1;\\n        }\\n        int count=0;\\n        for(int i=0;i<af.size();i++)\\n        {\\n            int p=af[i][0];\\n            int q=af[i][1];\\n            int r=af[i][2];\\n            int s=af[i][3];\\n            bool rest=true;\\n            for(int j=p;j<=r;j++)\\n            {\\n                for(int k=q;k<=s;k++)\\n                {\\n                    if(!res[{j,k}])\\n                        rest=false;\\n                }\\n            }\\n            if(rest)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844483,
                "title": "python-code-is-should-be-success-but-it-didn-t",
                "content": "Guys I don\\'t understand why test case didn\\'t work for this scenario. In this case output did should be 1 but it was 0. Can you help me?\\n```\\ndef digArtifacts( n, artifacts, dig):\\n        output=0\\n        for r1,c1,r2,c2 in artifacts:\\n            d1=[r1,c1]\\n            d2=[r2,c2]\\n            print(d1, not d1 in dig)\\n            print(d2, not d2 in dig)\\n            if (d1 in dig) and (d2 in dig):\\n                output+=1\\n            print(output)\\n        return output\\n\\t\\t\\nn=6\\nartifacts=[[0,2,0,5],[0,1,1,1],[3,0,3,3],[4,4,4,4],[2,1,2,4]]\\ndig=[[0,2],[0,3],[0,4],[2,0],[2,1],[2,2],[2,5],[3,0],[3,1],[3,3],[3,4],[4,0],[4,3],[4,5],[5,0],[5,1],[5,2],[5,4],[5,5]]\\nprint(digArtifacts(n, artifacts, dig))\\n```",
                "solutionTags": [],
                "code": "```\\ndef digArtifacts( n, artifacts, dig):\\n        output=0\\n        for r1,c1,r2,c2 in artifacts:\\n            d1=[r1,c1]\\n            d2=[r2,c2]\\n            print(d1, not d1 in dig)\\n            print(d2, not d2 in dig)\\n            if (d1 in dig) and (d2 in dig):\\n                output+=1\\n            print(output)\\n        return output\\n\\t\\t\\nn=6\\nartifacts=[[0,2,0,5],[0,1,1,1],[3,0,3,3],[4,4,4,4],[2,1,2,4]]\\ndig=[[0,2],[0,3],[0,4],[2,0],[2,1],[2,2],[2,5],[3,0],[3,1],[3,3],[3,4],[4,0],[4,3],[4,5],[5,0],[5,1],[5,2],[5,4],[5,5]]\\nprint(digArtifacts(n, artifacts, dig))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1844445,
                "title": "map-artifact-to-index-python-hashmap-intuitive-solution",
                "content": "-  Map every cell of a particular artifact area as a tuple to the unique \"artifactIndex\"\\n-  In artifactCellCount, maintain number of cells for every \"artifactIndex\"\\n-  Traverse the dig array and check if the dig tupple is contained in the artifacts hashmap\\n-  If contained, decrease the count in artifactCellCount for that particular artifact\\n-  If any artifactCellCount == 0, means all cells digged therefore add 1 to the result\\n\\nExample : \\n```\\nInput: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]\\n\\nartifactToIndex\\ndefaultdict(<class \\'int\\'>, {(0, 0): 0, (0, 1): 1, (1, 1): 1})\\n\\nartifactCellCount\\ndefaultdict(<class \\'int\\'>, {0: 0, 1: 1})\\n```\\n\\n\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        \\n        artifactToIndex = defaultdict(int)\\n        artifactCellCount = defaultdict(int)\\n        result = 0\\n        \\n        # Traverse all cells where artifact might be present\\n        for artifactIndex in range(len(artifacts)):\\n            r1,c1,r2,c2 = artifacts[artifactIndex]\\n            for i in range(r1,r2+1):\\n                for j in range(c1,c2+1):\\n                    artifactToIndex[(i,j)] = artifactIndex\\n                    artifactCellCount[artifactIndex] += 1\\n                    \\n                    \\n                    \\n        for a,b in dig:\\n            if (a,b) in artifactToIndex:\\n                artifactIndex = artifactToIndex[(a,b)]\\n                artifactCellCount[artifactIndex] -= 1\\n                if(artifactCellCount[artifactIndex] == 0):\\n                    result += 1\\n                    \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nInput: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]\\n\\nartifactToIndex\\ndefaultdict(<class \\'int\\'>, {(0, 0): 0, (0, 1): 1, (1, 1): 1})\\n\\nartifactCellCount\\ndefaultdict(<class \\'int\\'>, {0: 0, 1: 1})\\n```\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        \\n        artifactToIndex = defaultdict(int)\\n        artifactCellCount = defaultdict(int)\\n        result = 0\\n        \\n        # Traverse all cells where artifact might be present\\n        for artifactIndex in range(len(artifacts)):\\n            r1,c1,r2,c2 = artifacts[artifactIndex]\\n            for i in range(r1,r2+1):\\n                for j in range(c1,c2+1):\\n                    artifactToIndex[(i,j)] = artifactIndex\\n                    artifactCellCount[artifactIndex] += 1\\n                    \\n                    \\n                    \\n        for a,b in dig:\\n            if (a,b) in artifactToIndex:\\n                artifactIndex = artifactToIndex[(a,b)]\\n                artifactCellCount[artifactIndex] -= 1\\n                if(artifactCellCount[artifactIndex] == 0):\\n                    result += 1\\n                    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844438,
                "title": "java-easy-clean-concise-readbale-code-simple-approach",
                "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int numberOfArtifacts = 0;\\n        int colour = 1; // Assinging the artifact number to the grid.\\n        int[][] grid = new int[n][n];\\n        for (int[] row : grid) Arrays.fill(row, 0);\\n\\n        //Building the Location Grid.\\n        for (int[] positions : artifacts) {\\n            int count = 0;\\n            for (int p = positions[0]; p <= positions[2]; p++) {\\n                for (int q = positions[1]; q <= positions[3]; q++) {\\n                    grid[p][q] = colour;\\n                }\\n            }\\n            colour++;\\n        }\\n\\t\\t\\n        //Remove the Mud.\\n        for (int[] position : dig) {\\n            grid[position[0]][position[1]] *= -1;\\n        }\\n\\n        //Now Go through the Grid to check if we have discovered any artifact.\\n        for (int[] positions : artifacts) {\\n            int count = 0;\\n            boolean flag = true;\\n            for (int p = positions[0]; p <= positions[2]; p++) {\\n                for (int q = positions[1]; q <= positions[3]; q++) {\\n                    if (grid[p][q] > 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (flag) numberOfArtifacts++;\\n        }\\n\\n        return numberOfArtifacts;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int numberOfArtifacts = 0;\\n        int colour = 1; // Assinging the artifact number to the grid.\\n        int[][] grid = new int[n][n];\\n        for (int[] row : grid) Arrays.fill(row, 0);\\n\\n        //Building the Location Grid.\\n        for (int[] positions : artifacts) {\\n            int count = 0;\\n            for (int p = positions[0]; p <= positions[2]; p++) {\\n                for (int q = positions[1]; q <= positions[3]; q++) {\\n                    grid[p][q] = colour;\\n                }\\n            }\\n            colour++;\\n        }\\n\\t\\t\\n        //Remove the Mud.\\n        for (int[] position : dig) {\\n            grid[position[0]][position[1]] *= -1;\\n        }\\n\\n        //Now Go through the Grid to check if we have discovered any artifact.\\n        for (int[] positions : artifacts) {\\n            int count = 0;\\n            boolean flag = true;\\n            for (int p = positions[0]; p <= positions[2]; p++) {\\n                for (int q = positions[1]; q <= positions[3]; q++) {\\n                    if (grid[p][q] > 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (flag) numberOfArtifacts++;\\n        }\\n\\n        return numberOfArtifacts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844383,
                "title": "easy-to-understand-c-faster",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool solve(map<pair<int,int>,int> &mp, int &a , int &b, int &c ,int &d)\\n    {\\n        bool flag = true;\\n        for(int i = a; i<=c; i++)\\n        {\\n            for(int j = b; j<=d; j++)\\n            {\\n                flag &= (mp.find({i,j})!=mp.end());\\n            }\\n        }\\n        if(flag)\\n        {\\n           for(int i = a; i<=c; i++)\\n          {\\n            for(int j = b; j<=d; j++)\\n            {\\n                mp.erase({i,j});\\n            }\\n          } \\n        }\\n        return flag;\\n    }\\n    \\n public:  \\n    int digArtifacts(int n, vector<vector<int>>& nums, vector<vector<int>>& dig) {\\n        map<pair<int,int>,int> mp;\\n        for(auto it : dig) mp.insert({{it[0],it[1]},0});\\n        int cnt =0;\\n        for(int i =0; i<nums.size(); i++)\\n        {\\n          if(solve(mp,nums[i][0],nums[i][1],nums[i][2],nums[i][3])) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool solve(map<pair<int,int>,int> &mp, int &a , int &b, int &c ,int &d)\\n    {\\n        bool flag = true;\\n        for(int i = a; i<=c; i++)\\n        {\\n            for(int j = b; j<=d; j++)\\n            {\\n                flag &= (mp.find({i,j})!=mp.end());\\n            }\\n        }\\n        if(flag)\\n        {\\n           for(int i = a; i<=c; i++)\\n          {\\n            for(int j = b; j<=d; j++)\\n            {\\n                mp.erase({i,j});\\n            }\\n          } \\n        }\\n        return flag;\\n    }\\n    \\n public:  \\n    int digArtifacts(int n, vector<vector<int>>& nums, vector<vector<int>>& dig) {\\n        map<pair<int,int>,int> mp;\\n        for(auto it : dig) mp.insert({{it[0],it[1]},0});\\n        int cnt =0;\\n        for(int i =0; i<nums.size(); i++)\\n        {\\n          if(solve(mp,nums[i][0],nums[i][1],nums[i][2],nums[i][3])) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844296,
                "title": "c-brute-force-hashmap-version",
                "content": "Store all the grid with artifact into a hashmap, give each artifact an id, and label id to the grid. Then iterate all the digs to check how many grid is discovered for each artifact. Increase counter when the number of grid discovered equals the size of the corresponding artifact.\\nThis idea works because the size of each artifact is very small...\\n```\\n#include <unordered_set>\\n#include <unordered_map>\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& digs) {\\n\\t\\t// grid.first: represents a grid [row,col]\\n\\t\\t// grid.second: the id of the artifact, represents which artfact this grid belongs to\\n        unordered_map<int,int> grid;\\n\\t\\t// sizes.first: the id of the artifact\\n\\t\\t// sizes.second: the size of this artifact\\n        unordered_map<int,int> sizes;\\n        for(int i=0; i<artifacts.size(); i++){\\n            int r1 = artifacts[i][0];\\n            int c1 = artifacts[i][1];\\n            int r2 = artifacts[i][2];\\n            int c2 = artifacts[i][3];\\n            int size = 0;\\n            for(int r=r1; r<=r2; r++){\\n                for(int c=c1; c<=c2; c++){\\n                    grid[r*n+c] = i;\\n                    size ++;\\n                }\\n            }\\n            sizes[i] = size;\\n        }\\n        int count = 0;\\n\\t\\t// found.first: the id of the artifact\\n\\t\\t// found.second: the discovered size of the artifact\\n        unordered_map<int,int> found;\\n        for(auto dig: digs){\\n            int r = dig[0];\\n            int c = dig[1];\\n            if(grid.find(r*n+c)!=grid.end()){\\n                found[grid[r*n+c]] ++;\\n                if(found[grid[r*n+c]]==sizes[grid[r*n+c]]){\\n                    count ++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <unordered_set>\\n#include <unordered_map>\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& digs) {\\n\\t\\t// grid.first: represents a grid [row,col]\\n\\t\\t// grid.second: the id of the artifact, represents which artfact this grid belongs to\\n        unordered_map<int,int> grid;\\n\\t\\t// sizes.first: the id of the artifact\\n\\t\\t// sizes.second: the size of this artifact\\n        unordered_map<int,int> sizes;\\n        for(int i=0; i<artifacts.size(); i++){\\n            int r1 = artifacts[i][0];\\n            int c1 = artifacts[i][1];\\n            int r2 = artifacts[i][2];\\n            int c2 = artifacts[i][3];\\n            int size = 0;\\n            for(int r=r1; r<=r2; r++){\\n                for(int c=c1; c<=c2; c++){\\n                    grid[r*n+c] = i;\\n                    size ++;\\n                }\\n            }\\n            sizes[i] = size;\\n        }\\n        int count = 0;\\n\\t\\t// found.first: the id of the artifact\\n\\t\\t// found.second: the discovered size of the artifact\\n        unordered_map<int,int> found;\\n        for(auto dig: digs){\\n            int r = dig[0];\\n            int c = dig[1];\\n            if(grid.find(r*n+c)!=grid.end()){\\n                found[grid[r*n+c]] ++;\\n                if(found[grid[r*n+c]]==sizes[grid[r*n+c]]){\\n                    count ++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1844150,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n       \\n        vector<vector<int>> visited(n , vector<int> (n, 0));\\n        for (auto grave: dig){\\n            visited[grave[0]][grave[1]] = 1;\\n        }\\n        int ans = 0;\\n        for(auto artifact: artifacts){\\n            int cells = (artifact[2] - artifact[0] + 1) * (artifact[3] - artifact[1] + 1);\\n            int count = 0;\\n            for(int i = artifact[0]; i <= artifact[2]; i++){\\n                for(int j = artifact[1]; j <= artifact[3]; j++){\\n                    if (visited[i][j] == 1)\\n                        count++;\\n                    else\\n                        break;\\n                }\\n            }\\n            if (count == cells)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n       \\n        vector<vector<int>> visited(n , vector<int> (n, 0));\\n        for (auto grave: dig){\\n            visited[grave[0]][grave[1]] = 1;\\n        }\\n        int ans = 0;\\n        for(auto artifact: artifacts){\\n            int cells = (artifact[2] - artifact[0] + 1) * (artifact[3] - artifact[1] + 1);\\n            int count = 0;\\n            for(int i = artifact[0]; i <= artifact[2]; i++){\\n                for(int j = artifact[1]; j <= artifact[3]; j++){\\n                    if (visited[i][j] == 1)\\n                        count++;\\n                    else\\n                        break;\\n                }\\n            }\\n            if (count == cells)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844116,
                "title": "dsu-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int fn(int x,int y,int n){\\n        return (x*n)+y;\\n    }\\n    int get_par(int x,vector<int> &par){\\n        return par[x] = ((x==par[x]) ? x : get_par(par[x],par));\\n    }\\n    void union_(int x,int y,vector<int> &par,vector<int> &rank){\\n        int px=get_par(x,par) ,py=get_par(y,par);\\n        \\n        if(px!=py)\\n            if(rank[px] < rank[py])\\n                par[px]=py;\\n            else if(rank[px] > rank[py])\\n                par[py]=px;\\n            else{\\n                par[py]=px;\\n                rank[py]++;\\n            }\\n\\n    }\\n    int digArtifacts(int n, vector<vector<int>>& art, vector<vector<int>>& dig) {\\n        \\n        vector<int> par(n*n,0),rank(n*n,0);\\n        for(int i=0;i<n*n;++i)\\n            par[i]=i;\\n        \\n        unordered_map<int,int> ump;\\n        \\n        for(const auto &v:art)\\n            for(int i=v[0];i<=v[2];++i)\\n                for(int j=v[1];j<=v[3];++j){\\n                    union_(fn(v[0],v[1],n),fn(i,j,n),par,rank);\\n                    ump[get_par(fn(v[0],v[1],n),par)]++;\\n                }\\n\\n\\n        \\n        int ans=0;\\n        for(vector<int> &d:dig)\\n            if(ump.find(get_par(fn(d[0],d[1],n),par))!=ump.end() and (--ump[get_par(fn(d[0],d[1],n),par)]) == 0)ans++;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fn(int x,int y,int n){\\n        return (x*n)+y;\\n    }\\n    int get_par(int x,vector<int> &par){\\n        return par[x] = ((x==par[x]) ? x : get_par(par[x],par));\\n    }\\n    void union_(int x,int y,vector<int> &par,vector<int> &rank){\\n        int px=get_par(x,par) ,py=get_par(y,par);\\n        \\n        if(px!=py)\\n            if(rank[px] < rank[py])\\n                par[px]=py;\\n            else if(rank[px] > rank[py])\\n                par[py]=px;\\n            else{\\n                par[py]=px;\\n                rank[py]++;\\n            }\\n\\n    }\\n    int digArtifacts(int n, vector<vector<int>>& art, vector<vector<int>>& dig) {\\n        \\n        vector<int> par(n*n,0),rank(n*n,0);\\n        for(int i=0;i<n*n;++i)\\n            par[i]=i;\\n        \\n        unordered_map<int,int> ump;\\n        \\n        for(const auto &v:art)\\n            for(int i=v[0];i<=v[2];++i)\\n                for(int j=v[1];j<=v[3];++j){\\n                    union_(fn(v[0],v[1],n),fn(i,j,n),par,rank);\\n                    ump[get_par(fn(v[0],v[1],n),par)]++;\\n                }\\n\\n\\n        \\n        int ans=0;\\n        for(vector<int> &d:dig)\\n            if(ump.find(get_par(fn(d[0],d[1],n),par))!=ump.end() and (--ump[get_par(fn(d[0],d[1],n),par)]) == 0)ans++;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844114,
                "title": "c-solution-matrix-prefix-sum",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int> > d(n + 1, vector<int>(n + 1));\\n        for(auto &di : dig) {\\n            d[di[0] + 1][di[1] + 1] = 1;\\n        }\\n        for(int i = 1; i <= n; i++) {\\n            int sum = 0;\\n            for(int j = 1; j <= n; j++) {\\n                sum += d[i][j];\\n                d[i][j] = d[i - 1][j] + sum;\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &art : artifacts) {\\n            int r0 = art[0], c0 = art[1], r1 = art[2], c1 = art[3];\\n            int x = d[r1 + 1][c1 + 1] - d[r1 + 1][c0] - d[r0][c1 + 1] + d[r0][c0];\\n            if(x == (r1 - r0 + 1) * (c1 - c0 + 1)) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int> > d(n + 1, vector<int>(n + 1));\\n        for(auto &di : dig) {\\n            d[di[0] + 1][di[1] + 1] = 1;\\n        }\\n        for(int i = 1; i <= n; i++) {\\n            int sum = 0;\\n            for(int j = 1; j <= n; j++) {\\n                sum += d[i][j];\\n                d[i][j] = d[i - 1][j] + sum;\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &art : artifacts) {\\n            int r0 = art[0], c0 = art[1], r1 = art[2], c1 = art[3];\\n            int x = d[r1 + 1][c1 + 1] - d[r1 + 1][c0] - d[r0][c1 + 1] + d[r0][c0];\\n            if(x == (r1 - r0 + 1) * (c1 - c0 + 1)) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844085,
                "title": "searching",
                "content": "```\\n int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n       int ans=0;\\n        //use map to improve search efficiency\\n        unordered_map<int,unordered_set<int>>mp;\\n        for(auto i:dig){\\n            mp[i[0]].insert(i[1]);\\n        }\\n        \\n        for(auto i:artifacts){\\n            //define count and total count as 0\\n            int c=0,tc=0;\\n            \\n            //search all digs \\n            for(int x=i[0];x<=i[2];x++){\\n                for(int y=i[1];y<=i[3];y++)\\n                {\\n                    //search\\n                    if(mp.count(x) and mp[x].find(y)!=mp[x].end())\\n                        c++;\\n                    \\n                    //tc will increase all time\\n                    tc++;\\n                }\\n            }\\n            \\n            //if count and total count is equal means all artifact buried so increase answer\\n            if(c==tc)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n       int ans=0;\\n        //use map to improve search efficiency\\n        unordered_map<int,unordered_set<int>>mp;\\n        for(auto i:dig){\\n            mp[i[0]].insert(i[1]);\\n        }\\n        \\n        for(auto i:artifacts){\\n            //define count and total count as 0\\n            int c=0,tc=0;\\n            \\n            //search all digs \\n            for(int x=i[0];x<=i[2];x++){\\n                for(int y=i[1];y<=i[3];y++)\\n                {\\n                    //search\\n                    if(mp.count(x) and mp[x].find(y)!=mp[x].end())\\n                        c++;\\n                    \\n                    //tc will increase all time\\n                    tc++;\\n                }\\n            }\\n            \\n            //if count and total count is equal means all artifact buried so increase answer\\n            if(c==tc)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844084,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        // max grid size 1000\\n        vector<vector<int>> v(1000, vector<int>(1000, 0));\\n        \\n        // dig artifacts\\n        for(auto &i : dig) {\\n            v[i[0]][i[1]]--;\\n        }\\n        \\n        int count = 0;\\n        // check grid again to find if all pieces of artifacts are dig\\n        for(auto &i : artifacts) {\\n            int i1 = i[0];\\n            int j1 = i[1];\\n            int i2 = i[2];\\n            int j2 = i[3];\\n            bool flag = true;\\n            for(int x = i1; x <= i2; x++) {\\n                for(int y = j1; y <= j2; y++) {\\n                    // 0 implies that at least one piece was not dig\\n                    if(v[x][y] == 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n\\t\\t\\t\\tif(!flag) break;\\n            }\\n            // if all pieces were dig, increase count\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        // max grid size 1000\\n        vector<vector<int>> v(1000, vector<int>(1000, 0));\\n        \\n        // dig artifacts\\n        for(auto &i : dig) {\\n            v[i[0]][i[1]]--;\\n        }\\n        \\n        int count = 0;\\n        // check grid again to find if all pieces of artifacts are dig\\n        for(auto &i : artifacts) {\\n            int i1 = i[0];\\n            int j1 = i[1];\\n            int i2 = i[2];\\n            int j2 = i[3];\\n            bool flag = true;\\n            for(int x = i1; x <= i2; x++) {\\n                for(int y = j1; y <= j2; y++) {\\n                    // 0 implies that at least one piece was not dig\\n                    if(v[x][y] == 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n\\t\\t\\t\\tif(!flag) break;\\n            }\\n            // if all pieces were dig, increase count\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950053,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMARK EVERY DIG POSITION AND CHECK EVERY POSITION IN THE CURRENT ASTERIOD IS DIGGED\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dig) {\\n        vector<vector<int>>mat(n,vector<int>(n,0));\\n        for(auto i:dig)\\n       {\\n           mat[i[0]][i[1]]=1;\\n\\n       } \\n       int c=0;\\n       for(auto i:a){\\n           if(i[0]==i[2]&&i[1]==i[3]&&mat[i[0]][i[1]]){\\n               c++;\\n               continue;\\n           }\\n           if(mat[i[0]][i[1]]&&mat[i[2]][i[3]]){\\n               if(i[0]==i[2]){\\n                   int  k=i[1]+1;\\n                   while(k<i[3]&&mat[i[0]][k])k++;\\n                   if(k==i[3])c++;\\n               }\\n               else{\\n                   if(i[1]==i[3]){\\n                       int k=i[0]+1;\\n                       while(k<i[2]&&mat[k][i[1]])k++;\\n                       if(k==i[2])c++;\\n                   }\\n                   else\\n                   {\\n                       if(mat[i[2]][i[1]]&&mat[i[0]][i[3]])c++;\\n                   }\\n               }\\n               \\n           }\\n       }\\n       return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dig) {\\n        vector<vector<int>>mat(n,vector<int>(n,0));\\n        for(auto i:dig)\\n       {\\n           mat[i[0]][i[1]]=1;\\n\\n       } \\n       int c=0;\\n       for(auto i:a){\\n           if(i[0]==i[2]&&i[1]==i[3]&&mat[i[0]][i[1]]){\\n               c++;\\n               continue;\\n           }\\n           if(mat[i[0]][i[1]]&&mat[i[2]][i[3]]){\\n               if(i[0]==i[2]){\\n                   int  k=i[1]+1;\\n                   while(k<i[3]&&mat[i[0]][k])k++;\\n                   if(k==i[3])c++;\\n               }\\n               else{\\n                   if(i[1]==i[3]){\\n                       int k=i[0]+1;\\n                       while(k<i[2]&&mat[k][i[1]])k++;\\n                       if(k==i[2])c++;\\n                   }\\n                   else\\n                   {\\n                       if(mat[i[2]][i[1]]&&mat[i[0]][i[3]])c++;\\n                   }\\n               }\\n               \\n           }\\n       }\\n       return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921512,
                "title": "simple-solution-using-prefix-sums",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing prefix sums,calculating if all the squares that occupy the treasure are dug or not\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*n) for the prefix sum\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n*n) for storing the prefix array\\n# Code\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        \\n\\n        dug = [[0]*n for i in range(n)]\\n\\n        for i,j in dig:\\n            dug[i][j] = 1\\n        \\n\\n        for i in range(n):\\n            for j in range(1,n):\\n                dug[i][j] += dug[i][j-1]\\n    \\n        for j in range(n):\\n            for i in range(1,n):\\n                dug[i][j] += dug[i-1][j]\\n        \\n\\n        ans = 0\\n\\n        for x1,y1,x2,y2 in artifacts:\\n            add1 = 0\\n            add2 = 0\\n            min1 = 0\\n            min2 = 0\\n\\n            if x1-1 >= 0 and y1 - 1 >= 0:\\n                add1 += dug[x1-1][y1-1]\\n            \\n            if x1 - 1 >= 0:\\n                min1 += dug[x1-1][y2]\\n            \\n            if y1 - 1 >= 0:\\n                min2 += dug[x2][y1-1]\\n            \\n            add2 += dug[x2][y2]\\n\\n            occu = (x2-x1+1)*(y2-y1+1)\\n            # print(occu,add1 + add2 - min1 - min2)\\n            if occu == add1 + add2 - min1 - min2:\\n                ans += 1\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        \\n\\n        dug = [[0]*n for i in range(n)]\\n\\n        for i,j in dig:\\n            dug[i][j] = 1\\n        \\n\\n        for i in range(n):\\n            for j in range(1,n):\\n                dug[i][j] += dug[i][j-1]\\n    \\n        for j in range(n):\\n            for i in range(1,n):\\n                dug[i][j] += dug[i-1][j]\\n        \\n\\n        ans = 0\\n\\n        for x1,y1,x2,y2 in artifacts:\\n            add1 = 0\\n            add2 = 0\\n            min1 = 0\\n            min2 = 0\\n\\n            if x1-1 >= 0 and y1 - 1 >= 0:\\n                add1 += dug[x1-1][y1-1]\\n            \\n            if x1 - 1 >= 0:\\n                min1 += dug[x1-1][y2]\\n            \\n            if y1 - 1 >= 0:\\n                min2 += dug[x2][y1-1]\\n            \\n            add2 += dug[x2][y2]\\n\\n            occu = (x2-x1+1)*(y2-y1+1)\\n            # print(occu,add1 + add2 - min1 - min2)\\n            if occu == add1 + add2 - min1 - min2:\\n                ans += 1\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879042,
                "title": "c-easy-brute-force-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:map<pair<int,int>,int> p;\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& d) {\\n    for(auto i: a)\\n       {\\n        for(int r=i[0];r<=i[2];r++)\\n        for(int c=i[1];c<=i[3];c++)\\n          p[{r,c}]=1;\\n       }\\n\\n    int c=0;\\n    for(auto i: d)\\n        if(p[{i[0],i[1]}]==1)\\n        p[{i[0],i[1]}]=0;\\n\\n     for(auto i: a)\\n       {\\n         bool b=1;  \\n         for(int r=i[0];r<=i[2];r++)\\n          for(int c=i[1];c<=i[3];c++)\\n           if(p[{r,c}]==1)\\n            b=0;\\n        \\n        if(b) c++;\\n       }\\n    return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:map<pair<int,int>,int> p;\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& d) {\\n    for(auto i: a)\\n       {\\n        for(int r=i[0];r<=i[2];r++)\\n        for(int c=i[1];c<=i[3];c++)\\n          p[{r,c}]=1;\\n       }\\n\\n    int c=0;\\n    for(auto i: d)\\n        if(p[{i[0],i[1]}]==1)\\n        p[{i[0],i[1]}]=0;\\n\\n     for(auto i: a)\\n       {\\n         bool b=1;  \\n         for(int r=i[0];r<=i[2];r++)\\n          for(int c=i[1];c<=i[3];c++)\\n           if(p[{r,c}]==1)\\n            b=0;\\n        \\n        if(b) c++;\\n       }\\n    return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807155,
                "title": "easy-c-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>>grid(n,vector<int>(n,0));\\n        int count=1;\\n        map<int,int>mp;\\n        for(auto it:artifacts){\\n            int x1=it[0];\\n            int x2=it[2];\\n            int y1=it[1];\\n            int y2=it[3];\\n            for(int i=x1;i<=x2;i++){\\n                for(int j=y1;j<=y2;j++){\\n                    grid[i][j]=count;\\n                    mp[count]++;\\n                }\\n            }\\n            count++;\\n\\n        }\\n        int ans=0;\\n        for(auto it:dig){\\n            int x=it[0];\\n            int y=it[1];\\n            mp[grid[x][y]]--;\\n            if(mp[grid[x][y]]==0){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>>grid(n,vector<int>(n,0));\\n        int count=1;\\n        map<int,int>mp;\\n        for(auto it:artifacts){\\n            int x1=it[0];\\n            int x2=it[2];\\n            int y1=it[1];\\n            int y2=it[3];\\n            for(int i=x1;i<=x2;i++){\\n                for(int j=y1;j<=y2;j++){\\n                    grid[i][j]=count;\\n                    mp[count]++;\\n                }\\n            }\\n            count++;\\n\\n        }\\n        int ans=0;\\n        for(auto it:dig){\\n            int x=it[0];\\n            int y=it[1];\\n            mp[grid[x][y]]--;\\n            if(mp[grid[x][y]]==0){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763780,
                "title": "only-array-usage-neat-explanation-w-img-beginner-friendly",
                "content": "#  Brute Force works !\\n  - I think its the only way to solve this problem(we have to optimise inside that)\\n# Complexity\\n# Lets go PointWise :\\n- we have created the area of artifacts as `art[][]` of length `n`\\n- Intially we are marking the digged areas(given in `dig[][]`) in our `art` area (we will not encounter any duplicate as they are unique as per mentioned)\\n- for every top left and bottom right coordntes we will check whether every cord is digged already or not .\\n-   \\n    - If not digged anywhere in range we brekaing the loops and does not count that entire artifact using our `flag` \\n![leet_2201_sol_img.png](https://assets.leetcode.com/users/images/28fb83c8-4136-449b-b8c6-0bdf9e8fcd10_1689331878.897774.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artfc, int[][] dig) {\\n        int [][] art = new int[n][n];boolean flag;int cnt=0;\\n        for(int i=0;i<dig.length;i++){\\n            art[dig[i][0]][dig[i][1]]++;\\n        }\\n        for(int k[] : artfc){\\n            flag = true;\\n          for(int i=k[0];i<=k[2];i++){\\n            for(int j=k[1];j<=k[3];j++){\\n                if(art[i][j]!=1) {flag=false;break;}\\n            }}\\n            if(flag) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artfc, int[][] dig) {\\n        int [][] art = new int[n][n];boolean flag;int cnt=0;\\n        for(int i=0;i<dig.length;i++){\\n            art[dig[i][0]][dig[i][1]]++;\\n        }\\n        for(int k[] : artfc){\\n            flag = true;\\n          for(int i=k[0];i<=k[2];i++){\\n            for(int j=k[1];j<=k[3];j++){\\n                if(art[i][j]!=1) {flag=false;break;}\\n            }}\\n            if(flag) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601981,
                "title": "java-clean-and-clear-solution",
                "content": "# Approach\\n1. Use a boolean[n][n] to mark which sites have been excavated\\n2. For each artefact, check if each block between [x1,y1] -> [x2,y2] has been excavated.\\n3. If the whole aretefact is excavated, increment by 1.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        boolean[][] digged = getDiggedLocations(n, dig);\\n        int diggedArtefacts = 0;\\n        for(int[] artefact : artifacts) {\\n            diggedArtefacts += canBeDigged(digged, artefact) ? 1 : 0;\\n        }\\n        return diggedArtefacts;\\n    }\\n\\n    private boolean canBeDigged(boolean[][] digged, int[] artefact) {\\n        for (int i = artefact[0]; i <= artefact[2]; i++) {\\n            for (int j = artefact[1]; j <= artefact[3]; j++) {\\n                if (!digged[i][j]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean[][] getDiggedLocations(int n, int[][] dig) {\\n        boolean[][] digged = new boolean[n][n];\\n        for (int[] site: dig) {\\n            digged[site[0]][site[1]] = true;\\n        }\\n        return digged;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        boolean[][] digged = getDiggedLocations(n, dig);\\n        int diggedArtefacts = 0;\\n        for(int[] artefact : artifacts) {\\n            diggedArtefacts += canBeDigged(digged, artefact) ? 1 : 0;\\n        }\\n        return diggedArtefacts;\\n    }\\n\\n    private boolean canBeDigged(boolean[][] digged, int[] artefact) {\\n        for (int i = artefact[0]; i <= artefact[2]; i++) {\\n            for (int j = artefact[1]; j <= artefact[3]; j++) {\\n                if (!digged[i][j]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean[][] getDiggedLocations(int n, int[][] dig) {\\n        boolean[][] digged = new boolean[n][n];\\n        for (int[] site: dig) {\\n            digged[site[0]][site[1]] = true;\\n        }\\n        return digged;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599452,
                "title": "java-hashset",
                "content": "# Approach\\nAdd all dig coordinates to hashset \\nIterate in each artifac array if any cell int it doesnot contains it break it else count++\\n\\n# Complexity\\n- Time complexity: O(Dig + artifacts*(n*n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int[] a:dig)\\n            set.add(a[0]*n+a[1]);\\n\\n        int count=0;\\n        for(int[] a:artifacts){\\n            boolean flag = false;\\n            for(int i=a[0];i<=a[2];i++){\\n                for(int j=a[1];j<=a[3];j++){\\n                    if(!set.contains(i*n+j)){\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if(flag)\\n                    break;\\n            }\\n            if(!flag)\\n                count++;\\n\\n        }\\n\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int[] a:dig)\\n            set.add(a[0]*n+a[1]);\\n\\n        int count=0;\\n        for(int[] a:artifacts){\\n            boolean flag = false;\\n            for(int i=a[0];i<=a[2];i++){\\n                for(int j=a[1];j<=a[3];j++){\\n                    if(!set.contains(i*n+j)){\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if(flag)\\n                    break;\\n            }\\n            if(!flag)\\n                count++;\\n\\n        }\\n\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469042,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar digArtifacts = function(n, artifacts, dig) {\\n    const digSet = dig.reduce((set, [r, c]) => set.add(`${r}-${c}`), new Set());\\n\\n    return artifacts.reduce((result, [r1, c1, r2, c2]) => {\\n        for (let r = r1; r <= r2; r++) {\\n            for (let c = c1; c <= c2; c++) {\\n                if (!digSet.has(`${r}-${c}`)) return result;\\n            }\\n        }\\n        return result + 1;\\n    }, 0); \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar digArtifacts = function(n, artifacts, dig) {\\n    const digSet = dig.reduce((set, [r, c]) => set.add(`${r}-${c}`), new Set());\\n\\n    return artifacts.reduce((result, [r1, c1, r2, c2]) => {\\n        for (let r = r1; r <= r2; r++) {\\n            for (let c = c1; c <= c2; c++) {\\n                if (!digSet.has(`${r}-${c}`)) return result;\\n            }\\n        }\\n        return result + 1;\\n    }, 0); \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418875,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func digArtifacts(_ n: Int, _ artifacts: [[Int]], _ dig: [[Int]]) -> Int {\\n        \\n        func i(_ r: Int, _ c: Int) -> Int { r * n + c }\\n        func i(_ c: [Int]) -> Int { i(c[0], c[1]) }\\n\\n        var digged = Array(repeating: false, count: n * n)\\n        for d in dig { digged[i(d)] = true }\\n\\n        func dug(_ a: [Int]) -> Bool {\\n            for r in a[0]...a[2] {\\n                for c in a[1]...a[3]\\n                    where !digged[i(r, c)] {\\n                        return false\\n                    }\\n            }\\n            return true\\n        }\\n\\n        return artifacts.filter(dug).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func digArtifacts(_ n: Int, _ artifacts: [[Int]], _ dig: [[Int]]) -> Int {\\n        \\n        func i(_ r: Int, _ c: Int) -> Int { r * n + c }\\n        func i(_ c: [Int]) -> Int { i(c[0], c[1]) }\\n\\n        var digged = Array(repeating: false, count: n * n)\\n        for d in dig { digged[i(d)] = true }\\n\\n        func dug(_ a: [Int]) -> Bool {\\n            for r in a[0]...a[2] {\\n                for c in a[1]...a[3]\\n                    where !digged[i(r, c)] {\\n                        return false\\n                    }\\n            }\\n            return true\\n        }\\n\\n        return artifacts.filter(dug).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417647,
                "title": "c-hashing-easy-understanding-bruteforce-o-4-10-5",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        \\n        map<pair<int,int>,bool> visited;\\n        for(int i=0;i<dig.size();i++){\\n            int row=dig[i][0];\\n            int col=dig[i][1];\\n            visited[{row,col}]=true;\\n        }\\n        long long count=0;\\n        for(int k=0;k<artifacts.size();k++){\\n            \\n            int startrow=artifacts[k][0];\\n            int startcol=artifacts[k][1];\\n            int endrow=artifacts[k][2];\\n            int endcol=artifacts[k][3];\\n            int i=startrow;\\n            int j=startcol;\\n            if(endrow==startrow+1 && endcol==startcol+1){\\n                if(visited[{i,j}]==true && visited[{i,j+1}]==true && visited[{i+1,j}]==true && visited[{i+1,j+1}]==true){\\n                    count++;\\n                }\\n            }\\n            else if(endrow!=startrow && endcol==startcol){\\n                bool flag=1;\\n                for(int w=startrow;w<=endrow;w++){\\n                    if(visited[{w,j}]!=true){\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                if(flag==1){\\n                    count++;\\n                }\\n            }\\n            else if(endrow==startrow && endcol!=startcol){\\n                bool flag=1;\\n                for(int w=startcol;w<=endcol;w++){\\n                    if(visited[{i,w}]!=true){\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                if(flag==1){\\n                    count++;\\n                }\\n            }\\n            else if(startrow==endrow && startcol==endcol){\\n                if(visited[{i,j}]==true){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        \\n        map<pair<int,int>,bool> visited;\\n        for(int i=0;i<dig.size();i++){\\n            int row=dig[i][0];\\n            int col=dig[i][1];\\n            visited[{row,col}",
                "codeTag": "Java"
            },
            {
                "id": 3365992,
                "title": "javascript-short-and-readable",
                "content": "```\\nconst digArtifacts = (n, artifacts, dig) => {\\n  let grid = new Array(n).fill().map(() => new Array(n).fill(false));\\n  dig.map(([r, c]) => (grid[r][c] = true));\\n\\n  return artifacts.reduce((extracted, [r1, c1, r2, c2]) => {\\n    while (r1 <= r2) {\\n      for (let i = c1; i <= c2; i++) if (!grid[r1][i]) return extracted;\\n      r1++;\\n    }\\n    return extracted + 1;\\n  }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst digArtifacts = (n, artifacts, dig) => {\\n  let grid = new Array(n).fill().map(() => new Array(n).fill(false));\\n  dig.map(([r, c]) => (grid[r][c] = true));\\n\\n  return artifacts.reduce((extracted, [r1, c1, r2, c2]) => {\\n    while (r1 <= r2) {\\n      for (let i = c1; i <= c2; i++) if (!grid[r1][i]) return extracted;\\n      r1++;\\n    }\\n    return extracted + 1;\\n  }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3335841,
                "title": "clean-c-using-std-unordered-set-vector-int",
                "content": "# Intuition\\nThe answer is pretty straightforward, for each artifact check if every of its coordinates are in the dig vector. The reason I am posting this is because of the implementation of the `std::unordered_set<std::vector<int>>`\\n\\nUnordered Sets require a hashing function which is available in the standard library for many types, but not for `std::vector` and the reason it is not available is obvious: `std::vector` is very general, it can have various sizes and we can easily end  up with a  hashing function that is not useful for many cases. \\n\\nHowever for this specific problem we have a set of 2D Vector, where the values are limited to `1.000`, so we can create our own hashing function for this specific purpose only by calling the hashing function that is availble in the standard library for integers `std::hash<int>` and combining the entries in our 2-D vector to for a single int, in this case I chose `v[0]+10000*v[1]`. \\n\\nThis also lets us initialized the unordered_set using the iterator constructor, which is quite elegant in my opinion. \\n\\nHope this helps in your learning journey!\\n\\n# Code\\n```Cpp\\nstruct vector_hash\\n{\\n    template <class T>\\n    std::size_t operator () (const std::vector<T> &v) const{\\n        return std::hash<T>()(v[0] +10000*v[1]);    \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        std::unordered_set<vector<int>,vector_hash> st (dig.begin(),dig.end()); \\n\\n        int res = 0; \\n        for(const auto& artifact : artifacts){\\n            res+= isUncovered(artifact,st); \\n        }\\n        return res; \\n    }\\n\\n    bool isUncovered(const vector<int>& artifact,const std::unordered_set<vector<int>,vector_hash>& st){\\n        for(int r = artifact[0]; r <= artifact[2]; ++r){\\n            for(int c = artifact[1]; c <= artifact[3]; ++c){\\n                if(!st.count({r,c})) return false; \\n            }\\n        }\\n        return true; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```Cpp\\nstruct vector_hash\\n{\\n    template <class T>\\n    std::size_t operator () (const std::vector<T> &v) const{\\n        return std::hash<T>()(v[0] +10000*v[1]);    \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        std::unordered_set<vector<int>,vector_hash> st (dig.begin(),dig.end()); \\n\\n        int res = 0; \\n        for(const auto& artifact : artifacts){\\n            res+= isUncovered(artifact,st); \\n        }\\n        return res; \\n    }\\n\\n    bool isUncovered(const vector<int>& artifact,const std::unordered_set<vector<int>,vector_hash>& st){\\n        for(int r = artifact[0]; r <= artifact[2]; ++r){\\n            for(int c = artifact[1]; c <= artifact[3]; ++c){\\n                if(!st.count({r,c})) return false; \\n            }\\n        }\\n        return true; \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311083,
                "title": "c-golang-2d-hash-table",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> grid(n, vector<int>(n, -1));\\n        for(int i = 0; i < artifacts.size(); i++) {\\n            for(int j = artifacts[i][0]; j <= artifacts[i][2]; j++) {\\n                for(int k = artifacts[i][1]; k <= artifacts[i][3]; k++) {\\n                    grid[j][k] = i;\\n                }\\n            }\\n        }\\n        unordered_set<int> Set;\\n        for(vector<int> d: dig) {\\n            grid[d[0]][d[1]] = -1;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] != -1)\\n                    Set.insert(grid[i][j]);\\n            }\\n        }\\n        return artifacts.size() - Set.size();\\n    }\\n};\\n\\n\\n// Golang\\nfunc digArtifacts(n int, artifacts [][]int, dig [][]int) int {\\n    grid := make([][]int, n)    \\n    for i := 0; i < n; i++ {\\n        grid[i] = make([]int, n)\\n    }\\n    for i := 0; i < len(artifacts); i++ {\\n        for j := artifacts[i][0]; j <= artifacts[i][2]; j++ {\\n            for k := artifacts[i][1]; k <= artifacts[i][3]; k++ {\\n                grid[j][k] = i + 1\\n            }\\n        }\\n    }\\n    Set := make(map[int]bool)\\n    for _, d := range dig {\\n        grid[d[0]][d[1]] = 0\\n    }\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < n; j++ {\\n            if grid[i][j] != 0 {\\n                Set[grid[i][j]] = true\\n            }\\n        }\\n    }\\n    return len(artifacts) - len(Set)\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> grid(n, vector<int>(n, -1));\\n        for(int i = 0; i < artifacts.size(); i++) {\\n            for(int j = artifacts[i][0]; j <= artifacts[i][2]; j++) {\\n                for(int k = artifacts[i][1]; k <= artifacts[i][3]; k++) {\\n                    grid[j][k] = i;\\n                }\\n            }\\n        }\\n        unordered_set<int> Set;\\n        for(vector<int> d: dig) {\\n            grid[d[0]][d[1]] = -1;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] != -1)\\n                    Set.insert(grid[i][j]);\\n            }\\n        }\\n        return artifacts.size() - Set.size();\\n    }\\n};\\n\\n\\n// Golang\\nfunc digArtifacts(n int, artifacts [][]int, dig [][]int) int {\\n    grid := make([][]int, n)    \\n    for i := 0; i < n; i++ {\\n        grid[i] = make([]int, n)\\n    }\\n    for i := 0; i < len(artifacts); i++ {\\n        for j := artifacts[i][0]; j <= artifacts[i][2]; j++ {\\n            for k := artifacts[i][1]; k <= artifacts[i][3]; k++ {\\n                grid[j][k] = i + 1\\n            }\\n        }\\n    }\\n    Set := make(map[int]bool)\\n    for _, d := range dig {\\n        grid[d[0]][d[1]] = 0\\n    }\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < n; j++ {\\n            if grid[i][j] != 0 {\\n                Set[grid[i][j]] = true\\n            }\\n        }\\n    }\\n    return len(artifacts) - len(Set)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287412,
                "title": "very-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) \\n    {\\n        int count=0;\\n        vector<vector<int>> grid(n,vector<int> (n,0));\\n        for(auto it: dig) grid[it[0]][it[1]]=1;\\n        for(auto it: artifacts)\\n        {\\n            int f=1;\\n            for(int r=it[0]; r<=it[2]; r++)\\n            {\\n                for(int c=it[1]; c<=it[3]; c++)\\n                {\\n                    if(!grid[r][c])\\n                    {\\n                        f=0; break;\\n                    }\\n                }\\n            }\\n            if(f) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) \\n    {\\n        int count=0;\\n        vector<vector<int>> grid(n,vector<int> (n,0));\\n        for(auto it: dig) grid[it[0]][it[1]]=1;\\n        for(auto it: artifacts)\\n        {\\n            int f=1;\\n            for(int r=it[0]; r<=it[2]; r++)\\n            {\\n                for(int c=it[1]; c<=it[3]; c++)\\n                {\\n                    if(!grid[r][c])\\n                    {\\n                        f=0; break;\\n                    }\\n                }\\n            }\\n            if(f) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280534,
                "title": "dart-clean-code-explained",
                "content": "# Intuition\\nMake a grid, make true to all digged positions. If a artifact can have true for all in his range, that is mean all are uncovered. So res++. That\\'s it.\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n  int digArtifacts(int n, List<List<int>> artifacts, List<List<int>> dig) {\\n    List<List<bool>> grid = List.generate(\\n      n,\\n      (index) => List.filled(n, false),\\n    );\\n\\n    for (var i = 0; i < dig.length; i++) {\\n      grid[dig[i][0]][dig[i][1]] = true;\\n    }\\n\\n    int res = 0;\\n\\n    for (var art in artifacts) {\\n      var r1 = art[0], c1 = art[1], r2 = art[2], c2 = art[3];\\n      bool flag = true;\\n      for (var i = r1; i <= r2 && flag; i++) {\\n        for (var j = c1; j <= c2; j++) {\\n          if (!grid[i][j]) {\\n            flag = false;\\n            break;\\n          }\\n        }\\n      }\\n      if (flag) res++;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int digArtifacts(int n, List<List<int>> artifacts, List<List<int>> dig) {\\n    List<List<bool>> grid = List.generate(\\n      n,\\n      (index) => List.filled(n, false),\\n    );\\n\\n    for (var i = 0; i < dig.length; i++) {\\n      grid[dig[i][0]][dig[i][1]] = true;\\n    }\\n\\n    int res = 0;\\n\\n    for (var art in artifacts) {\\n      var r1 = art[0], c1 = art[1], r2 = art[2], c2 = art[3];\\n      bool flag = true;\\n      for (var i = r1; i <= r2 && flag; i++) {\\n        for (var j = c1; j <= c2; j++) {\\n          if (!grid[i][j]) {\\n            flag = false;\\n            break;\\n          }\\n        }\\n      }\\n      if (flag) res++;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275699,
                "title": "c-use-2d-hashtable",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>> g(n, vector<bool>(n));\\n        for (auto& v : dig)\\n            g[v[0]][v[1]] = true;\\n        int ans = 0;\\n        for (auto& v : artifacts){\\n            bool valid = true;\\n            int x = v[0], y = v[1], x2 = v[2], y2 = v[3];\\n            for (int b = x; b <= x2; ++b)\\n                for (int z = y; z <= y2; ++z)\\n                    if (!g[b][z]) valid = false;\\n            if (valid) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>> g(n, vector<bool>(n));\\n        for (auto& v : dig)\\n            g[v[0]][v[1]] = true;\\n        int ans = 0;\\n        for (auto& v : artifacts){\\n            bool valid = true;\\n            int x = v[0], y = v[1], x2 = v[2], y2 = v[3];\\n            for (int b = x; b <= x2; ++b)\\n                for (int z = y; z <= y2; ++z)\\n                    if (!g[b][z]) valid = false;\\n            if (valid) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236139,
                "title": "simple-neat-explanation-clean-c-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to count the number of valid artifacts based on a given dig area. We can consider an artifact valid if every grid square that the artifact occupies is also within the dig area.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first create a `yard` grid that stores whether a certain square has been dug or not. Then we iterate over each artifact and check if all its grid squares are dug or not within the specified dig area. If an artifact is valid, we increment the result counter.\\n\\nWe can check if all the grid squares of an artifact lie within the specified dig area using the `isValid` function. This function takes in the artifact\\'s `r1, c1, r2, c2` coordinates, along with the `yard` grid and the size `n` of the grid. It checks if every grid square between (`r1, c1`) and (`r2, c2`) is dug or not by iterating over each square and checking if it has been dug or not.\\n\\n# Complexity\\n- Time complexity: $$O(a * n^2)$$, where a is the number of artifacts and n is the size of the grid. We iterate over each artifact and check every grid square within the artifact\\'s area, which can take up to n^2 time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$ to store the yard grid.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp []\\nclass Solution {\\n    bool isValid(int r1, int c1, int r2, int c2, vector<vector<bool>>& yard, int n) {\\n        for(int i = r1; i <= r2; i++) {\\n            for(int j = c1; j <= c2; j++) {\\n                if(yard[i][j] == false) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>> yard(n, vector<bool>(n, false));\\n        for(auto &d: dig) {\\n            yard[d[0]][d[1]] = true;\\n        }\\n        int res = 0;\\n        for(auto &a: artifacts) {\\n            if(isValid(a[0], a[1], a[2], a[3], yard, n)) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        boolean[][] yard = new boolean[n][n];\\n        for(int[] d: dig) {\\n            yard[d[0]][d[1]] = true;\\n        }\\n        int res = 0;\\n        for(int[] a: artifacts) {\\n            if(isValid(a[0], a[1], a[2], a[3], yard, n)) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    private boolean isValid(int r1, int c1, int r2, int c2, boolean[][] yard, int n) {\\n        for(int i = r1; i <= r2; i++) {\\n            for(int j = c1; j <= c2; j++) {\\n                if(!yard[i][j]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```cpp []\\nclass Solution {\\n    bool isValid(int r1, int c1, int r2, int c2, vector<vector<bool>>& yard, int n) {\\n        for(int i = r1; i <= r2; i++) {\\n            for(int j = c1; j <= c2; j++) {\\n                if(yard[i][j] == false) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>> yard(n, vector<bool>(n, false));\\n        for(auto &d: dig) {\\n            yard[d[0]][d[1]] = true;\\n        }\\n        int res = 0;\\n        for(auto &a: artifacts) {\\n            if(isValid(a[0], a[1], a[2], a[3], yard, n)) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        boolean[][] yard = new boolean[n][n];\\n        for(int[] d: dig) {\\n            yard[d[0]][d[1]] = true;\\n        }\\n        int res = 0;\\n        for(int[] a: artifacts) {\\n            if(isValid(a[0], a[1], a[2], a[3], yard, n)) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    private boolean isValid(int r1, int c1, int r2, int c2, boolean[][] yard, int n) {\\n        for(int i = r1; i <= r2; i++) {\\n            for(int j = c1; j <= c2; j++) {\\n                if(!yard[i][j]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098739,
                "title": "c-neat-code-easily-understandable",
                "content": "Basically, what I am doing is:-\\n\\n1) Take a matrix of size n*n\\n2) Iterate the artifacts, and fill the matrix with the indices of artifacts\\n3) In a map keep the count of how many boxes  a artifact contain \\nNow,\\n1) Traverse the dig array, find out which artifact , the  box of dig array contain\\n2) if it represents the valid index, not -1 which we previously set, decrement its count from map\\n3) if the value of its count in map equals to zero , then we have fully uncovered it, increment our answer\\n\\n\\n```\\nvector<vector<int>>cov(n,vector<int>(n,-1));\\n        unordered_map<int,int>mapit;\\n        for(int i=0;i<art.size();i++)\\n        {\\n            int c = 0;\\n            for(int x=art[i][0];x<=art[i][2];x++)\\n            {\\n                for(int y=art[i][1];y<=art[i][3];y++)\\n                {\\n                    cov[x][y]=i;c++;\\n                }\\n            }\\n            mapit[i]=c;\\n        }\\n        int f = 0;\\n        for(vector<int>k:dig)\\n        {\\n            int i = cov[k[0]][k[1]];\\n            if(i!=-1)\\n            {\\n                mapit[i]--;\\n            if(mapit[i]==0)\\n                f++;\\n            }\\n            \\n        }\\n        return f;\\n    }\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>>cov(n,vector<int>(n,-1));\\n        unordered_map<int,int>mapit;\\n        for(int i=0;i<art.size();i++)\\n        {\\n            int c = 0;\\n            for(int x=art[i][0];x<=art[i][2];x++)\\n            {\\n                for(int y=art[i][1];y<=art[i][3];y++)\\n                {\\n                    cov[x][y]=i;c++;\\n                }\\n            }\\n            mapit[i]=c;\\n        }\\n        int f = 0;\\n        for(vector<int>k:dig)\\n        {\\n            int i = cov[k[0]][k[1]];\\n            if(i!=-1)\\n            {\\n                mapit[i]--;\\n            if(mapit[i]==0)\\n                f++;\\n            }\\n            \\n        }\\n        return f;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3078793,
                "title": "ok",
                "content": "```\\nint digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dd)\\n{\\n\\tint t[1000][1000]{};\\n\\tunordered_map<int, int> m;\\n\\tfor(int k{}; k<size(a); ++k)\\n\\t\\tfor(int i{a[k][0]}; i<=a[k][2]; ++i)\\n\\t\\t\\tfor(int j{a[k][1]}; j<=a[k][3]; ++j)\\n\\t\\t\\t\\tt[i][j]=k+1, m[k+1]++;\\n\\tint out{};\\n\\tfor(const auto & d : dd)\\n\\tif(t[d[0]][d[1]] and m.count(t[d[0]][d[1]]))\\n\\t\\tout += 0==--m[t[d[0]][d[1]]], t[d[0]][d[1]]=0;\\n\\t return out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dd)\\n{\\n\\tint t[1000][1000]{};\\n\\tunordered_map<int, int> m;\\n\\tfor(int k{}; k<size(a); ++k)\\n\\t\\tfor(int i{a[k][0]}; i<=a[k][2]; ++i)\\n\\t\\t\\tfor(int j{a[k][1]}; j<=a[k][3]; ++j)\\n\\t\\t\\t\\tt[i][j]=k+1, m[k+1]++;\\n\\tint out{};\\n\\tfor(const auto & d : dd)\\n\\tif(t[d[0]][d[1]] and m.count(t[d[0]][d[1]]))\\n\\t\\tout += 0==--m[t[d[0]][d[1]]], t[d[0]][d[1]]=0;\\n\\t return out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2927662,
                "title": "c-easy-explanation-searching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen u look at the problem you can just know that it requires some implementation involving searching.\\nGiven, are the top left portion of an artifact and the bottom right of an artifact. So we need to see if there is any coordinate which can not be uncovered , if this is true then the artifact extraction remains incomplete and thus skip it.\\n\\n---\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo search for if the particular coordinate is available for extraction, we can use sets or map kindof a thing where  we can search for an element in constant time.If a particular coordinate is not present in the set then it means that that artifact couldnot be extracted .    \\n\\n---\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*N)\\n    and N is the number of coordinates where digging could be done.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N*N)\\n    and N is the number of coordinates where digging could be done.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dig) {\\n        set<pair<int,int>>s;\\n        for(auto &x:dig){\\n            s.insert({x[0],x[1]});\\n        }\\n        int count=0;\\n        for(auto &x:a){\\n            bool canfind=true;\\n            for(int i=x[0];i<=x[2];i++){\\n                for(int j=x[1];j<=x[3];j++){\\n                pair<int,int>g={i,j};\\n                if(s.find(g)==s.end()){\\n                      canfind=false;\\n                      break;\\n                  }\\n                }\\n                if(canfind==false){\\n                    break;\\n                }\\n            }\\n            if(canfind==true){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dig) {\\n        set<pair<int,int>>s;\\n        for(auto &x:dig){\\n            s.insert({x[0],x[1]});\\n        }\\n        int count=0;\\n        for(auto &x:a){\\n            bool canfind=true;\\n            for(int i=x[0];i<=x[2];i++){\\n                for(int j=x[1];j<=x[3];j++){\\n                pair<int,int>g={i,j};\\n                if(s.find(g)==s.end()){\\n                      canfind=false;\\n                      break;\\n                  }\\n                }\\n                if(canfind==false){\\n                    break;\\n                }\\n            }\\n            if(canfind==true){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926036,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digArtifacts(self, n, artifacts, dig):\\n        mat = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        for i,j in dig:\\n            mat[i][j] = True\\n\\n        total = 0\\n\\n        for i in artifacts:\\n            x1,y1,x2,y2 = i\\n            flag = True\\n\\n            for i in range(x1,x2+1):\\n                for j in range(y1,y2+1):\\n                    if not mat[i][j]:\\n                        flag = False\\n\\n            if flag: total += 1\\n\\n        return total\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n, artifacts, dig):\\n        mat = [[0 for _ in range(n)] for _ in range(n)]\\n\\n        for i,j in dig:\\n            mat[i][j] = True\\n\\n        total = 0\\n\\n        for i in artifacts:\\n            x1,y1,x2,y2 = i\\n            flag = True\\n\\n            for i in range(x1,x2+1):\\n                for j in range(y1,y2+1):\\n                    if not mat[i][j]:\\n                        flag = False\\n\\n            if flag: total += 1\\n\\n        return total\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863306,
                "title": "python3-concise-and-constant-space-o-n-2-solution-featuring-unholy-two-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to check for each artifact, whether all cells have been dug up. Since no artifacts overlap, we can do that for each artifact independent.\\n\\nIn order to have a quick lookup whether a cell has been dug up, we convert our digs into a set of tuples for O(1) lookup.\\n\\nWe iterate through each cell of an artifact and check whether it is in our set of tuples. I made this a one-liner in order to use a builtin all, but I commented the same more verbose nested loop above it.\\n\\nAs we do not make a list of cells per artifact but iterate through them, we do not need any extra space other than the tuple we are currently checking.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach uses a set and nested loops to iterate through all cells of an artifact.\\n\\nI also added a totally unnecessary two liner solution to be very concise. This is just for fun, I would hate to find something like this anywhere. It has the same functionality while beeing absolutely ugly :-)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2) where N is the side-length of the grid our artifacts are in. One could also see this as O(N) if N would be all of the cells an artifact is under.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as we do not use any extra space (if you omit transformin the dig list to a dig set)\\n\\n# Code\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n\\n        # make a set from the digging for quick lookup\\n        self.digs = set((rx, cx) for rx, cx in dig)\\n        \\n        # go through the artifacts\\n        return sum(self.check_whole_cell(*artifact) for artifact in artifacts)\\n    \\n    def check_whole_cell(self, tlrx, tlcx, tbrx, tbcx):\\n        \"\"\"for rx in range(tlrx, tbrx+1):\\n            for cx in range(tlcx, tbcx):\\n                if (rx, cx) not in self.digs:\\n                    return 0\"\"\"\\n        return all((rx, cx) in self.digs for rx in range(tlrx, tbrx+1) for cx in range(tlcx, tbcx+1))\\n```\\n\\n**Unreadable Two-Liner:**\\n```\\ndef digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        digs = set((rx, cx) for rx, cx in dig)\\n        return sum(all((rx, cx) in digs for rx in range(tlrx, tbrx+1) for cx in range(tlcx, tbcx+1)) for tlrx, tlcx, tbrx, tbcx in artifacts)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n\\n        # make a set from the digging for quick lookup\\n        self.digs = set((rx, cx) for rx, cx in dig)\\n        \\n        # go through the artifacts\\n        return sum(self.check_whole_cell(*artifact) for artifact in artifacts)\\n    \\n    def check_whole_cell(self, tlrx, tlcx, tbrx, tbcx):\\n        \"\"\"for rx in range(tlrx, tbrx+1):\\n            for cx in range(tlcx, tbcx):\\n                if (rx, cx) not in self.digs:\\n                    return 0\"\"\"\\n        return all((rx, cx) in self.digs for rx in range(tlrx, tbrx+1) for cx in range(tlcx, tbcx+1))\\n```\n```\\ndef digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        digs = set((rx, cx) for rx, cx in dig)\\n        return sum(all((rx, cx) in digs for rx in range(tlrx, tbrx+1) for cx in range(tlcx, tbcx+1)) for tlrx, tlcx, tbrx, tbcx in artifacts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831348,
                "title": "python-simple-solution",
                "content": "# Intuition\\nWe have only at most 4 cells for each artifact. So we can mark 4 coordinates to artifact number and for each artifact number set amount of cells needed to be dug.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        cells = {}\\n        artMap = {}\\n\\n        for i in range(len(artifacts)):\\n            x1, y1, x2, y2 = artifacts[i]\\n            cells[i] = (x2 - x1 + 1) * (y2 - y1 + 1)\\n\\n            for j in range(x1, x2 + 1):\\n                for k in range(y1, y2 + 1):\\n                    artMap[(j, k)] = i\\n\\n        result = 0\\n        for x, y in dig:\\n            if (x, y) in artMap:\\n                cells[artMap[(x, y)]] -= 1\\n                if cells[artMap[(x, y)]] == 0:\\n                    result += 1\\n\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        cells = {}\\n        artMap = {}\\n\\n        for i in range(len(artifacts)):\\n            x1, y1, x2, y2 = artifacts[i]\\n            cells[i] = (x2 - x1 + 1) * (y2 - y1 + 1)\\n\\n            for j in range(x1, x2 + 1):\\n                for k in range(y1, y2 + 1):\\n                    artMap[(j, k)] = i\\n\\n        result = 0\\n        for x, y in dig:\\n            if (x, y) in artMap:\\n                cells[artMap[(x, y)]] -= 1\\n                if cells[artMap[(x, y)]] == 0:\\n                    result += 1\\n\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812672,
                "title": "golang-record-the-digged-cells",
                "content": "```go\\nfunc digArtifacts(n int, artifacts [][]int, dig [][]int) int {\\n  digged := make([][]bool, n)\\n  for i := 0; i < n; i++ {\\n    digged[i] = make([]bool, n)\\n  }\\n  for _, d := range dig {\\n    digged[d[0]][d[1]] = true\\n  }\\n  var res int\\n  for _, artifact := range artifacts {\\n    covered := true\\n    for i := artifact[0]; i <= artifact[2]; i++ {\\n      for j := artifact[1]; j <= artifact[3]; j++ {\\n        if !digged[i][j] {\\n          covered = false\\n          break\\n        }\\n      }\\n    }\\n    if covered {\\n      res++\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc digArtifacts(n int, artifacts [][]int, dig [][]int) int {\\n  digged := make([][]bool, n)\\n  for i := 0; i < n; i++ {\\n    digged[i] = make([]bool, n)\\n  }\\n  for _, d := range dig {\\n    digged[d[0]][d[1]] = true\\n  }\\n  var res int\\n  for _, artifact := range artifacts {\\n    covered := true\\n    for i := artifact[0]; i <= artifact[2]; i++ {\\n      for j := artifact[1]; j <= artifact[3]; j++ {\\n        if !digged[i][j] {\\n          covered = false\\n          break\\n        }\\n      }\\n    }\\n    if covered {\\n      res++\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2799308,
                "title": "c-easy-understanding-straight-forward",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n    \\n        map<pair<int,int>,int> mp;\\n        for(auto  it : dig)\\n        {\\n            mp[{it[0],it[1]}]++;\\n        }\\n        int ans = 0;\\n        for(auto arr : artifacts)\\n        {\\n            int r= arr[0];\\n            int c = arr[1];\\n            int n = arr[2];\\n            int m = arr[3];\\n            int flag = 1;\\n            for(int i=r;i<=n && flag;i++)\\n            {\\n                for(int j=c;j<=m && flag;j++)\\n                {\\n                    if(mp[{i,j}] == 0)\\n                    {\\n                        // cout<<i<<\" \"<<j<<endl;\\n                        flag = 0;\\n                        break;\\n                    }\\n                }\\n            }    \\n            if(flag)\\n            {\\n                ans++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n    \\n        map<pair<int,int>,int> mp;\\n        for(auto  it : dig)\\n        {\\n            mp[{it[0],it[1]}]++;\\n        }\\n        int ans = 0;\\n        for(auto arr : artifacts)\\n        {\\n            int r= arr[0];\\n            int c = arr[1];\\n            int n = arr[2];\\n            int m = arr[3];\\n            int flag = 1;\\n            for(int i=r;i<=n && flag;i++)\\n            {\\n                for(int j=c;j<=m && flag;j++)\\n                {\\n                    if(mp[{i,j}] == 0)\\n                    {\\n                        // cout<<i<<\" \"<<j<<endl;\\n                        flag = 0;\\n                        break;\\n                    }\\n                }\\n            }    \\n            if(flag)\\n            {\\n                ans++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2783729,
                "title": "c",
                "content": "Runtime: 500 ms, faster than 100.00% of C online submissions for Count Artifacts That Can Be Extracted.\\nMemory Usage: 47.1 MB, less than 100.00% of C online submissions for Count Artifacts That Can Be Extracted.\\n```\\nint digArtifacts(int n, int** artifacts, int artifactsSize, int* artifactsColSize, int** dig, int digSize, int* digColSize){\\n    bool** table = malloc(n * sizeof(bool*));\\n    for(int i = 0; i < n; i++){\\n        table[i] = calloc(n , sizeof(bool));\\n    }\\n    \\n    for(int i = 0; i < digSize; i++){\\n        int r = dig[i][0];\\n        int c = dig[i][1];\\n        table[r][c] = true;\\n    }\\n\\n    int ans = 0; \\n    for(int i = 0; i < artifactsSize; i++){\\n        int r1 = artifacts[i][0];\\n        int c1 = artifacts[i][1];\\n        int r2 = artifacts[i][2];\\n        int c2 = artifacts[i][3];\\n        ans++;\\n        for(int m = r1; m <= r2; m++){\\n            for(int n = c1; n <= c2; n++){\\n                if(table[m][n] == false)  {\\n                    ans--;\\n                    goto next;\\n                }  \\n            }\\n        }\\n        next:\\n            continue;\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint digArtifacts(int n, int** artifacts, int artifactsSize, int* artifactsColSize, int** dig, int digSize, int* digColSize){\\n    bool** table = malloc(n * sizeof(bool*));\\n    for(int i = 0; i < n; i++){\\n        table[i] = calloc(n , sizeof(bool));\\n    }\\n    \\n    for(int i = 0; i < digSize; i++){\\n        int r = dig[i][0];\\n        int c = dig[i][1];\\n        table[r][c] = true;\\n    }\\n\\n    int ans = 0; \\n    for(int i = 0; i < artifactsSize; i++){\\n        int r1 = artifacts[i][0];\\n        int c1 = artifacts[i][1];\\n        int r2 = artifacts[i][2];\\n        int c2 = artifacts[i][3];\\n        ans++;\\n        for(int m = r1; m <= r2; m++){\\n            for(int n = c1; n <= c2; n++){\\n                if(table[m][n] == false)  {\\n                    ans--;\\n                    goto next;\\n                }  \\n            }\\n        }\\n        next:\\n            continue;\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782893,
                "title": "c-simple-solution-1d-boolean-array",
                "content": "```\\nint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        bool dig1D[n*n];\\n        memset(dig1D, false, (n*n)*sizeof(bool));\\n        for(int i=0; i<dig.size(); i++)\\n            dig1D[dig[i][0]*n+dig[i][1]] = true;\\n        int ans = 0; bool allDigged;\\n        for(int k=0; k<artifacts.size(); k++) {\\n            allDigged = true;\\n            for(int i=artifacts[k][0]; allDigged && i<=artifacts[k][2]; i++)\\n                for(int j=artifacts[k][1]; allDigged && j<=artifacts[k][3]; j++)\\n                    if(!dig1D[i*n+j])\\n                        allDigged = false;\\n            if(allDigged)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        bool dig1D[n*n];\\n        memset(dig1D, false, (n*n)*sizeof(bool));\\n        for(int i=0; i<dig.size(); i++)\\n            dig1D[dig[i][0]*n+dig[i][1]] = true;\\n        int ans = 0; bool allDigged;\\n        for(int k=0; k<artifacts.size(); k++) {\\n            allDigged = true;\\n            for(int i=artifacts[k][0]; allDigged && i<=artifacts[k][2]; i++)\\n                for(int j=artifacts[k][1]; allDigged && j<=artifacts[k][3]; j++)\\n                    if(!dig1D[i*n+j])\\n                        allDigged = false;\\n            if(allDigged)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782877,
                "title": "c-simple-solution-submatrix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        int mat[n+1][n+1];\\n        memset(mat, 0, (n+1)*(n+1)*sizeof(int));\\n        for(int i=0; i<dig.size(); i++)\\n            mat[dig[i][0]+1][dig[i][1]+1] = 1;\\n        for(int i=1; i<=n; i++)\\n            for(int j=1; j<=n; j++)\\n                mat[i][j] += mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1];\\n        int ans = 0, i1,j1,i2,j2;\\n        for(int i=0; i<artifacts.size(); i++) {\\n            i1 = artifacts[i][0]+1; j1 = artifacts[i][1]+1;\\n            i2 = artifacts[i][2]+1; j2 = artifacts[i][3]+1;\\n            if(mat[i2][j2]-mat[i2][j1-1]-mat[i1-1][j2]+mat[i1-1][j1-1] ==\\n               (i2-i1+1)*(j2-j1+1)) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        int mat[n+1][n+1];\\n        memset(mat, 0, (n+1)*(n+1)*sizeof(int));\\n        for(int i=0; i<dig.size(); i++)\\n            mat[dig[i][0]+1][dig[i][1]+1] = 1;\\n        for(int i=1; i<=n; i++)\\n            for(int j=1; j<=n; j++)\\n                mat[i][j] += mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1];\\n        int ans = 0, i1,j1,i2,j2;\\n        for(int i=0; i<artifacts.size(); i++) {\\n            i1 = artifacts[i][0]+1; j1 = artifacts[i][1]+1;\\n            i2 = artifacts[i][2]+1; j2 = artifacts[i][3]+1;\\n            if(mat[i2][j2]-mat[i2][j1-1]-mat[i1-1][j2]+mat[i1-1][j1-1] ==\\n               (i2-i1+1)*(j2-j1+1)) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778865,
                "title": "c-dfs",
                "content": "```\\n    //nothing: 0, digged: -val, undigged: val\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        auto vv = vector(n, vector(n, 0));\\n        for(int k=0;k<artifacts.size();k++) {\\n            auto& ar = artifacts[k];\\n            for(int i=ar[0]; i<=ar[2]; i++) for(int j=ar[1];j<=ar[3];j++) vv[i][j] = k+1;\\n        }\\n        for(auto& d:dig) vv[d[0]][d[1]] *= -1;\\n        \\n        int res = 0;\\n        for(int i=0;i<n;i++) for(int j=0;j<n;j++)\\n            if(vv[i][j] != 0) res += dfs(vv, i, j, abs(vv[i][j]), n);                \\n        return res;\\n    }\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j, int val, int n){\\n        static const vector<pair<int,int>> dirs = {{0,1},{0,-1},{-1,0},{1,0}};\\n        if(grid[i][j] == val) return false;\\n        grid[i][j] = 0;\\n        bool res = true;\\n        for(auto [di, dj] : dirs){\\n            int x = i+di, y = j+dj;\\n            if(x<0 || x==n || y<0 || y==n || abs(grid[x][y]) != val) continue;\\n            res &= dfs(grid, x, y, val, n);\\n        }        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    //nothing: 0, digged: -val, undigged: val\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        auto vv = vector(n, vector(n, 0));\\n        for(int k=0;k<artifacts.size();k++) {\\n            auto& ar = artifacts[k];\\n            for(int i=ar[0]; i<=ar[2]; i++) for(int j=ar[1];j<=ar[3];j++) vv[i][j] = k+1;\\n        }\\n        for(auto& d:dig) vv[d[0]][d[1]] *= -1;\\n        \\n        int res = 0;\\n        for(int i=0;i<n;i++) for(int j=0;j<n;j++)\\n            if(vv[i][j] != 0) res += dfs(vv, i, j, abs(vv[i][j]), n);                \\n        return res;\\n    }\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j, int val, int n){\\n        static const vector<pair<int,int>> dirs = {{0,1},{0,-1},{-1,0},{1,0}};\\n        if(grid[i][j] == val) return false;\\n        grid[i][j] = 0;\\n        bool res = true;\\n        for(auto [di, dj] : dirs){\\n            int x = i+di, y = j+dj;\\n            if(x<0 || x==n || y<0 || y==n || abs(grid[x][y]) != val) continue;\\n            res &= dfs(grid, x, y, val, n);\\n        }        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2719747,
                "title": "short-scala-solution",
                "content": "```scala\\n  def digArtifacts(n: Int, artifacts: Array[Array[Int]], dig: Array[Array[Int]]): Int = {\\n    val set = dig.map(d => d(0) -> d(1)).toSet\\n    artifacts.count{case Array(r1, c1, r2, c2) => \\n      (r1 to r2).forall{r=> (c1 to c2).forall{c=>  set.contains((r,c)) }}}\\n  }\\n```",
                "solutionTags": [
                    "Scala",
                    "Ordered Set"
                ],
                "code": "```scala\\n  def digArtifacts(n: Int, artifacts: Array[Array[Int]], dig: Array[Array[Int]]): Int = {\\n    val set = dig.map(d => d(0) -> d(1)).toSet\\n    artifacts.count{case Array(r1, c1, r2, c2) => \\n      (r1 to r2).forall{r=> (c1 to c2).forall{c=>  set.contains((r,c)) }}}\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2677553,
                "title": "c-bfs",
                "content": "\"\\'\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& art, vector<vector<int>>& dig) {\\n     vector<vector<int>> check(n+1,vector<int> (n+1,0));\\n        for(int i=0;i<dig.size();i++){\\n            check[dig[i][0]][dig[i][1]]=1;\\n            \\n        }\\n        typedef pair<pair<int,int>,pair<int,int> > pi;\\n        queue<pi> q1;\\n        pair<int,int> start,end;\\n        for(int i=0;i<art.size();i++){\\n             start=make_pair(art[i][0],art[i][1]);\\n              end=make_pair(art[i][2],art[i][3]);\\n              q1.push(make_pair(start,end));\\n            \\n        }\\n        int row[2]={1,0};\\n        int col[2]={0,1};\\n        int count=0;\\n        \\n        while(!q1.empty()){\\n            pi temp=q1.front();\\n            pair<int,int> start=temp.first;\\n            pair<int,int> end =temp.second;\\n            q1.pop();\\n            int flag=0;\\n    \\n            if(check[start.first][start.second]==1){\\n            queue<pair<int,int>> q2;\\n                q2.push(make_pair(start.first,start.second));\\n                while(!q2.empty()){\\n                   pair<int,int> temp=q2.front();\\n                    q2.pop();\\n                for(int i=0;i<2;i++){\\n                int move_x=temp.first + row[i];\\n                int move_y=temp.second + col[i];\\n                if(move_x>=start.first && move_x<=end.first && move_x<n && move_y>=start.second && move_y<=end.second && move_y<n){\\n                    if(check[move_x][move_y]!=1){\\n                        flag=1;\\n                        break;\\n                    }\\n                    q2.push(make_pair(move_x,move_y));\\n                    \\n                }\\n                \\n            }\\n                    if(flag==1){\\n                        break;\\n                    }\\n                    \\n                }\\n                if(flag==0){\\n                    count++;\\n                }\\n            \\n        }\\n        }\\n        \\n        return count;\\n        \\n        \\n        \\n     \\n        \\n    }\\n};\\n\"\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& art, vector<vector<int>>& dig) {\\n     vector<vector<int>> check(n+1,vector<int> (n+1,0));\\n        for(int i=0;i<dig.size();i++){\\n            check[dig[i][0]][dig[i][1]]=1;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2621587,
                "title": "typescript-100",
                "content": "```\\nfunction digArtifacts(n: number, artifacts: number[][], dig: number[][]): number {\\n    \\n    let s = new Set();\\n    \\n    for(let d of dig) {\\n        let pos = d[0]*n+d[1];\\n        s.add(pos);   \\n    }\\n    \\n    let result = 0;\\n    for(let artifact of artifacts) {\\n        let extracted = true;\\n        \\n        \\n        for(let i=artifact[0]; i<=artifact[2]; i++) {\\n            for(let j=artifact[1]; j<=artifact[3]; j++) {\\n                let pos = i*n+j;\\n                if(!s.has(pos)) {\\n                    extracted = false;\\n                }\\n            }\\n        }\\n        if(extracted) {\\n            result++;\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3f709be4-c224-4626-a306-57ec7a710724_1664089245.1006455.png)\\n",
                "solutionTags": [],
                "code": "```\\nfunction digArtifacts(n: number, artifacts: number[][], dig: number[][]): number {\\n    \\n    let s = new Set();\\n    \\n    for(let d of dig) {\\n        let pos = d[0]*n+d[1];\\n        s.add(pos);   \\n    }\\n    \\n    let result = 0;\\n    for(let artifact of artifacts) {\\n        let extracted = true;\\n        \\n        \\n        for(let i=artifact[0]; i<=artifact[2]; i++) {\\n            for(let j=artifact[1]; j<=artifact[3]; j++) {\\n                let pos = i*n+j;\\n                if(!s.has(pos)) {\\n                    extracted = false;\\n                }\\n            }\\n        }\\n        if(extracted) {\\n            result++;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2606465,
                "title": "python-grid-index-better-than-97-time-and-size",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        num_artifacts = len(artifacts)\\n        art_count = [0] * num_artifacts\\n        art_grid = [[-1] * n for _ in range(n)]\\n        for art_id, (tr, lc, br, rc) in enumerate(artifacts):\\n            br += 1\\n            rc += 1\\n            art_count[art_id] = (br - tr) * (rc - lc)\\n            for r in range(tr, br):\\n                for c in range(lc, rc):\\n                    art_grid[r][c] = art_id\\n        \\n        dug_artifacts = 0\\n        for r, c in dig:\\n            art_id = art_grid[r][c]\\n            if art_id != -1:\\n                art_count[art_id] -= 1\\n                if art_count[art_id] == 0:\\n                    dug_artifacts += 1\\n        return dug_artifacts\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        num_artifacts = len(artifacts)\\n        art_count = [0] * num_artifacts\\n        art_grid = [[-1] * n for _ in range(n)]\\n        for art_id, (tr, lc, br, rc) in enumerate(artifacts):\\n            br += 1\\n            rc += 1\\n            art_count[art_id] = (br - tr) * (rc - lc)\\n            for r in range(tr, br):\\n                for c in range(lc, rc):\\n                    art_grid[r][c] = art_id\\n        \\n        dug_artifacts = 0\\n        for r, c in dig:\\n            art_id = art_grid[r][c]\\n            if art_id != -1:\\n                art_count[art_id] -= 1\\n                if art_count[art_id] == 0:\\n                    dug_artifacts += 1\\n        return dug_artifacts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544451,
                "title": "c-hashset",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dig) {\\n\\t\\t\\tset<pair<int,int>> st;\\n\\t\\t\\tint res=0;\\n\\t\\t\\tfor(int i=0;i<dig.size();i++) st.insert({dig[i][0],dig[i][1]});\\n\\t\\t\\tfor(int i=0;i<a.size();i++) {\\n\\t\\t\\t\\tint f=0;\\n\\t\\t\\t\\tfor(int j=a[i][0];j<=a[i][2];j++){\\n\\t\\t\\t\\t\\tfor(int k=a[i][1];k<=a[i][3];k++) {\\n\\t\\t\\t\\t\\t\\tif(!st.count({j,k})) {\\n\\t\\t\\t\\t\\t\\t\\tf=1;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(f==1) break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres+=!f;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dig) {\\n\\t\\t\\tset<pair<int,int>> st;\\n\\t\\t\\tint res=0;\\n\\t\\t\\tfor(int i=0;i<dig.size();i++) st.insert({dig[i][0],dig[i][1]}",
                "codeTag": "Java"
            },
            {
                "id": 2514846,
                "title": "straight-forword-c-solution",
                "content": "```\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>> visited(n, vector<bool>(n, false));\\n        for(auto &d : dig){\\n            visited[d[0]][d[1]] = true;\\n        }\\n        int count = 0;\\n        for(auto &artifact : artifacts){\\n            bool flag = true;\\n            for(int i = artifact[0]; i <= artifact[2] && flag; i++){\\n                for(int j = artifact[1]; j <= artifact[3] && flag; j++){\\n                    if(!visited[i][j]) flag = false;\\n                }\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>> visited(n, vector<bool>(n, false));\\n        for(auto &d : dig){\\n            visited[d[0]][d[1]] = true;\\n        }\\n        int count = 0;\\n        for(auto &artifact : artifacts){\\n            bool flag = true;\\n            for(int i = artifact[0]; i <= artifact[2] && flag; i++){\\n                for(int j = artifact[1]; j <= artifact[3] && flag; j++){\\n                    if(!visited[i][j]) flag = false;\\n                }\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2502707,
                "title": "python-tuple-set-solution",
                "content": "```\\ndef digArtifacts(self, n: int, arts: List[List[int]], dig: List[List[int]]) -> int:\\n\\tans, dig = 0, set([tuple(d) for d in dig])\\n\\tfor r1, c1, r2, c2 in arts:\\n\\t\\tcover = set([(r, c) for r in range(r1, r2+1) for c in range(c1, c2+1)])\\n\\t\\tans += (sum(1 for t in cover if t in dig) == len(cover))\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef digArtifacts(self, n: int, arts: List[List[int]], dig: List[List[int]]) -> int:\\n\\tans, dig = 0, set([tuple(d) for d in dig])\\n\\tfor r1, c1, r2, c2 in arts:\\n\\t\\tcover = set([(r, c) for r in range(r1, r2+1) for c in range(c1, c2+1)])\\n\\t\\tans += (sum(1 for t in cover if t in dig) == len(cover))\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2449725,
                "title": "python-simulation-set",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        # For each artifacts, check if all the boxes are digged\\n        # There can be max four boxes\\n        # row - r1 to r2 \\n        # col - c1 to c2\\n        dig = set((r,c) for r,c in dig)\\n        \\n        count = 0\\n        for r1, c1, r2, c2 in artifacts:\\n            points = set()\\n            for i in range(r1, r2 + 1):\\n                for j in range(c1, c2 + 1):\\n                    points.add((i, j))\\n            \\n            if all([p in dig for p in points]):\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        # For each artifacts, check if all the boxes are digged\\n        # There can be max four boxes\\n        # row - r1 to r2 \\n        # col - c1 to c2\\n        dig = set((r,c) for r,c in dig)\\n        \\n        count = 0\\n        for r1, c1, r2, c2 in artifacts:\\n            points = set()\\n            for i in range(r1, r2 + 1):\\n                for j in range(c1, c2 + 1):\\n                    points.add((i, j))\\n            \\n            if all([p in dig for p in points]):\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437553,
                "title": "c-map-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        int count=0;\\n        map<pair<int,int>,bool>mp;\\n        for(auto u:dig){\\n            mp[{u[0],u[1]}]=true;\\n        }\\n        for(auto u:artifacts){\\n            int i=u[0];\\n            int j=u[1];\\n            int n1=u[2];\\n            int m=u[3];\\n            int flag=1;\\n            for(i=u[0];i<=n1;i++){\\n                for(j=u[1];j<=m;j++){\\n                    // cout<<i<<\" \"<<j<<\"  \";\\n                    if(mp.find({i,j})==mp.end()){\\n                        flag=0;\\n                        break;\\n                    }\\n                }if(flag==0)break;\\n            }\\n            if(flag==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        int count=0;\\n        map<pair<int,int>,bool>mp;\\n        for(auto u:dig){\\n            mp[{u[0],u[1]}]=true;\\n        }\\n        for(auto u:artifacts){\\n            int i=u[0];\\n            int j=u[1];\\n            int n1=u[2];\\n            int m=u[3];\\n            int flag=1;\\n            for(i=u[0];i<=n1;i++){\\n                for(j=u[1];j<=m;j++){\\n                    // cout<<i<<\" \"<<j<<\"  \";\\n                    if(mp.find({i,j})==mp.end()){\\n                        flag=0;\\n                        break;\\n                    }\\n                }if(flag==0)break;\\n            }\\n            if(flag==1)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2249930,
                "title": "intuitive-simulation",
                "content": "```\\nclass Solution {\\n    using Pos = pair<int, int>;\\n    struct Area {\\n        \\n        // vector<Pos> area_;\\n        int total_tiles_ {0};\\n        int digged_ {0};\\n        bool uncovered() const { return digged_ >= total_tiles_; }\\n    };\\n    \\npublic:\\n    \\n    vector<Area> areas_;\\n    map<Pos, int> pos_to_areas_;\\n    \\n    void make_area(const vector<int>& artifact) {\\n        int top_x = artifact[0];\\n        int top_y = artifact[1];\\n        int bottom_x = artifact[2];\\n        int bottom_y = artifact[3];\\n        \\n        Area a;\\n        int idx = areas_.size();\\n        for (int i = top_x; i <= bottom_x; ++i) {\\n            for (int j = top_y; j <= bottom_y; ++j) {\\n                // a.area_.push_back({i, j});\\n                a.total_tiles_++;\\n                pos_to_areas_.insert({{i, j}, idx});\\n            }\\n        }\\n        areas_.push_back(a);\\n    }\\n    \\n    void dig_pos(const vector<int>& pos) {\\n        auto x = pos[0];\\n        auto y = pos[1];\\n        Pos p = {x, y};\\n        if (pos_to_areas_.find(p) == pos_to_areas_.end())\\n            return ;\\n        areas_[pos_to_areas_[p]].digged_++;\\n    }\\n    \\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        for (auto& a : artifacts) {\\n            make_area(a);\\n        }\\n        \\n        for (auto& d : dig) {\\n            dig_pos(d);\\n        }\\n        \\n        return accumulate(areas_.begin(), areas_.end(), 0, [](int summ, const Area& a) {\\n            return summ + a.uncovered();\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    using Pos = pair<int, int>;\\n    struct Area {\\n        \\n        // vector<Pos> area_;\\n        int total_tiles_ {0};\\n        int digged_ {0};\\n        bool uncovered() const { return digged_ >= total_tiles_; }\\n    };\\n    \\npublic:\\n    \\n    vector<Area> areas_;\\n    map<Pos, int> pos_to_areas_;\\n    \\n    void make_area(const vector<int>& artifact) {\\n        int top_x = artifact[0];\\n        int top_y = artifact[1];\\n        int bottom_x = artifact[2];\\n        int bottom_y = artifact[3];\\n        \\n        Area a;\\n        int idx = areas_.size();\\n        for (int i = top_x; i <= bottom_x; ++i) {\\n            for (int j = top_y; j <= bottom_y; ++j) {\\n                // a.area_.push_back({i, j});\\n                a.total_tiles_++;\\n                pos_to_areas_.insert({{i, j}, idx});\\n            }\\n        }\\n        areas_.push_back(a);\\n    }\\n    \\n    void dig_pos(const vector<int>& pos) {\\n        auto x = pos[0];\\n        auto y = pos[1];\\n        Pos p = {x, y};\\n        if (pos_to_areas_.find(p) == pos_to_areas_.end())\\n            return ;\\n        areas_[pos_to_areas_[p]].digged_++;\\n    }\\n    \\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        for (auto& a : artifacts) {\\n            make_area(a);\\n        }\\n        \\n        for (auto& d : dig) {\\n            dig_pos(d);\\n        }\\n        \\n        return accumulate(areas_.begin(), areas_.end(), 0, [](int summ, const Area& a) {\\n            return summ + a.uncovered();\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218537,
                "title": "c-set-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& arr, vector<vector<int>>& dig) {\\n        set<vector<int>>digPos;\\n        int count=0;\\n        for(int i=0;i<dig.size();i++){\\n            digPos.insert(dig[i]);\\n        }\\n        \\n        for(int i=0;i<arr.size();i++){\\n            int r1 = arr[i][0];\\n            int c1 = arr[i][1];\\n            int r2 = arr[i][2];\\n            int c2 = arr[i][3];\\n            \\n            int flag=0;\\n            \\n            for(int row = r1;row<=r2;row++){\\n                for(int col = c1;col<=c2;col++){\\n                    if(digPos.find({row, col}) == digPos.end()){\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if(flag==0){\\n                ++count;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& arr, vector<vector<int>>& dig) {\\n        set<vector<int>>digPos;\\n        int count=0;\\n        for(int i=0;i<dig.size();i++){\\n            digPos.insert(dig[i]);\\n        }\\n        \\n        for(int i=0;i<arr.size();i++){\\n            int r1 = arr[i][0];\\n            int c1 = arr[i][1];\\n            int r2 = arr[i][2];\\n            int c2 = arr[i][3];\\n            \\n            int flag=0;\\n            \\n            for(int row = r1;row<=r2;row++){\\n                for(int col = c1;col<=c2;col++){\\n                    if(digPos.find({row, col}) == digPos.end()){\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if(flag==0){\\n                ++count;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208694,
                "title": "javascript-using-set",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} artifacts\\n * @param {number[][]} dig\\n * @return {number}\\n */\\nvar digArtifacts = function(n, artifacts, dig) {\\n    const digSet = new Set()\\n    for (const d of dig) {\\n        digSet.add(d.join(\\'-\\'))\\n    }\\n    \\n    \\n    let result = 0\\n    forEachArt:\\n    for (const art of artifacts.values()) {\\n        const [iA, jA, iB, jB] = art\\n        for (let i = iA; i <= iB; i++) {\\n            for (let j = jA; j <= jB; j++) {\\n                const position = [i, j].join(\\'-\\')\\n                if (!digSet.has(position))\\n                    continue forEachArt\\n            }\\n        }\\n        \\n        result++\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} artifacts\\n * @param {number[][]} dig\\n * @return {number}\\n */\\nvar digArtifacts = function(n, artifacts, dig) {\\n    const digSet = new Set()\\n    for (const d of dig) {\\n        digSet.add(d.join(\\'-\\'))\\n    }\\n    \\n    \\n    let result = 0\\n    forEachArt:\\n    for (const art of artifacts.values()) {\\n        const [iA, jA, iB, jB] = art\\n        for (let i = iA; i <= iB; i++) {\\n            for (let j = jA; j <= jB; j++) {\\n                const position = [i, j].join(\\'-\\')\\n                if (!digSet.has(position))\\n                    continue forEachArt\\n            }\\n        }\\n        \\n        result++\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2205084,
                "title": "java-easy-approach-with-explanation",
                "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int [][]land= new int[n][n];// \"1\" - indicates diging done at that cell // \"0\" - indicates no diging done at that cell\\n        \\n        for (int []coord: dig) {\\n              int digg_r= coord[0];             \\n              int digg_c= coord[1];                 \\n            \\n               //Digging Done at this current cell      \\n               land[ digg_r][ digg_c]= 1;\\n         }\\n        \\n         int noOfArtifactDiscovered= 0;\\n         \\n         for (int []row: artifacts) {\\n             \\n              int r1= row[0], c1= row[1];//Top Left \\n              int r2= row[2], c2= row[3];//Bottom Right\\n             \\n              boolean artifactDiscovered= true;\\n             \\n              for (int col= c1; col <= c2; col++) {\\n                  for ( int ro=r1; ro<=r2; ro++ ) {\\n                      \\n                      if ( land[ro][col] == 0){//Undiscovered artifact cell\\n                           artifactDiscovered= false;\\n                           break;\\n                      }\\n                  }\\n                  if (!artifactDiscovered ) \\n                      break;\\n              }\\n              if (artifactDiscovered) {//all cell for the particular arifact is discovered \\n                  noOfArtifactDiscovered+= 1;\\n             }\\n         }\\n         \\n         return noOfArtifactDiscovered;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int [][]land= new int[n][n];// \"1\" - indicates diging done at that cell // \"0\" - indicates no diging done at that cell\\n        \\n        for (int []coord: dig) {\\n              int digg_r= coord[0];             \\n              int digg_c= coord[1];                 \\n            \\n               //Digging Done at this current cell      \\n               land[ digg_r][ digg_c]= 1;\\n         }\\n        \\n         int noOfArtifactDiscovered= 0;\\n         \\n         for (int []row: artifacts) {\\n             \\n              int r1= row[0], c1= row[1];//Top Left \\n              int r2= row[2], c2= row[3];//Bottom Right\\n             \\n              boolean artifactDiscovered= true;\\n             \\n              for (int col= c1; col <= c2; col++) {\\n                  for ( int ro=r1; ro<=r2; ro++ ) {\\n                      \\n                      if ( land[ro][col] == 0){//Undiscovered artifact cell\\n                           artifactDiscovered= false;\\n                           break;\\n                      }\\n                  }\\n                  if (!artifactDiscovered ) \\n                      break;\\n              }\\n              if (artifactDiscovered) {//all cell for the particular arifact is discovered \\n                  noOfArtifactDiscovered+= 1;\\n             }\\n         }\\n         \\n         return noOfArtifactDiscovered;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204823,
                "title": "c-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> digged(n, vector<int>(n,0));\\n        \\n        for(int i=0;i<dig.size();i++){\\n            digged[dig[i][0]][dig[i][1]]=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<artifacts.size();i++){\\n            int rst=artifacts[i][0], cst=artifacts[i][1], rend=artifacts[i][2], \\n                 cend=artifacts[i][3];\\n            \\n            int f=0;\\n            for(int x=rst;x<=rend;x++){\\n                for(int y=cst;y<=cend;y++){\\n                    if(digged[x][y]==0){\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(f==0) ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nDigged array shows where we have already digged. for a given artifacts, we check all the cells for a given artifact and if any of it\\'s cell is not digged by us, we don\\'t count that artifact.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> digged(n, vector<int>(n,0));\\n        \\n        for(int i=0;i<dig.size();i++){\\n            digged[dig[i][0]][dig[i][1]]=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<artifacts.size();i++){\\n            int rst=artifacts[i][0], cst=artifacts[i][1], rend=artifacts[i][2], \\n                 cend=artifacts[i][3];\\n            \\n            int f=0;\\n            for(int x=rst;x<=rend;x++){\\n                for(int y=cst;y<=cend;y++){\\n                    if(digged[x][y]==0){\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(f==0) ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192774,
                "title": "python-solution-dictionary-and-sets",
                "content": "```\\n def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        artDict = {}\\n        for i in range(len(artifacts)):\\n            artDict[i] = []\\n            for row in range(artifacts[i][0], artifacts[i][2]+1):\\n                for col in range(artifacts[i][1], artifacts[i][3]+1):\\n                    artDict[i] += [(row, col)]\\n        \\n        digarray = set()\\n        for i in range(len(dig)):\\n            digarray.add((dig[i][0], dig[i][1]))\\n            \\n        #print( artDict, digarray)\\n        count = 0\\n        for k, v in artDict.items():\\n            if len(set(v).intersection(digarray) ) == len(v):\\n                count+=1\\n                \\n        return count",
                "solutionTags": [],
                "code": "```\\n def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        artDict = {}\\n        for i in range(len(artifacts)):\\n            artDict[i] = []\\n            for row in range(artifacts[i][0], artifacts[i][2]+1):\\n                for col in range(artifacts[i][1], artifacts[i][3]+1):\\n                    artDict[i] += [(row, col)]\\n        \\n        digarray = set()\\n        for i in range(len(dig)):\\n            digarray.add((dig[i][0], dig[i][1]))\\n            \\n        #print( artDict, digarray)\\n        count = 0\\n        for k, v in artDict.items():\\n            if len(set(v).intersection(digarray) ) == len(v):\\n                count+=1\\n                \\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 2187467,
                "title": "the-easiest-c-solution-linear-time",
                "content": "\\nclass Solution {\\npublic:\\n    unordered_set<int> digged;\\n    int size=0;\\n    int getid(int r,int c)\\n    {\\n        return r*size+c;\\n    }\\n\\n    bool check(vector<int>& v)\\n    {\\n        int sr=v[0];\\n        int sc=v[1];\\n        int er=v[2];\\n        int ec=v[3];\\n\\n        for(int i=sr;i<=er;i++)\\n        {\\n            for(int j=sc;j<=ec;j++)\\n            {\\n                if(!digged.count(getid(i,j)))\\n                    return false;\\n            }\\n        }\\n\\n        return true;\\n}\\n\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        \\n        \\n        size=n;\\n\\n        for(auto& vec:dig)\\n            digged.insert(getid(vec[0],vec[1]));\\n\\n\\n        int res=0;\\n\\n        for(auto& vec:artifacts)\\n        {\\n            if(check(vec))\\n                res++;\\n        }  \\n\\n        return res; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_set<int> digged;\\n    int size=0;\\n    int getid(int r,int c)\\n    {\\n        return r*size+c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2177928,
                "title": "c-matrix-brute-force-t-c-o-n2-s-c-o-n2",
                "content": "**Just Mark The Digging points of a boolean matrix and check if the artifact subgrid has all ones in that boolean matrix**\\n\\n```\\nclass Solution {\\npublic:\\n    bool F(vector<int>& art,vector<vector<bool>>& arr){\\n        int r1 = art[0];\\n        int c1 = art[1];\\n        int r2 = art[2];\\n        int c2 = art[3];\\n        \\n        for(int i = r1;i<=r2;i++){\\n            for(int j = c1;j<=c2;j++){\\n                if(arr[i][j] == 0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int digArtifacts(int n, vector<vector<int>>& art, vector<vector<int>>& dig) {\\n        vector<vector<bool>> arr(n,vector<bool>(n,0));\\n        int ans = 0;\\n        for(int i=0;i<dig.size();i++){\\n            arr[dig[i][0]][dig[i][1]] = 1;\\n        }\\n        for(int i=0;i<art.size();i++){\\n            vector<int> temp = art[i];\\n            if(F(art[i],arr)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool F(vector<int>& art,vector<vector<bool>>& arr){\\n        int r1 = art[0];\\n        int c1 = art[1];\\n        int r2 = art[2];\\n        int c2 = art[3];\\n        \\n        for(int i = r1;i<=r2;i++){\\n            for(int j = c1;j<=c2;j++){\\n                if(arr[i][j] == 0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int digArtifacts(int n, vector<vector<int>>& art, vector<vector<int>>& dig) {\\n        vector<vector<bool>> arr(n,vector<bool>(n,0));\\n        int ans = 0;\\n        for(int i=0;i<dig.size();i++){\\n            arr[dig[i][0]][dig[i][1]] = 1;\\n        }\\n        for(int i=0;i<art.size();i++){\\n            vector<int> temp = art[i];\\n            if(F(art[i],arr)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114585,
                "title": "javascript-solution-set",
                "content": "```\\nvar digArtifacts = function(n, artifacts, dig) {\\n    const set = new Set();\\n    \\n    for (const [row, col] of dig) {\\n        set.add(getCoord(row, col));\\n    }\\n    \\n    let count = 0;\\n    \\n    for (let i = 0; i < artifacts.length; ++i) {\\n        const [startRow, startCol, endRow, endCol] = artifacts[i];\\n        \\n        let extracted = true;\\n        \\n        for (let row = startRow; row <= endRow; ++row) {\\n            for (let col = startCol; col <= endCol; ++col) {\\n                const coord = getCoord(row, col);        \\n        \\n                if (!set.has(coord)) {\\n                    extracted = false;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (extracted) ++count;\\n        \\n    }\\n    \\n    return count;\\n    \\n    function getCoord(row, col) {\\n        return `${row}#${col}`;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar digArtifacts = function(n, artifacts, dig) {\\n    const set = new Set();\\n    \\n    for (const [row, col] of dig) {\\n        set.add(getCoord(row, col));\\n    }\\n    \\n    let count = 0;\\n    \\n    for (let i = 0; i < artifacts.length; ++i) {\\n        const [startRow, startCol, endRow, endCol] = artifacts[i];\\n        \\n        let extracted = true;\\n        \\n        for (let row = startRow; row <= endRow; ++row) {\\n            for (let col = startCol; col <= endCol; ++col) {\\n                const coord = getCoord(row, col);        \\n        \\n                if (!set.has(coord)) {\\n                    extracted = false;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (extracted) ++count;\\n        \\n    }\\n    \\n    return count;\\n    \\n    function getCoord(row, col) {\\n        return `${row}#${col}`;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2058329,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int[] left = new int[artifacts.length];\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < artifacts.length; i++) {\\n            int[] a = artifacts[i];\\n            for (int r = a[0]; r <= a[2]; r++) {\\n                for (int c = a[1]; c <= a[3]; c++) {\\n                    String key = r + \",\" + c;\\n                    left[i]++;\\n                    map.put(key, i);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int[] d : dig) {\\n            String key = d[0] + \",\" + d[1];\\n            if (map.containsKey(key)) {\\n                left[map.get(key)]--;\\n                if (left[map.get(key)] == 0) res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int[] left = new int[artifacts.length];\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < artifacts.length; i++) {\\n            int[] a = artifacts[i];\\n            for (int r = a[0]; r <= a[2]; r++) {\\n                for (int c = a[1]; c <= a[3]; c++) {\\n                    String key = r + \",\" + c;\\n                    left[i]++;\\n                    map.put(key, i);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int[] d : dig) {\\n            String key = d[0] + \",\" + d[1];\\n            if (map.containsKey(key)) {\\n                left[map.get(key)]--;\\n                if (left[map.get(key)] == 0) res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014470,
                "title": "python3-hashmap-solution",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n      counter = 0\\n      dicts = {}\\n      for a,b,c,d in artifacts:\\n        for t in range(a, c+1):\\n          for k in range(b, d+1):\\n            dicts[(t,k)] = counter\\n        counter += 1\\n      \\n      for a,b in dig:\\n        if (a,b) in dicts:\\n          del dicts[(a,b)]\\n          \\n      remain = set()\\n      for value in dicts.values():\\n        remain.add(value)\\n                  \\n      return len(artifacts) - len(remain)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n      counter = 0\\n      dicts = {}\\n      for a,b,c,d in artifacts:\\n        for t in range(a, c+1):\\n          for k in range(b, d+1):\\n            dicts[(t,k)] = counter\\n        counter += 1\\n      \\n      for a,b in dig:\\n        if (a,b) in dicts:\\n          del dicts[(a,b)]\\n          \\n      remain = set()\\n      for value in dicts.values():\\n        remain.add(value)\\n                  \\n      return len(artifacts) - len(remain)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995281,
                "title": "python-faster-than-81-of-other-submissions",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifact: List[List[int]], dig: List[List[int]]) -> int:\\n        dig_set = set()\\n        for i in dig:\\n            dig_set.add(tuple(i))\\n            \\n        count = 0\\n        for afact in artifact:\\n            flag = True\\n            r1,c1,r2,c2 = afact\\n            for i in range(r1,r2+1):\\n                for j in range(c1,c2+1):\\n                    if (i,j) not in dig_set:\\n                        flag = False\\n                        break\\n                        \\n            if(flag == True):\\n                count += 1\\n                \\n        return count",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifact: List[List[int]], dig: List[List[int]]) -> int:\\n        dig_set = set()\\n        for i in dig:\\n            dig_set.add(tuple(i))\\n            \\n        count = 0\\n        for afact in artifact:\\n            flag = True\\n            r1,c1,r2,c2 = afact\\n            for i in range(r1,r2+1):\\n                for j in range(c1,c2+1):\\n                    if (i,j) not in dig_set:\\n                        flag = False\\n                        break\\n                        \\n            if(flag == True):\\n                count += 1\\n                \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1929042,
                "title": "python-if-part-of-artifacts-not-digged-pass",
                "content": "```python\\nclass Solution(object):\\n    def digArtifacts(self, n, artifacts, dig):\\n        \"\"\"\\n        :type n: int\\n        :type artifacts: List[List[int]]\\n        :type dig: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d_set = set([(x, y) for x, y in dig])\\n        res = 0\\n        \\n        for r1, c1, r2, c2 in artifacts:\\n            has = True\\n            r = r1\\n            while r <= r2 and has:\\n                c = c1\\n                while c <= c2 and has:\\n                    if (r, c) not in d_set:\\n                        has = False\\n                    c += 1\\n                r += 1\\n            if has:\\n                res += 1\\n                \\n                \\n        return res \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def digArtifacts(self, n, artifacts, dig):\\n        \"\"\"\\n        :type n: int\\n        :type artifacts: List[List[int]]\\n        :type dig: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d_set = set([(x, y) for x, y in dig])\\n        res = 0\\n        \\n        for r1, c1, r2, c2 in artifacts:\\n            has = True\\n            r = r1\\n            while r <= r2 and has:\\n                c = c1\\n                while c <= c2 and has:\\n                    if (r, c) not in d_set:\\n                        has = False\\n                    c += 1\\n                r += 1\\n            if has:\\n                res += 1\\n                \\n                \\n        return res \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902924,
                "title": "c-matrix-array-easy-to-understand",
                "content": "```\\n    public int DigArtifacts(int n, int[][] artifacts, int[][] dig) {\\n            int res = 0;\\n            bool[,] matrix =new bool[n,n];//matrix array store if a cell is digged\\n            foreach(var d in dig)\\n            {\\n                matrix[d[0], d[1]] = true;//true-digged\\n            }\\n            foreach(var arti in artifacts)\\n            {\\n                bool canDig = true;\\n                for(int i = arti[0]; i <= arti[2]; i++)\\n                {\\n                    for(int j = arti[1]; j <= arti[3]; j++)\\n                    {\\n                        if(!matrix[i,j])//any cell of current artifact cannot be digged\\n                        {\\n                            canDig = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (canDig) res++;\\n            }\\n            return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int DigArtifacts(int n, int[][] artifacts, int[][] dig) {\\n            int res = 0;\\n            bool[,] matrix =new bool[n,n];//matrix array store if a cell is digged\\n            foreach(var d in dig)\\n            {\\n                matrix[d[0], d[1]] = true;//true-digged\\n            }\\n            foreach(var arti in artifacts)\\n            {\\n                bool canDig = true;\\n                for(int i = arti[0]; i <= arti[2]; i++)\\n                {\\n                    for(int j = arti[1]; j <= arti[3]; j++)\\n                    {\\n                        if(!matrix[i,j])//any cell of current artifact cannot be digged\\n                        {\\n                            canDig = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (canDig) res++;\\n            }\\n            return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1899689,
                "title": "java-easy-to-understand-logic-explained",
                "content": "LOGIC:\\nFirst create a 2d array of n*n\\nTraverse Dig array and mark dig array(x,y) pairs in n*n as \\'D\\' { i use \\'1\\'}\\n\\nThen traverse the Artifacts array and for each row generate the values of\\n(x1,y1)    AND   (x2,y2) by\\n          int x1=artifacts[i][0]; int y1=artifacts[i][1]; \\n            int x2=artifacts[i][2]; int y2=artifacts[i][3]; \\n\\nthen start traversing from x1,y1 to x2,y2 \\nx1,y1 . .....................\\n ..................................\\n ..................................\\n ........................(x2,y2)\\n\\nAnd check if any of the (xi,yi) is not 1 (D) ; thn don\\'t count it to ans;\\nIf all the blocks in the artifacts==1(D) then count 1 to ans;\\n\\n\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int size=artifacts.length;\\n        //List<List<Integer>> art= new ArrayList<ArrayList<Integer>>();\\n        int [][] ar= new int[n][n];\\n        for(int i=0;i<dig.length;i++){\\n          ar[dig[i][0]][dig[i][1]]=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<size;i++){\\n            int x1=artifacts[i][0];\\n            int y1=artifacts[i][1];\\n            \\n            int x2=artifacts[i][2];\\n            int y2=artifacts[i][3];\\n            int flag=0;\\n            int a=x1,b=y1;\\n            while(a<=x2){\\n                 b=y1;\\n                while(b<=y2){\\n                     \\n                    if(ar[a][b]!=1)\\n                    {flag=1;\\n                    break;\\n                    }\\n                    \\n                    b++;\\n                }\\n                if(flag==1) break;\\n                a++;\\n            }\\n            \\n            if(a==x2+1 && b==y2+1)\\n              ans++;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int size=artifacts.length;\\n        //List<List<Integer>> art= new ArrayList<ArrayList<Integer>>();\\n        int [][] ar= new int[n][n];\\n        for(int i=0;i<dig.length;i++){\\n          ar[dig[i][0]][dig[i][1]]=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1895926,
                "title": "c-14-lines-logic-68-faster-43-less-memory",
                "content": "Create an unordered_set for all the ``` dig ``` points and then iterate over all possible ``` artifacts ``` points to check if they exist in ``` dig ```.\\n```\\nclass Solution {\\n    unordered_set<string> s;\\npublic:\\n    bool found(int& a, int& b, int& c, int& d) {\\n        for (int i = a; i <= c; i++) {\\n            for(int j = b; j <= d; j++) {\\n                if (s.find(to_string(i) + \\'-\\' + to_string(j)) == s.end()) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {        \\n        for (auto& d: dig) s.insert(to_string(d[0]) + \\'-\\' + to_string(d[1]));\\n        \\n        int ans = 0;\\n        for (auto& arti: artifacts) {\\n            if (found(arti[0], arti[1], arti[2], arti[3])) ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``` dig ```\n``` artifacts ```\n``` dig ```\n```\\nclass Solution {\\n    unordered_set<string> s;\\npublic:\\n    bool found(int& a, int& b, int& c, int& d) {\\n        for (int i = a; i <= c; i++) {\\n            for(int j = b; j <= d; j++) {\\n                if (s.find(to_string(i) + \\'-\\' + to_string(j)) == s.end()) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {        \\n        for (auto& d: dig) s.insert(to_string(d[0]) + \\'-\\' + to_string(d[1]));\\n        \\n        int ans = 0;\\n        for (auto& arti: artifacts) {\\n            if (found(arti[0], arti[1], arti[2], arti[3])) ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892918,
                "title": "java-simple-solution-with-set-having-o-n-2",
                "content": "```java\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        Set<String> diggableSpots = new HashSet<>();\\n        for (int[] d : dig) {\\n            diggableSpots.add(d[0] + \",\" + d[1]);\\n        }\\n\\n        int result = 0;\\n        for (int[] artifact : artifacts) {\\n            boolean isDiggable = true;\\n            for (int i = artifact[0]; i <= artifact[2]; i++) {\\n                for (int j = artifact[1]; j <= artifact[3]; j++) {\\n                    if (!diggableSpots.contains(i + \",\" + j)) {\\n                        isDiggable = false;\\n                    }\\n                    if (!isDiggable) break;\\n                }\\n                if (!isDiggable) break;\\n            }\\n            result += isDiggable ? 1 : 0;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        Set<String> diggableSpots = new HashSet<>();\\n        for (int[] d : dig) {\\n            diggableSpots.add(d[0] + \",\" + d[1]);\\n        }\\n\\n        int result = 0;\\n        for (int[] artifact : artifacts) {\\n            boolean isDiggable = true;\\n            for (int i = artifact[0]; i <= artifact[2]; i++) {\\n                for (int j = artifact[1]; j <= artifact[3]; j++) {\\n                    if (!diggableSpots.contains(i + \",\" + j)) {\\n                        isDiggable = false;\\n                    }\\n                    if (!isDiggable) break;\\n                }\\n                if (!isDiggable) break;\\n            }\\n            result += isDiggable ? 1 : 0;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892844,
                "title": "java-single-hashmap-liner-time-solution",
                "content": "First define class hold how many grids need to be digged for an artifact, \\nand encode to int into a Long to represent (x, y) by doing this: ` ( x << 32 ) + y `\\nthen we can build a hashmap of `(x,y) -> artifact`, and then just iterate through all grids we found in dig[]\\n```\\nclass Solution {\\n    \\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        Map<Long, Artifact> grids = new HashMap<>();\\n        for (int[] a : artifacts) {\\n           Artifact artifact = new Artifact(a);\\n           for (Long l : artifact.gridify()) {\\n               grids.put(l, artifact);\\n           }\\n        }\\n        int result = 0;\\n        for (int[] d : dig) {\\n            long k = (((long)d[0]) << 32) + d[1];\\n            if (grids.containsKey(k) && grids.get(k).dig() == 0) {\\n                result ++;\\n            }\\n        }\\n        return result;\\n    }\\n\\t\\n\\tpublic static class Artifact {\\n        \\n        int count;\\n        \\n        int[] co;\\n        \\n        public Artifact(int[] co) {\\n            this.co = co;\\n            count = (co[2] - co[0] + 1) * (co[3] - co[1] + 1);\\n        }\\n        \\n        public List<Long> gridify() {\\n            List<Long> result = new ArrayList<>();\\n            for (int i = co[0]; i <= co[2]; i ++) {\\n                for (int j = co[1]; j <= co[3]; j ++) {\\n                    result.add((((long)i) << 32) + j);\\n                }\\n            }\\n            return result;\\n        }\\n        \\n        public int dig() {\\n            return --count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        Map<Long, Artifact> grids = new HashMap<>();\\n        for (int[] a : artifacts) {\\n           Artifact artifact = new Artifact(a);\\n           for (Long l : artifact.gridify()) {\\n               grids.put(l, artifact);\\n           }\\n        }\\n        int result = 0;\\n        for (int[] d : dig) {\\n            long k = (((long)d[0]) << 32) + d[1];\\n            if (grids.containsKey(k) && grids.get(k).dig() == 0) {\\n                result ++;\\n            }\\n        }\\n        return result;\\n    }\\n\\t\\n\\tpublic static class Artifact {\\n        \\n        int count;\\n        \\n        int[] co;\\n        \\n        public Artifact(int[] co) {\\n            this.co = co;\\n            count = (co[2] - co[0] + 1) * (co[3] - co[1] + 1);\\n        }\\n        \\n        public List<Long> gridify() {\\n            List<Long> result = new ArrayList<>();\\n            for (int i = co[0]; i <= co[2]; i ++) {\\n                for (int j = co[1]; j <= co[3]; j ++) {\\n                    result.add((((long)i) << 32) + j);\\n                }\\n            }\\n            return result;\\n        }\\n        \\n        public int dig() {\\n            return --count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885075,
                "title": "c-clean-o-n-2-solution-with-2d-prefix-sum",
                "content": "```\\nint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n\\tvector<vector<int>> prefix(n+1, vector<int>(n+1)); // 2D 1-indexed prefix sum\\n\\t\\n\\t// setup initial value\\n\\tfor(auto &d : dig)\\n\\t\\tprefix[d[0]+1][d[1]+1] = 1;\\n\\t\\t\\n\\t// build up prefix sum\\n\\tfor (int i = 1; i <= n; i++)\\n\\t\\tfor (int j = 1; j <= n; j++)\\n\\t\\t\\tprefix[i][j] += prefix[i][j-1];\\n\\tfor (int j = 1; j <= n; j++)\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tprefix[i][j] += prefix[i-1][j];\\n\\n\\t// For each artifact, chek if all the area are digged \\n    // (check if the number of land being digged withing artifac area is equal to the size of the area)\\n\\tint ret = 0;\\n\\tfor (auto &a: artifacts) {\\n\\t\\tauto area = prefix[a[2]+1][a[3]+1] - prefix[a[2]+1][a[1]] - prefix[a[0]][a[3]+1] + prefix[a[0]][a[1]];\\n\\t\\tret += area == (a[2] - a[0] + 1) * (a[3] - a[1] + 1);\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n\\tvector<vector<int>> prefix(n+1, vector<int>(n+1)); // 2D 1-indexed prefix sum\\n\\t\\n\\t// setup initial value\\n\\tfor(auto &d : dig)\\n\\t\\tprefix[d[0]+1][d[1]+1] = 1;\\n\\t\\t\\n\\t// build up prefix sum\\n\\tfor (int i = 1; i <= n; i++)\\n\\t\\tfor (int j = 1; j <= n; j++)\\n\\t\\t\\tprefix[i][j] += prefix[i][j-1];\\n\\tfor (int j = 1; j <= n; j++)\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tprefix[i][j] += prefix[i-1][j];\\n\\n\\t// For each artifact, chek if all the area are digged \\n    // (check if the number of land being digged withing artifac area is equal to the size of the area)\\n\\tint ret = 0;\\n\\tfor (auto &a: artifacts) {\\n\\t\\tauto area = prefix[a[2]+1][a[3]+1] - prefix[a[2]+1][a[1]] - prefix[a[0]][a[3]+1] + prefix[a[0]][a[1]];\\n\\t\\tret += area == (a[2] - a[0] + 1) * (a[3] - a[1] + 1);\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1869997,
                "title": "java-simulation-dfs",
                "content": "```java\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        // 1. initialize the map\\n        int[][] map = new int[n][n];\\n        \\n        // 2. burry artifacts:\\n        //  - each artifact has a unique id\\n\\t\\t//  - we will use this id to identify whether 2 cells have the same artifact\\n        int artID = 1;\\n        for (int[] art : artifacts) {\\n            for (int i = art[0]; i <= art[2]; ++i) {\\n                for (int j = art[1]; j <= art[3]; ++j) {\\n                    map[i][j] = artID;\\n                }\\n            }\\n            artID++;\\n        }\\n        \\n        // 3. dig\\n        for (int[] d : dig) {\\n            map[d[0]][d[1]] = -map[d[0]][d[1]];\\n        }\\n        \\n        // 4. extract artifacts\\n        int extractCnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (map[i][j] < 0 && dfs(map, i, j, map[i][j])) {\\n\\t\\t\\t\\t\\t// if we have digged at this cell and if all \\n\\t\\t\\t\\t\\t// cells conntected to this cell belonged \\n\\t\\t\\t\\t\\t// to the same artifact and are digged, \\n\\t\\t\\t\\t\\t// then we can extract it \\n                    extractCnt++;\\n                }\\n            }\\n        }\\n        return extractCnt;\\n    }\\n    \\n    private boolean dfs(int[][] map, int x, int y, int art) {\\n        if (x < 0 || x >= map.length || y < 0 || y >= map[0].length) {\\n            return true;\\n        }\\n        if (map[x][y] == -art) return false;    // find a undigged cell\\n        if (map[x][y] != art) return true;      // find empty or other artifact\\n        map[x][y] = 0;  // mark this cell as visited (empty)\\n        return dfs(map, x+1, y, art) & dfs(map, x-1, y, art) & dfs(map, x, y+1, art) & dfs(map, x, y-1, art);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Simulation"
                ],
                "code": "```java\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        // 1. initialize the map\\n        int[][] map = new int[n][n];\\n        \\n        // 2. burry artifacts:\\n        //  - each artifact has a unique id\\n\\t\\t//  - we will use this id to identify whether 2 cells have the same artifact\\n        int artID = 1;\\n        for (int[] art : artifacts) {\\n            for (int i = art[0]; i <= art[2]; ++i) {\\n                for (int j = art[1]; j <= art[3]; ++j) {\\n                    map[i][j] = artID;\\n                }\\n            }\\n            artID++;\\n        }\\n        \\n        // 3. dig\\n        for (int[] d : dig) {\\n            map[d[0]][d[1]] = -map[d[0]][d[1]];\\n        }\\n        \\n        // 4. extract artifacts\\n        int extractCnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (map[i][j] < 0 && dfs(map, i, j, map[i][j])) {\\n\\t\\t\\t\\t\\t// if we have digged at this cell and if all \\n\\t\\t\\t\\t\\t// cells conntected to this cell belonged \\n\\t\\t\\t\\t\\t// to the same artifact and are digged, \\n\\t\\t\\t\\t\\t// then we can extract it \\n                    extractCnt++;\\n                }\\n            }\\n        }\\n        return extractCnt;\\n    }\\n    \\n    private boolean dfs(int[][] map, int x, int y, int art) {\\n        if (x < 0 || x >= map.length || y < 0 || y >= map[0].length) {\\n            return true;\\n        }\\n        if (map[x][y] == -art) return false;    // find a undigged cell\\n        if (map[x][y] != art) return true;      // find empty or other artifact\\n        map[x][y] = 0;  // mark this cell as visited (empty)\\n        return dfs(map, x+1, y, art) & dfs(map, x-1, y, art) & dfs(map, x, y+1, art) & dfs(map, x, y-1, art);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868709,
                "title": "python-simple-matrix-iteration",
                "content": "Simply walk through each element of the matrix and check if each artifact is extracable. \\nTime: O(n^2) \\nSpace: O(n^2)\\n\\n```\\nfrom itertools import product\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        def extracable(matrix, a: List[int]) -> int:\\n            for r, c in product(range(a[0], a[2]+1), range(a[1], a[3]+1)):\\n                if not matrix[r][c]:\\n                    return 0\\n            return 1\\n        \\n        m = [[False] * n for _ in range(n)]\\n        res = 0\\n        \\n        for i, j in dig:\\n            m[i][j] = True\\n        \\n        for a in artifacts:\\n            res += extracable(m, a)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        def extracable(matrix, a: List[int]) -> int:\\n            for r, c in product(range(a[0], a[2]+1), range(a[1], a[3]+1)):\\n                if not matrix[r][c]:\\n                    return 0\\n            return 1\\n        \\n        m = [[False] * n for _ in range(n)]\\n        res = 0\\n        \\n        for i, j in dig:\\n            m[i][j] = True\\n        \\n        for a in artifacts:\\n            res += extracable(m, a)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864889,
                "title": "i-think-this-is-an-optimal-python-solution",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        # Convert dig into nested hash set by x,y-axis. \\n        dug = {}\\n        for x, y in dig:\\n            if x not in dug:\\n                dug[x] = set()\\n            dug[x].add(y)\\n        \\n        cnt = 0\\n        # Check if artifact\\'s every tile is dug.\\n        for rl1, cl1, r2i, c2i in artifacts:\\n            covered = 1\\n            for i in range(rl1, r2i+1):\\n                # To break from loop faster.\\n                if covered == 0:\\n                    break\\n                if i not in dug:\\n                    covered = 0\\n                else:\\n                    for j in range(cl1, c2i+1):\\n                        if j not in dug[i]:\\n                            covered = 0\\n                            # Break from for loop faster.\\n                            break\\n            cnt += covered\\n        \\n        return cnt\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        # Convert dig into nested hash set by x,y-axis. \\n        dug = {}\\n        for x, y in dig:\\n            if x not in dug:\\n                dug[x] = set()\\n            dug[x].add(y)\\n        \\n        cnt = 0\\n        # Check if artifact\\'s every tile is dug.\\n        for rl1, cl1, r2i, c2i in artifacts:\\n            covered = 1\\n            for i in range(rl1, r2i+1):\\n                # To break from loop faster.\\n                if covered == 0:\\n                    break\\n                if i not in dug:\\n                    covered = 0\\n                else:\\n                    for j in range(cl1, c2i+1):\\n                        if j not in dug[i]:\\n                            covered = 0\\n                            # Break from for loop faster.\\n                            break\\n            cnt += covered\\n        \\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862883,
                "title": "easiest-simplest-best-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>>visited(n, vector<bool>(n, false));\\n        for(int i=0; i<dig.size(); i++)\\n        {\\n            visited[dig[i][0]][dig[i][1]] = true;\\n        }\\n        int c = 0;\\n        for(int i=0; i<artifacts.size(); i++)\\n        {\\n            int r1 = artifacts[i][0];\\n            int c1 = artifacts[i][1];\\n            int r2 = artifacts[i][2];\\n            int c2 = artifacts[i][3];\\n            bool flag = true;\\n            for(int j=r1; j<=r2; j++)\\n            {\\n                for(int k=c1; k<=c2; k++)\\n                {\\n                    if(!visited[j][k])\\n                    {\\n                        flag = false;\\n                    }\\n                }\\n            }\\n            if(flag)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\n//pls upvote if u find the solution helpful...!! Thanks...!!\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>>visited(n, vector<bool>(n, false));\\n        for(int i=0; i<dig.size(); i++)\\n        {\\n            visited[dig[i][0]][dig[i][1]] = true;\\n        }\\n        int c = 0;\\n        for(int i=0; i<artifacts.size(); i++)\\n        {\\n            int r1 = artifacts[i][0];\\n            int c1 = artifacts[i][1];\\n            int r2 = artifacts[i][2];\\n            int c2 = artifacts[i][3];\\n            bool flag = true;\\n            for(int j=r1; j<=r2; j++)\\n            {\\n                for(int k=c1; k<=c2; k++)\\n                {\\n                    if(!visited[j][k])\\n                    {\\n                        flag = false;\\n                    }\\n                }\\n            }\\n            if(flag)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\n//pls upvote if u find the solution helpful...!! Thanks...!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862434,
                "title": "c-2-d-bit-solution",
                "content": "```\\nclass Solution {\\n    int dp[1001][1001]{};\\n    int m;\\npublic:\\n    void update(int i, int j, int d) {\\n        for(int r = i; r <= m; r += r & -r) {\\n            for(int c = j; c <= m; c += c & -c) {\\n                dp[r][c] += d;\\n           }\\n        }\\n    }\\n    \\n    int get(int i, int j) {\\n        int sum = 0;\\n        for(int r = i; r > 0; r -= r & -r) {\\n            for(int c = j; c > 0; c -= c & -c) {\\n                sum += dp[r][c];\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& d) {\\n        m = n;\\n        for(auto& t : d) {\\n            update(t[0] + 1, t[1] + 1, 1);\\n        }\\n        int res = 0;\\n        for(auto& t : a) {\\n            int lt = get(t[0], t[1]);\\n            int lb = get(t[2] + 1, t[1]);\\n            int rt = get(t[0], t[3] + 1);\\n            int rb = get(t[2] + 1, t[3] + 1);\\n            int sum = rb - rt - lb + lt;\\n            if(sum == (t[3] - t[1] + 1) * (t[2] - t[0] + 1)) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[1001][1001]{};\\n    int m;\\npublic:\\n    void update(int i, int j, int d) {\\n        for(int r = i; r <= m; r += r & -r) {\\n            for(int c = j; c <= m; c += c & -c) {\\n                dp[r][c] += d;\\n           }\\n        }\\n    }\\n    \\n    int get(int i, int j) {\\n        int sum = 0;\\n        for(int r = i; r > 0; r -= r & -r) {\\n            for(int c = j; c > 0; c -= c & -c) {\\n                sum += dp[r][c];\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& d) {\\n        m = n;\\n        for(auto& t : d) {\\n            update(t[0] + 1, t[1] + 1, 1);\\n        }\\n        int res = 0;\\n        for(auto& t : a) {\\n            int lt = get(t[0], t[1]);\\n            int lb = get(t[2] + 1, t[1]);\\n            int rt = get(t[0], t[3] + 1);\\n            int rb = get(t[2] + 1, t[3] + 1);\\n            int sum = rb - rt - lb + lt;\\n            if(sum == (t[3] - t[1] + 1) * (t[2] - t[0] + 1)) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861651,
                "title": "o-n-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig)\\n\\t\\t{\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tbool digged[n][n];\\n\\t\\t\\tmemset(digged, 0 ,sizeof digged);\\n\\n\\t\\t\\tfor(int i = 0 ; i < dig.size() ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = dig[i][0];\\n\\t\\t\\t\\tint y = dig[i][1];\\n\\t\\t\\t\\tdigged[x][y] = 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 0 ; i < artifacts.size() ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint r1 = artifacts[i][0];\\n\\t\\t\\t\\tint c1 = artifacts[i][1];\\n\\t\\t\\t\\tint r2 = artifacts[i][2];\\n\\t\\t\\t\\tint c2 = artifacts[i][3];\\n\\n\\t\\t\\t\\tbool full = 1;\\n\\t\\t\\t\\tfor(int r = r1 ; r <= r2 ; r++)\\n\\t\\t\\t\\t\\tfor(int c = c1 ; c <= c2 ; c++)\\n\\t\\t\\t\\t\\t\\tfull &= digged[r][c];\\n\\n\\t\\t\\t\\tans += full;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig)\\n\\t\\t{\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tbool digged[n][n];\\n\\t\\t\\tmemset(digged, 0 ,sizeof digged);\\n\\n\\t\\t\\tfor(int i = 0 ; i < dig.size() ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = dig[i][0];\\n\\t\\t\\t\\tint y = dig[i][1];\\n\\t\\t\\t\\tdigged[x][y] = 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1860633,
                "title": "dp-method",
                "content": "We first mark the coordinates and using pre-calculated sum we find the number of ones that are present under the top-left and bottom rigth corners of query and  check if the number of ones present is equal to the area. This method can handle overlapping cases too if in case smaller ones are stacked up.\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        int cnt=0,x1,y1,x2,y2,area;\\n        for(auto d:dig){\\n            dp[d[0]][d[1]]=1;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0&&j==0){\\n                    continue;\\n                }\\n                else if(i==0){\\n                    dp[i][j]+=dp[i][j-1];\\n                }\\n                else if(j==0){\\n                    dp[i][j]+=dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]+=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\\n                }\\n            }\\n        }\\n        for(auto artifact:artifacts){\\n            x1=artifact[0];y1=artifact[1];x2=artifact[2];y2=artifact[3];\\n            area = dp[x2][y2];\\n            if(y1>0){\\n                area -= dp[x2][y1-1];\\n            }\\n            if(x1>0){\\n                area -= dp[x1-1][y2];\\n            }\\n            if(x1>0&&y1>0){\\n                area += dp[x1-1][y1-1];\\n            }\\n            if(area == (x2-x1+1)*(y2-y1+1)){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        int cnt=0,x1,y1,x2,y2,area;\\n        for(auto d:dig){\\n            dp[d[0]][d[1]]=1;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0&&j==0){\\n                    continue;\\n                }\\n                else if(i==0){\\n                    dp[i][j]+=dp[i][j-1];\\n                }\\n                else if(j==0){\\n                    dp[i][j]+=dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]+=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\\n                }\\n            }\\n        }\\n        for(auto artifact:artifacts){\\n            x1=artifact[0];y1=artifact[1];x2=artifact[2];y2=artifact[3];\\n            area = dp[x2][y2];\\n            if(y1>0){\\n                area -= dp[x2][y1-1];\\n            }\\n            if(x1>0){\\n                area -= dp[x1-1][y2];\\n            }\\n            if(x1>0&&y1>0){\\n                area += dp[x1-1][y1-1];\\n            }\\n            if(area == (x2-x1+1)*(y2-y1+1)){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860487,
                "title": "c-solution-easy-to-understand-with-explanation",
                "content": "```\\n    // Logic :-\\n// Initially set all elements of grid to 1  , after digging a point set the value of grid  \\n// at that point to 0 (represents that the point is visited)\\n// then for each artifact check if all elements which belong to artifact are visited or not\\n    bool isPresent(vector<vector<int>> &grid, int x1,int y1,int x2 , int y2)\\n    {\\n        for(int i = x1 ; i<= x2;i++)\\n        {\\n            for(int j = y1 ;j<= y2;j++)\\n            {\\n                if(grid[i][j] != 0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        \\n        //Initializing all the cells of Grid as unvisited (element = 1)\\n        vector<vector<int>> grid(n,vector<int>(n , 1));\\n        \\n        int i , j , cnt = 0;\\n        \\n        \\n        // Digging\\n        int s = dig.size();\\n        for(i = 0;i<s;i++)\\n        {\\n            int x = dig[i][0] , y = dig[i][1];\\n            grid[x][y]  = 0;\\n        }\\n        \\n        // counting artifacts \\n        int total = artifacts.size();\\n        for(i = 0;i<total;i++)\\n        {\\n            int x1 = artifacts[i][0] , x2 = artifacts[i][2];\\n            int y1 = artifacts[i][1] , y2 = artifacts[i][3];\\n            if(isPresent(grid,x1,y1,x2,y2))\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // Logic :-\\n// Initially set all elements of grid to 1  , after digging a point set the value of grid  \\n// at that point to 0 (represents that the point is visited)\\n// then for each artifact check if all elements which belong to artifact are visited or not\\n    bool isPresent(vector<vector<int>> &grid, int x1,int y1,int x2 , int y2)\\n    {\\n        for(int i = x1 ; i<= x2;i++)\\n        {\\n            for(int j = y1 ;j<= y2;j++)\\n            {\\n                if(grid[i][j] != 0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        \\n        //Initializing all the cells of Grid as unvisited (element = 1)\\n        vector<vector<int>> grid(n,vector<int>(n , 1));\\n        \\n        int i , j , cnt = 0;\\n        \\n        \\n        // Digging\\n        int s = dig.size();\\n        for(i = 0;i<s;i++)\\n        {\\n            int x = dig[i][0] , y = dig[i][1];\\n            grid[x][y]  = 0;\\n        }\\n        \\n        // counting artifacts \\n        int total = artifacts.size();\\n        for(i = 0;i<total;i++)\\n        {\\n            int x1 = artifacts[i][0] , x2 = artifacts[i][2];\\n            int y1 = artifacts[i][1] , y2 = artifacts[i][3];\\n            if(isPresent(grid,x1,y1,x2,y2))\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860293,
                "title": "c-simple-hashing-and-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        \\n        \\n        vector<vector<int>>v(n,vector<int>(n,-1));\\n        unordered_map<int,int>count,color;\\n        int c=0;\\n        \\n        for(auto x:artifacts)\\n        {\\n            int a=0;\\n            for(int i=x[0];i<=x[2];i++)\\n            {\\n                for(int j=x[1];j<=x[3];j++)\\n                {\\n                    v[i][j]=c;\\n                    a++;\\n                }\\n            }\\n            \\n            count[c]=a;\\n            c++;\\n        }\\n        \\n        for(auto x:dig)\\n        {\\n            color[v[x[0]][x[1]]]++;\\n        }\\n        \\n        \\n        c=0;\\n        for(auto x:color)\\n        {\\n            if(x.second==count[x.first])\\n                c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        \\n        \\n        vector<vector<int>>v(n,vector<int>(n,-1));\\n        unordered_map<int,int>count,color;\\n        int c=0;\\n        \\n        for(auto x:artifacts)\\n        {\\n            int a=0;\\n            for(int i=x[0];i<=x[2];i++)\\n            {\\n                for(int j=x[1];j<=x[3];j++)\\n                {\\n                    v[i][j]=c;\\n                    a++;\\n                }\\n            }\\n            \\n            count[c]=a;\\n            c++;\\n        }\\n        \\n        for(auto x:dig)\\n        {\\n            color[v[x[0]][x[1]]]++;\\n        }\\n        \\n        \\n        c=0;\\n        for(auto x:color)\\n        {\\n            if(x.second==count[x.first])\\n                c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858038,
                "title": "c-simulation-15-lines",
                "content": "```cpp\\nint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n\\tvector<vector<int>> grid(n, vector<int>(n, -1));\\n\\tvector<int> covered_cells(artifacts.size());\\n\\tfor(int i=0; i < artifacts.size(); ++i) {\\n\\t\\tconst auto& zone = artifacts[i];\\n\\t\\tcovered_cells[i] = (zone[2] - zone[0]+1) * (zone[3] - zone[1]+1);\\n\\t\\tfor(int r = zone[0]; r <= zone[2]; ++r)\\n\\t\\t\\tfor(int c = zone[1]; c <= zone[3]; ++c)\\n\\t\\t\\t\\tgrid[r][c] = i;\\n\\t}\\n\\tfor(const auto& cell: dig) {\\n\\t\\tif(int artifact = grid[cell[0]][cell[1]]; artifact != -1)\\n\\t\\t\\t--covered_cells[artifact];\\n\\t}\\n\\treturn count_if(covered_cells.begin(), covered_cells.end(),[](int n){return n==0;});\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n\\tvector<vector<int>> grid(n, vector<int>(n, -1));\\n\\tvector<int> covered_cells(artifacts.size());\\n\\tfor(int i=0; i < artifacts.size(); ++i) {\\n\\t\\tconst auto& zone = artifacts[i];\\n\\t\\tcovered_cells[i] = (zone[2] - zone[0]+1) * (zone[3] - zone[1]+1);\\n\\t\\tfor(int r = zone[0]; r <= zone[2]; ++r)\\n\\t\\t\\tfor(int c = zone[1]; c <= zone[3]; ++c)\\n\\t\\t\\t\\tgrid[r][c] = i;\\n\\t}\\n\\tfor(const auto& cell: dig) {\\n\\t\\tif(int artifact = grid[cell[0]][cell[1]]; artifact != -1)\\n\\t\\t\\t--covered_cells[artifact];\\n\\t}\\n\\treturn count_if(covered_cells.begin(), covered_cells.end(),[](int n){return n==0;});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1857417,
                "title": "through-presum-matrix-fast-and-easy",
                "content": "```\\n\\nclass Solution {\\nprivate:\\n    int getNumOfsCell(vector<int>& artifact) {\\n        int r = artifact[2] - artifact[0] + 1;\\n        int c = artifact[3] - artifact[1] + 1;\\n        return r * c;\\n    }\\n\\n    int getSumMatrix(vector<vector<int>>& matrix, int r, int c) {\\n        if (r < 0 || c < 0 || r >= matrix.size() || c >= matrix[0].size())\\n            return 0;\\n        return matrix[r][c];\\n    }\\n\\n    int getDigCell(vector<vector<int>>& matrix, vector<int>& artifact) {\\n        int s = getSumMatrix( matrix, artifact[2],artifact[3]);\\n        s -= getSumMatrix(matrix, artifact[0]-1, artifact[3]);\\n        s -= getSumMatrix(matrix, artifact[2], artifact[1]-1);\\n        s += getSumMatrix(matrix, artifact[0] - 1, artifact[1] - 1);\\n        return s;\\n    }\\n    \\n    void calculatePreSumMatrix(vector<vector<int>>& matrix , int n) {\\n        for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (i == 0 && j == 0)\\n                        continue;\\n                    else if (i == 0)\\n                        matrix[i][j] = matrix[i][j - 1] + matrix[i][j];\\n                    else if (j == 0)\\n                        matrix[i][j] = matrix[i - 1][j] + matrix[i][j];\\n                    else\\n                        matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1] - matrix[i - 1][j - 1] + matrix[i][j];\\n                }\\n            }   \\n    }\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        // mark all the digged cell\\n        for (auto d : dig) {\\n             matrix[d[0]][d[1]] = 1;\\n        }\\n        \\n        // calculate the presum \\n        calculatePreSumMatrix( matrix, n);\\n        \\n        int ans = 0;\\n        // all the cells are digged then count in result\\n        for (auto a : artifacts) {\\n            if (getNumOfsCell(a) == getDigCell(matrix, a))\\n                ans++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\nprivate:\\n    int getNumOfsCell(vector<int>& artifact) {\\n        int r = artifact[2] - artifact[0] + 1;\\n        int c = artifact[3] - artifact[1] + 1;\\n        return r * c;\\n    }\\n\\n    int getSumMatrix(vector<vector<int>>& matrix, int r, int c) {\\n        if (r < 0 || c < 0 || r >= matrix.size() || c >= matrix[0].size())\\n            return 0;\\n        return matrix[r][c];\\n    }\\n\\n    int getDigCell(vector<vector<int>>& matrix, vector<int>& artifact) {\\n        int s = getSumMatrix( matrix, artifact[2],artifact[3]);\\n        s -= getSumMatrix(matrix, artifact[0]-1, artifact[3]);\\n        s -= getSumMatrix(matrix, artifact[2], artifact[1]-1);\\n        s += getSumMatrix(matrix, artifact[0] - 1, artifact[1] - 1);\\n        return s;\\n    }\\n    \\n    void calculatePreSumMatrix(vector<vector<int>>& matrix , int n) {\\n        for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (i == 0 && j == 0)\\n                        continue;\\n                    else if (i == 0)\\n                        matrix[i][j] = matrix[i][j - 1] + matrix[i][j];\\n                    else if (j == 0)\\n                        matrix[i][j] = matrix[i - 1][j] + matrix[i][j];\\n                    else\\n                        matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1] - matrix[i - 1][j - 1] + matrix[i][j];\\n                }\\n            }   \\n    }\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> matrix(n, vector<int>(n, 0));\\n        // mark all the digged cell\\n        for (auto d : dig) {\\n             matrix[d[0]][d[1]] = 1;\\n        }\\n        \\n        // calculate the presum \\n        calculatePreSumMatrix( matrix, n);\\n        \\n        int ans = 0;\\n        // all the cells are digged then count in result\\n        for (auto a : artifacts) {\\n            if (getNumOfsCell(a) == getDigCell(matrix, a))\\n                ans++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856885,
                "title": "java-initialize-map-of-artifacts-check-all-dig-attempts",
                "content": "Different approach from top discussed solutions/comments.\\n```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int[][] map = new int[n][n];\\n        var result = 0;\\n        Map<Integer, Integer> artIdToSize = new HashMap<>();\\n        for (int i =0; i< artifacts.length; i++) {\\n            int [] art = artifacts[i];\\n            int r1 = art[0];\\n            int c1 = art[1];\\n            int r2 = art[2];\\n            int c2 = art[3];\\n            for( int r = r1; r<=r2; r++ ) {\\n                for (int c = c1; c<= c2; c++) {\\n                    map[r][c] = i+1;\\n                }\\n            }\\n            var size = (r2 - r1 + 1) * (c2-c1 +1);\\n            artIdToSize.put(i+1, size);\\n        }\\n        \\n        for (int[] d: dig){\\n            int id = map[d[0]][d[1]];\\n            if ( id> 0 && artIdToSize.getOrDefault(id, 0) > 0) {\\n                int curCount = artIdToSize.get(id);\\n                artIdToSize.put(id, curCount-1);\\n                if (artIdToSize.get(id) == 0 )\\n                    result++;\\n                \\n            }\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int[][] map = new int[n][n];\\n        var result = 0;\\n        Map<Integer, Integer> artIdToSize = new HashMap<>();\\n        for (int i =0; i< artifacts.length; i++) {\\n            int [] art = artifacts[i];\\n            int r1 = art[0];\\n            int c1 = art[1];\\n            int r2 = art[2];\\n            int c2 = art[3];\\n            for( int r = r1; r<=r2; r++ ) {\\n                for (int c = c1; c<= c2; c++) {\\n                    map[r][c] = i+1;\\n                }\\n            }\\n            var size = (r2 - r1 + 1) * (c2-c1 +1);\\n            artIdToSize.put(i+1, size);\\n        }\\n        \\n        for (int[] d: dig){\\n            int id = map[d[0]][d[1]];\\n            if ( id> 0 && artIdToSize.getOrDefault(id, 0) > 0) {\\n                int curCount = artIdToSize.get(id);\\n                artIdToSize.put(id, curCount-1);\\n                if (artIdToSize.get(id) == 0 )\\n                    result++;\\n                \\n            }\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854814,
                "title": "c-dfs-very-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int m; //boundary\\n    int dir[5] = {-1, 0, 1, 0, -1};\\n    unordered_map<int, unordered_map<int, bool>> mp, v; //maps for dig, and visited each\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        for(auto &d:dig) mp[d[0]][d[1]] = 1;\\n        m = n;\\n        int ret = 0;\\n        for(auto &art:artifacts)\\n            if(dfs(art, art[0], art[1])) ++ret;\\n        return ret;\\n    }\\n    bool dfs(vector<int>& art, int y, int x){\\n        if(!mp.count(y) || !mp[y].count(x)) return 0; //if can\\'t dig [y, x]\\n        v[y][x] = 1; //mark [y, x] as visited\\n        for(int i=0; i<4; ++i){\\n            int ny = y+dir[i], nx = x+dir[i+1];\\n            if(valid(art, ny, nx) && !dfs(art, ny, nx)) return 0;\\n        }\\n        return 1;\\n    }\\n    bool valid(vector<int>& art, int y, int x){\\n        return (y>=0 && x>=0 && y<m && x<m && //check if it\\'s within the boundary\\n                (!v.count(y) || !v[y].count(x)) && //check if it\\'s not been visited\\n               y>=art[0] && y<=art[2] && x>=art[1] && x<=art[3]); //check if it\\'s on the artifact\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m; //boundary\\n    int dir[5] = {-1, 0, 1, 0, -1};\\n    unordered_map<int, unordered_map<int, bool>> mp, v; //maps for dig, and visited each\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        for(auto &d:dig) mp[d[0]][d[1]] = 1;\\n        m = n;\\n        int ret = 0;\\n        for(auto &art:artifacts)\\n            if(dfs(art, art[0], art[1])) ++ret;\\n        return ret;\\n    }\\n    bool dfs(vector<int>& art, int y, int x){\\n        if(!mp.count(y) || !mp[y].count(x)) return 0; //if can\\'t dig [y, x]\\n        v[y][x] = 1; //mark [y, x] as visited\\n        for(int i=0; i<4; ++i){\\n            int ny = y+dir[i], nx = x+dir[i+1];\\n            if(valid(art, ny, nx) && !dfs(art, ny, nx)) return 0;\\n        }\\n        return 1;\\n    }\\n    bool valid(vector<int>& art, int y, int x){\\n        return (y>=0 && x>=0 && y<m && x<m && //check if it\\'s within the boundary\\n                (!v.count(y) || !v[y].count(x)) && //check if it\\'s not been visited\\n               y>=art[0] && y<=art[2] && x>=art[1] && x<=art[3]); //check if it\\'s on the artifact\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853708,
                "title": "python-hashmap-observation-o-n",
                "content": "**Intution here we need to track for either all cells in (x1,y1) to (x2,y2) are covered or not we can do it in O(1) using dictionary or hashmap**\\n\\nPossiblity of (x1,y1) and (x2,y2)\\n\\nif x1==y1 and x2==y2 then it has only one cell so check if present in dig array\\n\\nif x1==x2 then we have same row so iterate from y1 to y2 and see if any one cell is not covered don\\'t count the artifact same goes with y1==y2\\n\\nnow if both are not equall artifact is in 2*2 matrix form as the maxmimum difference between abs(x1-x2)+abs(y1-y2)==4\\n\\nso iterate from x1 to x2 and y1 to y2 and generate (x,y) pairs and check is any one pair doesn\\'t belong to dig array discard the artifact\\n\\nNow if we are unabe to discard the artifact then take it into account and increase count by 1\\n\\n\\n\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        hsh={}\\n        cnt=0\\n        for val in dig:\\n            hsh[tuple(val)]=1\\n        for cords in artifacts:\\n            x0,y0,x1,y1=cords[0],cords[1],cords[2],cords[3]\\n            f=True\\n            \\n            if x0==x1 and y0==y1:\\n                if hsh.get((x0,y0))==None or hsh.get((x1,y1))==None:f=False\\n            elif x0==x1:\\n                for y in range(y0,y1+1):\\n                    if hsh.get((x0,y))==None:\\n                        f=False;break\\n            elif y0==y1:\\n                for x in range(x0,x1+1):\\n                    if hsh.get((x,y0))==None:\\n                        f=False;break\\n            else:\\n                for x in range(x0,x1+1):\\n                    for y in range(y0,y1+1):\\n                        if hsh.get((x,y))==None:\\n                            f=False;break\\n            if f:cnt+=1\\n        return cnt\\n                \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        hsh={}",
                "codeTag": "Java"
            },
            {
                "id": 1852931,
                "title": "python-quick-using-set",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        site = {(x,y) for x,y in dig}\\n        res = 0\\n        for x1,y1,x2,y2 in artifacts:\\n            res += all((i,j) in site for i in range(x1,x2+1) for j in range(y1,y2+1))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        site = {(x,y) for x,y in dig}\\n        res = 0\\n        for x1,y1,x2,y2 in artifacts:\\n            res += all((i,j) in site for i in range(x1,x2+1) for j in range(y1,y2+1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852558,
                "title": "python-solution",
                "content": "Building the grid is the key in the below solution.\\n\\n* Make a grid with 0 as default value for each cell.\\n* Make the grid-cell value to 1 if dig (dug*)\\n* For every artificat check if all the cells in grid are dug. \\n* If yes, artifact can be extracted; res += 1\\n\\nYes, this way takes up (n^2) space along O(n^2) speed  (in worst case scenario).\\n\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n\\n        grid = [[0 for _ in range(n)] for _ in range(n)]\\n        \\n        for d in dig:\\n            grid[d[0]][d[1]] = 1\\n            \\n        # print(grid)\\n        \\n        res = [0]\\n        \\n        def findArtifactCells(artifact, res):\\n            x1, y1, x2, y2 = artifact[0], artifact[1], artifact[2], artifact[3]\\n            \\n            for i in range(x1, x2+1):\\n                for j in range(y1, y2+1):\\n                    if grid[i][j] == 0:\\n                        return\\n            res[0] += 1\\n            \\n        for artifact in artifacts:\\n            findArtifactCells(artifact, res)\\n            \\n        return res[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n\\n        grid = [[0 for _ in range(n)] for _ in range(n)]\\n        \\n        for d in dig:\\n            grid[d[0]][d[1]] = 1\\n            \\n        # print(grid)\\n        \\n        res = [0]\\n        \\n        def findArtifactCells(artifact, res):\\n            x1, y1, x2, y2 = artifact[0], artifact[1], artifact[2], artifact[3]\\n            \\n            for i in range(x1, x2+1):\\n                for j in range(y1, y2+1):\\n                    if grid[i][j] == 0:\\n                        return\\n            res[0] += 1\\n            \\n        for artifact in artifacts:\\n            findArtifactCells(artifact, res)\\n            \\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852221,
                "title": "a-few-solutions",
                "content": "Use a map `m` to associate each `i`,`j` cell with the `index` of the artifact within the input array `A`, and keep track of the count of cells per artifact in the array `cnt`.  When digging, we decrement each `i`,`j` cell and increment the answer count `ans` whenever the count of cells per artifact reaches `0`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun digArtifacts(N: Int, A: Array<IntArray>, dig: Array<IntArray>): Int {\\n        var ans = 0\\n        var m = mutableMapOf<String, Int>()\\n        var cnt = IntArray(A.size) { 0 }\\n        for ((index, value) in A.withIndex()) {\\n            var (i, j, u, v) = value\\n            while (i <= u) {\\n                var k = j\\n                while (k <= v) {\\n                    m[\"$i,$k\"] = index; ++cnt[index]\\n                    ++k\\n                }\\n                ++i\\n            }\\n        }\\n        for ((i, j) in dig) {\\n            var key = \"$i,$j\"\\n            if (!m.contains(key))\\n                continue\\n            var index = m[key]!!\\n            if (--cnt[index] == 0)\\n                ++ans\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet digArtifacts = (_, A, dig, m = new Map(), ans = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(0);\\n    for (let index = 0; index < N; ++index) {\\n        let [i, j, u, v] = A[index];\\n        while (i <= u) {\\n            let k = j;\\n            while (k <= v) {\\n                let key = `${i},${k}`;\\n                m.set(key, index), ++cnt[index];\\n                ++k;\\n            }\\n            ++i;\\n        }\\n    }\\n    for (let [i, j] of dig) {\\n        let key = `${i},${j}`;\\n        if (!m.has(key))\\n            continue;\\n        let index = m.get(key);\\n        if (!--cnt[index])\\n            ++ans;\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def digArtifacts(self, _: int, A: List[List[int]], dig: List[List[int]], ans = 0) -> int:\\n        N = len(A)\\n        m = {}\\n        cnt = [0 for _ in range(N)]\\n        for index, value in enumerate(A):\\n            i, j, u, v = value\\n            while i <= u:\\n                k = j\\n                while k <= v:\\n                    key = f\\'{i},{k}\\'\\n                    m[key] = index; cnt[index] += 1\\n                    k += 1\\n                i += 1\\n        for i, j in dig:\\n            key = f\\'{i},{j}\\'\\n            if key not in m:\\n                continue\\n            index = m[key]\\n            cnt[index] -= 1\\n            if not cnt[index]:\\n                ans += 1\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<string, int>;\\n    int digArtifacts(int _, VVI& A, VVI& dig, Map m = {}, int ans = 0) {\\n        int N = A.size();\\n        VI cnt(N);\\n        auto hash = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        for (auto index{ 0 }; index < N; ++index) {\\n            auto a = A[index];\\n            auto [i, j] = tie(a[0], a[1]);\\n            auto [u, v] = tie(a[2], a[3]);\\n            while (i <= u) {\\n                auto k = j;\\n                while (k <= v) {\\n                    auto key = hash(i, k);\\n                    m[key] = index, ++cnt[index];\\n                    ++k;\\n                }\\n                ++i;\\n            }\\n        }\\n        for (auto& pair: dig) {\\n            auto [i, j] = tie(pair[0], pair[1]);\\n            auto key = hash(i, j);\\n            if (m.find(key) == m.end())\\n                continue;\\n            auto index = m[key];\\n            if (!--cnt[index])\\n                ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun digArtifacts(N: Int, A: Array<IntArray>, dig: Array<IntArray>): Int {\\n        var ans = 0\\n        var m = mutableMapOf<String, Int>()\\n        var cnt = IntArray(A.size) { 0 }\\n        for ((index, value) in A.withIndex()) {\\n            var (i, j, u, v) = value\\n            while (i <= u) {\\n                var k = j\\n                while (k <= v) {\\n                    m[\"$i,$k\"] = index; ++cnt[index]\\n                    ++k\\n                }\\n                ++i\\n            }\\n        }\\n        for ((i, j) in dig) {\\n            var key = \"$i,$j\"\\n            if (!m.contains(key))\\n                continue\\n            var index = m[key]!!\\n            if (--cnt[index] == 0)\\n                ++ans\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nlet digArtifacts = (_, A, dig, m = new Map(), ans = 0) => {\\n    let N = A.length;\\n    let cnt = Array(N).fill(0);\\n    for (let index = 0; index < N; ++index) {\\n        let [i, j, u, v] = A[index];\\n        while (i <= u) {\\n            let k = j;\\n            while (k <= v) {\\n                let key = `${i},${k}`;\\n                m.set(key, index), ++cnt[index];\\n                ++k;\\n            }\\n            ++i;\\n        }\\n    }\\n    for (let [i, j] of dig) {\\n        let key = `${i},${j}`;\\n        if (!m.has(key))\\n            continue;\\n        let index = m.get(key);\\n        if (!--cnt[index])\\n            ++ans;\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def digArtifacts(self, _: int, A: List[List[int]], dig: List[List[int]], ans = 0) -> int:\\n        N = len(A)\\n        m = {}\\n        cnt = [0 for _ in range(N)]\\n        for index, value in enumerate(A):\\n            i, j, u, v = value\\n            while i <= u:\\n                k = j\\n                while k <= v:\\n                    key = f\\'{i},{k}\\'\\n                    m[key] = index; cnt[index] += 1\\n                    k += 1\\n                i += 1\\n        for i, j in dig:\\n            key = f\\'{i},{j}\\'\\n            if key not in m:\\n                continue\\n            index = m[key]\\n            cnt[index] -= 1\\n            if not cnt[index]:\\n                ans += 1\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<string, int>;\\n    int digArtifacts(int _, VVI& A, VVI& dig, Map m = {}, int ans = 0) {\\n        int N = A.size();\\n        VI cnt(N);\\n        auto hash = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        for (auto index{ 0 }; index < N; ++index) {\\n            auto a = A[index];\\n            auto [i, j] = tie(a[0], a[1]);\\n            auto [u, v] = tie(a[2], a[3]);\\n            while (i <= u) {\\n                auto k = j;\\n                while (k <= v) {\\n                    auto key = hash(i, k);\\n                    m[key] = index, ++cnt[index];\\n                    ++k;\\n                }\\n                ++i;\\n            }\\n        }\\n        for (auto& pair: dig) {\\n            auto [i, j] = tie(pair[0], pair[1]);\\n            auto key = hash(i, j);\\n            if (m.find(key) == m.end())\\n                continue;\\n            auto index = m[key];\\n            if (!--cnt[index])\\n                ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850625,
                "title": "understandable-java-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    static int[][] matrix;\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        matrix= new int[n][n];\\n        int found=0,count=0;\\n        for(int[] cell:dig){\\n            matrix[cell[0]][cell[1]]=1;\\n        }\\n        for(int[] arr:artifacts){\\n            found=excavate(arr[0],arr[1],arr[2],arr[3]);\\n            if(found==1){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    static int excavate(int startrow,int startcol,int endrow,int endcol){\\n        for(int row=startrow;row<=endrow;row++){\\n            for(int col=startcol;col<=endcol;col++){\\n                if(matrix[row][col]==0)\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    static int[][] matrix;\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        matrix= new int[n][n];\\n        int found=0,count=0;\\n        for(int[] cell:dig){\\n            matrix[cell[0]][cell[1]]=1;\\n        }\\n        for(int[] arr:artifacts){\\n            found=excavate(arr[0],arr[1],arr[2],arr[3]);\\n            if(found==1){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    static int excavate(int startrow,int startcol,int endrow,int endcol){\\n        for(int row=startrow;row<=endrow;row++){\\n            for(int col=startcol;col<=endcol;col++){\\n                if(matrix[row][col]==0)\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850456,
                "title": "rust-hashset-o-n",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn dig_artifacts(n: i32, artifacts: Vec<Vec<i32>>, dig: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n        let mut xs:HashSet<(i32, i32)> = HashSet::new();\\n        for v1 in dig {\\n            let x = v1[0];\\n            let y = v1[1];\\n            xs.insert((x, y));\\n        }\\n        \\n        for v in artifacts {\\n            let (r1,c1,r2,c2) = (v[0], v[1], v[2], v[3]);\\n            let mut covered = true;\\n\\n            \\'area_loop:\\n            for r in r1..=r2 {\\n                for c in c1..=c2 {\\n                    if !xs.contains(&(r,c)) {\\n                        covered = false;\\n                        break \\'area_loop;\\n                    }\\n                }\\n            }\\n            if covered {\\n                ans += 1;\\n            }\\n        }\\n        ans\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn dig_artifacts(n: i32, artifacts: Vec<Vec<i32>>, dig: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n        let mut xs:HashSet<(i32, i32)> = HashSet::new();\\n        for v1 in dig {\\n            let x = v1[0];\\n            let y = v1[1];\\n            xs.insert((x, y));\\n        }\\n        \\n        for v in artifacts {\\n            let (r1,c1,r2,c2) = (v[0], v[1], v[2], v[3]);\\n            let mut covered = true;\\n\\n            \\'area_loop:\\n            for r in r1..=r2 {\\n                for c in c1..=c2 {\\n                    if !xs.contains(&(r,c)) {\\n                        covered = false;\\n                        break \\'area_loop;\\n                    }\\n                }\\n            }\\n            if covered {\\n                ans += 1;\\n            }\\n        }\\n        ans\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850066,
                "title": "c-very-simple-clear-and-clean-code-tc-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        int ans = 0;\\n        \\n        vector<vector<int>>grid(n, vector<int>(n, 0));\\n        \\n        for(int i = 0; i<dig.size(); i++){\\n            grid[dig[i][0]][dig[i][1]] = 1;\\n        }\\n        \\n        for(int i = 0; i<artifacts.size(); i++){\\n            bool full = true;\\n            for(int sr = artifacts[i][0]; sr<=artifacts[i][2]; sr++){\\n                for(int sc = artifacts[i][1]; sc<=artifacts[i][3]; sc++){\\n                    if(grid[sr][sc]!=1){\\n                        full = false;\\n                        break;\\n                    }\\n                }\\n                if(!full){\\n                    break;\\n                }\\n            }\\n            \\n            if(full){\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        int ans = 0;\\n        \\n        vector<vector<int>>grid(n, vector<int>(n, 0));\\n        \\n        for(int i = 0; i<dig.size(); i++){\\n            grid[dig[i][0]][dig[i][1]] = 1;\\n        }\\n        \\n        for(int i = 0; i<artifacts.size(); i++){\\n            bool full = true;\\n            for(int sr = artifacts[i][0]; sr<=artifacts[i][2]; sr++){\\n                for(int sc = artifacts[i][1]; sc<=artifacts[i][3]; sc++){\\n                    if(grid[sr][sc]!=1){\\n                        full = false;\\n                        break;\\n                    }\\n                }\\n                if(!full){\\n                    break;\\n                }\\n            }\\n            \\n            if(full){\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849614,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        \\n        boolean[][] vis = new boolean[n][n];\\n        \\n        for(int [] x : dig){\\n            vis[x[0]][x[1]] = true;\\n        }\\n        int count = 0;\\n        for(int[] x : artifacts){\\n            boolean flag = true;\\n            int r1 = x[0];\\n            int c1 = x[1];\\n            int r2 = x[2];\\n            int c2 = x[3];\\n            \\n            for(int i=r1;i<=r2;i++){\\n                for(int j=c1;j<=c2;j++){\\n                    if(vis[i][j]==false){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        \\n        boolean[][] vis = new boolean[n][n];\\n        \\n        for(int [] x : dig){\\n            vis[x[0]][x[1]] = true;\\n        }\\n        int count = 0;\\n        for(int[] x : artifacts){\\n            boolean flag = true;\\n            int r1 = x[0];\\n            int c1 = x[1];\\n            int r2 = x[2];\\n            int c2 = x[3];\\n            \\n            for(int i=r1;i<=r2;i++){\\n                for(int j=c1;j<=c2;j++){\\n                    if(vis[i][j]==false){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849564,
                "title": "java-6ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n\\t\\tint[] counts = new int[artifacts.length];\\n        \\n        boolean[][] uncovered = new boolean[n][n];\\n\\n        for (int[] dg : dig){\\n           uncovered[dg[0]][dg[1]] = true;\\n        }\\n        \\n        int ans = 0;\\n        \\n        loop: for (int k=0; k<artifacts.length; k++){\\n            \\n            for (int i=artifacts[k][0]; i<=artifacts[k][2]; i++){\\n                for (int j=artifacts[k][1]; j<=artifacts[k][3]; j++){\\n                    if (!uncovered[i][j])\\n                        continue loop;\\n                }\\n            }\\n            \\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n\\t\\tint[] counts = new int[artifacts.length];\\n        \\n        boolean[][] uncovered = new boolean[n][n];\\n\\n        for (int[] dg : dig){\\n           uncovered[dg[0]][dg[1]] = true;\\n        }\\n        \\n        int ans = 0;\\n        \\n        loop: for (int k=0; k<artifacts.length; k++){\\n            \\n            for (int i=artifacts[k][0]; i<=artifacts[k][2]; i++){\\n                for (int j=artifacts[k][1]; j<=artifacts[k][3]; j++){\\n                    if (!uncovered[i][j])\\n                        continue loop;\\n                }\\n            }\\n            \\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849470,
                "title": "can-someone-tell-me-why-my-code-is-not-running-for-test-case-given-below",
                "content": "Test Case - \\n5\\n[[3,1,4,1],[1,1,2,2],[1,0,2,0],[4,3,4,4],[0,3,1,4],[2,3,3,4]]\\n[[0,0],[2,1],[2,0],[2,3],[4,3],[2,4],[4,1],[0,2],[4,0],[3,1],[1,2],[1,3],[3,2]]\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        int cnt=0;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        for(auto it:dig){\\n            vis[it[0]][it[1]]=true;\\n        }\\n        for(auto it:artifacts){\\n            int x1=it[0];\\n            int x2=it[1];\\n            int y1=it[2];\\n            int y2=it[3];\\n            bool flag=true;\\n            for(int i=x1;i<=x2;i++){\\n                for(int j=y1;j<=y2;j++){\\n                    if(!vis[i][j]){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        int cnt=0;\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        for(auto it:dig){\\n            vis[it[0]][it[1]]=true;\\n        }\\n        for(auto it:artifacts){\\n            int x1=it[0];\\n            int x2=it[1];\\n            int y1=it[2];\\n            int y2=it[3];\\n            bool flag=true;\\n            for(int i=x1;i<=x2;i++){\\n                for(int j=y1;j<=y2;j++){\\n                    if(!vis[i][j]){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849241,
                "title": "100-fast-of-all-java-solution",
                "content": "class Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        boolean[][] uncovered = new boolean[n][n];\\n        // Uncovered = false;\\n        for (int[] digged : dig) {\\n            uncovered[digged[0]][digged[1]] = true;\\n        }\\n        int count = 0;\\n        for (int[] artifact : artifacts) {\\n            boolean canBeExtracted = true;\\n            for (int i = artifact[0]; i <= artifact[2]; i++) {\\n                for (int j = artifact[1]; j <= artifact[3]; j++) {\\n                    if (!uncovered[i][j]) {\\n                        canBeExtracted = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (canBeExtracted) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        boolean[][] uncovered = new boolean[n][n];\\n        // Uncovered = false;\\n        for (int[] digged : dig) {\\n            uncovered[digged[0]][digged[1]] = true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1848595,
                "title": "slow-but-accepted-soln",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        \\n        def countAfterDig(artifact, dig):\\n            cnt = 0\\n            r1,c1,r2,c2 = artifact[0], artifact[1], artifact[2], artifact[3]\\n            for r in range(r1,r2+1):\\n                for c in range(c1,c2+1):\\n               \\n                    if (r,c) not in dig:\\n                        #print(r,c)\\n                        cnt = 1\\n                        break\\n                else:\\n                    # Continue if the inner loop wasn\\'t broken.\\n                    continue\\n                # Inner loop was broken, break the outer.\\n                break\\n            \\n            if cnt == 1:\\n                return 0\\n            else:\\n                return 1\\n        \\n        s = set()\\n        for d in dig:\\n            s.add( (d[0],d[1]) )    \\n        \\n        #print(s)\\n        uncovered = 0\\n        for artifact in artifacts:\\n            uncovered += countAfterDig(artifact, s)\\n        \\n        return uncovered\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        \\n        def countAfterDig(artifact, dig):\\n            cnt = 0\\n            r1,c1,r2,c2 = artifact[0], artifact[1], artifact[2], artifact[3]\\n            for r in range(r1,r2+1):\\n                for c in range(c1,c2+1):\\n               \\n                    if (r,c) not in dig:\\n                        #print(r,c)\\n                        cnt = 1\\n                        break\\n                else:\\n                    # Continue if the inner loop wasn\\'t broken.\\n                    continue\\n                # Inner loop was broken, break the outer.\\n                break\\n            \\n            if cnt == 1:\\n                return 0\\n            else:\\n                return 1\\n        \\n        s = set()\\n        for d in dig:\\n            s.add( (d[0],d[1]) )    \\n        \\n        #print(s)\\n        uncovered = 0\\n        for artifact in artifacts:\\n            uncovered += countAfterDig(artifact, s)\\n        \\n        return uncovered\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848166,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int ans = 0;\\n        \\n        boolean[][] dp = new boolean[n][n];\\n        boolean[][] visited = new boolean[n][n];\\n        \\n        for(int[] d : dig) {\\n            int r = d[0];\\n            int c = d[1];\\n            \\n            dp[r][c] = true;\\n        }\\n        \\n        for(int[] tmp : artifacts) {\\n            int sR = tmp[0];\\n            int sC = tmp[1];\\n            \\n            int eR = tmp[2];\\n            int eC = tmp[3];\\n            \\n            if(dfs(sR, sC, sR, sC, eR, eC, dp, visited)) {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    private boolean dfs(int i, int j, int s , int e, int r, int c, boolean[][] dp, boolean[][] visited ) {\\n        if( i < s || j < e || i > r || j > c || visited[i][j])\\n            return true;\\n        if(!dp[i][j])\\n            return false;\\n        visited[i][j] = true;\\n        \\n        return dfs(i+1, j, s, e, r, c, dp, visited) \\n            && dfs(i-1, j, s, e, r, c, dp, visited)\\n            && dfs(i, j+1, s, e, r, c, dp, visited)\\n            && dfs(i, j-1, s, e, r, c, dp, visited);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int ans = 0;\\n        \\n        boolean[][] dp = new boolean[n][n];\\n        boolean[][] visited = new boolean[n][n];\\n        \\n        for(int[] d : dig) {\\n            int r = d[0];\\n            int c = d[1];\\n            \\n            dp[r][c] = true;\\n        }\\n        \\n        for(int[] tmp : artifacts) {\\n            int sR = tmp[0];\\n            int sC = tmp[1];\\n            \\n            int eR = tmp[2];\\n            int eC = tmp[3];\\n            \\n            if(dfs(sR, sC, sR, sC, eR, eC, dp, visited)) {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    private boolean dfs(int i, int j, int s , int e, int r, int c, boolean[][] dp, boolean[][] visited ) {\\n        if( i < s || j < e || i > r || j > c || visited[i][j])\\n            return true;\\n        if(!dp[i][j])\\n            return false;\\n        visited[i][j] = true;\\n        \\n        return dfs(i+1, j, s, e, r, c, dp, visited) \\n            && dfs(i-1, j, s, e, r, c, dp, visited)\\n            && dfs(i, j+1, s, e, r, c, dp, visited)\\n            && dfs(i, j-1, s, e, r, c, dp, visited);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848145,
                "title": "java-hashing",
                "content": "```class Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        //typical Hashing problem\\n        int [][] hash = new int[n][n];//to store the hash of dig points inorder to compare...\\n        for(int[] row: hash){\\n             Arrays.fill(row,0);//Initialization\\n        }\\n        for(int[] a: dig){\\n            hash[a[0]][a[1]]=1;//to denote that these dig points are covering the artifact area or not\\n        }\\n        int cnt=0;\\n        for(int[] x: artifacts){\\n            int r1=x[0];//top-left x coordinate\\n            int c1=x[1];//top-left y coordinate\\n            int r2=x[2];//bottom-right x coordinate\\n            int c2=x[3];//bottom-right y coordinate\\n            boolean flag=true;\\n            for(int i=r1;i<=r2;i++){\\n                for(int j=c1;j<=c2;j++){\\n                    if(hash[i][j]==0){//checking if the dig point is not covering the artifact so this artifact can\\'t be uncovered\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==true) cnt++;\\n        }\\n        return cnt;\\n    }\\n}```\\nUpvote if you like the Solution...",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        //typical Hashing problem\\n        int [][] hash = new int[n][n];//to store the hash of dig points inorder to compare...\\n        for(int[] row: hash){\\n             Arrays.fill(row,0);//Initialization\\n        }\\n        for(int[] a: dig){\\n            hash[a[0]][a[1]]=1;//to denote that these dig points are covering the artifact area or not\\n        }\\n        int cnt=0;\\n        for(int[] x: artifacts){\\n            int r1=x[0];//top-left x coordinate\\n            int c1=x[1];//top-left y coordinate\\n            int r2=x[2];//bottom-right x coordinate\\n            int c2=x[3];//bottom-right y coordinate\\n            boolean flag=true;\\n            for(int i=r1;i<=r2;i++){\\n                for(int j=c1;j<=c2;j++){\\n                    if(hash[i][j]==0){//checking if the dig point is not covering the artifact so this artifact can\\'t be uncovered\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==true) cnt++;\\n        }\\n        return cnt;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1848124,
                "title": "python-concise-fast-solution",
                "content": "```python\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        mark = {(r, c) for r, c in dig}\\n        ans = 0\\n        def found(r1: int, c1: int, r2: int, c2: int) -> int:\\n            for r in range(r1, r2 + 1):\\n                for c in range(c1, c2 + 1):\\n                    if (r, c) not in mark:\\n                        return False\\n            return True\\n        for r1, c1, r2, c2 in artifacts:\\n            if found(r1, c1, r2, c2):\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        mark = {(r, c) for r, c in dig}\\n        ans = 0\\n        def found(r1: int, c1: int, r2: int, c2: int) -> int:\\n            for r in range(r1, r2 + 1):\\n                for c in range(c1, c2 + 1):\\n                    if (r, c) not in mark:\\n                        return False\\n            return True\\n        for r1, c1, r2, c2 in artifacts:\\n            if found(r1, c1, r2, c2):\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847716,
                "title": "c-using-array-hashing-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        int ans=0;        \\n        // creating hash array for dig array hashing\\n        vector<vector<int>> hash(n, vector<int>(n, 0));\\n        \\n        // hashing dig array\\n        for(auto &it: dig){\\n            hash[it[0]][it[1]]=1;\\n        }\\n        \\n        // checking hash checked places in array\\n        for(auto &it: artifacts){\\n            int x1=it[0];\\n            int y1=it[1];\\n            int x2=it[2];\\n            int y2=it[3];\\n            bool flag=true;\\n            for(int i=x1;i<=x2;i++){\\n                for(int j=y1;j<=y2;j++){\\n                    // breaking out of loop, because one cell gets none hashed in array\\n                    if(hash[i][j]==0){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            // incrementing the counter for answer\\n            ans+=flag;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        int ans=0;        \\n        // creating hash array for dig array hashing\\n        vector<vector<int>> hash(n, vector<int>(n, 0));\\n        \\n        // hashing dig array\\n        for(auto &it: dig){\\n            hash[it[0]][it[1]]=1;\\n        }\\n        \\n        // checking hash checked places in array\\n        for(auto &it: artifacts){\\n            int x1=it[0];\\n            int y1=it[1];\\n            int x2=it[2];\\n            int y2=it[3];\\n            bool flag=true;\\n            for(int i=x1;i<=x2;i++){\\n                for(int j=y1;j<=y2;j++){\\n                    // breaking out of loop, because one cell gets none hashed in array\\n                    if(hash[i][j]==0){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            // incrementing the counter for answer\\n            ans+=flag;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847532,
                "title": "c-intuitive",
                "content": "```\\npublic class Solution {\\n    public int DigArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int cnt = 0;\\n        bool[,] m = new bool[n, n];\\n\\n        foreach (int[] art in artifacts) {\\n            for (int rr = art[0]; rr <= art[2]; rr++) {\\n                for (int cc = art[1]; cc <= art[3]; cc++) {\\n                    m[rr, cc] = true;\\n                }\\n            }\\n        }\\n        foreach (int[] rem in dig) {\\n            m[rem[0], rem[1]] = false;\\n        }\\n\\n        foreach (var art in artifacts) {\\n            bool fullRem = true;\\n            for (int rr = art[0]; rr <= art[2] && fullRem; rr++) {\\n                for (int cc = art[1]; cc <= art[3] && fullRem; cc++) {\\n                    if (m[rr, cc] == true) {\\n                        fullRem = false;\\n                    }\\n                }\\n            }\\n            if (fullRem) cnt++;\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int DigArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int cnt = 0;\\n        bool[,] m = new bool[n, n];\\n\\n        foreach (int[] art in artifacts) {\\n            for (int rr = art[0]; rr <= art[2]; rr++) {\\n                for (int cc = art[1]; cc <= art[3]; cc++) {\\n                    m[rr, cc] = true;\\n                }\\n            }\\n        }\\n        foreach (int[] rem in dig) {\\n            m[rem[0], rem[1]] = false;\\n        }\\n\\n        foreach (var art in artifacts) {\\n            bool fullRem = true;\\n            for (int rr = art[0]; rr <= art[2] && fullRem; rr++) {\\n                for (int cc = art[1]; cc <= art[3] && fullRem; cc++) {\\n                    if (m[rr, cc] == true) {\\n                        fullRem = false;\\n                    }\\n                }\\n            }\\n            if (fullRem) cnt++;\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847499,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dig) {\\n        vector<vector<int>> g(n, vector<int>(n,0));\\n        for(auto it:dig){\\n            g[it[0]][it[1]]=1;\\n        }\\n        int c=0;\\n        for(auto it:a){\\n            int flag=0;\\n            for(int i=it[0];i<=it[2];i++){\\n                for(int j=it[1];j<=it[3];j++){\\n                    if(g[i][j]!=1){\\n                        flag=1;\\n                    }\\n                }\\n            }\\n            if(flag==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& a, vector<vector<int>>& dig) {\\n        vector<vector<int>> g(n, vector<int>(n,0));\\n        for(auto it:dig){\\n            g[it[0]][it[1]]=1;\\n        }\\n        int c=0;\\n        for(auto it:a){\\n            int flag=0;\\n            for(int i=it[0];i<=it[2];i++){\\n                for(int j=it[1];j<=it[3];j++){\\n                    if(g[i][j]!=1){\\n                        flag=1;\\n                    }\\n                }\\n            }\\n            if(flag==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847349,
                "title": "c-time-o-n-space-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>> digged(n, vector<bool>(n));\\n        \\n        for (auto& d : dig) {\\n            digged[d[0]][d[1]] = true;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for (auto& a : artifacts) {\\n            auto& top = a[0];\\n            auto& left = a[1];\\n            auto& bottom = a[2];\\n            auto& right = a[3];\\n            \\n            bool notDigged = false;\\n            for (int i = top; i <= bottom; ++i) {\\n                for (int j = left; j <= right; ++j) {\\n                    if (digged[i][j] == false) {\\n                        notDigged = true;\\n                        break;\\n                    }\\n                }\\n                \\n                if (notDigged) {\\n                    break;\\n                }\\n            }\\n            \\n            if (!notDigged) {\\n                ++ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<bool>> digged(n, vector<bool>(n));\\n        \\n        for (auto& d : dig) {\\n            digged[d[0]][d[1]] = true;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for (auto& a : artifacts) {\\n            auto& top = a[0];\\n            auto& left = a[1];\\n            auto& bottom = a[2];\\n            auto& right = a[3];\\n            \\n            bool notDigged = false;\\n            for (int i = top; i <= bottom; ++i) {\\n                for (int j = left; j <= right; ++j) {\\n                    if (digged[i][j] == false) {\\n                        notDigged = true;\\n                        break;\\n                    }\\n                }\\n                \\n                if (notDigged) {\\n                    break;\\n                }\\n            }\\n            \\n            if (!notDigged) {\\n                ++ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847286,
                "title": "java-easy-to-understand-hashset",
                "content": "class Cell{\\n\\tint rowIndex;\\n\\tint columnIndex;\\n\\tpublic Cell(int rowIndex, int columnIndex) {\\n\\t\\tthis.rowIndex = rowIndex;\\n\\t\\tthis.columnIndex = columnIndex;\\n\\t}\\n\\t@Override\\n\\tpublic boolean equals(Object c) {\\n\\t\\tCell toCompare = (Cell)c;\\n\\t\\treturn toCompare.columnIndex == this.columnIndex && toCompare.rowIndex == this.rowIndex;\\n\\t}\\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(rowIndex, columnIndex);\\n    }\\n\\t\\n}\\npublic class CountArtifacts {\\n    public static int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n    \\tint result=0;\\n    \\tSet<Cell> digs = new HashSet<Cell>();\\n    \\tfor(int[] d : dig) {\\n    \\t\\tdigs.add(new Cell(d[0], d[1]));\\n    \\t}\\n    \\tfor(int[] artifact : artifacts) {\\n    \\t\\t\\n    \\t\\tint firstCellRow = artifact[0];\\n    \\t\\tint firstCellColumn = artifact[1];\\n    \\t\\tint lastCellRow = artifact[2];\\n    \\t\\tint lastCellColumn = artifact[3];\\n    \\t\\tCell firstCell = new Cell(firstCellRow, firstCellColumn);\\n    \\t\\tCell lastCell = new Cell(lastCellRow, lastCellColumn);\\n    \\t\\tif(!digs.contains(firstCell) || !digs.contains(lastCell)) {\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif(firstCellRow == lastCellRow && firstCellColumn == lastCellColumn) {\\n    \\t\\t\\t\\tresult++;\\n    \\t\\t}else if(firstCellRow == lastCellRow) {\\n    \\t\\t\\tCell nextcell = null;\\n    \\t\\t\\tint nextCellColum = firstCellColumn;\\n    \\t\\t\\tboolean misMatchFound = false;\\n    \\t\\t\\twhile(nextCellColum < lastCellColumn) {\\n    \\t\\t\\t\\tnextcell = new Cell(firstCellRow, ++nextCellColum);\\n    \\t\\t\\t\\tif(!digs.contains(nextcell)) {\\n    \\t\\t\\t\\t\\tmisMatchFound = true;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif(misMatchFound) {\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tresult++;\\n    \\t\\t}else if(firstCellColumn == lastCellColumn) {\\n    \\t\\t\\tCell nextcell = null;\\n    \\t\\t\\tint nextCellrow = firstCellRow;\\n    \\t\\t\\tboolean misMatchFound = false;\\n    \\t\\t\\twhile(nextCellrow < lastCellRow) {\\n    \\t\\t\\t\\tnextcell = new Cell(++nextCellrow, firstCellColumn);\\n    \\t\\t\\t\\tif(!digs.contains(nextcell)) {\\n    \\t\\t\\t\\t\\tmisMatchFound = true;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif(misMatchFound) {\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tresult++;\\n    \\t\\t}else{\\n    \\t\\t\\tCell secondCell = null;\\n    \\t\\t\\tCell thirdCell = null;\\n    \\t\\t\\tif(firstCellColumn+1<n) {\\n    \\t\\t\\t\\tsecondCell = new Cell(firstCellRow, firstCellColumn+1);\\n    \\t\\t\\t}\\n    \\t\\t\\tif(lastCellColumn-1>=0) {\\n    \\t\\t\\t\\tthirdCell = new Cell(lastCellRow, lastCellColumn-1);\\n    \\t\\t\\t}\\n    \\t\\t\\t\\n    \\t\\t\\tif(secondCell!=null && digs.contains(secondCell) && thirdCell!=null && digs.contains(thirdCell) ) {\\n    \\t\\t\\t\\tresult++;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\t\\n    \\t}\\n    \\t\\t\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "class Cell{\\n\\tint rowIndex;\\n\\tint columnIndex;\\n\\tpublic Cell(int rowIndex, int columnIndex) {\\n\\t\\tthis.rowIndex = rowIndex;\\n\\t\\tthis.columnIndex = columnIndex;\\n\\t}\\n\\t@Override\\n\\tpublic boolean equals(Object c) {\\n\\t\\tCell toCompare = (Cell)c;\\n\\t\\treturn toCompare.columnIndex == this.columnIndex && toCompare.rowIndex == this.rowIndex;\\n\\t}\\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(rowIndex, columnIndex);\\n    }\\n\\t\\n}\\npublic class CountArtifacts {\\n    public static int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n    \\tint result=0;\\n    \\tSet<Cell> digs = new HashSet<Cell>();\\n    \\tfor(int[] d : dig) {\\n    \\t\\tdigs.add(new Cell(d[0], d[1]));\\n    \\t}\\n    \\tfor(int[] artifact : artifacts) {\\n    \\t\\t\\n    \\t\\tint firstCellRow = artifact[0];\\n    \\t\\tint firstCellColumn = artifact[1];\\n    \\t\\tint lastCellRow = artifact[2];\\n    \\t\\tint lastCellColumn = artifact[3];\\n    \\t\\tCell firstCell = new Cell(firstCellRow, firstCellColumn);\\n    \\t\\tCell lastCell = new Cell(lastCellRow, lastCellColumn);\\n    \\t\\tif(!digs.contains(firstCell) || !digs.contains(lastCell)) {\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif(firstCellRow == lastCellRow && firstCellColumn == lastCellColumn) {\\n    \\t\\t\\t\\tresult++;\\n    \\t\\t}else if(firstCellRow == lastCellRow) {\\n    \\t\\t\\tCell nextcell = null;\\n    \\t\\t\\tint nextCellColum = firstCellColumn;\\n    \\t\\t\\tboolean misMatchFound = false;\\n    \\t\\t\\twhile(nextCellColum < lastCellColumn) {\\n    \\t\\t\\t\\tnextcell = new Cell(firstCellRow, ++nextCellColum);\\n    \\t\\t\\t\\tif(!digs.contains(nextcell)) {\\n    \\t\\t\\t\\t\\tmisMatchFound = true;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif(misMatchFound) {\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tresult++;\\n    \\t\\t}else if(firstCellColumn == lastCellColumn) {\\n    \\t\\t\\tCell nextcell = null;\\n    \\t\\t\\tint nextCellrow = firstCellRow;\\n    \\t\\t\\tboolean misMatchFound = false;\\n    \\t\\t\\twhile(nextCellrow < lastCellRow) {\\n    \\t\\t\\t\\tnextcell = new Cell(++nextCellrow, firstCellColumn);\\n    \\t\\t\\t\\tif(!digs.contains(nextcell)) {\\n    \\t\\t\\t\\t\\tmisMatchFound = true;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif(misMatchFound) {\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tresult++;\\n    \\t\\t}else{\\n    \\t\\t\\tCell secondCell = null;\\n    \\t\\t\\tCell thirdCell = null;\\n    \\t\\t\\tif(firstCellColumn+1<n) {\\n    \\t\\t\\t\\tsecondCell = new Cell(firstCellRow, firstCellColumn+1);\\n    \\t\\t\\t}\\n    \\t\\t\\tif(lastCellColumn-1>=0) {\\n    \\t\\t\\t\\tthirdCell = new Cell(lastCellRow, lastCellColumn-1);\\n    \\t\\t\\t}\\n    \\t\\t\\t\\n    \\t\\t\\tif(secondCell!=null && digs.contains(secondCell) && thirdCell!=null && digs.contains(thirdCell) ) {\\n    \\t\\t\\t\\tresult++;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\t\\n    \\t}\\n    \\t\\t\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1847276,
                "title": "python3-just-follow-the-hint-check-the-artifact-one-by-one",
                "content": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        isDig = [[False] * n for _ in range(n)]\\n        for r, c in dig:\\n            isDig[r][c] = True\\n        ans = len(artifacts)\\n        for r1, c1, r2, c2 in artifacts:\\n            flg = False\\n            for r in range(r1, r2 + 1):\\n                if flg:\\n                    break\\n                for c in range(c1, c2 + 1):\\n                    if not isDig[r][c]:\\n                        ans -= 1\\n                        flg = True\\n                        break\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n        isDig = [[False] * n for _ in range(n)]\\n        for r, c in dig:\\n            isDig[r][c] = True\\n        ans = len(artifacts)\\n        for r1, c1, r2, c2 in artifacts:\\n            flg = False\\n            for r in range(r1, r2 + 1):\\n                if flg:\\n                    break\\n                for c in range(c1, c2 + 1):\\n                    if not isDig[r][c]:\\n                        ans -= 1\\n                        flg = True\\n                        break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847026,
                "title": "python-set-solution-o-n-m-n-number-of-artifacts-points-m-length-of-dig-list",
                "content": "We could check whether number of discovered points equals to area for each artifact. If they are equal means that this artifact is extracted. The first term could calculated by checking set of dig coord and the second term is (r2-r1+1)* (c2-c1+1).\\n\\nTime Comp: O( N+M) N:Number of artifacts points. M: Length of dig array\\nSpace Comp: O(M)\\n\\n```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n              \\n        dig_set = set()\\n        \\n        for r, c in dig:\\n            dig_set.add((r,c))\\n        \\n        result = 0\\n        \\n        for r1, c1, r2, c2 in artifacts:\\n            area_size = (r2-r1+1)*(c2-c1+1)\\n            \\n            for r in range(r1, r2+1):\\n                for c in range(c1, c2+1):\\n                    if((r,c) in dig_set):\\n                        area_size-=1\\n            if(area_size == 0):\\n                result+=1\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\\n              \\n        dig_set = set()\\n        \\n        for r, c in dig:\\n            dig_set.add((r,c))\\n        \\n        result = 0\\n        \\n        for r1, c1, r2, c2 in artifacts:\\n            area_size = (r2-r1+1)*(c2-c1+1)\\n            \\n            for r in range(r1, r2+1):\\n                for c in range(c1, c2+1):\\n                    if((r,c) in dig_set):\\n                        area_size-=1\\n            if(area_size == 0):\\n                result+=1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847016,
                "title": "count-artifacts-that-can-be-extracted",
                "content": "**\\nApproach:\\nfirst of all i created a simple nXn grid and filled it with INT_MAX value.\\nBy intialising all the grid Cell to INT_MAX can be used as flag to check whether it belog to the cell of ith artifacts;\\n\\nit will be more clear from my code;\\n**\\n**\\ntime complexity :-  O(m+n);\\nwhere m length of Artifacts array & n is size of dig array.\\n\\nspace complexity :-  O(m);\\n\\n**\\n\\n***\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig)\\n\\t\\t{\\n\\t\\t\\tint m;//size of artifacts array\\n\\t\\t\\tm=artifacts.size();\\n\\t\\t\\t//creating a flag which stores the count of all the cells for ith artifacts\\n\\t\\t\\tvector<int> flag(m,0); \\n\\t\\t\\t??Creating a nXn grid\\n\\t\\t\\tvector<vector<int>> grid(1000,vector<int>(1000,INT_MAX));\\n\\t\\t\\tfor(int i=0;i<m;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint sr,er,sc,ec;\\n\\t\\t\\t\\tsr=artifacts[i][0];\\n\\t\\t\\t\\ter=artifacts[i][2];\\n\\t\\t\\t\\tsc=artifacts[i][1];\\n\\t\\t\\t\\tec=artifacts[i][3];\\n\\t\\t\\t\\tfor(int x=sr;x<=er;x++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor(int y=sc;y<=ec;y++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(grid[x][y]==INT_MAX)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tflag[i]++;\\n\\t\\t\\t\\t\\t\\t\\tgrid[x][y]=i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(auto x:dig)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(grid[x[0]][x[1]]!=INT_MAX)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tflag[grid[x[0]][x[1]]]--;\\n\\t\\t\\t\\t\\tgrid[x[0]][x[1]]=INT_MAX;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn count(flag.begin(),flag.end(),0);\\n\\t\\t}\\n\\t};\\n\\n***\\n\\n**\\n**# If approach is good enough to help you out please upvote & suggestions are always welcomed;**\\n**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig)\\n\\t\\t{\\n\\t\\t\\tint m;//size of artifacts array\\n\\t\\t\\tm=artifacts.size();\\n\\t\\t\\t//creating a flag which stores the count of all the cells for ith artifacts\\n\\t\\t\\tvector<int> flag(m,0); \\n\\t\\t\\t??Creating a nXn grid\\n\\t\\t\\tvector<vector<int>> grid(1000,vector<int>(1000,INT_MAX));\\n\\t\\t\\tfor(int i=0;i<m;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint sr,er,sc,ec;\\n\\t\\t\\t\\tsr=artifacts[i][0];\\n\\t\\t\\t\\ter=artifacts[i][2];\\n\\t\\t\\t\\tsc=artifacts[i][1];\\n\\t\\t\\t\\tec=artifacts[i][3];\\n\\t\\t\\t\\tfor(int x=sr;x<=er;x++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor(int y=sc;y<=ec;y++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(grid[x][y]==INT_MAX)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tflag[i]++;\\n\\t\\t\\t\\t\\t\\t\\tgrid[x][y]=i;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1846985,
                "title": "count-artifacts-that-can-be-extracted-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) \\n    {\\n        int[][] d=new int[n][n];\\n        for(int i=0;i<dig.length;i++)\\n        {\\n            int x=dig[i][0];\\n            int y=dig[i][1];\\n            d[x][y]=1;\\n        }\\n        int c=0;\\n        for(int i=0;i<artifacts.length;i++)\\n        {\\n            int x1=artifacts[i][0];\\n            int y1=artifacts[i][1];\\n            int x2=artifacts[i][2];\\n            int y2=artifacts[i][3];\\n            int flag=0;\\n            for(int j=x1;j<=x2;j++)\\n            {\\n                for(int k=y1;k<=y2;k++)\\n                {\\n                    if(d[j][k]!=1)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==0)\\n                    c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) \\n    {\\n        int[][] d=new int[n][n];\\n        for(int i=0;i<dig.length;i++)\\n        {\\n            int x=dig[i][0];\\n            int y=dig[i][1];\\n            d[x][y]=1;\\n        }\\n        int c=0;\\n        for(int i=0;i<artifacts.length;i++)\\n        {\\n            int x1=artifacts[i][0];\\n            int y1=artifacts[i][1];\\n            int x2=artifacts[i][2];\\n            int y2=artifacts[i][3];\\n            int flag=0;\\n            for(int j=x1;j<=x2;j++)\\n            {\\n                for(int k=y1;k<=y2;k++)\\n                {\\n                    if(d[j][k]!=1)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==0)\\n                    c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846955,
                "title": "javascript-faster-than-100-00-memory-usage-less-than-100-00-answer",
                "content": "var digArtifacts = function (n, artifacts, dig) {\\n  const arr = Array.from(Array(n), () => Array(n).fill(false));\\n  let answer = 0;\\n  const coordinates = {};\\n\\n  for (let idx = 0; idx < artifacts.length; idx++) {\\n    const artifact = artifacts[idx];\\n    const [r1, c1, r2, c2] = artifact;\\n\\n    for (let r = r1; r <= r2; r++) {\\n      for (let c = c1; c <= c2; c++) {\\n        const elem = [r, c];\\n        coordinates[idx]\\n          ? coordinates[idx].push(elem)\\n          : (coordinates[idx] = [elem]);\\n      }\\n    }\\n  }\\n\\n  dig.forEach((elem) => {\\n    const [x, y] = elem;\\n    arr[x][y] = true;\\n  });\\n\\n  for (let idx = 0; idx < artifacts.length; idx++) {\\n    let diged = true;\\n    const artifact = coordinates[idx];\\n    artifact.forEach((elem, idx) => {\\n      const [x, y] = elem;\\n      if (!arr[x][y]) diged = false;\\n      if (artifact.length === idx + 1 && diged) answer++;\\n    });\\n  }\\n\\n  return answer;\\n};\\n",
                "solutionTags": [],
                "code": "var digArtifacts = function (n, artifacts, dig) {\\n  const arr = Array.from(Array(n), () => Array(n).fill(false));\\n  let answer = 0;\\n  const coordinates = {};\\n\\n  for (let idx = 0; idx < artifacts.length; idx++) {\\n    const artifact = artifacts[idx];\\n    const [r1, c1, r2, c2] = artifact;\\n\\n    for (let r = r1; r <= r2; r++) {\\n      for (let c = c1; c <= c2; c++) {\\n        const elem = [r, c];\\n        coordinates[idx]\\n          ? coordinates[idx].push(elem)\\n          : (coordinates[idx] = [elem]);\\n      }\\n    }\\n  }\\n\\n  dig.forEach((elem) => {\\n    const [x, y] = elem;\\n    arr[x][y] = true;\\n  });\\n\\n  for (let idx = 0; idx < artifacts.length; idx++) {\\n    let diged = true;\\n    const artifact = coordinates[idx];\\n    artifact.forEach((elem, idx) => {\\n      const [x, y] = elem;\\n      if (!arr[x][y]) diged = false;\\n      if (artifact.length === idx + 1 && diged) answer++;\\n    });\\n  }\\n\\n  return answer;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1846865,
                "title": "c-easy-solution-hashing",
                "content": "**Time Complexity : O(N^2)\\nSpace Complexity : O(N^2)**\\n```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> hash(n, vector<int>(n,0));\\n        for(auto it : dig){\\n            hash[it[0]][it[1]] = 1;\\n        }\\n        int cnt = 0;\\n        for(auto it : artifacts){\\n            int x1 = it[0];\\n            int y1 = it[1];\\n            int x2 = it[2];\\n            int y2 = it[3];\\n            bool fl = true;\\n            for(int i = x1; i<= x2 and fl; i++){\\n                for(int j = y1; j<=y2; j++){\\n                    if(hash[i][j] == 0){\\n                        fl=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            cnt+=fl;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\\n        vector<vector<int>> hash(n, vector<int>(n,0));\\n        for(auto it : dig){\\n            hash[it[0]][it[1]] = 1;\\n        }\\n        int cnt = 0;\\n        for(auto it : artifacts){\\n            int x1 = it[0];\\n            int y1 = it[1];\\n            int x2 = it[2];\\n            int y2 = it[3];\\n            bool fl = true;\\n            for(int i = x1; i<= x2 and fl; i++){\\n                for(int j = y1; j<=y2; j++){\\n                    if(hash[i][j] == 0){\\n                        fl=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            cnt+=fl;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846855,
                "title": "java-easy-simple-using-map",
                "content": "Hello,\\nWhat i did here, is to count the each artifacts size, like [0,0,1,1] is of size 4, if the index of this array in artifacts is 1, I placed in the map as 1-->4, also made an array where I kept  1 at four places, and simlarly for other indices, \\nand using dig just decreased the count in the map, if count reached zero, then 1 artifact was completely digged,\\n\\nJust keep Practicing, other things will come.\\n\\n\\n```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] a, int[][] dig) {\\n       // ArrayList<int[]> ans=new ArrayList<int[]>();\\n        int len=a.length;\\n        int b[][]=new int[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                b[i][j]=-1;\\n        }\\n        Map<Integer,Integer> m=new HashMap<Integer,Integer>();\\n        for(int i=0;i<len;i++)\\n        {\\n           int c=0;\\n                for(int j=a[i][0];j<=a[i][2];j++)\\n                {\\n                    for(int k=a[i][1];k<=a[i][3];k++)\\n                    {\\n                        if(j<n && k<n)\\n                        {b[j][k]=i;\\n                        c++;}\\n                    }\\n                }\\n              System.out.println(c+\" \"+i);  \\n            m.put(i,c);\\n                \\n            }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            System.out.println(Arrays.toString(b[i]));\\n        }\\n        System.out.println(m);\\n        int l1=dig.length;\\n        for(int i=0;i<l1;i++)\\n        {\\n            int u[]=dig[i];\\n            int pos=b[u[0]][u[1]];\\n            if(m.containsKey(pos))\\n            m.put(pos,m.get(pos)-1);\\n        }\\n        int ans=0;\\n        for(Map.Entry<Integer,Integer> hm: m.entrySet())\\n        {\\n            if(hm.getValue()<=0)\\n                ans++;\\n        }\\n        System.out.println(m);\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int digArtifacts(int n, int[][] a, int[][] dig) {\\n       // ArrayList<int[]> ans=new ArrayList<int[]>();\\n        int len=a.length;\\n        int b[][]=new int[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                b[i][j]=-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1846714,
                "title": "java-solution-using-set",
                "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int res = 0;\\n        Set<String> set = new HashSet<>();\\n        for (int[] i: dig) {\\n            set.add(i[0]+\" \"+i[1]);\\n        }\\n        for (int[] artifact: artifacts) {\\n            int r1 = artifact[0];\\n            int c1 = artifact[1];\\n            int r2 = artifact[2];\\n            int c2 = artifact[3];\\n            boolean found = true;\\n            for (;r1<=r2;r1++) {\\n                for(int c=c1;c<=c2;c++) {\\n                    if (!set.contains(r1+\" \"+c)) {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (found) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int res = 0;\\n        Set<String> set = new HashSet<>();\\n        for (int[] i: dig) {\\n            set.add(i[0]+\" \"+i[1]);\\n        }\\n        for (int[] artifact: artifacts) {\\n            int r1 = artifact[0];\\n            int c1 = artifact[1];\\n            int r2 = artifact[2];\\n            int c2 = artifact[3];\\n            boolean found = true;\\n            for (;r1<=r2;r1++) {\\n                for(int c=c1;c<=c2;c++) {\\n                    if (!set.contains(r1+\" \"+c)) {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (found) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846665,
                "title": "golang-simple-map-solution",
                "content": "```go\\nfunc digArtifacts(n int, artifacts [][]int, dig [][]int) int {\\n\\topen := make(map[[2]int]bool, len(dig))\\n\\tfor _, d := range dig {\\n\\t\\topen[[2]int{d[0], d[1]}] = true\\n\\t}\\n\\textract := 0\\nloop:\\n\\tfor _, artifact := range artifacts {\\n\\t\\tfor r := artifact[0]; r <= artifact[2]; r++ {\\n\\t\\t\\tfor c := artifact[1]; c <= artifact[3]; c++ {\\n\\t\\t\\t\\tif open[[2]int{r, c}] == false {\\n\\t\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\textract++\\n\\t}\\n\\treturn extract\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc digArtifacts(n int, artifacts [][]int, dig [][]int) int {\\n\\topen := make(map[[2]int]bool, len(dig))\\n\\tfor _, d := range dig {\\n\\t\\topen[[2]int{d[0], d[1]}] = true\\n\\t}\\n\\textract := 0\\nloop:\\n\\tfor _, artifact := range artifacts {\\n\\t\\tfor r := artifact[0]; r <= artifact[2]; r++ {\\n\\t\\t\\tfor c := artifact[1]; c <= artifact[3]; c++ {\\n\\t\\t\\t\\tif open[[2]int{r, c}] == false {\\n\\t\\t\\t\\t\\tcontinue loop\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\textract++\\n\\t}\\n\\treturn extract\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1846311,
                "title": "javascript-virtual-map-solution-sorry-no-have-idea-to-naming-the-solution",
                "content": "When I see the image in the example, it inspires me to come up with this idea. The concept is to create a virtual 2D map. There are four steps to follow:\\n\\n1. make a nxn 2D `virtualMap` (See examples picture in the question)\\n2. make an array of `artifactsSize` values.\\n3. iterate over the dig array, reducing `artifactSize` if an artifact can be found in a dig element\\n4. return the count of `artifactsSize` element that are 0\\n\\n``` javascript\\n/**\\n * @param {number} n\\n * @param {number[][]} artifacts\\n * @param {number[][]} dig\\n * @return {number}\\n */\\nvar digArtifacts = function(n, artifacts, dig) {\\n   // Step 1\\n    const virtualMap = [] // 0 = null, n = artifact_n\\n    for (let x = 0; x< n; x++){\\n        const row = []\\n        for(let y = 0; y<n; y++){\\n            row.push(0)\\n        }\\n        virtualMap.push(row)\\n    }\\n\\t\\n\\t// Step 2\\n    const artifactSize = []\\n    for(let artifactIdx in artifacts){\\n        let [artY1, artX1, artY2, artX2] = artifacts[artifactIdx]\\n        artifactSize.push((artX2 + 1 - artX1) * (artY2 + 1 - artY1))\\n        while(artY1 <= artY2){\\n            while(artX1 <= artX2){\\n                virtualMap[artY1][artX1] = Number(artifactIdx)+1\\n                artX1++\\n            }\\n            artY1++\\n            artX1 = artifacts[artifactIdx][1]\\n        }\\n    }\\n\\n    // Step 3\\n    for(let digComp of dig){\\n        const [digY, digX] = digComp\\n        const content = virtualMap[digY][digX]\\n        if(content !== 0){\\n            artifactSize[content-1] -= 1 \\n        }\\n    }\\n\\n    // Step 4\\n    return artifactSize.reduce((acc, remainder) => {\\n        if(remainder === 0){\\n            acc++\\n        }\\n        return acc\\n    }, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number} n\\n * @param {number[][]} artifacts\\n * @param {number[][]} dig\\n * @return {number}\\n */\\nvar digArtifacts = function(n, artifacts, dig) {\\n   // Step 1\\n    const virtualMap = [] // 0 = null, n = artifact_n\\n    for (let x = 0; x< n; x++){\\n        const row = []\\n        for(let y = 0; y<n; y++){\\n            row.push(0)\\n        }\\n        virtualMap.push(row)\\n    }\\n\\t\\n\\t// Step 2\\n    const artifactSize = []\\n    for(let artifactIdx in artifacts){\\n        let [artY1, artX1, artY2, artX2] = artifacts[artifactIdx]\\n        artifactSize.push((artX2 + 1 - artX1) * (artY2 + 1 - artY1))\\n        while(artY1 <= artY2){\\n            while(artX1 <= artX2){\\n                virtualMap[artY1][artX1] = Number(artifactIdx)+1\\n                artX1++\\n            }\\n            artY1++\\n            artX1 = artifacts[artifactIdx][1]\\n        }\\n    }\\n\\n    // Step 3\\n    for(let digComp of dig){\\n        const [digY, digX] = digComp\\n        const content = virtualMap[digY][digX]\\n        if(content !== 0){\\n            artifactSize[content-1] -= 1 \\n        }\\n    }\\n\\n    // Step 4\\n    return artifactSize.reduce((acc, remainder) => {\\n        if(remainder === 0){\\n            acc++\\n        }\\n        return acc\\n    }, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1846120,
                "title": "java-solution",
                "content": "Simulating the whole process.\\nFirst make the matrix of land map which has sand all over(which initally marked with 0 as default).\\nWe are given the top left and bottom right coordinate of the artifact. Mark every cells that comes under the given coordinate system with a unique number identifying unique artifact. \\nAlso we will have a hashmap of the artifact number and it\\'s total area(total number of cells covered under that artifact). \\nNow we will dig the land as given. If in the matrix the land is not sand which can be identify by it\\'s value on matrix (value > 0) (which is the number of any artifact) then dig that land and decrease 1 from it\\'s total area covered. if the total area comes down to 0 that means whole artifact is uncovered.\\n\\n```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int landMap[][] = new int[n][n], landNum = 1, artifactsUncovered = 0;\\n        Map<Integer, Integer> artifactSize = new HashMap<>();\\n        \\n        for(int[] artifact : artifacts){\\n            int startX = artifact[0], endX = artifact[2], \\n            startY = artifact[1], endY = artifact[3];\\n            markArtifactOnMap(startX, endX, startY, endY, landMap, landNum);\\n            artifactSize.put(landNum++, (endX - startX +1) * (endY - startY +1));\\n        }\\n        \\n        for(int[] digXY : dig){\\n            int i = digXY[0], j = digXY[1];\\n            if(landMap[i][j] > 0){\\n                artifactSize.put(landMap[i][j], artifactSize.get(landMap[i][j]) -1);\\n                if(artifactSize.get(landMap[i][j]) == 0)\\n                    artifactsUncovered++;\\n            }\\n        }\\n        return artifactsUncovered;\\n    }\\n    \\n    private void markArtifactOnMap(int startX, int endX, int startY, int endY, int[][] landMap, int landNum)    {\\n        for(int i = startX; i<=endX;i++)\\n            for(int j = startY ; j<=endY; j++)\\n                landMap[i][j] = landNum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        int landMap[][] = new int[n][n], landNum = 1, artifactsUncovered = 0;\\n        Map<Integer, Integer> artifactSize = new HashMap<>();\\n        \\n        for(int[] artifact : artifacts){\\n            int startX = artifact[0], endX = artifact[2], \\n            startY = artifact[1], endY = artifact[3];\\n            markArtifactOnMap(startX, endX, startY, endY, landMap, landNum);\\n            artifactSize.put(landNum++, (endX - startX +1) * (endY - startY +1));\\n        }\\n        \\n        for(int[] digXY : dig){\\n            int i = digXY[0], j = digXY[1];\\n            if(landMap[i][j] > 0){\\n                artifactSize.put(landMap[i][j], artifactSize.get(landMap[i][j]) -1);\\n                if(artifactSize.get(landMap[i][j]) == 0)\\n                    artifactsUncovered++;\\n            }\\n        }\\n        return artifactsUncovered;\\n    }\\n    \\n    private void markArtifactOnMap(int startX, int endX, int startY, int endY, int[][] landMap, int landNum)    {\\n        for(int i = startX; i<=endX;i++)\\n            for(int j = startY ; j<=endY; j++)\\n                landMap[i][j] = landNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1856590,
                "content": [
                    {
                        "username": "asutosh117",
                        "content": "Artifact of 4-length can lie horizontally or vertically not necessarily as the description says us. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "even simple brute force works due to the non overlapping constraints."
                    }
                ]
            },
            {
                "id": 1800779,
                "content": [
                    {
                        "username": "asutosh117",
                        "content": "Artifact of 4-length can lie horizontally or vertically not necessarily as the description says us. "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "even simple brute force works due to the non overlapping constraints."
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Collisions on a Road",
        "question_content": "<p>There are <code>n</code> cars on an infinitely long road. The cars are numbered from <code>0</code> to <code>n - 1</code> from left to right and each car is present at a <strong>unique</strong> point.</p>\n\n<p>You are given a <strong>0-indexed</strong> string <code>directions</code> of length <code>n</code>. <code>directions[i]</code> can be either <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, or <code>&#39;S&#39;</code> denoting whether the <code>i<sup>th</sup></code> car is moving towards the <strong>left</strong>, towards the <strong>right</strong>, or <strong>staying</strong> at its current point respectively. Each moving car has the <strong>same speed</strong>.</p>\n\n<p>The number of collisions can be calculated as follows:</p>\n\n<ul>\n\t<li>When two cars moving in <strong>opposite</strong> directions collide with each other, the number of collisions increases by <code>2</code>.</li>\n\t<li>When a moving car collides with a stationary car, the number of collisions increases by <code>1</code>.</li>\n</ul>\n\n<p>After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.</p>\n\n<p>Return <em>the <strong>total number of collisions</strong> that will happen on the road</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> directions = &quot;RLRSLL&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nThe collisions that will happen on the road are:\n- Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.\n- Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.\n- Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.\n- Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.\nThus, the total number of collisions that will happen on the road is 5. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> directions = &quot;LLRR&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\nNo cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= directions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>directions[i]</code> is either <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, or <code>&#39;S&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1865669,
                "title": "easy-understanding-tc-o-n-sc-o-1",
                "content": "```\\n/*\\ncars on left side which are moving in left direction are never going to collide,\\nSimilarly, cars on right side which are moving right side are never going to collide.\\n\\nIn between them every car is going to collide.\\n*/\\n\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int left = 0, right = directions.length() - 1;\\n        \\n        while (left < directions.length() && directions.charAt(left) == \\'L\\') {\\n            left++;\\n        }\\n        \\n        while (right >= 0 && directions.charAt(right) == \\'R\\') {\\n            right--;\\n        }\\n        \\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (directions.charAt(i) != \\'S\\') {\\n                count++;\\n            }\\n        }\\n\\t\\t//combining these three loops - TC : O(N).\\n        \\n        return count;\\n    }\\n}\\n```\\n\\nTC : O(N)\\nSC : O(1)\\n\\nFeel free to upvote : )",
                "solutionTags": [],
                "code": "```\\n/*\\ncars on left side which are moving in left direction are never going to collide,\\nSimilarly, cars on right side which are moving right side are never going to collide.\\n\\nIn between them every car is going to collide.\\n*/\\n\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int left = 0, right = directions.length() - 1;\\n        \\n        while (left < directions.length() && directions.charAt(left) == \\'L\\') {\\n            left++;\\n        }\\n        \\n        while (right >= 0 && directions.charAt(right) == \\'R\\') {\\n            right--;\\n        }\\n        \\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (directions.charAt(i) != \\'S\\') {\\n                count++;\\n            }\\n        }\\n\\t\\t//combining these three loops - TC : O(N).\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865557,
                "title": "not-a-stupid-problem",
                "content": "**Similar Question :-** [ https://leetcode.com/problems/asteroid-collision/]\\n**C++ Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        \\n        int res(0), n(size(dir)), i(0), carsFromRight(0);\\n        \\n        while (i < n and dir[i] == \\'L\\') i++; // skipping all the cars going to left from beginning as they will never collide\\n        \\n        for ( ; i<n; i++) {\\n            if (dir[i] == \\'R\\')  carsFromRight++;\\n            else {\\n                // if dir[i] == \\'S\\' then there will be carsFromRight number of collission\\n                // if dir[i] == \\'L\\' then there will be carsFromRight+1 number of collision (one collision for the rightmost cars and carsFromRight collision for the cars coming from left)\\n                res += (dir[i] == \\'S\\') ? carsFromRight : carsFromRight+1;\\n                carsFromRight = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Java Solution**\\n\\n```\\nclass Solution {\\n    public int countCollisions(String dir) {\\n        \\n        int res = 0, n = dir.length(), i = 0, carsFromRight = 0;\\n        \\n        while (i < n && dir.charAt(i) == \\'L\\') i++;\\n        \\n        for ( ; i<n; i++) {\\n            if (dir.charAt(i) == \\'R\\')  carsFromRight++;\\n            else {\\n                res += (dir.charAt(i) == \\'S\\') ? carsFromRight : carsFromRight+1;\\n                carsFromRight = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n**Python Solution**\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        \\n        res, n, i, carsFromRight = 0, len(directions), 0, 0\\n        \\n        while i < n and directions[i] == \\'L\\':\\n               i+=1\\n        \\n        while i<n:\\n            if directions[i] == \\'R\\':\\n                carsFromRight+=1\\n            else:\\n                res += carsFromRight if directions[i] == \\'S\\' else carsFromRight+1;\\n                carsFromRight = 0\\n            i+=1\\n                \\n        return res\\n```\\n**Upvote if it helps :)**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        \\n        int res(0), n(size(dir)), i(0), carsFromRight(0);\\n        \\n        while (i < n and dir[i] == \\'L\\') i++; // skipping all the cars going to left from beginning as they will never collide\\n        \\n        for ( ; i<n; i++) {\\n            if (dir[i] == \\'R\\')  carsFromRight++;\\n            else {\\n                // if dir[i] == \\'S\\' then there will be carsFromRight number of collission\\n                // if dir[i] == \\'L\\' then there will be carsFromRight+1 number of collision (one collision for the rightmost cars and carsFromRight collision for the cars coming from left)\\n                res += (dir[i] == \\'S\\') ? carsFromRight : carsFromRight+1;\\n                carsFromRight = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int countCollisions(String dir) {\\n        \\n        int res = 0, n = dir.length(), i = 0, carsFromRight = 0;\\n        \\n        while (i < n && dir.charAt(i) == \\'L\\') i++;\\n        \\n        for ( ; i<n; i++) {\\n            if (dir.charAt(i) == \\'R\\')  carsFromRight++;\\n            else {\\n                res += (dir.charAt(i) == \\'S\\') ? carsFromRight : carsFromRight+1;\\n                carsFromRight = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        \\n        res, n, i, carsFromRight = 0, len(directions), 0, 0\\n        \\n        while i < n and directions[i] == \\'L\\':\\n               i+=1\\n        \\n        while i<n:\\n            if directions[i] == \\'R\\':\\n                carsFromRight+=1\\n            else:\\n                res += carsFromRight if directions[i] == \\'S\\' else carsFromRight+1;\\n                carsFromRight = 0\\n            i+=1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865558,
                "title": "what-a-stupid-problem",
                "content": "What a Stupid problem! There are so many unclear cases need to be decribed better: should we consider the collision before/after the each pair or so???\\n\\n**If you are trying to practice the algorithm and sharpen your interview skills, I will do you a favor to tell you to SKIP this STUPID question with no doubt!!**\\n\\n```\\npublic int countCollisions(String directions) {\\n        char[] s = directions.toCharArray();\\n        int n = s.length;\\n        int ans = 0;\\n        for(int i = 0;i < n;i++){\\n            if(s[i] == \\'S\\'){\\n                for(int j = i-1;j >= 0;j--){\\n                    if(s[j] == \\'R\\'){\\n                        ans++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                for(int j = i+1;j < n;j++){\\n                    if(s[j] == \\'L\\'){\\n                        ans++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 0;i < n-1;i++){\\n            if(s[i] == \\'R\\' && s[i+1] == \\'L\\'){\\n                ans += 2;\\n                for(int j = i-1;j >= 0;j--){\\n                    if(s[j] == \\'R\\'){\\n                        ans++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                for(int j = i+2;j < n;j++){\\n                    if(s[j] == \\'L\\'){\\n                        ans++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countCollisions(String directions) {\\n        char[] s = directions.toCharArray();\\n        int n = s.length;\\n        int ans = 0;\\n        for(int i = 0;i < n;i++){\\n            if(s[i] == \\'S\\'){\\n                for(int j = i-1;j >= 0;j--){\\n                    if(s[j] == \\'R\\'){\\n                        ans++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                for(int j = i+1;j < n;j++){\\n                    if(s[j] == \\'L\\'){\\n                        ans++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 0;i < n-1;i++){\\n            if(s[i] == \\'R\\' && s[i+1] == \\'L\\'){\\n                ans += 2;\\n                for(int j = i-1;j >= 0;j--){\\n                    if(s[j] == \\'R\\'){\\n                        ans++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                for(int j = i+2;j < n;j++){\\n                    if(s[j] == \\'L\\'){\\n                        ans++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865694,
                "title": "one-liner-in-python",
                "content": "All the cars that move to the middle will eventually collide.... \\n\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        return sum(d!=\\'S\\' for d in directions.lstrip(\\'L\\').rstrip(\\'R\\'))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        return sum(d!=\\'S\\' for d in directions.lstrip(\\'L\\').rstrip(\\'R\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865572,
                "title": "java-stack-solution",
                "content": "```\\n\\n\\n/*\\nIn the case LLRR : there will be no collisions since two cars are moving towards Left and two cars moving towards right\\n<- <- -> ->\\n L  L  R  R \\n\\nIn the case RRRRLL : \\n->  ->  -> ->  <- <- \\nR    R   R  R  L  L \\n0    1   2  3  4  5\\n\\n Cars 3 and 4 collide and become stationary (S), since cars 0, 1, 2 are moving towards this stationary car so they will all \\n collide and cars 4 and 5 are moving towards the same stationary card from the left direction so even they will collide and \\n become stationary (S). We will store cars 0,1,2, 3 in stack and when current car is driving towards left we pop 3 and change \\n the current car\\u2019s state to stationary and pop rest of the cars driving towards it from the right direction and calculate the \\n collision value. \\n\\nIn the case RSLRL: \\n\\n-> |  <-  -> <-\\nR  S  L    R  L \\n0  1  2    3  4\\n\\nCar 0 collides with the stationary car 1, car 2 collides with the stationary car 1 and cars 3 and 4 collide with each other. \\n\\n*/\\n    public int countCollisions(String directions) {\\n        \\n        int collisions = 0;\\n        Stack<Character> stack = new Stack();\\n        stack.push(directions.charAt(0));\\n        for(int i = 1;i<directions.length();i++){\\n            char curr = directions.charAt(i);\\n      \\n            if((stack.peek()== \\'R\\' && curr == \\'L\\')  ){\\n                \\n                collisions+=2;\\n                stack.pop();\\n                curr = \\'S\\';\\n     \\n\\n            }else if((stack.peek() == \\'S\\' && curr == \\'L\\')){\\n                curr = \\'S\\';\\n                collisions+=1;\\n            }\\n        \\n            while(!stack.isEmpty() && ((stack.peek() == \\'R\\' && curr == \\'S\\') )){\\n                collisions+=1;\\n              stack.pop();\\n            }\\n            \\n            stack.push(curr);\\n        }\\n        \\n        return collisions;\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\n\\n/*\\nIn the case LLRR : there will be no collisions since two cars are moving towards Left and two cars moving towards right\\n<- <- -> ->\\n L  L  R  R \\n\\nIn the case RRRRLL : \\n->  ->  -> ->  <- <- \\nR    R   R  R  L  L \\n0    1   2  3  4  5\\n\\n Cars 3 and 4 collide and become stationary (S), since cars 0, 1, 2 are moving towards this stationary car so they will all \\n collide and cars 4 and 5 are moving towards the same stationary card from the left direction so even they will collide and \\n become stationary (S). We will store cars 0,1,2, 3 in stack and when current car is driving towards left we pop 3 and change \\n the current car\\u2019s state to stationary and pop rest of the cars driving towards it from the right direction and calculate the \\n collision value. \\n\\nIn the case RSLRL: \\n\\n-> |  <-  -> <-\\nR  S  L    R  L \\n0  1  2    3  4\\n\\nCar 0 collides with the stationary car 1, car 2 collides with the stationary car 1 and cars 3 and 4 collide with each other. \\n\\n*/\\n    public int countCollisions(String directions) {\\n        \\n        int collisions = 0;\\n        Stack<Character> stack = new Stack();\\n        stack.push(directions.charAt(0));\\n        for(int i = 1;i<directions.length();i++){\\n            char curr = directions.charAt(i);\\n      \\n            if((stack.peek()== \\'R\\' && curr == \\'L\\')  ){\\n                \\n                collisions+=2;\\n                stack.pop();\\n                curr = \\'S\\';\\n     \\n\\n            }else if((stack.peek() == \\'S\\' && curr == \\'L\\')){\\n                curr = \\'S\\';\\n                collisions+=1;\\n            }\\n        \\n            while(!stack.isEmpty() && ((stack.peek() == \\'R\\' && curr == \\'S\\') )){\\n                collisions+=1;\\n              stack.pop();\\n            }\\n            \\n            stack.push(curr);\\n        }\\n        \\n        return collisions;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1879294,
                "title": "counting-vs-simulation",
                "content": "I originally solved this problem using simulation (see below).  But later I realized that all cars, except cars on the left moving left and cars on the right moving right, will collide.\\n\\n#### Counting\\n**C++**\\n```cpp\\nint countCollisions(string d) {\\n    int l = d.find_first_not_of(\"L\"), r = d.find_last_not_of(\"R\");\\n    return l == string::npos || r == string::npos ? 0 : \\n        count_if(begin(d) + l, begin(d) + r + 1, [](char ch){ return ch != \\'S\\';});\\n}\\n```\\n\\n#### Simulation\\n**C++**\\n```cpp\\nint countCollisions(string directions) {\\n    int right = 0, res = 0, obstacle = false;\\n    for (char d : directions)\\n        if (d == \\'R\\')\\n            ++right;\\n        else if (d == \\'S\\') {\\n            res += right;\\n            right = 0;\\n            obstacle = true;\\n        }\\n        else {\\n            if (right > 0) {\\n                res += right + 1;\\n                right = 0;\\n                obstacle = true;\\n            }\\n            else if (obstacle)\\n                ++res;\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countCollisions(string d) {\\n    int l = d.find_first_not_of(\"L\"), r = d.find_last_not_of(\"R\");\\n    return l == string::npos || r == string::npos ? 0 : \\n        count_if(begin(d) + l, begin(d) + r + 1, [](char ch){ return ch != \\'S\\';});\\n}\\n```\n```cpp\\nint countCollisions(string directions) {\\n    int right = 0, res = 0, obstacle = false;\\n    for (char d : directions)\\n        if (d == \\'R\\')\\n            ++right;\\n        else if (d == \\'S\\') {\\n            res += right;\\n            right = 0;\\n            obstacle = true;\\n        }\\n        else {\\n            if (right > 0) {\\n                res += right + 1;\\n                right = 0;\\n                obstacle = true;\\n            }\\n            else if (obstacle)\\n                ++res;\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865868,
                "title": "c-stack-o-n-one-for-loop",
                "content": "**Code:**\\n```\\nint countCollisions(string dir) {\\n    int n = dir.size();\\n    stack<char> s;\\n    int ans = 0;\\n    for(int i=0; i<n; i++)\\n    {\\n        if(s.empty()) s.push(dir[i]);\\n        else if( (s.top() == \\'S\\') && (dir[i] == \\'L\\')) ans++;\\n        else if(s.top() == \\'R\\' && (dir[i] == \\'L\\')) {\\n            s.pop();\\n            dir[i] = \\'S\\';\\n            i--;\\n            ans += 2;\\n        }\\n        else if( (s.top() == \\'R\\') && (dir[i] == \\'S\\')){\\n            s.pop();\\n            dir[i] = \\'S\\';\\n            i--;\\n            ans++;\\n        }\\n        else{\\n            s.push(dir[i]);\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nint countCollisions(string dir) {\\n    int n = dir.size();\\n    stack<char> s;\\n    int ans = 0;\\n    for(int i=0; i<n; i++)\\n    {\\n        if(s.empty()) s.push(dir[i]);\\n        else if( (s.top() == \\'S\\') && (dir[i] == \\'L\\')) ans++;\\n        else if(s.top() == \\'R\\' && (dir[i] == \\'L\\')) {\\n            s.pop();\\n            dir[i] = \\'S\\';\\n            i--;\\n            ans += 2;\\n        }\\n        else if( (s.top() == \\'R\\') && (dir[i] == \\'S\\')){\\n            s.pop();\\n            dir[i] = \\'S\\';\\n            i--;\\n            ans++;\\n        }\\n        else{\\n            s.push(dir[i]);\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865926,
                "title": "short-easy-python-solution-with-explanation",
                "content": "We can transform this problem into whether go right or go left cars will stop and count the sum of stops. After transformation, we just need to check the situation of each go left and go right car individually.\\n\\nStarting from left->right,\\n\\nIf there is no car at the beginning go right or stop, then go left car after them will never stop.\\nExample\\nLLLLL -> No one car will stop\\nIf there one car stop or go right at the beginning, then go left car after them is bound to stop\\nExample\\nLR | LLL -> After R, three L will stop  there are **three** left car stop\\nLS | LLL -> After S, three L will stop\\n\\n\\nStarting from right->left,\\nIf there is no car at the beginning go left or stop, then go right car after them will never stop.\\nExample\\nRRRRR -> No one car will stop\\n\\nIf there is one car stop or go left at the beginning, then go right car after them is bound to stop\\nExample\\nRRR | LR -> After L, three RRR will stop  \\nRRR | SR -> After S, three R will stop\\n\\nThen we check wether left car will stop by (left->right) and then check wether right car will stop by (right->left). The answer is the sum\\n\\n\\n\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        ans = 0\\n        # At the beginning, leftest car can go without collide\\n        # At the beginning, rightest car can go without collide\\n        \\n        leftc = rightc = 0\\n        \\n        for c in directions:\\n            # if left side, no car stop or right answer + 0\\n            # if left side start to have car go right or stop\\n            # then cars after that are bound to be stopped so answer + 1\\n            if c == \"L\":\\n                ans += leftc\\n            else:\\n                leftc = 1\\n                \\n        for c in directions[::-1]:\\n            # if right side, no car stop or left answer + 0\\n            # if right side start to have car go left or stop\\n            # then cars after that are bound to be stopped so answer + 1\\n            if c == \"R\":\\n                ans += rightc\\n            else:\\n                rightc = 1\\n       \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        ans = 0\\n        # At the beginning, leftest car can go without collide\\n        # At the beginning, rightest car can go without collide\\n        \\n        leftc = rightc = 0\\n        \\n        for c in directions:\\n            # if left side, no car stop or right answer + 0\\n            # if left side start to have car go right or stop\\n            # then cars after that are bound to be stopped so answer + 1\\n            if c == \"L\":\\n                ans += leftc\\n            else:\\n                leftc = 1\\n                \\n        for c in directions[::-1]:\\n            # if right side, no car stop or left answer + 0\\n            # if right side start to have car go left or stop\\n            # then cars after that are bound to be stopped so answer + 1\\n            if c == \"R\":\\n                ans += rightc\\n            else:\\n                rightc = 1\\n       \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944204,
                "title": "full-explained-c-solution",
                "content": "### **INTUTION**\\n\\nTo understand the problem first we need to know how any kind of the collision will happen?\\n\\n**Case1:** \\n\\nSo if the current direction let suppose be **L**. So how car moving in the left direction will collide?\\nAnswer would be - \\n\\n**Way1:** \\n![image](https://assets.leetcode.com/users/images/00d86e49-5002-47a8-8e9f-0ad90bf9e53e_1649878565.6698678.png)\\nAs we see car from the right (**R**) can collide with car with left (**L**) direction\\n\\n**Way2:**\\n![image](https://assets.leetcode.com/users/images/77d9948e-c341-4d63-8031-f1665ca9e792_1649879273.7621076.png)\\nAnother way is that we collide to the stationay car or **previous accident**\\n\\n**Case2:**\\n\\nSo if the current condition of car is stationary **\"S\"**  so what are ways we can encounter the collision?\\n\\n**Way1:**\\n![image](https://assets.leetcode.com/users/images/b04cdf3d-5057-494f-ba4a-10554067fd1e_1649879617.8356025.png)\\nAs we can see car coming from the right **\"R\"** will colide to the stationary (**\"S\"**) car\\n\\n**Case3:**\\n\\nIf current car direction is right **\"R\"** how collision will happen?\\n\\nAnswer would be none way as in first two case we encounter how car from the right (**\"R\"**) will collide to stationary (**\"S\"**) and car moving to the left (**\"L\"**) . So we don\\'t need to consider any case here for the collision.\\n\\n**Now we know how all ways to the collision that can happen!!**\\n\\n#### **Special Case**\\n![image](https://assets.leetcode.com/users/images/68ec5888-4d9f-4fa2-848c-ecd466cdce46_1649880144.322184.png)![image](https://assets.leetcode.com/users/images/6a7cf6d2-3bd2-41c2-b721-6aa2a2887e0f_1649880210.660004.png)\\n\\nNow if we have multiple car in the right (**\"R\"**) direction we need to check all the right cars to the stationary (**\"S\"**) or accident location car\\n\\n### **Conclusion**\\nNumber of ways cars can collide we will use them as if condition for given direction of the current car and we use the special case as while loop when the current car direction is stationary (**\"S\"**). If accident occur we will denote that location with stationary (**\"S\"**).\\nTo solve the problem we will use the **stack** data structure\\n\\n### **Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> s;\\n        int res = 0;\\n        for(char dir : directions) {\\n            if(s.empty()) s.push(dir);\\n            else {\\n                if(dir==\\'L\\'){\\n                    if(s.top()==\\'R\\'){\\n                        res+=2;\\n                        s.pop();\\n                        s.push(\\'S\\');\\n                    }else if(s.top()==\\'S\\') res++;\\n                    else s.push(dir);\\n                }else if(dir==\\'R\\') s.push(dir);\\n                else {\\n                    if(s.top()==\\'R\\'){\\n                        res++;\\n                        s.pop();\\n                    }\\n                    s.push(dir);\\n                }\\n            }\\n        }\\n        int cnt = 0;\\n        while(!s.empty()){\\n            char dir = s.top();\\n            s.pop();\\n            if(dir==\\'R\\') res+=cnt;\\n            else if(dir==\\'S\\') cnt = 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**If my intutuion and code help you with the understanding of the problem please upvote.**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> s;\\n        int res = 0;\\n        for(char dir : directions) {\\n            if(s.empty()) s.push(dir);\\n            else {\\n                if(dir==\\'L\\'){\\n                    if(s.top()==\\'R\\'){\\n                        res+=2;\\n                        s.pop();\\n                        s.push(\\'S\\');\\n                    }else if(s.top()==\\'S\\') res++;\\n                    else s.push(dir);\\n                }else if(dir==\\'R\\') s.push(dir);\\n                else {\\n                    if(s.top()==\\'R\\'){\\n                        res++;\\n                        s.pop();\\n                    }\\n                    s.push(dir);\\n                }\\n            }\\n        }\\n        int cnt = 0;\\n        while(!s.empty()){\\n            char dir = s.top();\\n            s.pop();\\n            if(dir==\\'R\\') res+=cnt;\\n            else if(dir==\\'S\\') cnt = 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866101,
                "title": "short-easy-c-o-n-solution-with-explanation",
                "content": "My solution :\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string D) {//D is Direction string\\n        int n = D.size(), ans = 0;\\n\\t\\tint i = 0 , j = n-1;\\n        while(i<=j and D[i] == \\'L\\') i++;    // Cars on left going left => no colision\\n\\t\\twhile(i<=j and D[j] == \\'R\\') j--;    // Cars on right going right => no colision\\n        for( ; i<=j ; i++) ans += (D[i] != \\'S\\');  // Whether S collides or not it doesn\\'t change answer , all other collide and change score\\n        return ans;\\n        }\\n        \\n    \\n};\\n```\\nExplanation:\\ni. The Ones on left going left and on right going right will not collide .\\n hence the first two while loops \\nii. All others will collide but a stopped vehicles collision doesn\\'t count so we count the rest.\\n\\nEdit : \\nReason for S not contribiting to score is, collision can occur in 3 ways only\\ncolliding pair   |    score increase ...\\n    R-L         |                 2\\n    R-S         |                1\\n    S-L         |                1\\nSo we can say that if S is involved in collision it has 0 contribution to score while R or L would contribute 1 in collision. Thus whether S takes part in a collision or not is immaterial .\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string D) {//D is Direction string\\n        int n = D.size(), ans = 0;\\n\\t\\tint i = 0 , j = n-1;\\n        while(i<=j and D[i] == \\'L\\') i++;    // Cars on left going left => no colision\\n\\t\\twhile(i<=j and D[j] == \\'R\\') j--;    // Cars on right going right => no colision\\n        for( ; i<=j ; i++) ans += (D[i] != \\'S\\');  // Whether S collides or not it doesn\\'t change answer , all other collide and change score\\n        return ans;\\n        }\\n        \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865816,
                "title": "c-easy-simulation-stack-explanation-beginner-friendly-solution",
                "content": "The problem was a good simulation problem. Here we have three cases of collision and one hidden case.\\n* First case, if the car is moving **R** and the car next to it is moving **L**\\n* Second, if the car is moving **R** and the very next car is stationary *i.e.* **S**\\n* Third, one is if the first car is stationary **S** and the next car is moving in left direction **L**\\n* and the hidden case which i found it later was, what if ***two or more*** cars is moving in right direction and later on some collision take place and the car become stationary\\n\\t\\n# \\tExplanation with examples and proof\\n\\t Example and explanation of the 4th hidden case\\n\\t Eg: RRRRRRL\\n\\t Here we can see that R and L will become stationary (After collision of R and L)\\n\\t -> RRRRRS (after collision or after first traverse)\\n\\t but, we have just missed the couple of R\\'s before S\\n\\t \\n\\t To handle this, we will remove the leading R\\'s from the stack.\\n\\t and after removing leading R\\'s count remaing R\\'s and add to the answer\\n\\t **Proof**\\n\\t Let a string S S R S S R L L R S L L R S R S S R L R R R R L L R R L S S R R\\n\\t after performing first traverse( handling only first 3 cases ) the stack will look like \\n\\t R R S S S R S R R R S S S S S S S S S S the string is in reverse order\\n\\t\\t\\t             \\n\\t After reversing it S S S S S S S S S S R R R S R S S S R R\\n\\t \\n\\t Now, we can see that there are couple of collision are left i.e R R R S R S S S R R\\n\\t last two R R cant collide in any way so remove them from the stack \\n\\t current stack R R R S R S S S\\n\\t \\n\\t Resulting  we are only remain with some R\\'s that are surely going to collide because even if we\\n\\t have single \\'S\\' it is sure that after collide if any car it will become stationary and number of\\n\\t stationary will increment.\\n\\t \\n\\t So, count the remaining R\\'s and add to the answer\\n\\t \\n\\t Please do dry run on this case, for better understand\\n\\t S S R S S R L L R S L L R S R S S R L R R R R L L R R L S S R R\\n\\t \\n**read the comment in the code for better understand**\\n**CODE**\\n\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        stack<char> st; // creating a stack\\n        int n = s.size();\\n        if(n == 1)return 0; // edge case !\\n        st.push(s[0]); // Push the very first element in stack \\n        int ans = 0;\\n        for(int i=1; i<n; i++)\\n        {\\n            if(!st.empty() && st.top() == \\'R\\' && s[i] == \\'L\\') // First case \\n            {\\n                ans += 2;\\n                st.pop();   // remove the last element from the stack because they have collide \\n                st.push(\\'S\\'); // after collide the car become stationary so, push \"S\"\\n            }\\n            else if(!st.empty() && st.top() == \\'R\\' && s[i] == \\'S\\') // second case\\n            {\\n                ans += 1;\\n                st.pop();   // same here \\n                st.push(\\'S\\');\\n            }\\n            else if(!st.empty() && st.top() == \\'S\\' && s[i] == \\'L\\') // third case \\n                ans += 1; \\n            else\\n                st.push(s[i]); // if no condition is matched push the current element;\\n        } \\n        // handling 4th case \\n        while(!st.empty() && st.top() == \\'R\\') // remove the leading R\\'s\\n            st.pop();\\n        while(!st.empty()) // count the remaing R\\'s\\n        {\\n            if(st.top() == \\'R\\')ans++;\\n            st.pop();\\n        }\\n        // please dry  run this case of your own for better understand\\n        // S S R S S R L L R S L L R S R S S R L R R R R L L R R L S S R R\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        stack<char> st; // creating a stack\\n        int n = s.size();\\n        if(n == 1)return 0; // edge case !\\n        st.push(s[0]); // Push the very first element in stack \\n        int ans = 0;\\n        for(int i=1; i<n; i++)\\n        {\\n            if(!st.empty() && st.top() == \\'R\\' && s[i] == \\'L\\') // First case \\n            {\\n                ans += 2;\\n                st.pop();   // remove the last element from the stack because they have collide \\n                st.push(\\'S\\'); // after collide the car become stationary so, push \"S\"\\n            }\\n            else if(!st.empty() && st.top() == \\'R\\' && s[i] == \\'S\\') // second case\\n            {\\n                ans += 1;\\n                st.pop();   // same here \\n                st.push(\\'S\\');\\n            }\\n            else if(!st.empty() && st.top() == \\'S\\' && s[i] == \\'L\\') // third case \\n                ans += 1; \\n            else\\n                st.push(s[i]); // if no condition is matched push the current element;\\n        } \\n        // handling 4th case \\n        while(!st.empty() && st.top() == \\'R\\') // remove the leading R\\'s\\n            st.pop();\\n        while(!st.empty()) // count the remaing R\\'s\\n        {\\n            if(st.top() == \\'R\\')ans++;\\n            st.pop();\\n        }\\n        // please dry  run this case of your own for better understand\\n        // S S R S S R L L R S L L R S R S S R L R R R R L L R R L S S R R\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865895,
                "title": "python-add-a-imaged-block-in-front-of-every-car",
                "content": "x|x|x|x|x|x|x|x|x|x|x|x|\\n\\nimage all the x are moveing left, every point can be potentially blocked (that is, if there is a S, and R before those x, they all being blocked), and vice versa\\n\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        \\n        ans = 0\\n        L_block = 0\\n        R_block = 0\\n        \\n        \\n        for ch in directions:\\n            if ch == \"L\":\\n                ans += L_block\\n            else:\\n                L_block = 1\\n        \\n        for ch in directions[::-1]:\\n            if ch == \"R\":\\n                ans += R_block  \\n            else:\\n                R_block = 1\\n        \\n        return ans\\n    \\n    # time---N, space---1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        \\n        ans = 0\\n        L_block = 0\\n        R_block = 0\\n        \\n        \\n        for ch in directions:\\n            if ch == \"L\":\\n                ans += L_block\\n            else:\\n                L_block = 1\\n        \\n        for ch in directions[::-1]:\\n            if ch == \"R\":\\n                ans += R_block  \\n            else:\\n                R_block = 1\\n        \\n        return ans\\n    \\n    # time---N, space---1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202445,
                "title": "easy-and-simplest-one-liner",
                "content": "```\\n return len(directions.lstrip(\\'L\\').rstrip(\\'R\\').replace(\\'S\\',\\'\\'))\\n ```\\n\\n**Update:**\\nExcept for the Left Most cars going in left and Rightmost Cars going towards Right\\nEvery Car will collide So Counting these by taking length after removing stay",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n return len(directions.lstrip(\\'L\\').rstrip(\\'R\\').replace(\\'S\\',\\'\\'))\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865659,
                "title": "logic-complexity-analysis-c",
                "content": "## **Solution**\\n\\n#### **Logic**\\n- For all ```R``` look for next index, Whenever you get collison change current index and next index to ```S```\\n- For all ```L``` look previous index, Whenever you get collison change current index and previous index to ```S```\\n- For all ```S```, skip it\\n- Whenever you change current index to ```S```, look backward for all continous occuring ```R```\\n\\n#### **Code**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int sol = 0;\\n        \\n        for (int j = 0; j < directions.size(); j++) {\\n            if (directions[j] == \\'S\\') {\\n                continue;\\n            }\\n            if (j + 1 < directions.size() && directions[j] == \\'R\\' && directions[j + 1] != \\'R\\') {\\n                if (directions[j + 1] == \\'L\\') {\\n                    directions[j + 1] = \\'S\\';\\n                    sol += 1;\\n                }\\n                directions[j] = \\'S\\';\\n                sol += 1;\\n\\n            }\\n            if (j - 1 >= 0 && directions[j] == \\'L\\' && directions[j - 1] != \\'L\\') {\\n                if (directions[j - 1] == \\'R\\'){\\n                    directions[j - 1] = \\'S\\';\\n                    sol += 1;\\n                }\\n                directions[j] = \\'S\\';\\n                sol +=  1;\\n            } \\n            if (directions[j] == \\'S\\') {\\n                int i = j - 1;\\n                while (i >= 0 && directions[i] == \\'R\\') {\\n                    sol++;\\n                    i--;\\n                }   \\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n```\\n\\n## **Complexity**\\n\\n#### Time Complexity: **O(size_of_directions * size_of_directions)**, outer ```for``` loop will run (size_of_directions) times, but inner ```while``` loop can run for (size_of_directions - 1) times, for the worst case like ```RRRRRRRRL```.\\n\\n#### Space Complexity: **O(1)**, \\n<br>\\n<br>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```R```\n```S```\n```L```\n```S```\n```S```\n```S```\n```R```\n```cpp\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int sol = 0;\\n        \\n        for (int j = 0; j < directions.size(); j++) {\\n            if (directions[j] == \\'S\\') {\\n                continue;\\n            }\\n            if (j + 1 < directions.size() && directions[j] == \\'R\\' && directions[j + 1] != \\'R\\') {\\n                if (directions[j + 1] == \\'L\\') {\\n                    directions[j + 1] = \\'S\\';\\n                    sol += 1;\\n                }\\n                directions[j] = \\'S\\';\\n                sol += 1;\\n\\n            }\\n            if (j - 1 >= 0 && directions[j] == \\'L\\' && directions[j - 1] != \\'L\\') {\\n                if (directions[j - 1] == \\'R\\'){\\n                    directions[j - 1] = \\'S\\';\\n                    sol += 1;\\n                }\\n                directions[j] = \\'S\\';\\n                sol +=  1;\\n            } \\n            if (directions[j] == \\'S\\') {\\n                int i = j - 1;\\n                while (i >= 0 && directions[i] == \\'R\\') {\\n                    sol++;\\n                    i--;\\n                }   \\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n```\n```for```\n```while```\n```RRRRRRRRL```",
                "codeTag": "Java"
            },
            {
                "id": 1865645,
                "title": "simple-java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int start = 0, end = directions.length()-1;\\n        int count = 0;\\n        while(start<directions.length() && directions.charAt(start)==\\'L\\')\\n            start++;\\n        while(end>=0 && directions.charAt(end)==\\'R\\')\\n            end--;\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i = start; i<=end;i++){\\n            char c = directions.charAt(i);\\n            if(stack.size()==0)\\n                stack.push(c);\\n            else{\\n                char prev = stack.peek();\\n                if(c == \\'L\\'){\\n                   if(prev==\\'S\\')\\n                   {\\n                       count++;\\n                   }else{// prev ==\\'R\\'\\n                       stack.pop();\\n                       stack.push(\\'S\\');\\n                       count+=2;\\n                   }\\n                }else{\\n                    stack.push(c);\\n                }\\n              \\n            }\\n        }\\n        while(stack.size()>0)\\n        {\\n            char c = stack.pop();\\n            if(c==\\'R\\')\\n                count++;//R\\'s will eventually crash into \\'S\\'es\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countCollisions(String directions) {\\n        int start = 0, end = directions.length()-1;\\n        int count = 0;\\n        while(start<directions.length() && directions.charAt(start)==\\'L\\')\\n            start++;\\n        while(end>=0 && directions.charAt(end)==\\'R\\')\\n            end--;\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i = start; i<=end;i++){\\n            char c = directions.charAt(i);\\n            if(stack.size()==0)\\n                stack.push(c);\\n            else{\\n                char prev = stack.peek();\\n                if(c == \\'L\\'){\\n                   if(prev==\\'S\\')\\n                   {\\n                       count++;\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 1865578,
                "title": "efficient-python-solution-o-n-time-o-1-space-with-clear-explanation",
                "content": "This question is similar to the [Asteroid Collision](https://leetcode.com/problems/asteroid-collision/) question.\\n\\nWe need a few variables:\\n- has_stationary - determines if there stationary objects which will result in collisions\\n- number of cars moving towards the right - when they hit a left/stationary car, they will result in collisions\\n\\n```py\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        has_stationary, right, collisions = False, 0, 0\\n        for direction in directions:\\n            if direction == \\'R\\':\\n\\t\\t\\t    # Just record number of right-moving cars. We will resolve them when we encounter a left-moving/stationary car.\\n                right += 1\\n            elif direction == \\'L\\' and (has_stationary or right > 0): \\n\\t\\t\\t    # Left-moving cars which don\\'t have any existing right-moving/stationary cars to their left can be ignored. They won\\'t hit anything.\\n\\t\\t\\t\\t# But if there are right-moving/stationary cars, it will result in collisions and we can resolve them.\\n\\t\\t\\t\\t# We reset right to 0 because they have collided and will become stationary cars.\\n                collisions += 1 + right\\n                right = 0\\n                has_stationary = True\\n            elif direction == \\'S\\':\\n\\t\\t\\t    # Resolve any right-moving cars and reset right to 0 because they are now stationary.\\n                collisions += right\\n                right = 0\\n                has_stationary = True\\n        return collisions\\n```\\n\\nShorter solution (but less readable IMO)\\n\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        has_stationary, right, collisions = False, 0, 0\\n        for direction in directions:\\n            if direction == \\'R\\':\\n                right += 1\\n            elif (direction == \\'L\\' and (has_stationary or right > 0)) or direction == \\'S\\':\\n                collisions += (1 if direction == \\'L\\' else 0) + right\\n                right = 0\\n                has_stationary = True\\n        return collisions\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        has_stationary, right, collisions = False, 0, 0\\n        for direction in directions:\\n            if direction == \\'R\\':\\n\\t\\t\\t    # Just record number of right-moving cars. We will resolve them when we encounter a left-moving/stationary car.\\n                right += 1\\n            elif direction == \\'L\\' and (has_stationary or right > 0): \\n\\t\\t\\t    # Left-moving cars which don\\'t have any existing right-moving/stationary cars to their left can be ignored. They won\\'t hit anything.\\n\\t\\t\\t\\t# But if there are right-moving/stationary cars, it will result in collisions and we can resolve them.\\n\\t\\t\\t\\t# We reset right to 0 because they have collided and will become stationary cars.\\n                collisions += 1 + right\\n                right = 0\\n                has_stationary = True\\n            elif direction == \\'S\\':\\n\\t\\t\\t    # Resolve any right-moving cars and reset right to 0 because they are now stationary.\\n                collisions += right\\n                right = 0\\n                has_stationary = True\\n        return collisions\\n```\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        has_stationary, right, collisions = False, 0, 0\\n        for direction in directions:\\n            if direction == \\'R\\':\\n                right += 1\\n            elif (direction == \\'L\\' and (has_stationary or right > 0)) or direction == \\'S\\':\\n                collisions += (1 if direction == \\'L\\' else 0) + right\\n                right = 0\\n                has_stationary = True\\n        return collisions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866302,
                "title": "c-easy-solution-1-pass-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        \\n        int nr=0,check=0,ans=0;\\n        \\n        for(int i=0;i<directions.size();i++){\\n            if(directions[i]==\\'R\\'){\\n                nr++;\\n            }else if(directions[i]==\\'S\\'){\\n                ans+=nr;\\n                check=1;\\n                nr=0;\\n            }else if(directions[i]==\\'L\\'){\\n                if(i>0 and directions[i-1]!=\\'R\\' and check==1){\\n                    ans++;\\n                }else if(nr>0){\\n                    ans+=(nr+1);\\n                    nr=0;\\n                    check=1;\\n                }\\n            }\\n           \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\t\\t\\t\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        \\n        int nr=0,check=0,ans=0;\\n        \\n        for(int i=0;i<directions.size();i++){\\n            if(directions[i]==\\'R\\'){\\n                nr++;\\n            }else if(directions[i]==\\'S\\'){\\n                ans+=nr;\\n                check=1;\\n                nr=0;\\n            }else if(directions[i]==\\'L\\'){\\n                if(i>0 and directions[i-1]!=\\'R\\' and check==1){\\n                    ans++;\\n                }else if(nr>0){\\n                    ans+=(nr+1);\\n                    nr=0;\\n                    check=1;\\n                }\\n            }\\n           \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419641,
                "title": "fastest-solution-without-stack-tc-o-n",
                "content": "# Approach\\nif R then increase the count of R.\\nif L then calculate the collision.\\nif S then calculate the collision due to previous pending R.\\n\\n# Complexity\\n- Time complexity:\\nAdd your time complexity here, e.g. $$O(n)$$\\n\\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int n = directions.size();\\n        bool sl = false;\\n        int right =0, ans=0;\\n        for(int i=0; i<n; i++){\\n            if(directions[i]==\\'S\\'){\\n                sl = true;\\n                ans += right;\\n                right =0;\\n            }\\n            else if(directions[i]==\\'L\\'){\\n               if(right){\\n                   right--;\\n                   ans+=2;\\n                   ans+= right;\\n                   right = 0;\\n                   sl = true;\\n               }\\n               else if(sl){\\n                   ans++;\\n               }\\n           }\\n           else{\\n               right++;\\n           }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int n = directions.size();\\n        bool sl = false;\\n        int right =0, ans=0;\\n        for(int i=0; i<n; i++){\\n            if(directions[i]==\\'S\\'){\\n                sl = true;\\n                ans += right;\\n                right =0;\\n            }\\n            else if(directions[i]==\\'L\\'){\\n               if(right){\\n                   right--;\\n                   ans+=2;\\n                   ans+= right;\\n                   right = 0;\\n                   sl = true;\\n               }\\n               else if(sl){\\n                   ans++;\\n               }\\n           }\\n           else{\\n               right++;\\n           }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704013,
                "title": "easy-way-to-solve-no-stack-c-tc-o-n-sc-o-1",
                "content": "1> Calculate the number of cars which will not collide and which will not count in collision ...\\n2> Then subtract that count (non collide car ) with the size of the string you will get the number of collisions.\\n\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int n = dir.size();\\n        int notcol=0;\\n\\t\\t\\n\\t\\t// calculating the no. of cars from 0th index which are going only LEFT till any car goes right or stationary\\n\\t\\t\\n\\t\\t// <L  <L  <L  <L   |S|   R>  |S|   R>   R>\\n\\t\\t\\n\\t\\t// starting 4 cars will never collide with any of the other cars\\n\\n        for(int i=0;i<n; i++){\\n            if(dir[i] != \\'L\\')\\n                break;\\n            notcol++;\\n        }\\n\\t\\t\\n\\t\\t// calculating the no. of cars from last (n-1)th index which are going only RIGHT till any car goes left or stationary\\n\\t\\t\\n\\t\\t//  <L  <L  <L   R>  |S|   R>  <L  <L   R>  R>\\n\\n\\t\\t// last 2 cars will never collide with any of the other cars\\n\\t\\t\\n        for(int i=n-1; i>=0; i--){\\n            if(dir[i] != \\'R\\') \\n                break;\\n            notcol++;\\n        }\\n\\t\\t\\n\\t\\t//counting the stationary car\\n\\t\\t//reason behind calculating stationary car because stationary cars will not count in collisions\\n        for(int i=0; i<n; i++){\\n            if(dir[i] == \\'S\\') notcol++;\\n        }\\n\\t\\t\\n        // subtract the non collide cars with the total no. of cars\\n\\t\\treturn n-notcol; \\n    }\\n};\\n```\\nI hope this is helpful..   : ) \\uD83D\\uDC4D : )\\nif any doubt comment below",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int n = dir.size();\\n        int notcol=0;\\n\\t\\t\\n\\t\\t// calculating the no. of cars from 0th index which are going only LEFT till any car goes right or stationary\\n\\t\\t\\n\\t\\t// <L  <L  <L  <L   |S|   R>  |S|   R>   R>\\n\\t\\t\\n\\t\\t// starting 4 cars will never collide with any of the other cars\\n\\n        for(int i=0;i<n; i++){\\n            if(dir[i] != \\'L\\')\\n                break;\\n            notcol++;\\n        }\\n\\t\\t\\n\\t\\t// calculating the no. of cars from last (n-1)th index which are going only RIGHT till any car goes left or stationary\\n\\t\\t\\n\\t\\t//  <L  <L  <L   R>  |S|   R>  <L  <L   R>  R>\\n\\n\\t\\t// last 2 cars will never collide with any of the other cars\\n\\t\\t\\n        for(int i=n-1; i>=0; i--){\\n            if(dir[i] != \\'R\\') \\n                break;\\n            notcol++;\\n        }\\n\\t\\t\\n\\t\\t//counting the stationary car\\n\\t\\t//reason behind calculating stationary car because stationary cars will not count in collisions\\n        for(int i=0; i<n; i++){\\n            if(dir[i] == \\'S\\') notcol++;\\n        }\\n\\t\\t\\n        // subtract the non collide cars with the total no. of cars\\n\\t\\treturn n-notcol; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696113,
                "title": "c-oneliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll cars collide except the leftmost ones which moves left and rightmost moving right.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can trim cars which don\\'t collide and count the rest\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    public int CountCollisions(string directions) =>\\n        directions.TrimStart(\\'L\\').TrimEnd(\\'R\\').Count(c => c != \\'S\\'); \\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public int CountCollisions(string directions) =>\\n        directions.TrimStart(\\'L\\').TrimEnd(\\'R\\').Count(c => c != \\'S\\'); \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346154,
                "title": "java-solution-beats-98-5",
                "content": "# Logic --> To skip all leading L\\'s and Trailing R\\'s  and then iterate the remaining L and R\\'s and keep a count of only L and R. Then return the count\\n\\n```\\nclass Solution {\\n    public int countCollisions(String dir) {\\n        int i = 0;\\n        int j = dir.length() - 1;\\n        int count = 0;\\n        while(i<dir.length() && dir.charAt(i) == \\'L\\'){\\n            i++;\\n        }\\n        while(j>=0 && dir.charAt(j) == \\'R\\'){\\n            j--;\\n        }\\n        for(int it = i;it<=j;it++){\\n            if(dir.charAt(it) != \\'S\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCollisions(String dir) {\\n        int i = 0;\\n        int j = dir.length() - 1;\\n        int count = 0;\\n        while(i<dir.length() && dir.charAt(i) == \\'L\\'){\\n            i++;\\n        }\\n        while(j>=0 && dir.charAt(j) == \\'R\\'){\\n            j--;\\n        }\\n        for(int it = i;it<=j;it++){\\n            if(dir.charAt(it) != \\'S\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048707,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> st;\\n        int n = directions.size();\\n        int left = 0;\\n        st.push(directions[left]);\\n        left++;\\n        int cnt = 0;\\n        while(left < n) \\n        {\\n            if(directions[left] == \\'R\\')\\n            {\\n                //R++;\\n                st.push(directions[left]);\\n                left++;\\n            }\\n            else if(directions[left] == \\'L\\')\\n            {\\n                if(st.top() == \\'R\\')\\n                {\\n                    st.pop();\\n                    cnt += 2;\\n                    st.push(\\'S\\');\\n                }\\n                else if(st.top() == \\'S\\')\\n                {\\n                    cnt++;\\n                }\\n                left++;\\n            }\\n            else\\n            {\\n                if(st.top() == \\'R\\')\\n                {\\n                    cnt++;\\n                    st.pop();\\n                }\\n                st.push(directions[left]);\\n                left++;\\n            }\\n            if(st.top() == \\'S\\')\\n            {\\n                st.pop();\\n                while(!st.empty() && st.top() == \\'R\\')\\n                {\\n                    cnt++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> st;\\n        int n = directions.size();\\n        int left = 0;\\n        st.push(directions[left]);\\n        left++;\\n        int cnt = 0;\\n        while(left < n) \\n        {\\n            if(directions[left] == \\'R\\')\\n            {\\n                //R++;\\n                st.push(directions[left]);\\n                left++;\\n            }\\n            else if(directions[left] == \\'L\\')\\n            {\\n                if(st.top() == \\'R\\')\\n                {\\n                    st.pop();\\n                    cnt += 2;\\n                    st.push(\\'S\\');\\n                }\\n                else if(st.top() == \\'S\\')\\n                {\\n                    cnt++;\\n                }\\n                left++;\\n            }\\n            else\\n            {\\n                if(st.top() == \\'R\\')\\n                {\\n                    cnt++;\\n                    st.pop();\\n                }\\n                st.push(directions[left]);\\n                left++;\\n            }\\n            if(st.top() == \\'S\\')\\n            {\\n                st.pop();\\n                while(!st.empty() && st.top() == \\'R\\')\\n                {\\n                    cnt++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866943,
                "title": "what-a-stupid-solution-5-lines-i-like-this-problem",
                "content": "## Observation \\nAll car will hit each other except the continuously \"L\" substring from begin of s and \\ncontinuously \"L\" substring from end of s.  This nice observation is from  \\u5F81\\u8ECD\\n\\nfor example, \\n```\\nLLL XX S X S XX RRRR    (X can be L or R)\\nL_cnt = 3, R_cnt = 4, S_cnt = 2,  length n = 14. \\nThe answer = n - S_cnt - L_cnt - R_cnt = 14- 3 - 4 - 2 = 5\\n```\\n\\nThen we can make the following good solution by 5 lines.\\n# Good solution \\n```C++\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int S_cnt=0, L_cnt=0, R_cnt=0, n = s.length();\\n        for(int i=0; i<n; i++) if(s[i]==\\'S\\') ++S_cnt;  //figure out the count of all \"S\" in s\\n        for(int i=0; i<n && s[i]==\\'L\\'; i++) ++L_cnt; //figure out the count of continuously \"L\" substring from begin of s\\n        for(int i=n-1; i>=0 && s[i]==\\'R\\';--i) ++R_cnt;  //figure out the count of continuously \"R\" substring from end of s\\n        return n - S_cnt - L_cnt - R_cnt;\\n    }\\n};\\n```\\nTime complexity O(N), Space complexity O(1) \\n\\n\\nIf the observation is too hard for people, It still have a some stupid solution can solve this problem in easy way, \\n# Idea\\nMy stupid way to  solve this easy problem \\n**Step 1.** Clean all \"LR\" in the input string\\n**Step 2.** Solve this problem RRR**S**LLL...**S**LLL ... RRR**S**LLL \\n\\n(Detail of Step 2.)\\nThe way to solve RRR**S**LLL is a simple counting problem. \\nJust count up number of R in left of S and number of L in right of S. \\nDo the samething for each S and answer will be get.\\n\\nThe following is my stipid solution that can solve this problem. \\n# Source Code \\n\\n\\n\\n```C++\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int ans = 0;\\n        int n = s.length();\\n\\t\\t//siv(S index vector) is to save all index of S after replace all \"LR\" to \"SS\"\\n        vector<int> siv; \\n\\t\\t\\n\\t\\t//Step 1.\\n\\t\\t//Replace all \"LR\" into \"SS\" and makeing the data of siv.\\n        for(int i=0; i<n;i++) {\\n            if( i+1<n && s[i] == \\'R\\' && s[i+1] == \\'L\\') {\\n                s[i] = s[i+1] = \\'S\\';\\n                ans+=2;\\n            }\\n            if(s[i]==\\'S\\') siv.push_back(i);\\n        }\\n        \\n\\t\\t//Step 2. \\n        //Start to solve this problem RRRSLLL... RRSLLL ... RRRSLLL \\n        for(auto &idx:siv) {\\n            int i = idx-1;\\n            while(i>=0 && s[i]==\\'R\\') {\\n                ++ans;\\n                s[i--] = \\'S\\';\\n            }\\n            \\n            i = idx+1;\\n            while(i<n && s[i]==\\'L\\') {\\n                ++ans;\\n                s[i++] = \\'S\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nJust need to seperate the problem in to \\ntwo steps and the there is no any \\ncomplicated case inside of this problem. \\n\\n**Upvote if my simple solution can help you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLLL XX S X S XX RRRR    (X can be L or R)\\nL_cnt = 3, R_cnt = 4, S_cnt = 2,  length n = 14. \\nThe answer = n - S_cnt - L_cnt - R_cnt = 14- 3 - 4 - 2 = 5\\n```\n```C++\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int S_cnt=0, L_cnt=0, R_cnt=0, n = s.length();\\n        for(int i=0; i<n; i++) if(s[i]==\\'S\\') ++S_cnt;  //figure out the count of all \"S\" in s\\n        for(int i=0; i<n && s[i]==\\'L\\'; i++) ++L_cnt; //figure out the count of continuously \"L\" substring from begin of s\\n        for(int i=n-1; i>=0 && s[i]==\\'R\\';--i) ++R_cnt;  //figure out the count of continuously \"R\" substring from end of s\\n        return n - S_cnt - L_cnt - R_cnt;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int ans = 0;\\n        int n = s.length();\\n\\t\\t//siv(S index vector) is to save all index of S after replace all \"LR\" to \"SS\"\\n        vector<int> siv; \\n\\t\\t\\n\\t\\t//Step 1.\\n\\t\\t//Replace all \"LR\" into \"SS\" and makeing the data of siv.\\n        for(int i=0; i<n;i++) {\\n            if( i+1<n && s[i] == \\'R\\' && s[i+1] == \\'L\\') {\\n                s[i] = s[i+1] = \\'S\\';\\n                ans+=2;\\n            }\\n            if(s[i]==\\'S\\') siv.push_back(i);\\n        }\\n        \\n\\t\\t//Step 2. \\n        //Start to solve this problem RRRSLLL... RRSLLL ... RRRSLLL \\n        for(auto &idx:siv) {\\n            int i = idx-1;\\n            while(i>=0 && s[i]==\\'R\\') {\\n                ++ans;\\n                s[i--] = \\'S\\';\\n            }\\n            \\n            i = idx+1;\\n            while(i<n && s[i]==\\'L\\') {\\n                ++ans;\\n                s[i++] = \\'S\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865619,
                "title": "simple-stack-problem-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int n=s.size();\\n        stack<char> st;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if( s[i]==\\'R\\')\\n                st.push(s[i]);     // we will take care of it in future so just push it \\n            else if(s[i]==\\'S\\')\\n            {\\n                while(st.size() && st.top()==\\'R\\')           //all cars coming from left to right will hit \\n                {\\n                    c++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');                                         //it will become a stationary object\\n            }\\n            else if(st.size())\\n            {\\n\\t\\t\\t//all cars moving to left\\n\\t\\t\\t// if a stationary object is their then you will get only 1 point only\\n                if(st.top()==\\'S\\')\\n                {\\n                    c++;\\n                    continue;\\n                }\\n                char ch=s[i];\\n\\t\\t\\t\\t// if a car is moving to right then you will get 2 points in first collision after that it will become a stationary object\\n                while(st.size() && st.top()==\\'R\\')\\n                {\\n                    if(ch==\\'L\\')\\n                        c+=2,ch=\\'S\\';\\n                    else\\n                        c++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n**please upvote**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int n=s.size();\\n        stack<char> st;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if( s[i]==\\'R\\')\\n                st.push(s[i]);     // we will take care of it in future so just push it \\n            else if(s[i]==\\'S\\')\\n            {\\n                while(st.size() && st.top()==\\'R\\')           //all cars coming from left to right will hit \\n                {\\n                    c++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');                                         //it will become a stationary object\\n            }\\n            else if(st.size())\\n            {\\n\\t\\t\\t//all cars moving to left\\n\\t\\t\\t// if a stationary object is their then you will get only 1 point only\\n                if(st.top()==\\'S\\')\\n                {\\n                    c++;\\n                    continue;\\n                }\\n                char ch=s[i];\\n\\t\\t\\t\\t// if a car is moving to right then you will get 2 points in first collision after that it will become a stationary object\\n                while(st.size() && st.top()==\\'R\\')\\n                {\\n                    if(ch==\\'L\\')\\n                        c+=2,ch=\\'S\\';\\n                    else\\n                        c++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865589,
                "title": "c-easy-to-understand-simple-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int c=0;\\n        int n=dir.size();\\n        stack<char> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dir[i]==\\'L\\'&&!s.empty()&&s.top()==\\'R\\')\\n            {\\n                bool ff=true;\\n                while(!s.empty()&&s.top()==\\'R\\')\\n                {\\n                    if(ff)\\n                    {\\n                        c+=2;\\n                        ff=false;\\n                    }\\n                    else\\n                    {\\n                        c++;\\n                    }\\n                    s.pop();\\n                }\\n                s.push(\\'S\\');\\n                continue;\\n            }\\n            else if(dir[i]==\\'S\\'&&!s.empty()&&s.top()==\\'R\\')\\n            {\\n                while(!s.empty()&&s.top()==\\'R\\')\\n                {\\n                        c++;\\n                        s.pop();\\n                }   \\n                s.push(\\'S\\');\\n                continue;\\n            }\\n            else if(dir[i]==\\'L\\'&&!s.empty()&&s.top()==\\'S\\')\\n            {\\n                c+=1;\\n                s.push(\\'S\\');\\n                continue;\\n            }\\n            s.push(dir[i]);\\n        }\\n        return c;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int c=0;\\n        int n=dir.size();\\n        stack<char> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dir[i]==\\'L\\'&&!s.empty()&&s.top()==\\'R\\')\\n            {\\n                bool ff=true;\\n                while(!s.empty()&&s.top()==\\'R\\')\\n                {\\n                    if(ff)\\n                    {\\n                        c+=2;\\n                        ff=false;\\n                    }\\n                    else\\n                    {\\n                        c++;\\n                    }\\n                    s.pop();\\n                }\\n                s.push(\\'S\\');\\n                continue;\\n            }\\n            else if(dir[i]==\\'S\\'&&!s.empty()&&s.top()==\\'R\\')\\n            {\\n                while(!s.empty()&&s.top()==\\'R\\')\\n                {\\n                        c++;\\n                        s.pop();\\n                }   \\n                s.push(\\'S\\');\\n                continue;\\n            }\\n            else if(dir[i]==\\'L\\'&&!s.empty()&&s.top()==\\'S\\')\\n            {\\n                c+=1;\\n                s.push(\\'S\\');\\n                continue;\\n            }\\n            s.push(dir[i]);\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800242,
                "title": "easy-to-understand-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int ans = 0, cnt = 0;\\n        stack<char>st;\\n        for(auto ch : directions){\\n            if(ch == \\'R\\') st.push(\\'R\\'), cnt++;\\n            else if(ch == \\'L\\'){\\n                if(!st.empty() && st.top() == \\'S\\'){\\n                    ans++;\\n                }\\n                else if(!st.empty() && st.top() == \\'R\\'){\\n                    ans += 2;\\n                    if(cnt > 1) ans += (cnt-1);\\n                    st.push(\\'S\\');\\n                    cnt = 0;\\n                }\\n            }\\n            else {\\n                if(!st.empty() && st.top() == \\'R\\') {\\n                    ans++;\\n                    if(cnt > 1) ans += (cnt-1);\\n                    st.push(\\'S\\');\\n                    cnt = 0;\\n                }\\n                st.push(\\'S\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int ans = 0, cnt = 0;\\n        stack<char>st;\\n        for(auto ch : directions){\\n            if(ch == \\'R\\') st.push(\\'R\\'), cnt++;\\n            else if(ch == \\'L\\'){\\n                if(!st.empty() && st.top() == \\'S\\'){\\n                    ans++;\\n                }\\n                else if(!st.empty() && st.top() == \\'R\\'){\\n                    ans += 2;\\n                    if(cnt > 1) ans += (cnt-1);\\n                    st.push(\\'S\\');\\n                    cnt = 0;\\n                }\\n            }\\n            else {\\n                if(!st.empty() && st.top() == \\'R\\') {\\n                    ans++;\\n                    if(cnt > 1) ans += (cnt-1);\\n                    st.push(\\'S\\');\\n                    cnt = 0;\\n                }\\n                st.push(\\'S\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642925,
                "title": "what-a-dumb-easy-solution-little-observation-is-needed-0-n",
                "content": "If you **observe** carefully that between two S whatever value is there whether it is R or L count of these L or R contributes to the collisions i will give you cases.\\n\\n1- SLLLRRRS \\n- all car\\'s with L collide wits S same for R\\'s so 6 contributes to answer\\n \\n2 - SRRLLS\\n- at index 1 and 2 collision will happen and contribution of 2 will happen then new configuration is like SRSSLS again apply idea of case 1 then 2 more contribution from R(at index 1) and L(at index 4) and if we observe carefully 4 is added to answer which is nothing but no of L or R between this S (S**RRLL**S)\\n\\nSo what we do now is just count all non S characters but **we still have to remove something** i.e----\\n1- LLLLLLLLL________  \\n- THIS L\\'S FROM LEFTMOST SIDE IS NOT CONTRIBUTING\\n\\n2- ________RRRRR      \\n- THIS R\\'S FROM RIGHTMOST SIDE IS NOT CONTRIBUTING\\n\\n***-------------------CODE IS HERE-----------------***\\n\\n```\\nint countCollisions(string s) {\\n        int  n = s.size();\\n        int collisions = 0;\\n        for(int i = 0;i<n ; i++){\\n            if(s[i]!=\\'S\\') collisions++;\\n        }\\n        for(int i =0;i<n;i++) {\\n            if(s[i]==\\'L\\') collisions--;\\n            else break;\\n        }\\n        for(int i =n-1;i>=0;i--){\\n            if(s[i]==\\'R\\') collisions--;\\n            else break;\\n        }\\n        return collisions;\\n    }\\n```\\nHope you like this solution upvote if you like this--\\n",
                "solutionTags": [],
                "code": "```\\nint countCollisions(string s) {\\n        int  n = s.size();\\n        int collisions = 0;\\n        for(int i = 0;i<n ; i++){\\n            if(s[i]!=\\'S\\') collisions++;\\n        }\\n        for(int i =0;i<n;i++) {\\n            if(s[i]==\\'L\\') collisions--;\\n            else break;\\n        }\\n        for(int i =n-1;i>=0;i--){\\n            if(s[i]==\\'R\\') collisions--;\\n            else break;\\n        }\\n        return collisions;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2947910,
                "title": "simple-just-remove-left-l-and-right-r-and-ans-is-total-count-in-remaining-without-s",
                "content": "# Intuition\\nJust remove left L and right R. and ans is total count in remaining without S becoz those will definitely stop.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int n = directions.length();\\n        int ans=0;\\n        int k=0;\\n        while(k<n && directions.charAt(k)==\\'L\\'){\\n            k++;\\n        }\\n        while(n-1>=0 && directions.charAt(n-1)==\\'R\\'){\\n            n--;\\n        }\\n\\n        for(int i=k; i<n ; i++){\\n            if(directions.charAt(i)!=\\'S\\'){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int n = directions.length();\\n        int ans=0;\\n        int k=0;\\n        while(k<n && directions.charAt(k)==\\'L\\'){\\n            k++;\\n        }\\n        while(n-1>=0 && directions.charAt(n-1)==\\'R\\'){\\n            n--;\\n        }\\n\\n        for(int i=k; i<n ; i++){\\n            if(directions.charAt(i)!=\\'S\\'){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728052,
                "title": "easy-to-understand-c-tc-o-n-constant-space-well-commented",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n    cars on the left end moving to the left side wont ever contribute to the answer since they are not gonna\\n    collide with anyone, the same way, cars on the right end and moving to the right side wont ever contribute \\n    to the answer.\\n    Keep note that all the cars in between will contribute to the answer\\n    any pattern forming an RL pair will contribute to 2 points whereas an RS or SR or LS or SL will contribute\\n    1 point.\\n    Hence the answer will be 2*rlPairs+(n-2*rlPairs-sNum)\\n    here n is basically the new size after ignoring the left ends\\' left cars and vice versa for right.\\n    */\\npublic:\\n    int countCollisions(string &str) {\\n        int n=str.size(), i=0;\\n        while(i<n&&str[i]==\\'L\\') {i++;}\\n        if(i==n) {return 0;}\\n        int j=n-1;\\n        while(str[j]==\\'R\\'&&j>i) {j--;}\\n        if(i==j) {return 0;}\\n        n=j-i+1;\\n        int rlPairs=0, sNum=0;\\n        for(int k=i; k<=j; k++) {\\n            if(str[k]==\\'S\\') {sNum++;}\\n            // else if(k+1<=j&&str[k]==\\'R\\'&&str[k+1]==\\'L\\') {rlPairs++;}\\n        }\\n        // return 2*rlPairs+n-2*rlPairs-sNum;\\n        return n-sNum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n    cars on the left end moving to the left side wont ever contribute to the answer since they are not gonna\\n    collide with anyone, the same way, cars on the right end and moving to the right side wont ever contribute \\n    to the answer.\\n    Keep note that all the cars in between will contribute to the answer\\n    any pattern forming an RL pair will contribute to 2 points whereas an RS or SR or LS or SL will contribute\\n    1 point.\\n    Hence the answer will be 2*rlPairs+(n-2*rlPairs-sNum)\\n    here n is basically the new size after ignoring the left ends\\' left cars and vice versa for right.\\n    */\\npublic:\\n    int countCollisions(string &str) {\\n        int n=str.size(), i=0;\\n        while(i<n&&str[i]==\\'L\\') {i++;}\\n        if(i==n) {return 0;}\\n        int j=n-1;\\n        while(str[j]==\\'R\\'&&j>i) {j--;}\\n        if(i==j) {return 0;}\\n        n=j-i+1;\\n        int rlPairs=0, sNum=0;\\n        for(int k=i; k<=j; k++) {\\n            if(str[k]==\\'S\\') {sNum++;}\\n            // else if(k+1<=j&&str[k]==\\'R\\'&&str[k+1]==\\'L\\') {rlPairs++;}\\n        }\\n        // return 2*rlPairs+n-2*rlPairs-sNum;\\n        return n-sNum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702118,
                "title": "2211-count-collisions-on-a-road-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string str) \\n    {    \\n       if(str.length()==0)\\n           return 0;\\n        \\n       stack<char>stk;\\n       int count=0;\\n       bool flag=false;   //ek bhi colliosin nahi hua\\n         \\n       for(int i=0;i<str.length();i++)\\n       {\\n          char ch = str[i];\\n\\n          if(stk.size()==0)\\n          {\\n            stk.push(ch);\\n          } \\n          else if(stk.size()>0)\\n          {\\n             if(ch==\\'L\\')\\n             {\\n                //if we have something like s or r on the top of the stack then collision will happen\\n                if(!stk.empty() and stk.top()==\\'L\\')\\n                {\\n                    //if we have something like l on the top of the stack then the colliosion is not possible\\n                    stk.push(ch);\\n                }\\n                else if(!stk.empty() and stk.top()==\\'R\\')\\n                {\\n                   //if we have something like  r on the top of the stack then collision will happen and counted twice\\n                   flag=true;\\n                   count=count+2;\\n                   stk.pop();\\n                   stk.push(\\'S\\');\\n                }\\n                else if(!stk.empty() and stk.top()==\\'S\\')\\n                {\\n                    //if we have something like s on the top of the stack then collision will happen and counted ones\\n                    flag=true;\\n                    count=count+1;\\n                    stk.push(\\'S\\');\\n                }\\n             }\\n             else if(ch==\\'R\\')\\n             {\\n                if(!stk.empty() and stk.top()==\\'L\\')\\n                {\\n                    //if we have something like l on the top of the stack then the colliosion is not possible\\n                    stk.push(\\'R\\');\\n                }\\n                else if(!stk.empty() and stk.top()==\\'R\\')\\n                {\\n                   //if we have something like  r on the top of the stack then collision will happen and counted twice\\n                   stk.push(\\'R\\');\\n                }\\n                else if(!stk.empty() and stk.top()==\\'S\\')\\n                {\\n                    //if we have something like s on the top of the stack then collision will happen and counted ones\\n                    stk.push(\\'R\\');\\n                } \\t\\n             }\\n             else if(ch==\\'S\\')\\n             {\\n                if(!stk.empty() and stk.top()==\\'L\\')\\n                {\\n                    //if we have something like l on the top of the stack then the colliosion is not possible\\n                    stk.push(\\'S\\');\\n                }\\n                else if(!stk.empty() and stk.top()==\\'R\\')\\n                {\\n                   //if we have something like  r on the top of the stack then collision will happen and counted twice\\n                   flag=true;\\n                   count=count+1;\\n                   stk.pop();\\n                   stk.push(\\'S\\');\\n                }\\n                else if(!stk.empty() and stk.top()==\\'S\\')\\n                {\\n                    //if we have something like s on the top of the stack then collision will happen and counted ones\\n                    stk.push(\\'S\\');\\n                } \\t\\n             }\\n          }\\n       }      \\n        while(!stk.empty())\\n        {\\n            char ch=stk.top();\\n            stk.pop();\\n            if(!stk.empty())\\n            {\\n                if(ch==\\'S\\' and stk.top()==\\'R\\')\\n                {\\n                    count+=1;\\n                    stk.top()=\\'S\\';\\n                }\\n                else if(ch==\\'L\\' and stk.top()==\\'R\\')\\n                {\\n                    stk.top()=\\'S\\';\\n                    count+=2;\\n                }\\n            }\\n        }\\n      return count;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string str) \\n    {    \\n       if(str.length()==0)\\n           return 0;\\n        \\n       stack<char>stk;\\n       int count=0;\\n       bool flag=false;   //ek bhi colliosin nahi hua\\n         \\n       for(int i=0;i<str.length();i++)\\n       {\\n          char ch = str[i];\\n\\n          if(stk.size()==0)\\n          {\\n            stk.push(ch);\\n          } \\n          else if(stk.size()>0)\\n          {\\n             if(ch==\\'L\\')\\n             {\\n                //if we have something like s or r on the top of the stack then collision will happen\\n                if(!stk.empty() and stk.top()==\\'L\\')\\n                {\\n                    //if we have something like l on the top of the stack then the colliosion is not possible\\n                    stk.push(ch);\\n                }\\n                else if(!stk.empty() and stk.top()==\\'R\\')\\n                {\\n                   //if we have something like  r on the top of the stack then collision will happen and counted twice\\n                   flag=true;\\n                   count=count+2;\\n                   stk.pop();\\n                   stk.push(\\'S\\');\\n                }\\n                else if(!stk.empty() and stk.top()==\\'S\\')\\n                {\\n                    //if we have something like s on the top of the stack then collision will happen and counted ones\\n                    flag=true;\\n                    count=count+1;\\n                    stk.push(\\'S\\');\\n                }\\n             }\\n             else if(ch==\\'R\\')\\n             {\\n                if(!stk.empty() and stk.top()==\\'L\\')\\n                {\\n                    //if we have something like l on the top of the stack then the colliosion is not possible\\n                    stk.push(\\'R\\');\\n                }\\n                else if(!stk.empty() and stk.top()==\\'R\\')\\n                {\\n                   //if we have something like  r on the top of the stack then collision will happen and counted twice\\n                   stk.push(\\'R\\');\\n                }\\n                else if(!stk.empty() and stk.top()==\\'S\\')\\n                {\\n                    //if we have something like s on the top of the stack then collision will happen and counted ones\\n                    stk.push(\\'R\\');\\n                } \\t\\n             }\\n             else if(ch==\\'S\\')\\n             {\\n                if(!stk.empty() and stk.top()==\\'L\\')\\n                {\\n                    //if we have something like l on the top of the stack then the colliosion is not possible\\n                    stk.push(\\'S\\');\\n                }\\n                else if(!stk.empty() and stk.top()==\\'R\\')\\n                {\\n                   //if we have something like  r on the top of the stack then collision will happen and counted twice\\n                   flag=true;\\n                   count=count+1;\\n                   stk.pop();\\n                   stk.push(\\'S\\');\\n                }\\n                else if(!stk.empty() and stk.top()==\\'S\\')\\n                {\\n                    //if we have something like s on the top of the stack then collision will happen and counted ones\\n                    stk.push(\\'S\\');\\n                } \\t\\n             }\\n          }\\n       }      \\n        while(!stk.empty())\\n        {\\n            char ch=stk.top();\\n            stk.pop();\\n            if(!stk.empty())\\n            {\\n                if(ch==\\'S\\' and stk.top()==\\'R\\')\\n                {\\n                    count+=1;\\n                    stk.top()=\\'S\\';\\n                }\\n                else if(ch==\\'L\\' and stk.top()==\\'R\\')\\n                {\\n                    stk.top()=\\'S\\';\\n                    count+=2;\\n                }\\n            }\\n        }\\n      return count;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911443,
                "title": "python-o-n-stack-o-1-space-counting-count-middle-movers",
                "content": "We start with the stack, managing collisions as we go.\\n\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        s = []\\n        col = 0\\n        \\n        for i, d in enumerate(directions):\\n            if d == \\'R\\':\\n                s.append(\\'R\\')\\n\\n            elif d == \\'L\\':\\n                if s and s[-1] == \\'S\\':\\n                    col += 1\\n                \\n                elif s and s[-1] == \\'R\\':\\n                    col += self.getNumRight(s) + 1\\n                    s.append(\\'S\\')\\n\\n            elif d == \\'S\\':\\n                col += self.getNumRight(s)\\n                s.append(\\'S\\')\\n        \\n        return col\\n    \\n    def getNumRight(self, s):\\n        n = 0\\n        \\n        while s and s[-1] == \\'R\\':\\n            n += 1\\n            s.pop()\\n            \\n        return n\\n        \\n```\\n\\n\\nThen we realize that our stack will always look like [SSSSRRRR], some number of S (possibly 0) followed by higher in the stack some number of R (possibly 0). So why don\\'t we just track those in two integers?\\n\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        numS = 0\\n        numR = 0\\n        col = 0\\n        \\n        for i, d in enumerate(directions):\\n            if d == \\'R\\':\\n                numR += 1\\n\\n            elif d == \\'L\\':\\n                if numR == 0 and numS > 0:\\n                    col += 1\\n                elif numR > 0:\\n                    col += numR + 1\\n                    numR = 0\\n                    numS += 1\\n\\n            elif d == \\'S\\':\\n                col += numR\\n                numR = 0\\n                numS += 1\\n        \\n        return col\\n```\\n\\nThen we realize we can strip the Ls to the left and Rs to the right. We\\'re left with immovable \"walls\" of S on each side of the string, like SRRRSSLRSLRLRLRLS. Every mover (L or R) will eventually hit some S, either an S in the middle or one of the \"immovable walls\" on the left and right side. \\n\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        stripped = directions.lstrip(\\'L\\').rstrip(\\'R\\')\\n        # string now looks like S [either R, L, or S]* S\\n        return sum(1 for c in stripped if c in [\\'L\\', \\'R\\'])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        s = []\\n        col = 0\\n        \\n        for i, d in enumerate(directions):\\n            if d == \\'R\\':\\n                s.append(\\'R\\')\\n\\n            elif d == \\'L\\':\\n                if s and s[-1] == \\'S\\':\\n                    col += 1\\n                \\n                elif s and s[-1] == \\'R\\':\\n                    col += self.getNumRight(s) + 1\\n                    s.append(\\'S\\')\\n\\n            elif d == \\'S\\':\\n                col += self.getNumRight(s)\\n                s.append(\\'S\\')\\n        \\n        return col\\n    \\n    def getNumRight(self, s):\\n        n = 0\\n        \\n        while s and s[-1] == \\'R\\':\\n            n += 1\\n            s.pop()\\n            \\n        return n\\n        \\n```\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        numS = 0\\n        numR = 0\\n        col = 0\\n        \\n        for i, d in enumerate(directions):\\n            if d == \\'R\\':\\n                numR += 1\\n\\n            elif d == \\'L\\':\\n                if numR == 0 and numS > 0:\\n                    col += 1\\n                elif numR > 0:\\n                    col += numR + 1\\n                    numR = 0\\n                    numS += 1\\n\\n            elif d == \\'S\\':\\n                col += numR\\n                numR = 0\\n                numS += 1\\n        \\n        return col\\n```\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        stripped = directions.lstrip(\\'L\\').rstrip(\\'R\\')\\n        # string now looks like S [either R, L, or S]* S\\n        return sum(1 for c in stripped if c in [\\'L\\', \\'R\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904592,
                "title": "c-solution-easy-to-understand-linear-time-complexity-o-1-extra-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int countCollisions(string s)\\n    {\\n        int i = 0;\\n        int ct = 0;\\n\\n        int k = 0; // it stores count of R and it will be subtracted if last index of R is the last element;\\n        while (i < s.length())\\n        {\\n            if (s[i] == \\'R\\' and s[i + 1] == \\'R\\')\\n            {\\n                ct++;\\n\\n                k++;\\n                if ((i + 1) == (s.length() - 1))\\n                {\\n                    ct = ct - k;\\n                }\\n                else if (s[i + 2] != s[i + 1]) // if last index of combination of R is not the last element of the string, the value of k will reset to 0\\n                {\\n                    k = 0; // k will increase only when the ending index of \\'R\\' is the last element and for the rest of the cases the value of the k is 0;\\n                }\\n            }\\n\\n            else if (s[i] == \\'R\\' and s[i + 1] == \\'L\\')\\n            {\\n                ct = ct + 2;\\n                s[i + 1] = \\'S\\';\\n            }\\n\\n            else if (s[i] == \\'S\\' and s[i + 1] == \\'L\\')\\n            {\\n                ct++;\\n\\n                s[i + 1] = \\'S\\';\\n            }\\n            else if (s[i] == \\'R\\' and s[i + 1] == \\'S\\')\\n            {\\n                ct++;\\n            }\\n\\n            i++;  \\n        }\\n\\n        return ct;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution\\n{\\npublic:\\n    int countCollisions(string s)\\n    {\\n        int i = 0;\\n        int ct = 0;\\n\\n        int k = 0; // it stores count of R and it will be subtracted if last index of R is the last element;\\n        while (i < s.length())\\n        {\\n            if (s[i] == \\'R\\' and s[i + 1] == \\'R\\')\\n            {\\n                ct++;\\n\\n                k++;\\n                if ((i + 1) == (s.length() - 1))\\n                {\\n                    ct = ct - k;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1903029,
                "title": "c-solution-two-pointer-linear-time-and-space-complexity-intuitive-code",
                "content": "**Time Complexity : O(N)\\nSpace Complexity : O(1)**\\n\\n**Simple Solution**\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int count = 0;\\n        int i = 0, j = dir.length()-1;\\n\\t\\t\\n\\t\\t// remove left moving cars from begining\\n        while(i < dir.length() and dir[i] == \\'L\\')\\n            i++;\\n        \\n\\t\\t// remove right moving cars from ending\\n        while(j >= 0 and dir[j] == \\'R\\')\\n            j--;\\n        \\n\\t\\t//  All cars betwee \\'i\\' index ad \\'j\\' index will Collide\\n\\t\\t// Count right moving and left moving only\\n        while(i <= j) {\\n            count += (dir[i] == \\'R\\');\\n            count += (dir[i] == \\'L\\');\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int count = 0;\\n        int i = 0, j = dir.length()-1;\\n\\t\\t\\n\\t\\t// remove left moving cars from begining\\n        while(i < dir.length() and dir[i] == \\'L\\')\\n            i++;\\n        \\n\\t\\t// remove right moving cars from ending\\n        while(j >= 0 and dir[j] == \\'R\\')\\n            j--;\\n        \\n\\t\\t//  All cars betwee \\'i\\' index ad \\'j\\' index will Collide\\n\\t\\t// Count right moving and left moving only\\n        while(i <= j) {\\n            count += (dir[i] == \\'R\\');\\n            count += (dir[i] == \\'L\\');\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876388,
                "title": "easy-tc-o-n-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> s;\\n        int collisions = 0;\\n        for(int i=0;i<directions.size();i++){\\n            if(s.empty()){\\n                s.push(directions[i]);\\n            }\\n            else if(directions[i]==\\'L\\'){\\n                if(s.top()==\\'R\\'){\\n                    collisions+=2;\\n                    s.pop();\\n                    while(!s.empty() && s.top()==\\'R\\'){\\n                        collisions++;\\n                        s.pop();\\n                    }\\n                    s.push(\\'S\\');\\n                }else if(s.top()==\\'S\\'){\\n                    collisions++;\\n                    \\n                }else{\\n                    s.push(\\'L\\');\\n                }\\n            }\\n            else if( directions[i]==\\'R\\'){\\n                s.push(\\'R\\');\\n            }\\n            else if(directions[i]==\\'S\\'){\\n                if(s.top()==\\'R\\'){\\n                    while(!s.empty() && s.top()==\\'R\\' ){\\n                        collisions++;\\n                        s.pop();\\n                    }\\n                    s.push(\\'S\\');\\n                }else{\\n                    s.push(\\'S\\');\\n                }\\n            }\\n        }\\n        return collisions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> s;\\n        int collisions = 0;\\n        for(int i=0;i<directions.size();i++){\\n            if(s.empty()){\\n                s.push(directions[i]);\\n            }\\n            else if(directions[i]==\\'L\\'){\\n                if(s.top()==\\'R\\'){\\n                    collisions+=2;\\n                    s.pop();\\n                    while(!s.empty() && s.top()==\\'R\\'){\\n                        collisions++;\\n                        s.pop();\\n                    }\\n                    s.push(\\'S\\');\\n                }else if(s.top()==\\'S\\'){\\n                    collisions++;\\n                    \\n                }else{\\n                    s.push(\\'L\\');\\n                }\\n            }\\n            else if( directions[i]==\\'R\\'){\\n                s.push(\\'R\\');\\n            }\\n            else if(directions[i]==\\'S\\'){\\n                if(s.top()==\\'R\\'){\\n                    while(!s.empty() && s.top()==\\'R\\' ){\\n                        collisions++;\\n                        s.pop();\\n                    }\\n                    s.push(\\'S\\');\\n                }else{\\n                    s.push(\\'S\\');\\n                }\\n            }\\n        }\\n        return collisions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869922,
                "title": "c-easy-to-understand-and-75-fast",
                "content": "DON\\'T FERGET TO UPVOTE\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int res=0,left=0,right=directions.size()-1;\\n        while(left<directions.size() && directions[left]==\\'L\\'){\\n            left++;\\n        }\\n        while(right>=0 && directions[right]==\\'R\\'){\\n            right--;\\n        }\\n        for(int i=left;i<=right;i++){\\n            if(directions[i]!=\\'S\\'){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int res=0,left=0,right=directions.size()-1;\\n        while(left<directions.size() && directions[left]==\\'L\\'){\\n            left++;\\n        }\\n        while(right>=0 && directions[right]==\\'R\\'){\\n            right--;\\n        }\\n        for(int i=left;i<=right;i++){\\n            if(directions[i]!=\\'S\\'){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869567,
                "title": "easy-c-no-stack-nothing-with-comments",
                "content": "int countCollisions(string str) {\\n        \\n        /*\\n        \\n          making the new vector and storing the string as follows\\n          \\n             string ->   R        L      R        S       LL\\n            vector  ->[(\\'R\\',1),(\\'L\\',1),(\\'R\\',1),(\\'S\\',1),(\\'L\\',2)]\\n            \\n            this will help us to count the colliosin easily\\n            \\n        */\\n        \\n        //collosion ocurs only when any of the three condition occurs\\n        /*\\n        \\n          1 R->  <-L\\n          2 R->   S\\n          3 S    <-L\\n        \\n        */\\n        vector<pair<char,int>>ans;\\n        \\n        for(int i=0;i<str.length();i++)\\n        {\\n            int count=1;\\n            \\n            while(i+1<str.length() and str[i]==str[i+1])\\n            {\\n                count++;\\n                i++;\\n            }\\n           \\n            ans.push_back({str[i],count});\\n        }\\n        \\n        \\n        \\n        int result=0;\\n        \\n        for(int i=0;i<ans.size()-1;i++)\\n        {\\n            \\n            //since R-> <-L //no of  collison will be sum of continous R+ continous Lthat we store in vector pair\\n            \\n            \\n            if(ans[i].first==\\'R\\' and ans[i+1].first==\\'L\\')/\\n            {\\n                result+=ans[i].second+ans[i+1].second;\\n            }\\n            \\n            \\n            //since R-> S  ,,right moving car will collide to S so no of  collisions will the count of countinous R\\n            \\n            \\n            else if(ans[i].first==\\'R\\' and ans[i+1].first==\\'S\\')\\n             {\\n                result+=ans[i].second;\\n            }\\n            \\n            //since S <-L ,,right moving car will collide to S so no of collisions will the count of countinous L\\n            else if(ans[i].first==\\'S\\' and ans[i+1].first==\\'L\\')\\n                \\n            {\\n                result+=ans[i+1].second;\\n            }\\n            \\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "int countCollisions(string str) {\\n        \\n        /*\\n        \\n          making the new vector and storing the string as follows\\n          \\n             string ->   R        L      R        S       LL\\n            vector  ->[(\\'R\\',1),(\\'L\\',1),(\\'R\\',1),(\\'S\\',1),(\\'L\\',2)]\\n            \\n            this will help us to count the colliosin easily\\n            \\n        */\\n        \\n        //collosion ocurs only when any of the three condition occurs\\n        /*\\n        \\n          1 R->  <-L\\n          2 R->   S\\n          3 S    <-L\\n        \\n        */\\n        vector<pair<char,int>>ans;\\n        \\n        for(int i=0;i<str.length();i++)\\n        {\\n            int count=1;\\n            \\n            while(i+1<str.length() and str[i]==str[i+1])\\n            {\\n                count++;\\n                i++;\\n            }\\n           \\n            ans.push_back({str[i],count});\\n        }\\n        \\n        \\n        \\n        int result=0;\\n        \\n        for(int i=0;i<ans.size()-1;i++)\\n        {\\n            \\n            //since R-> <-L //no of  collison will be sum of continous R+ continous Lthat we store in vector pair\\n            \\n            \\n            if(ans[i].first==\\'R\\' and ans[i+1].first==\\'L\\')/\\n            {\\n                result+=ans[i].second+ans[i+1].second;\\n            }\\n            \\n            \\n            //since R-> S  ,,right moving car will collide to S so no of  collisions will the count of countinous R\\n            \\n            \\n            else if(ans[i].first==\\'R\\' and ans[i+1].first==\\'S\\')\\n             {\\n                result+=ans[i].second;\\n            }\\n            \\n            //since S <-L ,,right moving car will collide to S so no of collisions will the count of countinous L\\n            else if(ans[i].first==\\'S\\' and ans[i+1].first==\\'L\\')\\n                \\n            {\\n                result+=ans[i+1].second;\\n            }\\n            \\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1868286,
                "title": "easy-cpp-solution-runtime-76-ms-faster-than-75-00-of-c",
                "content": "1. The problem was a good simulation problem. Here we have three cases of collision and one hidden case.\\n\\n\\nFirst case, if the car is moving R and the car next to it is moving L\\nSecond, if the car is moving R and the very next car is stationary i.e. S\\nThird, one is if the first car is stationary S and the next car is moving in left direction L\\nand the hidden case which i found it later was, what if two or more cars is moving in right direction and later on some collision take place and the car become stationary\\n\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        int n=d.size();\\n        int count=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(d[i]==\\'R\\' && d[i+1]==\\'L\\')\\n                {count+=2;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            if(d[i]==\\'S\\' && d[i+1]==\\'L\\')\\n                {count++;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            if(d[i]==\\'R\\' && d[i+1]==\\'S\\')\\n                {count++;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            // cout<<count<<\" \";\\n            // cout<<d[i]<<\" \";\\n        }\\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(d[i]==\\'R\\' && d[i+1]==\\'L\\')\\n                {count+=2;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            if(d[i]==\\'S\\' && d[i+1]==\\'L\\')\\n                {count++;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            if(d[i]==\\'R\\' && d[i+1]==\\'S\\')\\n                {count++;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            // cout<<count<<\" \";\\n            // cout<<d[i]<<\" \";\\n        }\\n     return count;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        int n=d.size();\\n        int count=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(d[i]==\\'R\\' && d[i+1]==\\'L\\')\\n                {count+=2;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            if(d[i]==\\'S\\' && d[i+1]==\\'L\\')\\n                {count++;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            if(d[i]==\\'R\\' && d[i+1]==\\'S\\')\\n                {count++;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            // cout<<count<<\" \";\\n            // cout<<d[i]<<\" \";\\n        }\\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(d[i]==\\'R\\' && d[i+1]==\\'L\\')\\n                {count+=2;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            if(d[i]==\\'S\\' && d[i+1]==\\'L\\')\\n                {count++;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            if(d[i]==\\'R\\' && d[i+1]==\\'S\\')\\n                {count++;d[i]=\\'S\\';d[i+1]=\\'S\\';}\\n            // cout<<count<<\" \";\\n            // cout<<d[i]<<\" \";\\n        }\\n     return count;   \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1867491,
                "title": "c-stack",
                "content": "```\\nint countCollisions(string s) {\\n        stack<char> st;\\n        st.push(s[0]);\\n        int ans=0;\\n        for(int i=1;i<s.size();i++){\\n            if(st.top() == \\'R\\' && s[i] == \\'L\\'){ \\n                ans += 2;\\n                st.pop();\\n                while(!st.empty() && st.top()==\\'R\\'){\\n                    ans++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n            else if(st.top() == \\'R\\' && s[i] == \\'S\\'){\\n                ans++;\\n                st.pop();\\n                while(!st.empty() && st.top()==\\'R\\'){\\n                    ans++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n            else if(st.top() == \\'S\\' && s[i] == \\'L\\'){\\n                ans++;\\n                st.pop();\\n                st.push(\\'S\\');\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint countCollisions(string s) {\\n        stack<char> st;\\n        st.push(s[0]);\\n        int ans=0;\\n        for(int i=1;i<s.size();i++){\\n            if(st.top() == \\'R\\' && s[i] == \\'L\\'){ \\n                ans += 2;\\n                st.pop();\\n                while(!st.empty() && st.top()==\\'R\\'){\\n                    ans++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n            else if(st.top() == \\'R\\' && s[i] == \\'S\\'){\\n                ans++;\\n                st.pop();\\n                while(!st.empty() && st.top()==\\'R\\'){\\n                    ans++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n            else if(st.top() == \\'S\\' && s[i] == \\'L\\'){\\n                ans++;\\n                st.pop();\\n                st.push(\\'S\\');\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1866827,
                "title": "easy-stack-approach-c",
                "content": "The problem is really simple. There are basically two scenarios for a collision:\\n1. LR\\n2. RS\\n\\nAnd when a car crashes it just stops so the next collision (if it happens will only happen with that car).\\nIf a car is going left check if a car before is going right or staying, if yes it will collide if not the left car is never colliding. When car collides increase collision accordingly and then for the remaining right going cars increase it by one. For eg:- RRRRRRS or RRRRRRL. Here collisions will be 6 and 7 respectivly.\\n\\n1. Insert R as it is going right it cannot collide with anything that comes before it. \\n2. If you encounter L check the stack if its empty dont push L. Else increase collision by one or two depending on S or R. After that pop all elements from stack and for every R increase collision by one as it will collide with these cars. After stack is empty push S to denote current collided cars.\\n3. If you encounter S do the same steps as 2.\\n\\nIt isn\\'t the best solution but it is what came to my mind. Upvote if you liked it.\\n\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) \\n    {\\n        stack<char> stk;\\n        int collisions = 0;\\n        \\n        for (int i=0;i<directions.size();i++)\\n        {\\n            if (directions[i] == \\'L\\')\\n            {\\n                if (stk.empty())\\n                    continue;\\n                \\n                if (stk.top() == \\'R\\')\\n                {\\n                    collisions += 2;\\n                    stk.pop();\\n                    \\n                    while (!stk.empty())\\n                    {\\n                        if (stk.top() == \\'R\\')\\n                            collisions++;\\n                        \\n                        stk.pop();\\n                    }\\n                    \\n                    stk.push(\\'S\\');\\n                }\\n                else\\n                {\\n                    collisions++;\\n                    stk.pop();\\n                    stk.push(\\'S\\');\\n                }\\n            }\\n            else if (directions[i] == \\'R\\')\\n            {\\n                stk.push(\\'R\\');\\n            }\\n            else\\n            {\\n                while (!stk.empty())\\n                {\\n                    if (stk.top() == \\'R\\')\\n                        collisions++;\\n\\n                    stk.pop();\\n                }\\n                \\n                stk.push(\\'S\\');\\n            }\\n        }\\n        \\n        return collisions;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) \\n    {\\n        stack<char> stk;\\n        int collisions = 0;\\n        \\n        for (int i=0;i<directions.size();i++)\\n        {\\n            if (directions[i] == \\'L\\')\\n            {\\n                if (stk.empty())\\n                    continue;\\n                \\n                if (stk.top() == \\'R\\')\\n                {\\n                    collisions += 2;\\n                    stk.pop();\\n                    \\n                    while (!stk.empty())\\n                    {\\n                        if (stk.top() == \\'R\\')\\n                            collisions++;\\n                        \\n                        stk.pop();\\n                    }\\n                    \\n                    stk.push(\\'S\\');\\n                }\\n                else\\n                {\\n                    collisions++;\\n                    stk.pop();\\n                    stk.push(\\'S\\');\\n                }\\n            }\\n            else if (directions[i] == \\'R\\')\\n            {\\n                stk.push(\\'R\\');\\n            }\\n            else\\n            {\\n                while (!stk.empty())\\n                {\\n                    if (stk.top() == \\'R\\')\\n                        collisions++;\\n\\n                    stk.pop();\\n                }\\n                \\n                stk.push(\\'S\\');\\n            }\\n        }\\n        \\n        return collisions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866420,
                "title": "easy-understanding-c",
                "content": "\\tint countCollisions(string directions) {\\n\\t\\t\\tint Rsum = 0;\\n\\t\\t\\tint Lsum = 0;\\n\\n\\t\\t\\tint r = 0;\\n\\t\\t\\tint l = 0;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//find all car going to the right will collide to the car on left\\n\\t\\t\\tfor(int i = 0; i<directions.size(); i++){\\n\\t\\t\\t\\tif(directions[i] != \\'R\\')continue;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif(i == directions.size())break;\\n\\n\\t\\t\\t\\twhile(i < directions.size() && directions[i] == \\'R\\'){\\n\\t\\t\\t\\t\\tr++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(i == directions.size())break;\\n\\t\\t\\t\\tif(directions[i] == \\'L\\'){\\n\\t\\t\\t\\t\\tRsum += (2+r);\\n\\t\\t\\t\\t\\tr = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(directions[i] == \\'S\\'){\\n\\t\\t\\t\\t\\tRsum += (1+r);\\n\\t\\t\\t\\t\\tr = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//find all the cars going to left which will collide to right.\\n\\t\\t\\tfor(int i = directions.size()-1; i>=0; i--){\\n\\t\\t\\t\\tif(directions[i] != \\'L\\')continue;\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t\\tif(i < 0)break;\\n\\n\\n\\t\\t\\t\\twhile(i >= 0 && directions[i] == \\'L\\'){\\n\\t\\t\\t\\t\\tl++;\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(i < 0)break;\\n\\t\\t\\t\\tif(directions[i] == \\'R\\'){\\n\\n\\t\\t\\t\\t\\tLsum += (0+l);\\n\\t\\t\\t\\t\\tl = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(directions[i] == \\'S\\'){\\n\\n\\t\\t\\t\\t\\tLsum += (1+l);\\n\\t\\t\\t\\t\\tl = 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (Rsum+Lsum);\\n\\t\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint countCollisions(string directions) {\\n\\t\\t\\tint Rsum = 0;\\n\\t\\t\\tint Lsum = 0;\\n\\n\\t\\t\\tint r = 0;\\n\\t\\t\\tint l = 0;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//find all car going to the right will collide to the car on left\\n\\t\\t\\tfor(int i = 0; i<directions.size(); i++){\\n\\t\\t\\t\\tif(directions[i] != \\'R\\')continue;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif(i == directions.size())break;\\n\\n\\t\\t\\t\\twhile(i < directions.size() && directions[i] == \\'R\\'){\\n\\t\\t\\t\\t\\tr++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(i == directions.size())break;\\n\\t\\t\\t\\tif(directions[i] == \\'L\\'){\\n\\t\\t\\t\\t\\tRsum += (2+r);\\n\\t\\t\\t\\t\\tr = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(directions[i] == \\'S\\'){\\n\\t\\t\\t\\t\\tRsum += (1+r);\\n\\t\\t\\t\\t\\tr = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//find all the cars going to left which will collide to right.\\n\\t\\t\\tfor(int i = directions.size()-1; i>=0; i--){\\n\\t\\t\\t\\tif(directions[i] != \\'L\\')continue;\\n\\t\\t\\t\\ti--;\\n\\t\\t\\t\\tif(i < 0)break;\\n\\n\\n\\t\\t\\t\\twhile(i >= 0 && directions[i] == \\'L\\'){\\n\\t\\t\\t\\t\\tl++;\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(i < 0)break;\\n\\t\\t\\t\\tif(directions[i] == \\'R\\'){\\n\\n\\t\\t\\t\\t\\tLsum += (0+l);\\n\\t\\t\\t\\t\\tl = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(directions[i] == \\'S\\'){\\n\\n\\t\\t\\t\\t\\tLsum += (1+l);\\n\\t\\t\\t\\t\\tl = 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (Rsum+Lsum);\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1866315,
                "title": "easy-cpp-solution-simple-if-else",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int count=0,countR=0;\\n        char prev=directions[0];\\n        \\n        if(directions[0]==\\'R\\')\\n            countR=1;\\n        \\n        for(int i=1;i<directions.size();i++){\\n            \\n            if(directions[i]==\\'L\\'){\\n                if(prev==\\'R\\'){\\n                    count+=countR+1;\\n                    prev=\\'S\\';\\n                    countR=0;\\n                }\\n                else if(prev==\\'S\\')\\n                    count++;\\n            }\\n            else if(directions[i]==\\'R\\'){\\n                prev=\\'R\\';\\n                countR++;\\n            }\\n            else if(directions[i]==\\'S\\'){\\n                if(prev==\\'R\\'){\\n                    count+=countR;\\n                    \\n                }\\n            prev=\\'S\\';\\n            countR=0;\\n            }\\n            \\n        }\\n            \\n            \\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int count=0,countR=0;\\n        char prev=directions[0];\\n        \\n        if(directions[0]==\\'R\\')\\n            countR=1;\\n        \\n        for(int i=1;i<directions.size();i++){\\n            \\n            if(directions[i]==\\'L\\'){\\n                if(prev==\\'R\\'){\\n                    count+=countR+1;\\n                    prev=\\'S\\';\\n                    countR=0;\\n                }\\n                else if(prev==\\'S\\')\\n                    count++;\\n            }\\n            else if(directions[i]==\\'R\\'){\\n                prev=\\'R\\';\\n                countR++;\\n            }\\n            else if(directions[i]==\\'S\\'){\\n                if(prev==\\'R\\'){\\n                    count+=countR;\\n                    \\n                }\\n            prev=\\'S\\';\\n            countR=0;\\n            }\\n            \\n        }\\n            \\n            \\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865945,
                "title": "tc-o-n-with-intuition-explained",
                "content": "Intution: We need to find total number of collision there are two directions L and R hence we\\'ll iterate the array from left and then from right to count all the collisions.\\nNow in first loop we are going left->right (0->n) hence we\\'ll be searching left to collide with other cars we have found before.\\nThe left counter is 0 at first as if we find the left at the start of the array where there is no car to collide as soon we find one whether it is \"R\" or \"S\" we have a car to collide hence we\\'ll increase the counter of left to 1.\\nThe same logic will be applied to the reverse loop (right->left)/(n-1->0).\\nCase: \"R\"->\"L\" will be covered in this as are traversing two times (front and reverse) hence we\\'ll cover that case 2 times and two times 1 will be added in the ans.\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        n = len(directions)\\n        left,right,ans = 0,0,0\\n        for i in range(n):\\n            if directions[i] == \"L\":\\n                ans += left \\n            else:\\n                left = 1\\n        for i in range(n-1,-1,-1):\\n            if directions[i] == \"R\":\\n                ans += right\\n            else:\\n                right = 1\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "Intution: We need to find total number of collision there are two directions L and R hence we\\'ll iterate the array from left and then from right to count all the collisions.\\nNow in first loop we are going left->right (0->n) hence we\\'ll be searching left to collide with other cars we have found before.\\nThe left counter is 0 at first as if we find the left at the start of the array where there is no car to collide as soon we find one whether it is \"R\" or \"S\" we have a car to collide hence we\\'ll increase the counter of left to 1.\\nThe same logic will be applied to the reverse loop (right->left)/(n-1->0).\\nCase: \"R\"->\"L\" will be covered in this as are traversing two times (front and reverse) hence we\\'ll cover that case 2 times and two times 1 will be added in the ans.\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        n = len(directions)\\n        left,right,ans = 0,0,0\\n        for i in range(n):\\n            if directions[i] == \"L\":\\n                ans += left \\n            else:\\n                left = 1\\n        for i in range(n-1,-1,-1):\\n            if directions[i] == \"R\":\\n                ans += right\\n            else:\\n                right = 1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1865711,
                "title": "golang-o-n-time-o-1-space-11-lines-solution",
                "content": "At first we can delete all cars without collision: all cars from left, which going left and cars from right, which going right\\nAfter that we can just sum all ```L``` and ```R``` cars \\n```golang\\nfunc countCollisions(directions string) int {\\n    res := 0\\n    directions = strings.TrimLeft(directions, \"L\")\\n    directions = strings.TrimRight(directions, \"R\")\\n    for i := 0; i < len(directions); i++ {\\n        if directions[i] == \\'L\\' || directions[i] == \\'R\\' {\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```L```\n```R```\n```golang\\nfunc countCollisions(directions string) int {\\n    res := 0\\n    directions = strings.TrimLeft(directions, \"L\")\\n    directions = strings.TrimRight(directions, \"R\")\\n    for i := 0; i < len(directions); i++ {\\n        if directions[i] == \\'L\\' || directions[i] == \\'R\\' {\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865599,
                "title": "c-easy-o-n",
                "content": "\\t   int countCollisions(string d) {\\n        int i=0;\\n        int n=d.size();\\n        int count=0;\\n        while(i<n){\\n            if(d[i]==\\'S\\'){\\n                i++;\\n                continue;\\n            }\\n            if(d[i]==\\'R\\' and i<n-1){\\n                if(d[i+1]==\\'S\\'){\\n                    d[i]=\\'S\\';\\n                    count+=1;\\n                    if(i>0 and d[i-1]==\\'R\\')i--;\\n\\n                    else i++;\\n                    \\n                }\\n                else if(d[i+1]==\\'L\\'){\\n                    count+=2;\\n                    d[i]=\\'S\\';\\n                    d[i+1]=\\'S\\';\\n                    \\n                    if(i>0 and d[i-1]==\\'R\\')i--;\\n                    else i++;\\n                }\\n                \\n                else i++;\\n            }\\n            else if(d[i]==\\'L\\' and i>0){\\n                if(d[i-1]==\\'S\\'){\\n                    count+=1;\\n                    d[i]=\\'S\\';\\n                    \\n                }\\n                else if(d[i-1]==\\'R\\'){\\n                    count+=1;\\n                    d[i]=\\'S\\';\\n                    d[i-1]=\\'S\\';\\n                }\\n                i++;\\n            }\\n            else i++;\\n            \\n        }\\n        return count;",
                "solutionTags": [],
                "code": "\\t   int countCollisions(string d) {\\n        int i=0;\\n        int n=d.size();\\n        int count=0;\\n        while(i<n){\\n            if(d[i]==\\'S\\'){\\n                i++;\\n                continue;\\n            }\\n            if(d[i]==\\'R\\' and i<n-1){\\n                if(d[i+1]==\\'S\\'){\\n                    d[i]=\\'S\\';\\n                    count+=1;\\n                    if(i>0 and d[i-1]==\\'R\\')i--;\\n\\n                    else i++;\\n                    \\n                }\\n                else if(d[i+1]==\\'L\\'){\\n                    count+=2;\\n                    d[i]=\\'S\\';\\n                    d[i+1]=\\'S\\';\\n                    \\n                    if(i>0 and d[i-1]==\\'R\\')i--;\\n                    else i++;\\n                }\\n                \\n                else i++;\\n            }\\n            else if(d[i]==\\'L\\' and i>0){\\n                if(d[i-1]==\\'S\\'){\\n                    count+=1;\\n                    d[i]=\\'S\\';\\n                    \\n                }\\n                else if(d[i-1]==\\'R\\'){\\n                    count+=1;\\n                    d[i]=\\'S\\';\\n                    d[i-1]=\\'S\\';\\n                }\\n                i++;\\n            }\\n            else i++;\\n            \\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 3792845,
                "title": "easy-cpp-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int collisionCount = 0;\\n        stack<char> dirStack;\\n        int Right_way = 0;\\n\\n        for (auto dir : directions) {\\n            \\n            if(dir == \\'R\\') Right_way++;\\n            bool noRoute = false; \\n            \\n            if (dirStack.empty()) dirStack.push(dir); \\n    \\n            else if (dirStack.top() == \\'S\\' && dir == \\'L\\') collisionCount++; \\n\\n            else if (dirStack.top() == \\'R\\' && dir == \\'L\\') {\\n                collisionCount += 2 ; dirStack.pop(); \\n                noRoute = true;Right_way--;\\n            }\\n            else dirStack.push(dir);\\n            \\n            if (noRoute || dir == \\'S\\') {\\n               collisionCount += (Right_way); \\n               Right_way = 0;\\n               dirStack.push(\\'S\\'); \\n            }\\n        }\\n        \\n        return collisionCount; // Return the total collision count\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int collisionCount = 0;\\n        stack<char> dirStack;\\n        int Right_way = 0;\\n\\n        for (auto dir : directions) {\\n            \\n            if(dir == \\'R\\') Right_way++;\\n            bool noRoute = false; \\n            \\n            if (dirStack.empty()) dirStack.push(dir); \\n    \\n            else if (dirStack.top() == \\'S\\' && dir == \\'L\\') collisionCount++; \\n\\n            else if (dirStack.top() == \\'R\\' && dir == \\'L\\') {\\n                collisionCount += 2 ; dirStack.pop(); \\n                noRoute = true;Right_way--;\\n            }\\n            else dirStack.push(dir);\\n            \\n            if (noRoute || dir == \\'S\\') {\\n               collisionCount += (Right_way); \\n               Right_way = 0;\\n               dirStack.push(\\'S\\'); \\n            }\\n        }\\n        \\n        return collisionCount; // Return the total collision count\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730213,
                "title": "java-just-pure-logic",
                "content": "```java\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int result = 0, x = 0;\\n        char prev = directions.charAt(0);\\n\\n        for(int i = 1; i < directions.length(); ++i) {\\n            char curr = directions.charAt(i);\\n\\n            if(prev == \\'R\\' && curr == \\'L\\') {\\n                result += 2 + x;\\n                prev = \\'S\\';\\n                x = 0;\\n            } else if((prev == \\'S\\' && curr == \\'L\\') || (prev == \\'R\\' && curr == \\'S\\')) {\\n                result += 1 + x;\\n                prev = \\'S\\';\\n                x = 0;\\n            } else {\\n                if(curr == \\'R\\' && prev == \\'R\\')\\n                    ++x;\\n                prev = curr;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int result = 0, x = 0;\\n        char prev = directions.charAt(0);\\n\\n        for(int i = 1; i < directions.length(); ++i) {\\n            char curr = directions.charAt(i);\\n\\n            if(prev == \\'R\\' && curr == \\'L\\') {\\n                result += 2 + x;\\n                prev = \\'S\\';\\n                x = 0;\\n            } else if((prev == \\'S\\' && curr == \\'L\\') || (prev == \\'R\\' && curr == \\'S\\')) {\\n                result += 1 + x;\\n                prev = \\'S\\';\\n                x = 0;\\n            } else {\\n                if(curr == \\'R\\' && prev == \\'R\\')\\n                    ++x;\\n                prev = curr;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008966,
                "title": "one-liner-with-built-in-methods",
                "content": "# Code\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        return sum(d!=\\'S\\' for d in directions.lstrip(\\'L\\').rstrip(\\'R\\'))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        return sum(d!=\\'S\\' for d in directions.lstrip(\\'L\\').rstrip(\\'R\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847540,
                "title": "simulation-stack-visualization-o-n",
                "content": "* The problem is just simulation of the events(collisions)\\n* when ever a collision happens all the cars involved will stop moving (important catch) these now represent a \\'S\\'\\n* iteraate over chars of the string \\n* if a \\'R\\' comes just push it\\n* if a \\'S\\' comes that means all the \\'R\\'s just before( i,e RRSRRRS in this only 3Rs will collide with \\'S\\' and the first 2 \\'R\\'s will collide to First \\'S\\' and they would have got poped already) to it will collide with it on by obe and that will be a Stationary fleet so push \\'S\\' at the end;\\n* when a \\'L\\' comes if there is \\'R\\' just  before it then it will collide(2 points) and all the continuous \\'R\\'s before it will collide (+1 points each) else if \\'L\\' seas a \\'S\\' then collides with it and become Stationary\\n* Push a \\'S\\' after performing collisions.\\n```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        Stack<Character> st = new Stack<>();\\n        int cnt = 0;\\n        for(char ch : directions.toCharArray()){\\n            if(ch == \\'R\\'){\\n                st.push(\\'R\\');\\n            }else if(ch == \\'S\\'){\\n                while(st.size() > 0 && st.peek() == \\'R\\'){\\n                    st.pop();\\n                    cnt++;\\n                }\\n                st.push(\\'S\\');\\n            }else{\\n                boolean colsn = false;\\n                if(st.size() > 0 && st.peek() == \\'R\\'){\\n                    cnt+=2;\\n                    st.pop();\\n                    colsn = true;\\n                }else if(st.size() > 0 && st.peek() == \\'S\\'){\\n                    cnt++;\\n                    colsn = true;\\n                }\\n                while(st.size() > 0 && st.peek() == \\'R\\'){\\n                    st.pop();\\n                    cnt++;\\n                    colsn = true;\\n                }\\n                if(colsn) st.push(\\'S\\');\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n**If you find this useful give \\u2B50 and a\\uD83D\\uDD3C **",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        Stack<Character> st = new Stack<>();\\n        int cnt = 0;\\n        for(char ch : directions.toCharArray()){\\n            if(ch == \\'R\\'){\\n                st.push(\\'R\\');\\n            }else if(ch == \\'S\\'){\\n                while(st.size() > 0 && st.peek() == \\'R\\'){\\n                    st.pop();\\n                    cnt++;\\n                }\\n                st.push(\\'S\\');\\n            }else{\\n                boolean colsn = false;\\n                if(st.size() > 0 && st.peek() == \\'R\\'){\\n                    cnt+=2;\\n                    st.pop();\\n                    colsn = true;\\n                }else if(st.size() > 0 && st.peek() == \\'S\\'){\\n                    cnt++;\\n                    colsn = true;\\n                }\\n                while(st.size() > 0 && st.peek() == \\'R\\'){\\n                    st.pop();\\n                    cnt++;\\n                    colsn = true;\\n                }\\n                if(colsn) st.push(\\'S\\');\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702119,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string str) {\\n        stack<char>st;\\n        int ans=0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(str[i]);\\n            }\\n            else\\n            {\\n                if(st.top()==\\'R\\' and str[i]==\\'L\\')\\n                {\\n                    st.top()=\\'S\\';\\n                    ans+=2;\\n                }\\n                else if(st.top()==\\'S\\' and str[i]==\\'L\\')\\n                {\\n                    ans+=1;\\n                }\\n                else if(st.top()==\\'S\\' and str[i]==\\'R\\')\\n                {\\n                    st.push(str[i]);\\n                }\\n                else if(st.top()==\\'R\\' and str[i]==\\'S\\')\\n                {\\n                    ans+=1;\\n                    st.top()=\\'S\\';\\n                }\\n                else if(st.top()==\\'L\\' and str[i]==\\'S\\')\\n                {\\n                    st.push(str[i]);\\n                }\\n                else\\n                {\\n                    st.push(str[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            char ch=st.top();\\n            st.pop();\\n            if(!st.empty())\\n            {\\n                if(ch==\\'S\\' and st.top()==\\'R\\')\\n                {\\n                    ans+=1;\\n                    st.top()=\\'S\\';\\n                }\\n                else if(ch==\\'L\\' and st.top()==\\'R\\')\\n                {\\n                    st.top()=\\'S\\';\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string str) {\\n        stack<char>st;\\n        int ans=0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(str[i]);\\n            }\\n            else\\n            {\\n                if(st.top()==\\'R\\' and str[i]==\\'L\\')\\n                {\\n                    st.top()=\\'S\\';\\n                    ans+=2;\\n                }\\n                else if(st.top()==\\'S\\' and str[i]==\\'L\\')\\n                {\\n                    ans+=1;\\n                }\\n                else if(st.top()==\\'S\\' and str[i]==\\'R\\')\\n                {\\n                    st.push(str[i]);\\n                }\\n                else if(st.top()==\\'R\\' and str[i]==\\'S\\')\\n                {\\n                    ans+=1;\\n                    st.top()=\\'S\\';\\n                }\\n                else if(st.top()==\\'L\\' and str[i]==\\'S\\')\\n                {\\n                    st.push(str[i]);\\n                }\\n                else\\n                {\\n                    st.push(str[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            char ch=st.top();\\n            st.pop();\\n            if(!st.empty())\\n            {\\n                if(ch==\\'S\\' and st.top()==\\'R\\')\\n                {\\n                    ans+=1;\\n                    st.top()=\\'S\\';\\n                }\\n                else if(ch==\\'L\\' and st.top()==\\'R\\')\\n                {\\n                    st.top()=\\'S\\';\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388812,
                "title": "javascript-solution-beats-81-08",
                "content": "inspired from : https://leetcode.com/problems/count-collisions-on-a-road/discuss/2056999/Very-simple-JS-with-explanation.-93-faster-O(N)-time-no-extra-space.\\n\\n```\\n/**\\n * @param {string} directions\\n * @return {number}\\n */\\nconst countCollisions = directions => {\\n  let start, end, counter = 0, n = directions.length;\\n\\n  for (let i = 0; i < n; i++)\\n    if (directions[i] !== `L`) {\\n      start = i;\\n      break;\\n    }\\n\\n  for (let i = n - 1; i > -1; i--)\\n    if (directions[i] !== `R`) {\\n      end = i;\\n      break;\\n    }\\n\\n  for (let i = start; i < end + 1; i++) \\n    if (directions[i] !== `S`)\\n      counter++;\\n\\n  return counter;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} directions\\n * @return {number}\\n */\\nconst countCollisions = directions => {\\n  let start, end, counter = 0, n = directions.length;\\n\\n  for (let i = 0; i < n; i++)\\n    if (directions[i] !== `L`) {\\n      start = i;\\n      break;\\n    }\\n\\n  for (let i = n - 1; i > -1; i--)\\n    if (directions[i] !== `R`) {\\n      end = i;\\n      break;\\n    }\\n\\n  for (let i = start; i < end + 1; i++) \\n    if (directions[i] !== `S`)\\n      counter++;\\n\\n  return counter;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2351375,
                "title": "python-solution-o-n-with-implementing-the-stack-not-returning-just-the-length",
                "content": "Let me try to explain, there is no doubt that the cars on the left side going L and cars on the right side going R will not collide, Ex the LLLRR test case in the example, the answer is zero because the LLL will all go left and RR will all go right and hence won\\'t collide, our input string might have LLL.... and RRR.. on the sides and therefore we must eliminate that as they won\\'t be doing anything to the solution, this can be done by .lstrip(\\'L\\') and .rstrip(\\'R\\'), both will simply strip out any contentious occurrence of L from the left most and R from the right most part of the string. After we get rid of that I want you to understand this \"RSL is same as RL\", because in the case of RSL there will be +1 for R to S and then +1 for L to S, in case of R AND L we simply do +1+1 which is why its +2 in the question. And hence its safe to say we can simple eliminate the S in the string as they are just dead cars, or debris out of a Michael Bay movie, that wont have any effect on the final answer. This can be done by the .replace(\\'S\\',\\'\\') after that is done we pretty much have our answer in front of us, you can perform stack operations on the remaining string or just return the length of the remaining string which would be the answer.\\n\\nAnother thing to notice now is that after doing the above operations our string will always end with \\'L\\' as any extra \\'R\\' has been stripped on the right handside.\\n\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        #i will make some modification to the string, the reason why I am doing so is explained above\\n        directions = directions.lstrip(\\'L\\').rstrip(\\'R\\').replace(\\'S\\',\\'\\')\\n        stack = []\\n        count=0\\n        for i in directions:\\n            if stack and stack[-1]==\"R\":\\n                if i==\"L\":\\n                    stack.pop()\\n                    stack.pop()\\n                    count+=2\\n                elif i==\"R\":\\n                    stack.append(i)\\n            stack.append(\"L\")\\n        \\n        return count+len(stack)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        #i will make some modification to the string, the reason why I am doing so is explained above\\n        directions = directions.lstrip(\\'L\\').rstrip(\\'R\\').replace(\\'S\\',\\'\\')\\n        stack = []\\n        count=0\\n        for i in directions:\\n            if stack and stack[-1]==\"R\":\\n                if i==\"L\":\\n                    stack.pop()\\n                    stack.pop()\\n                    count+=2\\n                elif i==\"R\":\\n                    stack.append(i)\\n            stack.append(\"L\")\\n        \\n        return count+len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303872,
                "title": "c-simple-code-using-if-else-tc-o-n-sc-o-1-with-comments",
                "content": "**c++ Solution**\\n\\n    int countCollisions(string directions) {\\n        int n = directions.size(), colls = 0;\\n        char prevdir = directions[0];// prevdir contains direction of the previous car, initializing prevdir with first car direction.\\n        int Rcount = directions[0] == \\'R\\' ? 1 : 0; // initially Rcount will be 1 if first car direction is R, else 0.\\n            \\n        for(int i=1; i<n; ++i){\\n            if(directions[i] == \\'L\\'){\\n                if(prevdir == \\'R\\'){\\n                    colls += Rcount + 1; // Adding 1 because first time collision of oppsite cars give 2 and then for every other car we add 1.\\n                    prevdir = \\'S\\'; // quenstion mentioned that after every collision, the car becomes stationary, hence dir becomes \\'S\\'.\\n                    Rcount = 0;\\n                } else if(prevdir == \\'S\\'){\\n                    colls += 1;\\n                }                \\n            } else if(directions[i] == \\'S\\'){\\n                if(prevdir == \\'R\\'){\\n                    colls += Rcount;\\n                    Rcount = 0;\\n                }\\n                prevdir = \\'S\\';\\n            } else {\\n                prevdir = \\'R\\';\\n                Rcount++;\\n            }\\n        }\\n        \\n        return colls;\\n    }\\n\\n**Time: O(N), Space: O(1).**\\n**PLEASE UPVOTE IF HELPFUL!!!**\\n\\nSimilar Question :- [ https://leetcode.com/problems/asteroid-collision/]\\n\\nFor query or doubt, comment below.",
                "solutionTags": [
                    "C"
                ],
                "code": "**c++ Solution**\\n\\n    int countCollisions(string directions) {\\n        int n = directions.size(), colls = 0;\\n        char prevdir = directions[0];// prevdir contains direction of the previous car, initializing prevdir with first car direction.\\n        int Rcount = directions[0] == \\'R\\' ? 1 : 0; // initially Rcount will be 1 if first car direction is R, else 0.\\n            \\n        for(int i=1; i<n; ++i){\\n            if(directions[i] == \\'L\\'){\\n                if(prevdir == \\'R\\'){\\n                    colls += Rcount + 1; // Adding 1 because first time collision of oppsite cars give 2 and then for every other car we add 1.\\n                    prevdir = \\'S\\'; // quenstion mentioned that after every collision, the car becomes stationary, hence dir becomes \\'S\\'.\\n                    Rcount = 0;\\n                } else if(prevdir == \\'S\\'){\\n                    colls += 1;\\n                }                \\n            } else if(directions[i] == \\'S\\'){\\n                if(prevdir == \\'R\\'){\\n                    colls += Rcount;\\n                    Rcount = 0;\\n                }\\n                prevdir = \\'S\\';\\n            } else {\\n                prevdir = \\'R\\';\\n                Rcount++;\\n            }\\n        }\\n        \\n        return colls;\\n    }\\n\\n**Time: O(N), Space: O(1).**\\n**PLEASE UPVOTE IF HELPFUL!!!**\\n\\nSimilar Question :- [ https://leetcode.com/problems/asteroid-collision/]\\n\\nFor query or doubt, comment below.",
                "codeTag": "Unknown"
            },
            {
                "id": 2195467,
                "title": "c-tc-o-n-sc-o-1-very-concise-code-detailed-explanation",
                "content": "```\\n// 1- If L is present at very strat of the string they are not going to participate in collission.\\n// 2- Similarly if R is present at the end of the string they are also not going to participate in collission.\\n// 3- remaining every element will collide at most one except S.\\n// 3a- if we have situation like \"RLS\" here we can see ans will be 2 as R collide with L. we can also treate it as every element (except S) is only moving towards write in this case also ans will be 2.\\n// 3b- other possible case may be \"SRL\" if we consider every element as L that is moving toward left we can find ans as 2.\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int n=s.size();\\n        int i=0,j=s.size()-1;\\n        while(i<n && s[i]==\\'L\\') i++;\\n        while(j>=0 && s[j]==\\'R\\') j--;\\n        int cnt_S=0;\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(s[k]==\\'S\\') cnt_S++;\\n        }\\n        return (i<=j)?(j-i-cnt_S+1):0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n// 1- If L is present at very strat of the string they are not going to participate in collission.\\n// 2- Similarly if R is present at the end of the string they are also not going to participate in collission.\\n// 3- remaining every element will collide at most one except S.\\n// 3a- if we have situation like \"RLS\" here we can see ans will be 2 as R collide with L. we can also treate it as every element (except S) is only moving towards write in this case also ans will be 2.\\n// 3b- other possible case may be \"SRL\" if we consider every element as L that is moving toward left we can find ans as 2.\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int n=s.size();\\n        int i=0,j=s.size()-1;\\n        while(i<n && s[i]==\\'L\\') i++;\\n        while(j>=0 && s[j]==\\'R\\') j--;\\n        int cnt_S=0;\\n        for(int k=i;k<=j;k++)\\n        {\\n            if(s[k]==\\'S\\') cnt_S++;\\n        }\\n        return (i<=j)?(j-i-cnt_S+1):0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109320,
                "title": "python-simple-logic",
                "content": "\\n    def countCollisions(self, directions):\\n        n = len(directions)\\n        \\n        left, right = 0, n - 1\\n        \\n        while left < n and directions[left] == \\'L\\':\\n            left += 1\\n            \\n        while right >= 0 and directions[right] == \\'R\\':\\n            right -= 1\\n        \\n        return sum(1 for car in range(left, right + 1) if directions[car] != \\'S\\')",
                "solutionTags": [],
                "code": "\\n    def countCollisions(self, directions):\\n        n = len(directions)\\n        \\n        left, right = 0, n - 1\\n        \\n        while left < n and directions[left] == \\'L\\':\\n            left += 1\\n            \\n        while right >= 0 and directions[right] == \\'R\\':\\n            right -= 1\\n        \\n        return sum(1 for car in range(left, right + 1) if directions[car] != \\'S\\')",
                "codeTag": "Python3"
            },
            {
                "id": 2055523,
                "title": "c-no-stack-o-n-time-and-o-1-space",
                "content": "```\\n  int countCollisions(string s) {\\n        int lc=0,rc=0,ans=0,sc=0,n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'L\\')lc++;\\n            else if(s[i]==\\'R\\')rc++;\\n            else\\n                sc++;\\n            if(s[i]==\\'L\\')\\n            {\\n                if(rc>0)\\n                {\\n                    ans+=2;\\n                    ans+=(rc-1);\\n                    sc=1;\\n                    rc=0;\\n                    lc=0;\\n                }\\n                else if(sc>0)\\n                {\\n                    ans+=lc;\\n                    lc=0;\\n                    sc=1;\\n                }\\n            }\\n            else if(s[i]==\\'S\\')\\n            {\\n                lc=0;\\n                sc=1;\\n                if(rc>0)\\n                {\\n                    ans+=(rc);\\n                    rc=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int countCollisions(string s) {\\n        int lc=0,rc=0,ans=0,sc=0,n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'L\\')lc++;\\n            else if(s[i]==\\'R\\')rc++;\\n            else\\n                sc++;\\n            if(s[i]==\\'L\\')\\n            {\\n                if(rc>0)\\n                {\\n                    ans+=2;\\n                    ans+=(rc-1);\\n                    sc=1;\\n                    rc=0;\\n                    lc=0;\\n                }\\n                else if(sc>0)\\n                {\\n                    ans+=lc;\\n                    lc=0;\\n                    sc=1;\\n                }\\n            }\\n            else if(s[i]==\\'S\\')\\n            {\\n                lc=0;\\n                sc=1;\\n                if(rc>0)\\n                {\\n                    ans+=(rc);\\n                    rc=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938622,
                "title": "ruby-one-liner-faster-than-100",
                "content": "```\\n# @param {String} directions\\n# @return {Integer}\\ndef count_collisions(directions)\\n  directions[/^L*([^L].*[^R])R*$/, 1].to_s.tr(\\'S\\', \\'\\').size\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} directions\\n# @return {Integer}\\ndef count_collisions(directions)\\n  directions[/^L*([^L].*[^R])R*$/, 1].to_s.tr(\\'S\\', \\'\\').size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1926334,
                "title": "easy-and-precise-time-o-n-space-o-1",
                "content": "Let \\'right\\' be the number of cars moving towards right which we\\'ve already encountered. \\'isStationaryPresent\\' represents if there is a stationary encountered object before, or a stationary object formed by the collision of \"L and R\", \"R and S\" or \"L and S\". \\n\\nWhen we encounter a \\'R\\', we increment the \\'right\\' counter as we don\\'t know what\\'s there next. When we encounter a \\'S\\', we eliminate all the right moving cars, and increments \\'collisions\\' by 1 accordingly. When we encounter a left, we check if there are right moving cars, then the first \\'R\\' and the current \\'L\\' will collide and create a stationary object, which will collide with other right moving cards encountered before.\\n\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int right = 0, collisions = 0; bool isStationaryPresent = false;\\n        for(char &d : directions) {\\n            if(d == \\'R\\')\\n                right++;\\n            else if(d == \\'L\\') {\\n                if(right > 0) {\\n                    collisions += 1+right;\\n                    right = 0;\\n                    isStationaryPresent = true;\\n                }\\n                else if(isStationaryPresent)\\n                    collisions++;\\n            }\\n            else {\\n                isStationaryPresent = true;\\n                collisions += right;\\n                right = 0;\\n            }\\n        }\\n        return collisions;\\n    }\\n};\\n```\\n\\nFeel free to comment and please upvote!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int right = 0, collisions = 0; bool isStationaryPresent = false;\\n        for(char &d : directions) {\\n            if(d == \\'R\\')\\n                right++;\\n            else if(d == \\'L\\') {\\n                if(right > 0) {\\n                    collisions += 1+right;\\n                    right = 0;\\n                    isStationaryPresent = true;\\n                }\\n                else if(isStationaryPresent)\\n                    collisions++;\\n            }\\n            else {\\n                isStationaryPresent = true;\\n                collisions += right;\\n                right = 0;\\n            }\\n        }\\n        return collisions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898369,
                "title": "java-using-sttack",
                "content": "\\n\\n        \\n        Stack<Character> st=new Stack<>();\\n        int ans=0;\\n        for(int i=0;i<directions.length();i++)\\n        {\\n            char ch=directions.charAt(i);\\n            if(st.size()==0 && ch==\\'L\\')\\n                continue;\\n            if(st.size()==0 || ch==\\'R\\')\\n            {\\n                st.push(ch);\\n                continue;\\n            }\\n            else if(ch==\\'L\\')\\n            {\\n                if(st.peek()==\\'R\\')\\n                {\\n                   ans+=2;\\n                   st.pop();\\n                }\\n                else\\n                {\\n                    ans+=1;\\n                    st.pop();\\n                }\\n                while(st.size()>0 && st.peek()==\\'R\\')\\n                {\\n                       st.pop();\\n                       ans+=1;\\n                 }\\n                   st.push(\\'S\\'); \\n            }\\n            else if(ch==\\'S\\')\\n            {\\n                  while(st.size()>0 && st.peek()==\\'R\\')\\n                   {\\n                       st.pop();\\n                       ans+=1;\\n                   }\\n                   st.push(\\'S\\'); \\n\\n            }\\n            \\n        }\\n        return ans;\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "\\n\\n        \\n        Stack<Character> st=new Stack<>();\\n        int ans=0;\\n        for(int i=0;i<directions.length();i++)\\n        {\\n            char ch=directions.charAt(i);\\n            if(st.size()==0 && ch==\\'L\\')\\n                continue;\\n            if(st.size()==0 || ch==\\'R\\')\\n            {\\n                st.push(ch);\\n                continue;\\n            }\\n            else if(ch==\\'L\\')\\n            {\\n                if(st.peek()==\\'R\\')\\n                {\\n                   ans+=2;\\n                   st.pop();\\n                }\\n                else\\n                {\\n                    ans+=1;\\n                    st.pop();\\n                }\\n                while(st.size()>0 && st.peek()==\\'R\\')\\n                {\\n                       st.pop();\\n                       ans+=1;\\n                 }\\n                   st.push(\\'S\\'); \\n            }\\n            else if(ch==\\'S\\')\\n            {\\n                  while(st.size()>0 && st.peek()==\\'R\\')\\n                   {\\n                       st.pop();\\n                       ans+=1;\\n                   }\\n                   st.push(\\'S\\'); \\n\\n            }\\n            \\n        }\\n        return ans;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1896501,
                "title": "c-the-most-elegant-solution-in-o-n-using-only-3-cases",
                "content": "```\\nThere are only \\'3\\' cases where collisions are possible\\n\\n[01] (n*R)L -> collision count = n + 1\\n- here we keep track of number of \\'R\\'s and if \\'L\\' is encountered we add n + 1 to count\\n- we update \\'L\\' to \\'S\\', since after collision it becomes stationary.\\n\\n[02] (n*R)S -> collision count = n\\n- here we keep track of number of \\'R\\'s and if \\'S\\' is encountered we add n to count\\n- no need of updating \\'S\\' ro \\'S\\'\\n\\n[03] (m*S)(n*L) -> collision count = n\\n- number of \\'S\\' before \\'L\\' doesn\\'t matter\\n- update the colllided \\'L\\' to \\'S\\'\\n\\nnote that if the string is say \"RRRLLL\", \"RRRL\" is handled by the first \\'if else\\' and the first \\'L\\' is updated to \\'S\\', so next time \"SLL\" is handled by third \\'if else\\'\\n\\nrest all cases can be ignored\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions){\\n        int i, R = 0, count = 0;\\n        \\n        for (i = 1; i < directions.size(); ++i){\\n            \\n            if (directions[i - 1] == \\'R\\' && directions[i] == \\'R\\')\\n                ++R;\\n            \\n            else if (directions[i - 1] == \\'R\\' && directions[i] == \\'L\\'){\\n                count += R + 2;\\n                directions[i] = \\'S\\';\\n                R = 0;}\\n            \\n            else if (directions[i - 1] == \\'R\\' && directions[i] == \\'S\\'){\\n                count += R + 1;\\n                R = 0;}\\n            \\n            else if (directions[i - 1] == \\'S\\' && directions[i] == \\'L\\'){\\n                ++count;\\n                directions[i] = \\'S\\';}}\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n**Do upvote if these details helped you understand.**",
                "solutionTags": [],
                "code": "```\\nThere are only \\'3\\' cases where collisions are possible\\n\\n[01] (n*R)L -> collision count = n + 1\\n- here we keep track of number of \\'R\\'s and if \\'L\\' is encountered we add n + 1 to count\\n- we update \\'L\\' to \\'S\\', since after collision it becomes stationary.\\n\\n[02] (n*R)S -> collision count = n\\n- here we keep track of number of \\'R\\'s and if \\'S\\' is encountered we add n to count\\n- no need of updating \\'S\\' ro \\'S\\'\\n\\n[03] (m*S)(n*L) -> collision count = n\\n- number of \\'S\\' before \\'L\\' doesn\\'t matter\\n- update the colllided \\'L\\' to \\'S\\'\\n\\nnote that if the string is say \"RRRLLL\", \"RRRL\" is handled by the first \\'if else\\' and the first \\'L\\' is updated to \\'S\\', so next time \"SLL\" is handled by third \\'if else\\'\\n\\nrest all cases can be ignored\\n```\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions){\\n        int i, R = 0, count = 0;\\n        \\n        for (i = 1; i < directions.size(); ++i){\\n            \\n            if (directions[i - 1] == \\'R\\' && directions[i] == \\'R\\')\\n                ++R;\\n            \\n            else if (directions[i - 1] == \\'R\\' && directions[i] == \\'L\\'){\\n                count += R + 2;\\n                directions[i] = \\'S\\';\\n                R = 0;}\\n            \\n            else if (directions[i - 1] == \\'R\\' && directions[i] == \\'S\\'){\\n                count += R + 1;\\n                R = 0;}\\n            \\n            else if (directions[i - 1] == \\'S\\' && directions[i] == \\'L\\'){\\n                ++count;\\n                directions[i] = \\'S\\';}}\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895332,
                "title": "count-collisions-on-a-road-c-easy-solution-two-pointer-approach",
                "content": "**Time Complexity : O(N)\\nSpace Complexity : O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        \\n        int l = 0, r = d.size()-1;\\n        while(l < d.size() and d[l] == \\'L\\'){\\n            l++;\\n        }\\n        while(r>=0 and d[r] == \\'R\\'){\\n            r--;\\n        }\\n        int ans = 0;\\n        while(l<=r){\\n            if(d[l++]!=\\'S\\')\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        \\n        int l = 0, r = d.size()-1;\\n        while(l < d.size() and d[l] == \\'L\\'){\\n            l++;\\n        }\\n        while(r>=0 and d[r] == \\'R\\'){\\n            r--;\\n        }\\n        int ans = 0;\\n        while(l<=r){\\n            if(d[l++]!=\\'S\\')\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889813,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        collisions = 0\\n        st = [directions[0]]\\n        \\n        for i in range(1, len(directions)):\\n            d = directions[i]\\n            \\n            if st[-1] == \\'R\\' and (d == \\'L\\' or d == \\'S\\'):\\n                st.pop()\\n                collisions += 2 if d == \\'L\\' else 1\\n                \\n                while st and st[-1] == \\'R\\':\\n                    st.pop()\\n                    collisions += 1\\n                    \\n                st.append(\\'S\\')\\n                \\n            elif d == \\'L\\' and st[-1] == \\'S\\':\\n                collisions += 1\\n            elif d == \\'S\\':\\n                st = [d]\\n            elif d == \\'R\\':\\n                st.append(d)\\n        \\n        return collisions\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        collisions = 0\\n        st = [directions[0]]\\n        \\n        for i in range(1, len(directions)):\\n            d = directions[i]\\n            \\n            if st[-1] == \\'R\\' and (d == \\'L\\' or d == \\'S\\'):\\n                st.pop()\\n                collisions += 2 if d == \\'L\\' else 1\\n                \\n                while st and st[-1] == \\'R\\':\\n                    st.pop()\\n                    collisions += 1\\n                    \\n                st.append(\\'S\\')\\n                \\n            elif d == \\'L\\' and st[-1] == \\'S\\':\\n                collisions += 1\\n            elif d == \\'S\\':\\n                st = [d]\\n            elif d == \\'R\\':\\n                st.append(d)\\n        \\n        return collisions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888481,
                "title": "c-code-for-beginners-easy-code-using-stack-without-stack",
                "content": "# **NO STACK**\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int res=0;\\n        int i=0;\\n        int n=directions.size();\\n        while(i<n && directions[i]==\\'L\\'){\\n            i++;\\n        }\\n        int carsRight=0;\\n        while(i<n){\\n            if(directions[i]==\\'R\\'){  // moving right, increment all rightSide cars\\n                carsRight++;\\n            }\\n            else{\\n                res+=(directions[i]==\\'S\\' ? carsRight : carsRight+1); \\n/* if we encounter a stationary car all rightSide cars will chain collide \\nand give sum of number of rightSide cars points, while if we have a left \\nincoming car, we will get 1+carRight points, because carRight-1 points for\\nstationary collision and +2 for head on moving collision so total points comes\\nto carRight+1*/\\n                carsRight=0;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# **Using Stack**\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int res=0;\\n        stack<char> s;\\n        int i=0;\\n        int n=directions.size();\\n        while(i<n && directions[i]==\\'L\\'){  // ignoring all left going cars from first <- <- <- etc\\n            i++;\\n        }\\n        while(i<n){\\n            if(directions[i]==\\'R\\'){  // if we got a right going car push it in stack\\n                s.push(\\'R\\');\\n            }\\n            else if(!s.empty() && s.top()==\\'R\\' && directions[i]==\\'L\\'){  //collision, ->  <- , collision is bound to happen\\n                res+=2;  //collision points for two head on head moving cars\\n                s.pop();  // pop the right incoming car, its stationary now, so all cars behind it will crash also\\n                while(!s.empty() && s.top()==\\'R\\'){ //chain collision of all rightSide cars\\n                    s.pop();\\n                    res++;  //collision for a moving and stationary car is 1.  -> -> \\'S\\',  -> \\'S\\' \\'S\\',   \\'S\\' \\'S\\' \\'S\\'\\n                }\\n                s.push(\\'S\\');  //Push the stationary car in stack\\n            }\\n            else if(!s.empty() && s.top()==\\'S\\' && directions[i]==\\'L\\'){  // if a car hits a stationary car from left side \\'S\\' <-\\n                res++;\\n            }\\n            else if(directions[i]==\\'S\\'){  // if we are having a stationary car now\\n                while(!s.empty() && s.top()==\\'R\\'){ // all rightSide cars are gonna hit one after another with this, A chain collision\\n                    s.pop();\\n                    res++;\\n                }\\n                if(s.empty()){  //if all rightSide cars crashed and stack got empty, we just have a stationary car now.\\n                    s.push(\\'S\\');\\n                }\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int res=0;\\n        int i=0;\\n        int n=directions.size();\\n        while(i<n && directions[i]==\\'L\\'){\\n            i++;\\n        }\\n        int carsRight=0;\\n        while(i<n){\\n            if(directions[i]==\\'R\\'){  // moving right, increment all rightSide cars\\n                carsRight++;\\n            }\\n            else{\\n                res+=(directions[i]==\\'S\\' ? carsRight : carsRight+1); \\n/* if we encounter a stationary car all rightSide cars will chain collide \\nand give sum of number of rightSide cars points, while if we have a left \\nincoming car, we will get 1+carRight points, because carRight-1 points for\\nstationary collision and +2 for head on moving collision so total points comes\\nto carRight+1*/\\n                carsRight=0;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int res=0;\\n        stack<char> s;\\n        int i=0;\\n        int n=directions.size();\\n        while(i<n && directions[i]==\\'L\\'){  // ignoring all left going cars from first <- <- <- etc\\n            i++;\\n        }\\n        while(i<n){\\n            if(directions[i]==\\'R\\'){  // if we got a right going car push it in stack\\n                s.push(\\'R\\');\\n            }\\n            else if(!s.empty() && s.top()==\\'R\\' && directions[i]==\\'L\\'){  //collision, ->  <- , collision is bound to happen\\n                res+=2;  //collision points for two head on head moving cars\\n                s.pop();  // pop the right incoming car, its stationary now, so all cars behind it will crash also\\n                while(!s.empty() && s.top()==\\'R\\'){ //chain collision of all rightSide cars\\n                    s.pop();\\n                    res++;  //collision for a moving and stationary car is 1.  -> -> \\'S\\',  -> \\'S\\' \\'S\\',   \\'S\\' \\'S\\' \\'S\\'\\n                }\\n                s.push(\\'S\\');  //Push the stationary car in stack\\n            }\\n            else if(!s.empty() && s.top()==\\'S\\' && directions[i]==\\'L\\'){  // if a car hits a stationary car from left side \\'S\\' <-\\n                res++;\\n            }\\n            else if(directions[i]==\\'S\\'){  // if we are having a stationary car now\\n                while(!s.empty() && s.top()==\\'R\\'){ // all rightSide cars are gonna hit one after another with this, A chain collision\\n                    s.pop();\\n                    res++;\\n                }\\n                if(s.empty()){  //if all rightSide cars crashed and stack got empty, we just have a stationary car now.\\n                    s.push(\\'S\\');\\n                }\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885352,
                "title": "c-two-pointers",
                "content": "\\tint countCollisions(string s) {\\n        int l = 0, n = s.length(), r = n - 1, ans = 0;\\n        \\n        while(l < n && s[l] == \\'L\\')\\n            l++;\\n        \\n        while(r >= 0 && s[r] == \\'R\\')\\n            r--;\\n        \\n        while(l <= r) {\\n            if(s[l] != \\'S\\')\\n                ans++;\\n            \\n            l++;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\tint countCollisions(string s) {\\n        int l = 0, n = s.length(), r = n - 1, ans = 0;\\n        \\n        while(l < n && s[l] == \\'L\\')\\n            l++;\\n        \\n        while(r >= 0 && s[r] == \\'R\\')\\n            r--;\\n        \\n        while(l <= r) {\\n            if(s[l] != \\'S\\')\\n                ans++;\\n            \\n            l++;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1875456,
                "title": "easy-to-understand-faster-than-100-00-of-python-online-submissions",
                "content": "- 3 times faster than the 2nd fastest submission.\\n-  using less memory than 94.81% of submissions.\\n\\nAs stated in other responses, the key is to understand that all leading L\\'s all trailing R\\'s will escape collision.  Everything else that is moving will collide with something, and since the S\\'s don\\'t score a point if something collides with it, we need only count the R\\'s and L\\'s after stripping out leading L\\'s and trailing R\\'s.\\n\\nIt might have been greatly simplified with `directions.rstrip(\\'L\\')` and `directions.lstrip(\\'R\\')`, but apparently these functions are more costly than returning a slice of a string.  A potentially faster alternative still might have been to `return len(dirs) - dirs.count(\\'S\\')`\\n\\nMy code is as follows...\\n\\n```\\nclass Solution(object):\\n    def countCollisions(self, directions):\\n        \"\"\"\\n        :type directions: str\\n        :rtype: int\\n        \"\"\"\\n        if len(directions) <= 1: return 0\\n        dirs = str(directions)\\n        start = min((dirs.find(\\'R\\') if dirs.find(\\'R\\') != -1 else len(dirs)), \\\\\\n                    (dirs.find(\\'S\\') if dirs.find(\\'S\\') != -1 else len(dirs)))\\n        if start == -1: start = 0\\n        end = max(dirs.rfind(\\'L\\'), dirs.rfind(\\'S\\'))\\n        dirs = dirs[start:end+1]\\n        return dirs.count(\\'R\\') + dirs.count(\\'L\\') ```\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countCollisions(self, directions):\\n        \"\"\"\\n        :type directions: str\\n        :rtype: int\\n        \"\"\"\\n        if len(directions) <= 1: return 0\\n        dirs = str(directions)\\n        start = min((dirs.find(\\'R\\') if dirs.find(\\'R\\') != -1 else len(dirs)), \\\\\\n                    (dirs.find(\\'S\\') if dirs.find(\\'S\\') != -1 else len(dirs)))\\n        if start == -1: start = 0\\n        end = max(dirs.rfind(\\'L\\'), dirs.rfind(\\'S\\'))\\n        dirs = dirs[start:end+1]\\n        return dirs.count(\\'R\\') + dirs.count(\\'L\\') ```",
                "codeTag": "Java"
            },
            {
                "id": 1871565,
                "title": "python-with-detailed-explanation",
                "content": "We will count L\\'s and R\\'s  collision separately in two different loops. \\nThere are three kinds of collisions:\\n1. L and R: it will increase total collisions by two.  We can see it as L and R each caused one collision.\\n2. R and S: only \"RS\" will cause a collision, but \"SR\" doesn\\'t result in collision. So we will have to check if there is any \"R\" on the left of \"S\".\\n3. S and L:  only \"SL\"  will cause a collision, but \"LS\" doesn\\'t result in collision. We will have to check if there is any \"S\"  on the left of \"L\". So we loop backwards. \\n\\nFor cars heading right ,\\n\\t if there is L(s) to its right, the cars will collide, and total collision increase by the number total Rs. \\n\\tif there is S to its right,  two cars will collide, and total collision increase by the number total Rs. \\n\\t\\nFor cars heading left ,\\n\\tif there is R(s) to its left, the cars will collide, and total collision increase by the number total Ls. \\n\\t if there is S to its left, the cars will collide, and total collision increase by the number total Ls. \\n```\\nclass Solution(object):\\n    def countCollisions(self, directions):\\n        \"\"\"\\n        :type directions: str\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        carsFromRight = 0\\n        carsFromLeft = 0\\n        for car in directions:\\n            if car == \\'R\\':\\n                carsFromRight += 1\\n            if car == \\'S\\':\\n                ans += carsFromRight\\n                carsFromRight = 0\\n            if car == \"L\":\\n                ans += carsFromRight\\n                carsFromRight = 0\\n\\n        for car in reversed(directions):\\n            if car == \"L\":\\n                carsFromLeft += 1\\n            if car == \\'S\\':\\n                ans += carsFromLeft\\n                carsFromLeft = 0\\n            if car == \\'R\\':\\n                ans += carsFromLeft\\n                carsFromLeft = 0\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countCollisions(self, directions):\\n        \"\"\"\\n        :type directions: str\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        carsFromRight = 0\\n        carsFromLeft = 0\\n        for car in directions:\\n            if car == \\'R\\':\\n                carsFromRight += 1\\n            if car == \\'S\\':\\n                ans += carsFromRight\\n                carsFromRight = 0\\n            if car == \"L\":\\n                ans += carsFromRight\\n                carsFromRight = 0\\n\\n        for car in reversed(directions):\\n            if car == \"L\":\\n                carsFromLeft += 1\\n            if car == \\'S\\':\\n                ans += carsFromLeft\\n                carsFromLeft = 0\\n            if car == \\'R\\':\\n                ans += carsFromLeft\\n                carsFromLeft = 0\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871323,
                "title": "53-85-faster-solution-in-javascript-constant-space-use-and-time-complexity-o-n",
                "content": "```\\n/**\\n * @param {string} directions\\n * @return {number}\\n */\\nvar countCollisions = function(directions) {\\n            if(directions.length == 1){\\n            return 0;\\n        }\\n        let count =0;\\n        let couplet;\\n        let retreivedWieght;\\n        let convertedArr=[];\\n        let rightMovingCount= 0;\\n        let  weights= new Map();\\n        weights.set(\"LR\",0);\\n        weights.set(\"RL\",2);\\n        weights.set(\"LS\",0);\\n        weights.set(\"SL\",1);\\n        weights.set(\"SR\",0);\\n        weights.set(\"RS\",1);\\n        weights.set(\"LL\",0);\\n        weights.set(\"RR\",0);\\n        weights.set(\"SS\",0);\\n        \\n        for(let i=0;i<directions.length;i++){\\n            convertedArr[i]=directions[i];\\n        }\\n        \\n        for(let i=1;i< convertedArr.length; i++){\\n            couplet=convertedArr[i-1]+convertedArr[i];\\n            retreivedWieght=weights.get(couplet);\\n            count=count+retreivedWieght;\\n            if(retreivedWieght>0){\\n                convertedArr[i-1]=\"S\"; \\n                convertedArr[i]=\"S\";\\n                if(rightMovingCount>0){\\n                    count=count+rightMovingCount;\\n                    rightMovingCount=0;\\n                }\\n            }\\n            if(couplet === \"RR\"){\\n                rightMovingCount++;\\n            }\\n            \\n        }\\n        return count;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/44c2f1b4-8529-4b94-a9f2-7f638527d6ac_1647893275.942525.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {string} directions\\n * @return {number}\\n */\\nvar countCollisions = function(directions) {\\n            if(directions.length == 1){\\n            return 0;\\n        }\\n        let count =0;\\n        let couplet;\\n        let retreivedWieght;\\n        let convertedArr=[];\\n        let rightMovingCount= 0;\\n        let  weights= new Map();\\n        weights.set(\"LR\",0);\\n        weights.set(\"RL\",2);\\n        weights.set(\"LS\",0);\\n        weights.set(\"SL\",1);\\n        weights.set(\"SR\",0);\\n        weights.set(\"RS\",1);\\n        weights.set(\"LL\",0);\\n        weights.set(\"RR\",0);\\n        weights.set(\"SS\",0);\\n        \\n        for(let i=0;i<directions.length;i++){\\n            convertedArr[i]=directions[i];\\n        }\\n        \\n        for(let i=1;i< convertedArr.length; i++){\\n            couplet=convertedArr[i-1]+convertedArr[i];\\n            retreivedWieght=weights.get(couplet);\\n            count=count+retreivedWieght;\\n            if(retreivedWieght>0){\\n                convertedArr[i-1]=\"S\"; \\n                convertedArr[i]=\"S\";\\n                if(rightMovingCount>0){\\n                    count=count+rightMovingCount;\\n                    rightMovingCount=0;\\n                }\\n            }\\n            if(couplet === \"RR\"){\\n                rightMovingCount++;\\n            }\\n            \\n        }\\n        return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1871220,
                "title": "python3-two-liner-44ms",
                "content": "Get rid of cars that are moving away from the center, and count all the cars that are moving towards the center.\\n\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        x = directions.lstrip(\"L\").rstrip(\"R\")\\n        return len(x) - x.count(\"S\")\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        x = directions.lstrip(\"L\").rstrip(\"R\")\\n        return len(x) - x.count(\"S\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868594,
                "title": "javascript-stack-solution",
                "content": "```\\n/**\\n * @param {string} directions\\n * @return {number}\\n */\\nconst countCollisions = (directions) => {\\n  if (directions.length === 1) return 0;\\n  let stack = [directions[0]];\\n  let collisions = 0;\\n  for (let i = 1; i < directions.length; i++) {\\n    const top = stack[stack.length - 1];\\n    if (\\n      (directions[i] === \\'L\\' && (top === \\'S\\' || top === \\'R\\')) ||\\n      (directions[i] === \\'S\\' && top === \\'R\\')\\n    ) {\\n      stack.pop();\\n      stack.push(\\'S\\');\\n\\n      if (directions[i] === \\'L\\' && top === \\'R\\') {\\n        collisions += 2;\\n      } else {\\n        collisions++;\\n      }\\n    } else {\\n      stack.push(directions[i]);\\n    }\\n  }\\n\\n  for (let i = stack.length - 1; i >= 0; i--) {\\n    if (stack[i] === \\'S\\') {\\n      continue;\\n    } else if (stack[i] === \\'R\\') {\\n      if (!stack[i + 1] || stack[i + 1] === \\'R\\') {\\n        continue;\\n      } else {\\n        stack[i] = \\'S\\';\\n        collisions++;\\n      }\\n    } else {\\n      if (!stack[i - 1] || stack[i - 1] === \\'L\\') {\\n        continue;\\n      } else {\\n        stack[i] = \\'S\\';\\n        collisions++;\\n      }\\n    }\\n  }\\n\\n  return collisions;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} directions\\n * @return {number}\\n */\\nconst countCollisions = (directions) => {\\n  if (directions.length === 1) return 0;\\n  let stack = [directions[0]];\\n  let collisions = 0;\\n  for (let i = 1; i < directions.length; i++) {\\n    const top = stack[stack.length - 1];\\n    if (\\n      (directions[i] === \\'L\\' && (top === \\'S\\' || top === \\'R\\')) ||\\n      (directions[i] === \\'S\\' && top === \\'R\\')\\n    ) {\\n      stack.pop();\\n      stack.push(\\'S\\');\\n\\n      if (directions[i] === \\'L\\' && top === \\'R\\') {\\n        collisions += 2;\\n      } else {\\n        collisions++;\\n      }\\n    } else {\\n      stack.push(directions[i]);\\n    }\\n  }\\n\\n  for (let i = stack.length - 1; i >= 0; i--) {\\n    if (stack[i] === \\'S\\') {\\n      continue;\\n    } else if (stack[i] === \\'R\\') {\\n      if (!stack[i + 1] || stack[i + 1] === \\'R\\') {\\n        continue;\\n      } else {\\n        stack[i] = \\'S\\';\\n        collisions++;\\n      }\\n    } else {\\n      if (!stack[i - 1] || stack[i - 1] === \\'L\\') {\\n        continue;\\n      } else {\\n        stack[i] = \\'S\\';\\n        collisions++;\\n      }\\n    }\\n  }\\n\\n  return collisions;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868029,
                "title": "java-4-line-solution-o-n-time-o-1-space",
                "content": "**Runtime: 19 ms, faster than 100.00% of Java online submissions for Count Collisions on a Road.\\nMemory Usage: 54.1 MB, less than 100.00% of Java online submissions for Count Collisions on a Road.**\\n```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int i = 0, j = directions.length()-1,n = directions.length(),res = 0;\\n        while(i < n && directions.charAt(i) == \\'L\\')i++;\\n        while(j >= 0 && directions.charAt(j) == \\'R\\')j--;\\n        while(i <= j)if(directions.charAt(i++) != \\'S\\')res++;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int i = 0, j = directions.length()-1,n = directions.length(),res = 0;\\n        while(i < n && directions.charAt(i) == \\'L\\')i++;\\n        while(j >= 0 && directions.charAt(j) == \\'R\\')j--;\\n        while(i <= j)if(directions.charAt(i++) != \\'S\\')res++;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868001,
                "title": "time-complexity-o-n-space-complexity-o-1-my-stupid-code",
                "content": "r : how many currently car move to the right without collision.\\n\\nFor three directions:\\n\\'L\\' :\\n\\t1. If there is a car which is moving to right, then we plus 2 collisions, and current position become \"S\".\\n\\t2. If there is only a stationary car , then we add 1 collision, and current position become \"S\".\\n\\t3. just move to next car.\\n\\n\\'S\\': For all car which is moving to right without collision will collide now, hence we plus answer by \"r\" , and reset \"r\" to 0. And set the \"s\" to 1 to indicate that there is a stationary car, and move to next car(i++).\\n\\n\\'R\\': r plus one and move to next car.\\n\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int ans = 0 , r = 0 , s = 0, i = 0, n = directions.size();\\n        while(i < n) {\\n            if(directions[i] == \\'L\\') {\\n                if(r) {\\n                    ans += 2 + max(r - 1, 0);\\n                    r = 0;\\n                    s = 1;\\n                    directions[i] = \\'S\\';\\n                } else if(s) {\\n                    ans += 1;\\n                    directions[i] = \\'S\\';\\n                } else {\\n                    i++;\\n                }\\n            } else if(directions[i] == \\'S\\') {\\n                ans += r;\\n                r = 0;\\n                s = 1;\\n                i++;\\n            } else {\\n                r += 1;\\n                i++;\\n            }    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int ans = 0 , r = 0 , s = 0, i = 0, n = directions.size();\\n        while(i < n) {\\n            if(directions[i] == \\'L\\') {\\n                if(r) {\\n                    ans += 2 + max(r - 1, 0);\\n                    r = 0;\\n                    s = 1;\\n                    directions[i] = \\'S\\';\\n                } else if(s) {\\n                    ans += 1;\\n                    directions[i] = \\'S\\';\\n                } else {\\n                    i++;\\n                }\\n            } else if(directions[i] == \\'S\\') {\\n                ans += r;\\n                r = 0;\\n                s = 1;\\n                i++;\\n            } else {\\n                r += 1;\\n                i++;\\n            }    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867939,
                "title": "runtime-248-ms-faster-than-100-00-of-python3-online-submissions-for-count-collisions-on-a-road",
                "content": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        #collsion are only possible in following cases\\n        #SL,RL,RS\\n        \\n        n=len(directions)\\n        total=0\\n        right=0\\n        s=False\\n        for j in range(n):\\n            \\n            #When S is found all previous R changes to S.\\n            \\n            if directions[j]==\\'S\\':\\n                total+=right\\n                right=0\\n                s=True\\n                \\n            #when L is found then:\\n              #check if there is any previous R,if yes then change them to S.\\n              #check if there is any previous S,if yes then total+=1\\n            \\n            elif directions[j]==\\'L\\':\\n                if right:\\n                    total+=right+1\\n                    s=True\\n                    right=0\\n                elif s:\\n                    total+=1\\n                    \\n            else:\\n                right+=1\\n                \\n        return total\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        #collsion are only possible in following cases\\n        #SL,RL,RS\\n        \\n        n=len(directions)\\n        total=0\\n        right=0\\n        s=False\\n        for j in range(n):\\n            \\n            #When S is found all previous R changes to S.\\n            \\n            if directions[j]==\\'S\\':\\n                total+=right\\n                right=0\\n                s=True\\n                \\n            #when L is found then:\\n              #check if there is any previous R,if yes then change them to S.\\n              #check if there is any previous S,if yes then total+=1\\n            \\n            elif directions[j]==\\'L\\':\\n                if right:\\n                    total+=right+1\\n                    s=True\\n                    right=0\\n                elif s:\\n                    total+=1\\n                    \\n            else:\\n                right+=1\\n                \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867742,
                "title": "java-solution-just-loop-twice-very-easy-to-understand",
                "content": "Loop the input directions twince.\\nFirst time, go from left to right. If everyone go to left, then no collision at all. But if there is someone not \"L\", all the L after it will cause one collision.\\nThen go from right to left. If we have anyone not go R, then all the Rs after it will cause one collison.\\nJust go through and count.\\n\\n```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        char[] chars = directions.toCharArray();\\n        int count = 0;\\n        int n = chars.length;\\n        boolean start = false;\\n        for (int i = 0; i < n; i++) {\\n        \\tif (chars[i] == \\'L\\') {\\n        \\t\\tif (start)\\n        \\t\\t\\tcount++;\\n        \\t} else {\\n        \\t\\tstart = true;\\n        \\t}\\n        }\\n        start = false;\\n        for (int i = n - 1; i >= 0; i--) {\\n        \\tif (chars[i] == \\'R\\') {\\n        \\t\\tif (start)\\n        \\t\\t\\tcount++;\\n        \\t} else {\\n        \\t\\tstart = true;\\n        \\t}\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countCollisions(String directions) {\\n        char[] chars = directions.toCharArray();\\n        int count = 0;\\n        int n = chars.length;\\n        boolean start = false;\\n        for (int i = 0; i < n; i++) {\\n        \\tif (chars[i] == \\'L\\') {\\n        \\t\\tif (start)\\n        \\t\\t\\tcount++;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1867420,
                "title": "python-simple-solution-beats-100-in-time-and-space",
                "content": "```python\\n        ds = directions\\n        i = 0\\n        j = len(ds) - 1\\n        while i < len(ds) and ds[i] == \\'L\\':\\n            i += 1\\n        while j >= 0 and ds[j] == \\'R\\':\\n            j -= 1\\n        return len(ds[i:j + 1]) - ds[i:j + 1].count(\\'S\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n        ds = directions\\n        i = 0\\n        j = len(ds) - 1\\n        while i < len(ds) and ds[i] == \\'L\\':\\n            i += 1\\n        while j >= 0 and ds[j] == \\'R\\':\\n            j -= 1\\n        return len(ds[i:j + 1]) - ds[i:j + 1].count(\\'S\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1867030,
                "title": "c-100-fast-just-simulate-using-some-conditions-self-explainable",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n          int collisions = 0, i = 0, R = 0;\\n          // skipping the left car\\'s from the starting, because\\n          // they wont contribute to the answer\\n        \\n        while(directions[i] == \\'L\\') i++;\\n          \\n        for(; i<directions.size(); i++){\\n               if(directions[i] == \\'R\\') R++;\\n               else {\\n                   if(directions[i] == \\'L\\'){\\n                       collisions += R + 1;\\n                   }\\n                   else collisions += R;\\n                   R = 0;\\n               }\\n                   \\n           }\\n        return collisions;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countCollisions(string directions) {\\n          int collisions = 0, i = 0, R = 0;\\n          // skipping the left car\\'s from the starting, because\\n          // they wont contribute to the answer\\n        \\n        while(directions[i] == \\'L\\') i++;\\n          \\n        for(; i<directions.size(); i++){\\n               if(directions[i] == \\'R\\') R++;\\n               else {\\n                   if(directions[i] == \\'L\\'){\\n                       collisions += R + 1;\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 1866829,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        string s = directions;\\n        int ans=0;\\n        for(int i=0; i < s.size()-1; i++){\\n            if(s[i]==\\'R\\' and s[i+1]==\\'L\\')       ans+=2, s[i] = (s[i+1] = \\'S\\');\\n            else if(s[i]==\\'S\\' and s[i+1]==\\'L\\')  ans++, s[i] = (s[i+1] = \\'S\\');\\n            else if(s[i]==\\'R\\' and s[i+1]==\\'S\\')  ans++, s[i] = (s[i+1] = \\'S\\');\\n        }\\n        for(int i = s.size()-1; i>=1; i--){\\n            if(s[i]==\\'L\\' and s[i-1]==\\'R\\')       ans+=2, s[i] = (s[i-1] = \\'S\\');\\n            else if(s[i]==\\'L\\' and s[i-1]==\\'S\\')  ans++, s[i] = (s[i-1] = \\'S\\');\\n            else if(s[i]==\\'S\\' and s[i-1]==\\'R\\')  ans++, s[i] = (s[i-1] = \\'S\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        string s = directions;\\n        int ans=0;\\n        for(int i=0; i < s.size()-1; i++){\\n            if(s[i]==\\'R\\' and s[i+1]==\\'L\\')       ans+=2, s[i] = (s[i+1] = \\'S\\');\\n            else if(s[i]==\\'S\\' and s[i+1]==\\'L\\')  ans++, s[i] = (s[i+1] = \\'S\\');\\n            else if(s[i]==\\'R\\' and s[i+1]==\\'S\\')  ans++, s[i] = (s[i+1] = \\'S\\');\\n        }\\n        for(int i = s.size()-1; i>=1; i--){\\n            if(s[i]==\\'L\\' and s[i-1]==\\'R\\')       ans+=2, s[i] = (s[i-1] = \\'S\\');\\n            else if(s[i]==\\'L\\' and s[i-1]==\\'S\\')  ans++, s[i] = (s[i-1] = \\'S\\');\\n            else if(s[i]==\\'S\\' and s[i-1]==\\'R\\')  ans++, s[i] = (s[i-1] = \\'S\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866739,
                "title": "stack-based-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> st;\\n        int collision = 0;\\n        for(auto ch: directions){\\n            if(st.empty() and ch == \\'L\\'){\\n                continue;\\n            }\\n            if(ch == \\'R\\'){\\n                st.push(ch);\\n                continue;\\n            }\\n            if(ch == \\'S\\'){\\n                while(st.empty() == false and st.top() == \\'R\\'){\\n                    st.pop();\\n                    collision += 1;\\n                }\\n            }\\n            else if(ch == \\'L\\'){\\n                bool flag = true;\\n                collision += 1;\\n                if(st.top() == \\'S\\'){\\n                    flag = false;\\n                }\\n                while(flag and !st.empty() and st.top() == \\'R\\'){\\n                    st.pop();\\n                    collision += 1;\\n                }\\n                \\n            }\\n            st.push(\\'S\\'); \\n        }\\n        return collision;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> st;\\n        int collision = 0;\\n        for(auto ch: directions){\\n            if(st.empty() and ch == \\'L\\'){\\n                continue;\\n            }\\n            if(ch == \\'R\\'){\\n                st.push(ch);\\n                continue;\\n            }\\n            if(ch == \\'S\\'){\\n                while(st.empty() == false and st.top() == \\'R\\'){\\n                    st.pop();\\n                    collision += 1;\\n                }\\n            }\\n            else if(ch == \\'L\\'){\\n                bool flag = true;\\n                collision += 1;\\n                if(st.top() == \\'S\\'){\\n                    flag = false;\\n                }\\n                while(flag and !st.empty() and st.top() == \\'R\\'){\\n                    st.pop();\\n                    collision += 1;\\n                }\\n                \\n            }\\n            st.push(\\'S\\'); \\n        }\\n        return collision;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866514,
                "title": "two-linear-time-approaches-o-n-o-1-space-complexity",
                "content": "**Approach 1**: We simulate the car collisions with help of stack\\n\\n**TC** - O(N) | **SC** - O(N)\\n\\n```\\nclass Solution {\\n public int countCollisions(String directions) {\\n        int ans = 0;\\n        Stack<Character> stk = new Stack<>();\\n        for(Character ch : directions.toCharArray()) {\\n            if(stk.isEmpty()) {\\n                stk.push(ch);\\n                continue;\\n            }\\n            if(ch==\\'S\\') {\\n                while(!stk.isEmpty() && stk.peek()==\\'R\\') {\\n                    stk.pop();\\n                    ++ans;\\n                }\\n                stk.push(ch);\\n            } else if(ch==\\'L\\') {\\n                if(!stk.isEmpty() && stk.peek()==\\'R\\') {\\n                    stk.pop();\\n                    ans+=2;\\n                    ch = \\'S\\';\\n                }\\n                if(ch==\\'L\\' && !stk.isEmpty() && stk.peek()==\\'S\\') {\\n                    ans+=1;\\n                    ch = \\'S\\';\\n                }\\n                if(ch==\\'S\\')\\n                    while(!stk.isEmpty() && stk.peek()==\\'R\\') {\\n                        stk.pop();\\n                        ++ans;\\n                    }\\n                stk.push(ch);\\n            } else if(ch==\\'R\\') {\\n                stk.push(ch);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n\\n**Approach 2**: Notice that for a car going left (\\'L\\' car), if there is a car that was going Right (\\'R\\') or there was a stopped car (\\'S\\') on the left side of `\\'L\\' car` then it will collide with it. Similar goes for a car going right (\\'R\\' car). Hence we use this fact and individually increment the collision counter for each car by checking if it will collide or not.\\n\\n**TC** - O(N) | **SC** - O(1)\\n\\n```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int leftL = 0, leftR = 0, leftS = 0, rightS = 0, rightL = 0, rightR = 0, ans = 0;\\n        for(Character ch: directions.toCharArray()) {\\n            switch(ch) {\\n                case \\'L\\' : ++rightL; break;\\n                case \\'R\\' : ++rightR; break;\\n                case \\'S\\' : ++rightS; break;\\n            }\\n        }\\n        for(Character ch: directions.toCharArray()) {\\n            switch(ch) {\\n                case \\'L\\' : --rightL; \\n                    if (leftR>0 || leftS>0) \\n                        ++ans;\\n                    ++leftL;\\n                    break;\\n                case \\'R\\' : --rightR; \\n                    if (rightL>0 || rightS>0) \\n                        ++ans;\\n                    ++leftR;\\n                    break;\\n                case \\'S\\' : --rightS; \\n                    ++leftS;\\n                    break;\\n            }\\n        }\\n        return ans;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n public int countCollisions(String directions) {\\n        int ans = 0;\\n        Stack<Character> stk = new Stack<>();\\n        for(Character ch : directions.toCharArray()) {\\n            if(stk.isEmpty()) {\\n                stk.push(ch);\\n                continue;\\n            }\\n            if(ch==\\'S\\') {\\n                while(!stk.isEmpty() && stk.peek()==\\'R\\') {\\n                    stk.pop();\\n                    ++ans;\\n                }\\n                stk.push(ch);\\n            } else if(ch==\\'L\\') {\\n                if(!stk.isEmpty() && stk.peek()==\\'R\\') {\\n                    stk.pop();\\n                    ans+=2;\\n                    ch = \\'S\\';\\n                }\\n                if(ch==\\'L\\' && !stk.isEmpty() && stk.peek()==\\'S\\') {\\n                    ans+=1;\\n                    ch = \\'S\\';\\n                }\\n                if(ch==\\'S\\')\\n                    while(!stk.isEmpty() && stk.peek()==\\'R\\') {\\n                        stk.pop();\\n                        ++ans;\\n                    }\\n                stk.push(ch);\\n            } else if(ch==\\'R\\') {\\n                stk.push(ch);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int leftL = 0, leftR = 0, leftS = 0, rightS = 0, rightL = 0, rightR = 0, ans = 0;\\n        for(Character ch: directions.toCharArray()) {\\n            switch(ch) {\\n                case \\'L\\' : ++rightL; break;\\n                case \\'R\\' : ++rightR; break;\\n                case \\'S\\' : ++rightS; break;\\n            }\\n        }\\n        for(Character ch: directions.toCharArray()) {\\n            switch(ch) {\\n                case \\'L\\' : --rightL; \\n                    if (leftR>0 || leftS>0) \\n                        ++ans;\\n                    ++leftL;\\n                    break;\\n                case \\'R\\' : --rightR; \\n                    if (rightL>0 || rightS>0) \\n                        ++ans;\\n                    ++leftR;\\n                    break;\\n                case \\'S\\' : --rightS; \\n                    ++leftS;\\n                    break;\\n            }\\n        }\\n        return ans;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866260,
                "title": "single-pass-without-stack-time-complexity-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int cnt=0,n=dir.length(),i=0,j=n-1;\\n        bool l=false,r=false;\\n        while(i<n && j>=0){\\n            if(dir[j]==\\'L\\')l=true;\\n            if(dir[i]==\\'R\\') r=true;\\n            if(dir[i]==\\'S\\'){\\n                r=true;\\n            }\\n            if(dir[j]==\\'S\\') l=true;\\n            if(dir[j]==\\'R\\' && l) cnt++;\\n            if(dir[i]==\\'L\\' && r) cnt++;\\n            i++;\\n            j--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int cnt=0,n=dir.length(),i=0,j=n-1;\\n        bool l=false,r=false;\\n        while(i<n && j>=0){\\n            if(dir[j]==\\'L\\')l=true;\\n            if(dir[i]==\\'R\\') r=true;\\n            if(dir[i]==\\'S\\'){\\n                r=true;\\n            }\\n            if(dir[j]==\\'S\\') l=true;\\n            if(dir[j]==\\'R\\' && l) cnt++;\\n            if(dir[i]==\\'L\\' && r) cnt++;\\n            i++;\\n            j--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866146,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 :***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nint countCollisions(string str) {\\n        \\n        int n = str.size();\\n        \\n        int ans = 0;\\n        \\n        vector<pair<int, int>> freq;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 1;\\n            \\n            while(i + 1 < str.size() && str[i] == str[i + 1])\\n            {\\n                count++;\\n                \\n                i++;\\n            }\\n            \\n            freq.push_back({str[i], count});\\n        }\\n        \\n        for(int i = 0; i < freq.size() - 1; i++)\\n        {\\n            if(freq[i].first == \\'R\\' && freq[i + 1].first == \\'L\\')\\n                ans += freq[i].second + freq[i + 1].second;\\n            \\n            else if(freq[i].first == \\'R\\' && freq[i + 1].first == \\'S\\')\\n                ans += freq[i].second;\\n            \\n            else if(freq[i].first == \\'S\\' && freq[i + 1].first == \\'L\\')\\n                ans += freq[i + 1].second;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nint countCollisions(string str) {\\n        \\n        int n = str.size();\\n        \\n        int ans = 0;\\n        \\n        vector<pair<int, int>> freq;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 1;\\n            \\n            while(i + 1 < str.size() && str[i] == str[i + 1])\\n            {\\n                count++;\\n                \\n                i++;\\n            }\\n            \\n            freq.push_back({str[i], count});\\n        }\\n        \\n        for(int i = 0; i < freq.size() - 1; i++)\\n        {\\n            if(freq[i].first == \\'R\\' && freq[i + 1].first == \\'L\\')\\n                ans += freq[i].second + freq[i + 1].second;\\n            \\n            else if(freq[i].first == \\'R\\' && freq[i + 1].first == \\'S\\')\\n                ans += freq[i].second;\\n            \\n            else if(freq[i].first == \\'S\\' && freq[i + 1].first == \\'L\\')\\n                ans += freq[i + 1].second;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865830,
                "title": "using-stack-simple-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        \\n        int n = dir.size();\\n        \\n        stack<char> st;\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(dir[i] == \\'L\\'){\\n                if(st.size() > 0){\\n                    if(st.top() == \\'S\\'){\\n                        cnt+=1;    \\n                    }else if(st.top() == \\'R\\'){\\n                        cnt+=2;\\n                        st.pop();\\n                        while(st.size() > 0 and st.top() == \\'R\\'){\\n                            st.pop();\\n                            cnt++;\\n                        }\\n                        st.push(\\'S\\');\\n                    }\\n                }\\n            }else if(dir[i] == \\'R\\'){\\n                st.push(\\'R\\');\\n            }else{\\n                while(st.size() > 0 and st.top() == \\'R\\'){\\n                    st.pop();\\n                    cnt++;\\n                }\\n                st.push(\\'S\\');   \\n            }\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "Stack",
                    "Simulation"
                ],
                "code": "class Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        \\n        int n = dir.size();\\n        \\n        stack<char> st;\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(dir[i] == \\'L\\'){\\n                if(st.size() > 0){\\n                    if(st.top() == \\'S\\'){\\n                        cnt+=1;    \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1865814,
                "title": "java-solution-faster-than-100-submission-simple-approach-logic-building",
                "content": "So there can be 3 cases for collision\\nRS\\nSL\\nRL\\nSo in RS after collision it becomes SS\\nNow we need to re chesk the left side to check that if any car collides with th car which was travelling to right and after collision became steady.\\nIn case of RL after collision it becomes SS\\nNow we need to re chesk the left side to check that if any car collides with th car which was travelling to right and after collision became steady.\\nAnd for SL it becomes SS\\nSo no need to re check the left side.\\nAnd we will be checking the right while traversing through the loop.\\n```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        char[] dir = directions.toCharArray();\\n        int count=0;\\n        for(int i=0; i<dir.length-1; i++){\\n            char firstChar = dir[i], secondChar = dir[i+1];\\n            if(firstChar==\\'S\\'&&secondChar==\\'L\\'){\\n                count++;\\n                dir[i+1]=\\'S\\';\\n            }else if(firstChar==\\'R\\'&&secondChar==\\'S\\'){\\n                count++;\\n                dir[i]=\\'S\\';\\n                int j=i-1;\\n                while(j>=0 && dir[j]==\\'R\\'){\\n                    count++;\\n                    dir[j]=\\'S\\';\\n                    j--;\\n                }\\n            }else if(firstChar==\\'R\\'&&secondChar==\\'L\\'){\\n                count+=2;\\n                dir[i+1]=\\'S\\';\\n                dir[i]=\\'S\\';\\n                int j=i-1;\\n                while(j>=0 && dir[j]==\\'R\\'){\\n                    count++;\\n                    dir[j]=\\'S\\';\\n                    j--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        char[] dir = directions.toCharArray();\\n        int count=0;\\n        for(int i=0; i<dir.length-1; i++){\\n            char firstChar = dir[i], secondChar = dir[i+1];\\n            if(firstChar==\\'S\\'&&secondChar==\\'L\\'){\\n                count++;\\n                dir[i+1]=\\'S\\';\\n            }else if(firstChar==\\'R\\'&&secondChar==\\'S\\'){\\n                count++;\\n                dir[i]=\\'S\\';\\n                int j=i-1;\\n                while(j>=0 && dir[j]==\\'R\\'){\\n                    count++;\\n                    dir[j]=\\'S\\';\\n                    j--;\\n                }\\n            }else if(firstChar==\\'R\\'&&secondChar==\\'L\\'){\\n                count+=2;\\n                dir[i+1]=\\'S\\';\\n                dir[i]=\\'S\\';\\n                int j=i-1;\\n                while(j>=0 && dir[j]==\\'R\\'){\\n                    count++;\\n                    dir[j]=\\'S\\';\\n                    j--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865806,
                "title": "java-solution-without-stack",
                "content": "we find out that only RL RS SL may cause collison. once collision happened, we need to check if there are any other collision happened.  \\neg:\\nRRRRLLLL --->8 collision\\nRRRRSLLL ---> 7 collision\\nRRRSLLLL ---> 7 collision\\nBTW: The des of this question is very unclear!!!!\\nCode :\\n``` java\\npublic int countCollisions(String directions) {\\n        char[] chs = directions.toCharArray();\\n        int ans = 0;\\n        int idx = 1;\\n        while(idx < chs.length){\\n            char curr = chs[idx];\\n            char prev = chs[idx-1];\\n            if((curr==\\'L\\' && prev == \\'R\\') ||(curr==\\'S\\' && prev == \\'R\\') || (curr==\\'L\\' && prev == \\'S\\')){\\n                if(curr==\\'L\\' && prev == \\'R\\'){\\n                    ans+=2;\\n                }else{\\n                    ans+=1;\\n                }\\n                int x = idx+1;\\n                while(x < chs.length && chs[x] == \\'L\\'){\\n                    x++;\\n                    ans++;\\n                }\\n                int y = idx-2;\\n                while(y >= 0 && chs[y] == \\'R\\'){\\n                    y--;\\n                    ans++;\\n                }\\n                idx = x;\\n            }else{\\n                idx++;\\n            }\\n        }\\n        return ans;\\n    }\\n``` \\n",
                "solutionTags": [],
                "code": "``` java\\npublic int countCollisions(String directions) {\\n        char[] chs = directions.toCharArray();\\n        int ans = 0;\\n        int idx = 1;\\n        while(idx < chs.length){\\n            char curr = chs[idx];\\n            char prev = chs[idx-1];\\n            if((curr==\\'L\\' && prev == \\'R\\') ||(curr==\\'S\\' && prev == \\'R\\') || (curr==\\'L\\' && prev == \\'S\\')){\\n                if(curr==\\'L\\' && prev == \\'R\\'){\\n                    ans+=2;\\n                }else{\\n                    ans+=1;\\n                }\\n                int x = idx+1;\\n                while(x < chs.length && chs[x] == \\'L\\'){\\n                    x++;\\n                    ans++;\\n                }\\n                int y = idx-2;\\n                while(y >= 0 && chs[y] == \\'R\\'){\\n                    y--;\\n                    ans++;\\n                }\\n                idx = x;\\n            }else{\\n                idx++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865795,
                "title": "python3-two-pass",
                "content": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        temp = []\\n        for dire in directions:\\n            temp.append(dire)\\n        directions = temp\\n        n = len(directions)\\n        if n == 0 or n == 1:\\n            return 0\\n        ans = 0\\n        # while \\n        for i in range(1,n):\\n            if directions[i-1] == \"R\" and directions[i] == \"L\":\\n                ans += 2\\n                directions[i] = \"S\"\\n                directions[i-1] = \"S\"\\n            elif directions[i-1] == \"R\" and directions[i] == \"S\":\\n                ans += 1\\n                directions[i] = \"S\"\\n                directions[i-1] = \"S\"\\n            elif directions[i-1] == \"S\" and directions[i] == \"L\":\\n                ans += 1\\n                directions[i] = \"S\"\\n                directions[i-1] = \"S\"\\n        for i in range(n-2,-1,-1):\\n            if directions[i] == \"R\" and directions[i+1] == \"L\":\\n                ans += 2\\n                directions[i+1] = \"S\"\\n                directions[i] = \"S\"\\n            elif directions[i] == \"R\" and directions[i+1] == \"S\":\\n                ans += 1\\n                directions[i+1] = \"S\"\\n                directions[i] = \"S\"\\n            elif directions[i] == \"S\" and directions[i+1] == \"L\":\\n                ans += 1\\n                directions[i+1] = \"S\"\\n                directions[i] = \"S\"\\n                \\n        return ans\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        temp = []\\n        for dire in directions:\\n            temp.append(dire)\\n        directions = temp\\n        n = len(directions)\\n        if n == 0 or n == 1:\\n            return 0\\n        ans = 0\\n        # while \\n        for i in range(1,n):\\n            if directions[i-1] == \"R\" and directions[i] == \"L\":\\n                ans += 2\\n                directions[i] = \"S\"\\n                directions[i-1] = \"S\"\\n            elif directions[i-1] == \"R\" and directions[i] == \"S\":\\n                ans += 1\\n                directions[i] = \"S\"\\n                directions[i-1] = \"S\"\\n            elif directions[i-1] == \"S\" and directions[i] == \"L\":\\n                ans += 1\\n                directions[i] = \"S\"\\n                directions[i-1] = \"S\"\\n        for i in range(n-2,-1,-1):\\n            if directions[i] == \"R\" and directions[i+1] == \"L\":\\n                ans += 2\\n                directions[i+1] = \"S\"\\n                directions[i] = \"S\"\\n            elif directions[i] == \"R\" and directions[i+1] == \"S\":\\n                ans += 1\\n                directions[i+1] = \"S\"\\n                directions[i] = \"S\"\\n            elif directions[i] == \"S\" and directions[i+1] == \"L\":\\n                ans += 1\\n                directions[i+1] = \"S\"\\n                directions[i] = \"S\"\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865772,
                "title": "java-stack",
                "content": "```\\nclass Solution {\\n    int answer = 0;\\n    public int countCollisions(String directions) {\\n        Deque<Character> st = new ArrayDeque<>();\\n        for (char ch : directions.toCharArray()) {\\n            if (st.size() == 0) {\\n                st.push(ch);\\n            } else {\\n                if (st.peek().equals(\\'L\\')) {\\n                    st.push(ch);\\n                } else if(st.peek().equals(\\'R\\')) {\\n                    if (ch == \\'L\\') {\\n                        answer += 2;\\n                        st.pop();\\n                        st.push(\\'S\\');\\n                    } else if(ch == \\'R\\') {\\n                        st.push(ch);\\n                    } else {\\n                        st.pop();\\n                        answer += 1;\\n                        st.push(\\'S\\');\\n                    }\\n                } else {\\n                    if (ch == \\'L\\') {\\n                        answer += 1;\\n                        st.pop();\\n                        st.push(\\'S\\');\\n                    } else {\\n                        st.push(ch);\\n                    }\\n                }\\n            }\\n            makeValid(st);\\n        }\\n        return answer;\\n    }\\n    \\n    //  for \"...RRRRS\" case\\n    public void makeValid(Deque<Character> st) {\\n        while (st.size() > 1) {\\n            char r = st.pop();\\n            char l = st.pop();\\n            if (l == \\'R\\' && r == \\'S\\') {\\n                st.push(\\'S\\');\\n                answer++;\\n            } else {\\n\\t\\t\\t\\t//  resetting \\n                st.push(l);\\n                st.push(r);\\n                break;\\n            }\\n        }\\n    }\\n}\\n\\n\\n```\\n```\\nthis may not be the fastest but it is easier to understand",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int answer = 0;\\n    public int countCollisions(String directions) {\\n        Deque<Character> st = new ArrayDeque<>();\\n        for (char ch : directions.toCharArray()) {\\n            if (st.size() == 0) {\\n                st.push(ch);\\n            } else {\\n                if (st.peek().equals(\\'L\\')) {\\n                    st.push(ch);\\n                } else if(st.peek().equals(\\'R\\')) {\\n                    if (ch == \\'L\\') {\\n                        answer += 2;\\n                        st.pop();\\n                        st.push(\\'S\\');\\n                    } else if(ch == \\'R\\') {\\n                        st.push(ch);\\n                    } else {\\n                        st.pop();\\n                        answer += 1;\\n                        st.push(\\'S\\');\\n                    }\\n                } else {\\n                    if (ch == \\'L\\') {\\n                        answer += 1;\\n                        st.pop();\\n                        st.push(\\'S\\');\\n                    } else {\\n                        st.push(ch);\\n                    }\\n                }\\n            }\\n            makeValid(st);\\n        }\\n        return answer;\\n    }\\n    \\n    //  for \"...RRRRS\" case\\n    public void makeValid(Deque<Character> st) {\\n        while (st.size() > 1) {\\n            char r = st.pop();\\n            char l = st.pop();\\n            if (l == \\'R\\' && r == \\'S\\') {\\n                st.push(\\'S\\');\\n                answer++;\\n            } else {\\n\\t\\t\\t\\t//  resetting \\n                st.push(l);\\n                st.push(r);\\n                break;\\n            }\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865743,
                "title": "why-ssrssrllrsllrsrssrlrrrrllrrlssrr-is-20-not-16",
                "content": "because of this case ```RRRRS``` case i was missing this case too.\\n\\noutput is 20.\\nwhile building the stack we encounter a state :\\n```.....RRRRS```\\nwe skipped this in stack we need to check for this, when we are pushing ```S``` into our stack we may encounter ```R``` on left of ```S``` which will again collide and increase our answer.\\nin this case :\\n```RRRRS``` -> 1 + ```RRRS``` -> 2 + ```RRS``` -> 3 + ```RS``` -> 4 + ``````\\n\\n\\n```\\nplease upvote if you find this helpful :)",
                "solutionTags": [],
                "code": "```RRRRS```\n```.....RRRRS```\n```S```\n```R```\n```S```\n```RRRRS```\n```RRRS```\n```RRS```\n```RS```\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 1865731,
                "title": "time-o-n-stack-based-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        stack<char> st;\\n        int score=0;\\n        for(int i=d.length()-1;i>=0;i--)\\n        {\\n            if(d[i]==\\'L\\')\\n            {\\n                st.push(\\'L\\');\\n            }\\n            else if(d[i]==\\'S\\')\\n            {\\n                while(!st.empty()&&st.top()==\\'S\\')\\n                {\\n                    st.pop();\\n                }\\n                while(!st.empty()&&st.top()==\\'L\\')\\n                    {\\n                        score+=1;\\n                        st.pop();\\n                    }\\n                \\n                st.push(\\'S\\');\\n            }\\n            else\\n            {\\n                if(!st.empty()&&st.top()==\\'S\\')\\n                {\\n                    \\n                    score+=1;\\n                    st.pop();\\n                    while(!st.empty()&&st.top()==\\'S\\')\\n                        {\\n                            st.pop();\\n                        }\\n                    st.push(\\'S\\');\\n                }\\n                else if(!st.empty()&&st.top()==\\'L\\')\\n                {\\n                    score+=2;\\n                    st.pop();\\n                    while(!st.empty()&&st.top()==\\'L\\')\\n                    {\\n                        score+=1;\\n                        st.pop();\\n                    }\\n                    st.push(\\'S\\');\\n                }\\n\\n            }\\n        }\\n\\n        return score;\\n    }\\n};\\n``` \\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        stack<char> st;\\n        int score=0;\\n        for(int i=d.length()-1;i>=0;i--)\\n        {\\n            if(d[i]==\\'L\\')\\n            {\\n                st.push(\\'L\\');\\n            }\\n            else if(d[i]==\\'S\\')\\n            {\\n                while(!st.empty()&&st.top()==\\'S\\')\\n                {\\n                    st.pop();\\n                }\\n                while(!st.empty()&&st.top()==\\'L\\')\\n                    {\\n                        score+=1;\\n                        st.pop();\\n                    }\\n                \\n                st.push(\\'S\\');\\n            }\\n            else\\n            {\\n                if(!st.empty()&&st.top()==\\'S\\')\\n                {\\n                    \\n                    score+=1;\\n                    st.pop();\\n                    while(!st.empty()&&st.top()==\\'S\\')\\n                        {\\n                            st.pop();\\n                        }\\n                    st.push(\\'S\\');\\n                }\\n                else if(!st.empty()&&st.top()==\\'L\\')\\n                {\\n                    score+=2;\\n                    st.pop();\\n                    while(!st.empty()&&st.top()==\\'L\\')\\n                    {\\n                        score+=1;\\n                        st.pop();\\n                    }\\n                    st.push(\\'S\\');\\n                }\\n\\n            }\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865690,
                "title": "c-tc-o-n-sc-o-1-with-no-extra-space-and-linear-time-complexity",
                "content": "```\\nint n=s.size();\\n        int cnt=0;\\n        int right=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            if(i==0) {\\n                if(s[i]==\\'R\\') right++;\\n                continue;\\n            }\\n            \\n            if(s[i]==\\'L\\') {\\n                if(s[i-1]==\\'R\\') {\\n                    cnt+=2;\\n                    right--;\\n                    cnt+=right;\\n                    right=0;\\n                    s[i]=\\'S\\';\\n                } else if(s[i-1]==\\'L\\') {\\n                    continue;\\n                } else {\\n                    cnt++;\\n                    s[i]=\\'S\\';\\n                }\\n                continue;\\n            }\\n            \\n            if(s[i]==\\'R\\') {\\n                if(s[i-1]==\\'R\\') {\\n                    right++;\\n                } else if(s[i-1]==\\'L\\') {\\n                    right++;\\n                    continue;\\n                } else {\\n                    right++;\\n                    // cnt++;\\n                    // s[i]=\\'S\\';/\\n                }\\n                continue;\\n            }\\n            \\n            if(s[i]==\\'S\\') {\\n                if(s[i-1]==\\'R\\') {\\n                    cnt+=right;\\n                    right=0;\\n                    s[i]=\\'S\\';\\n                } else if(s[i-1]==\\'L\\') {\\n                    continue;\\n                } else {\\n                    continue;\\n                }\\n                continue;\\n            }\\n        }\\n        \\n        return cnt;\\n\\t\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint n=s.size();\\n        int cnt=0;\\n        int right=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            if(i==0) {\\n                if(s[i]==\\'R\\') right++;\\n                continue;\\n            }\\n            \\n            if(s[i]==\\'L\\') {\\n                if(s[i-1]==\\'R\\') {\\n                    cnt+=2;\\n                    right--;\\n                    cnt+=right;\\n                    right=0;\\n                    s[i]=\\'S\\';\\n                } else if(s[i-1]==\\'L\\') {\\n                    continue;\\n                } else {\\n                    cnt++;\\n                    s[i]=\\'S\\';\\n                }\\n                continue;\\n            }\\n            \\n            if(s[i]==\\'R\\') {\\n                if(s[i-1]==\\'R\\') {\\n                    right++;\\n                } else if(s[i-1]==\\'L\\') {\\n                    right++;\\n                    continue;\\n                } else {\\n                    right++;\\n                    // cnt++;\\n                    // s[i]=\\'S\\';/\\n                }\\n                continue;\\n            }\\n            \\n            if(s[i]==\\'S\\') {\\n                if(s[i-1]==\\'R\\') {\\n                    cnt+=right;\\n                    right=0;\\n                    s[i]=\\'S\\';\\n                } else if(s[i-1]==\\'L\\') {\\n                    continue;\\n                } else {\\n                    continue;\\n                }\\n                continue;\\n            }\\n        }\\n        \\n        return cnt;\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865678,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n    stack<char> s; int count =0;\\n    for(auto c:directions)\\n    {\\n        if(!s.empty() && s.top() == \\'R\\' && c == \\'L\\')\\n        {\\n            count+=2;\\n            s.pop();\\n            s.push(\\'S\\');\\n        }\\n        else if(!s.empty() && s.top() == \\'S\\' && c == \\'L\\')\\n        {\\n            count+=1;\\n        }\\n       else s.push(c);\\n    }\\n    while(!s.empty())\\n    {\\n       char tmp = s.top();\\n       s.pop();\\n       if(!s.empty() && s.top() == \\'S\\' && tmp ==\\'L\\')\\n       {\\n           count++;\\n       }\\n       else if(!s.empty() && s.top() == \\'R\\' && tmp ==\\'S\\')\\n       {\\n           count++;\\n           s.pop();\\n           s.push(\\'S\\');\\n       }\\n    }\\n     return count;   \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int countCollisions(string directions) {\\n    stack<char> s; int count =0;\\n    for(auto c:directions)\\n    {\\n        if(!s.empty() && s.top() == \\'R\\' && c == \\'L\\')\\n        {\\n            count+=2;\\n            s.pop();\\n            s.push(\\'S\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1865675,
                "title": "c-greedy-approach-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        \\n        int n=directions.length();\\n        int fromRight=0;\\n        int cnt=0;\\n        \\n        int i=0;\\n        while(i<n && directions[i]==\\'L\\')\\n            i++;\\n        \\n        while(i<n)\\n        {\\n            if(directions[i]==\\'R\\')\\n                fromRight++;\\n            else\\n            {\\n                if(directions[i]==\\'S\\')\\n                    cnt+=fromRight;\\n                else\\n                    cnt+=fromRight+1;\\n                \\n                fromRight=0;\\n            }\\n            \\n            i++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        \\n        int n=directions.length();\\n        int fromRight=0;\\n        int cnt=0;\\n        \\n        int i=0;\\n        while(i<n && directions[i]==\\'L\\')\\n            i++;\\n        \\n        while(i<n)\\n        {\\n            if(directions[i]==\\'R\\')\\n                fromRight++;\\n            else\\n            {\\n                if(directions[i]==\\'S\\')\\n                    cnt+=fromRight;\\n                else\\n                    cnt+=fromRight+1;\\n                \\n                fromRight=0;\\n            }\\n            \\n            i++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865665,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\n    def countCollisions(self, directions: str) -> int:\\n        i=1\\n        res=0\\n        prev=directions[0]\\n        rstack=1 if prev==\"R\" else 0\\n        while i<len(directions):\\n            if prev==\"L\":\\n                if directions[i]==\"R\":\\n                    prev=\"R\"\\n                    rstack+=1\\n                if directions[i]==\"S\":\\n                    prev=\"S\"\\n            elif prev==\"R\":\\n                if directions[i]==\"L\":\\n                    res+=(1+rstack)\\n                    prev=\"S\"\\n                    rstack=0\\n                if directions[i]==\"S\":\\n                    res+=(rstack)\\n                    prev=\"S\"\\n                    rstack=0\\n                if directions[i]==\"R\":\\n                    rstack+=1\\n            elif prev==\"S\":\\n                if directions[i]==\"L\":\\n                    res+=1\\n                if directions[i]==\"R\":\\n                    prev=\"R\"\\n                    rstack+=1\\n            i+=1\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def countCollisions(self, directions: str) -> int:\\n        i=1\\n        res=0\\n        prev=directions[0]\\n        rstack=1 if prev==\"R\" else 0\\n        while i<len(directions):\\n            if prev==\"L\":\\n                if directions[i]==\"R\":\\n                    prev=\"R\"\\n                    rstack+=1\\n                if directions[i]==\"S\":\\n                    prev=\"S\"\\n            elif prev==\"R\":\\n                if directions[i]==\"L\":\\n                    res+=(1+rstack)\\n                    prev=\"S\"\\n                    rstack=0\\n                if directions[i]==\"S\":\\n                    res+=(rstack)\\n                    prev=\"S\"\\n                    rstack=0\\n                if directions[i]==\"R\":\\n                    rstack+=1\\n            elif prev==\"S\":\\n                if directions[i]==\"L\":\\n                    res+=1\\n                if directions[i]==\"R\":\\n                    prev=\"R\"\\n                    rstack+=1\\n            i+=1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1865604,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> road;\\n        int ans = 0;\\n        for (auto& c : directions)\\n        {\\n            if (c == \\'L\\')\\n            {\\n                if (road.empty())\\n                    continue;\\n                else if (road.top() == \\'S\\')\\n                    ans += 1;\\n                else if (road.top() == \\'R\\')\\n                {\\n                    ans += 2;\\n                    road.pop();\\n                    while (!road.empty())\\n                    {\\n                        ans += 1;\\n                        road.pop();\\n                    }\\n                    road.push(\\'S\\');\\n                }\\n            }\\n            else if (c == \\'R\\')\\n            {\\n                while (!road.empty() && road.top() == \\'S\\')\\n                    road.pop();\\n                road.push(\\'R\\');\\n            }\\n            else\\n            {\\n                while (!road.empty())\\n                {\\n                    if (road.top() == \\'R\\')\\n                        ans += 1;\\n                    road.pop();\\n                }\\n                road.push(\\'S\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> road;\\n        int ans = 0;\\n        for (auto& c : directions)\\n        {\\n            if (c == \\'L\\')\\n            {\\n                if (road.empty())\\n                    continue;\\n                else if (road.top() == \\'S\\')\\n                    ans += 1;\\n                else if (road.top() == \\'R\\')\\n                {\\n                    ans += 2;\\n                    road.pop();\\n                    while (!road.empty())\\n                    {\\n                        ans += 1;\\n                        road.pop();\\n                    }\\n                    road.push(\\'S\\');\\n                }\\n            }\\n            else if (c == \\'R\\')\\n            {\\n                while (!road.empty() && road.top() == \\'S\\')\\n                    road.pop();\\n                road.push(\\'R\\');\\n            }\\n            else\\n            {\\n                while (!road.empty())\\n                {\\n                    if (road.top() == \\'R\\')\\n                        ans += 1;\\n                    road.pop();\\n                }\\n                road.push(\\'S\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865593,
                "title": "python-o-n-no-queue-or-stack",
                "content": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        prev = directions[0]\\n        ans = 0\\n        prev_r = 1 if directions[0] == \\'R\\' else 0\\n        for i in range(1,len(directions)):\\n            if prev == \\'R\\' and directions[i] == \\'L\\':\\n                ans += 2\\n                prev = \\'S\\'\\n            elif (prev == \\'S\\' and directions[i] == \\'L\\') or (prev == \\'R\\' and directions[i] == \\'S\\'):\\n                ans += 1\\n                prev = \\'S\\'\\n            else:\\n                prev = directions[i]\\n                if prev == \\'R\\':\\n                    prev_r += 1\\n                continue\\n            if prev_r != 0:\\n                ans += prev_r-1\\n                prev_r = 0\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        prev = directions[0]\\n        ans = 0\\n        prev_r = 1 if directions[0] == \\'R\\' else 0\\n        for i in range(1,len(directions)):\\n            if prev == \\'R\\' and directions[i] == \\'L\\':\\n                ans += 2\\n                prev = \\'S\\'\\n            elif (prev == \\'S\\' and directions[i] == \\'L\\') or (prev == \\'R\\' and directions[i] == \\'S\\'):\\n                ans += 1\\n                prev = \\'S\\'\\n            else:\\n                prev = directions[i]\\n                if prev == \\'R\\':\\n                    prev_r += 1\\n                continue\\n            if prev_r != 0:\\n                ans += prev_r-1\\n                prev_r = 0\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865576,
                "title": "c-greedy-approach-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countCollisions(string s) {\\n\\t\\t\\tint res = 0, cnt = 0;\\n\\t\\t\\tchar prev = s[0];\\n\\t\\t\\tfor(int i = 1;i<s.length();i++){\\n\\t\\t\\t\\t\\tif(prev ==\\'R\\'){\\n\\t\\t\\t\\t\\t\\tif(s[i]==\\'L\\') {\\n\\t\\t\\t\\t\\t\\t\\tres+=2+cnt;\\n\\t\\t\\t\\t\\t\\t\\tprev = \\'S\\';\\n\\t\\t\\t\\t\\t\\t\\tcnt = 0;\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(s[i]==\\'S\\'){\\n\\t\\t\\t\\t\\t\\t\\tres+=1+cnt;\\n\\t\\t\\t\\t\\t\\t\\tprev = \\'S\\';\\n\\t\\t\\t\\t\\t\\t\\tcnt = 0;\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\t\\telse prev = s[i];\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(prev==\\'S\\'){\\n\\t\\t\\t\\t\\t\\tif(s[i]==\\'L\\') res+=1;\\n\\t\\t\\t\\t\\t\\telse prev = s[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse prev = s[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countCollisions(string s) {\\n\\t\\t\\tint res = 0, cnt = 0;\\n\\t\\t\\tchar prev = s[0];\\n\\t\\t\\tfor(int i = 1;i<s.length();i++){\\n\\t\\t\\t\\t\\tif(prev ==\\'R\\'){\\n\\t\\t\\t\\t\\t\\tif(s[i]==\\'L\\') {\\n\\t\\t\\t\\t\\t\\t\\tres+=2+cnt;\\n\\t\\t\\t\\t\\t\\t\\tprev = \\'S\\';\\n\\t\\t\\t\\t\\t\\t\\tcnt = 0;\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4069316,
                "title": "easy-java-two-pointer-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int start = 0; \\n        int end = directions.length() - 1;\\n\\n        while(start < directions.length() && directions.charAt(start) == \\'L\\') start++;\\n\\n        while(end >= 0 && directions.charAt(end) == \\'R\\') end--;\\n\\n        int ans = 0;\\n        for(int i = start; i <= end; i++){\\n            if(directions.charAt(i) == \\'S\\') continue;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int start = 0; \\n        int end = directions.length() - 1;\\n\\n        while(start < directions.length() && directions.charAt(start) == \\'L\\') start++;\\n\\n        while(end >= 0 && directions.charAt(end) == \\'R\\') end--;\\n\\n        int ans = 0;\\n        for(int i = start; i <= end; i++){\\n            if(directions.charAt(i) == \\'S\\') continue;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068621,
                "title": "c-simple-solution-without-stack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) \\n    {\\n        int ans = 0, cars = 0;\\n        char last_dir;\\n\\n        for(int i=0; i<directions.length(); i++)\\n        {\\n            if(directions[i] == \\'R\\') ++cars, last_dir = \\'R\\';\\n            else if(directions[i] == \\'S\\' and last_dir == \\'R\\'){\\n                ans += cars;\\n                cars = 0;\\n                last_dir = \\'S\\';\\n            }\\n            else if(directions[i] == \\'L\\' and last_dir == \\'S\\'){\\n                cars = 0;\\n                ans += 1;\\n                last_dir = \\'S\\';\\n            }\\n            else if(directions[i] == \\'L\\' and last_dir == \\'R\\')\\n            {\\n                ans += cars + 1;\\n                cars = 0;\\n                last_dir = \\'S\\';\\n            }\\n            else last_dir = directions[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) \\n    {\\n        int ans = 0, cars = 0;\\n        char last_dir;\\n\\n        for(int i=0; i<directions.length(); i++)\\n        {\\n            if(directions[i] == \\'R\\') ++cars, last_dir = \\'R\\';\\n            else if(directions[i] == \\'S\\' and last_dir == \\'R\\'){\\n                ans += cars;\\n                cars = 0;\\n                last_dir = \\'S\\';\\n            }\\n            else if(directions[i] == \\'L\\' and last_dir == \\'S\\'){\\n                cars = 0;\\n                ans += 1;\\n                last_dir = \\'S\\';\\n            }\\n            else if(directions[i] == \\'L\\' and last_dir == \\'R\\')\\n            {\\n                ans += cars + 1;\\n                cars = 0;\\n                last_dir = \\'S\\';\\n            }\\n            else last_dir = directions[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026731,
                "title": "very-straightforward-commented-o-1-space-and-o-n-time-solution-top-98-runtime-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n// solution\\n// max_collisions = total_cars - statitionary_cars - \\n// - cars_initially_going_left (on left side)\\n// - cars_initially_going_right (on right side)\\n\\n// Only stationary cars (inside) are able to avoid a collision but they \\n// are not included in count anyway (from question specification)\\n// hence the max_collisions == total_collisions\\n\\n// O(n) time and O(1) space\\nclass Solution {\\npublic:\\n    int countCollisions(std::string directions) {\\n        // upper bound\\n        size_t total_collisions { directions.size() };\\n        \\n        // all L cars on left dont collide\\n        for (char dir: directions)\\n        {\\n            if (dir != \\'L\\') break;\\n            total_collisions -= 1;\\n        }\\n        // all R cars on right dont collide\\n        for (auto revers_iter = directions.rbegin();\\n                  revers_iter != directions.rend();\\n                ++revers_iter\\n        )\\n        {\\n            if (*revers_iter != \\'R\\') break;\\n            total_collisions -= 1;\\n        }       \\n        // all stationary cars aren\\'t included in count\\n        for (char dir: directions)\\n        {\\n            if (dir == \\'S\\') total_collisions -= 1;\\n        }\\n        return total_collisions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// solution\\n// max_collisions = total_cars - statitionary_cars - \\n// - cars_initially_going_left (on left side)\\n// - cars_initially_going_right (on right side)\\n\\n// Only stationary cars (inside) are able to avoid a collision but they \\n// are not included in count anyway (from question specification)\\n// hence the max_collisions == total_collisions\\n\\n// O(n) time and O(1) space\\nclass Solution {\\npublic:\\n    int countCollisions(std::string directions) {\\n        // upper bound\\n        size_t total_collisions { directions.size() };\\n        \\n        // all L cars on left dont collide\\n        for (char dir: directions)\\n        {\\n            if (dir != \\'L\\') break;\\n            total_collisions -= 1;\\n        }\\n        // all R cars on right dont collide\\n        for (auto revers_iter = directions.rbegin();\\n                  revers_iter != directions.rend();\\n                ++revers_iter\\n        )\\n        {\\n            if (*revers_iter != \\'R\\') break;\\n            total_collisions -= 1;\\n        }       \\n        // all stationary cars aren\\'t included in count\\n        for (char dir: directions)\\n        {\\n            if (dir == \\'S\\') total_collisions -= 1;\\n        }\\n        return total_collisions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008646,
                "title": "easy-intuitive-o-1-space-complexity-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int s , r, count;\\n        s = r = count = 0;\\n        for ( int i=0; i < directions.length(); i++){\\n            char cd = directions.charAt(i);\\n            if ( cd == \\'L\\'){\\n                if ( r > 0){\\n                    // there are some cars moving to right\\n                    count += (r+1);\\n                    r = 0;  // all will become stationary\\n                    s = s + r+1; \\n                }\\n                else if ( s > 0){\\n                    count += 1;\\n                }\\n            }\\n            else if ( cd == \\'S\\'){\\n                if ( r > 0){\\n                    // there are some cars moving to right\\n                    count += r;\\n                    r = 0;\\n                }\\n                s += 1;\\n            }\\n            else{\\n                r +=1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int s , r, count;\\n        s = r = count = 0;\\n        for ( int i=0; i < directions.length(); i++){\\n            char cd = directions.charAt(i);\\n            if ( cd == \\'L\\'){\\n                if ( r > 0){\\n                    // there are some cars moving to right\\n                    count += (r+1);\\n                    r = 0;  // all will become stationary\\n                    s = s + r+1; \\n                }\\n                else if ( s > 0){\\n                    count += 1;\\n                }\\n            }\\n            else if ( cd == \\'S\\'){\\n                if ( r > 0){\\n                    // there are some cars moving to right\\n                    count += r;\\n                    r = 0;\\n                }\\n                s += 1;\\n            }\\n            else{\\n                r +=1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007131,
                "title": "python3-stack",
                "content": "```\\nclass Solution:\\n    def countCollisions(self, ds: str) -> int:\\n        st=[]\\n        c=0\\n        for i in range(len(ds)):\\n            if ds[i]==\"L\":\\n                if not st:continue\\n                if st[-1]==\"S\":c+=1\\n                elif st[-1]==\"R\":\\n                    st[-1]=\"S\"\\n                    c+=2\\n            elif ds[i]==\"R\":\\n                st.append(\"R\")\\n            else:\\n                if st and st[-1]==\"R\":\\n                    st[-1]=\"S\"\\n                    c+=1\\n                else:\\n                    st.append(\"S\")\\n        cc=0\\n        for x in st:\\n            if x==\"R\":\\n                cc+=1\\n            else:\\n                c+=cc\\n                cc=0\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, ds: str) -> int:\\n        st=[]\\n        c=0\\n        for i in range(len(ds)):\\n            if ds[i]==\"L\":\\n                if not st:continue\\n                if st[-1]==\"S\":c+=1\\n                elif st[-1]==\"R\":\\n                    st[-1]=\"S\"\\n                    c+=2\\n            elif ds[i]==\"R\":\\n                st.append(\"R\")\\n            else:\\n                if st and st[-1]==\"R\":\\n                    st[-1]=\"S\"\\n                    c+=1\\n                else:\\n                    st.append(\"S\")\\n        cc=0\\n        for x in st:\\n            if x==\"R\":\\n                cc+=1\\n            else:\\n                c+=cc\\n                cc=0\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990441,
                "title": "js-simple-beats-100-58ms",
                "content": "# Code\\n```\\n/**\\n * @param {string} directions\\n * @return {number}\\n */\\nconst countCollisions = function(directions) {\\n    let l = 0, r = directions.length - 1;\\n    while (l < directions.length && directions[l] === \\'L\\') {\\n        l++;\\n    }\\n    while (r >= 0 && directions[r] === \\'R\\') {\\n        r--;\\n    }\\n    let count = 0;\\n    for (;l <= r; l++) {\\n        if (directions[l] !== \\'S\\') {\\n            count++; // Increment counter if the current car is not stationary\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} directions\\n * @return {number}\\n */\\nconst countCollisions = function(directions) {\\n    let l = 0, r = directions.length - 1;\\n    while (l < directions.length && directions[l] === \\'L\\') {\\n        l++;\\n    }\\n    while (r >= 0 && directions[r] === \\'R\\') {\\n        r--;\\n    }\\n    let count = 0;\\n    for (;l <= r; l++) {\\n        if (directions[l] !== \\'S\\') {\\n            count++; // Increment counter if the current car is not stationary\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958595,
                "title": "c-solution-in-o-n-time-and-o-1-space",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int collisions = 0;\\n        // count # of cars moving right direction before every collision \\n        // since they will collide at a certain point\\n        // RR ------ X (if X is crash)\\n        // therefore this 2 RR cars will collide later\\n        int rights = 0; \\n        if (directions[0] == \\'R\\') rights++;\\n        char top = directions[0];\\n        \\n        for (int i = 1; i < directions.length(); i++) {\\n            if (directions[i] == \\'L\\' && top != \\'L\\') {\\n                // since LL not an accident \\n                \\n                if (top == \\'R\\') {\\n                    //RL will be SS therefore rights decrease by 1\\n                    collisions += 2;\\n                    rights--;\\n                } else if (top == \\'S\\') {\\n                    //SL will be SS \\n                    collisions ++;\\n                }\\n                // if collision occurs, therefore all right cars before me should contribute to this collision and then reset right cars\\n                collisions += rights;\\n                rights = 0;\\n                top = \\'S\\';\\n            } else if (directions[i] == \\'S\\') {\\n                if (top == \\'R\\'){\\n                    //RS will be SS therefore rights decrease by 1\\n                    rights--;\\n                    collisions ++;\\n                }\\n                // if collision occurs, therefore all right cars before me should contribute to this collision and then reset right cars\\n                collisions += rights;\\n                rights = 0;\\n                top = \\'S\\';\\n            } else if (directions[i] == \\'R\\'){\\n                rights++;\\n                top = \\'R\\';\\n            }\\n        }\\n        return collisions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int collisions = 0;\\n        // count # of cars moving right direction before every collision \\n        // since they will collide at a certain point\\n        // RR ------ X (if X is crash)\\n        // therefore this 2 RR cars will collide later\\n        int rights = 0; \\n        if (directions[0] == \\'R\\') rights++;\\n        char top = directions[0];\\n        \\n        for (int i = 1; i < directions.length(); i++) {\\n            if (directions[i] == \\'L\\' && top != \\'L\\') {\\n                // since LL not an accident \\n                \\n                if (top == \\'R\\') {\\n                    //RL will be SS therefore rights decrease by 1\\n                    collisions += 2;\\n                    rights--;\\n                } else if (top == \\'S\\') {\\n                    //SL will be SS \\n                    collisions ++;\\n                }\\n                // if collision occurs, therefore all right cars before me should contribute to this collision and then reset right cars\\n                collisions += rights;\\n                rights = 0;\\n                top = \\'S\\';\\n            } else if (directions[i] == \\'S\\') {\\n                if (top == \\'R\\'){\\n                    //RS will be SS therefore rights decrease by 1\\n                    rights--;\\n                    collisions ++;\\n                }\\n                // if collision occurs, therefore all right cars before me should contribute to this collision and then reset right cars\\n                collisions += rights;\\n                rights = 0;\\n                top = \\'S\\';\\n            } else if (directions[i] == \\'R\\'){\\n                rights++;\\n                top = \\'R\\';\\n            }\\n        }\\n        return collisions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938981,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int countCollisions(String directions) {\\n    int ans = 0;\\n    int l = 0;\\n    int r = directions.length() - 1;\\n\\n    while (l < directions.length() && directions.charAt(l) == \\'L\\')\\n      ++l;\\n\\n    while (r >= 0 && directions.charAt(r) == \\'R\\')\\n      --r;\\n\\n    for (int i = l; i <= r; ++i)\\n      if (directions.charAt(i) != \\'S\\')\\n        ++ans;\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int countCollisions(String directions) {\\n    int ans = 0;\\n    int l = 0;\\n    int r = directions.length() - 1;\\n\\n    while (l < directions.length() && directions.charAt(l) == \\'L\\')\\n      ++l;\\n\\n    while (r >= 0 && directions.charAt(r) == \\'R\\')\\n      --r;\\n\\n    for (int i = l; i <= r; ++i)\\n      if (directions.charAt(i) != \\'S\\')\\n        ++ans;\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905851,
                "title": "use-stack-to-store-only-s-or-r",
                "content": "# Intuition\\nWe use stack and store S/R. Values in stack reps values moving to right. S can be viewed as neutral (can be viewed as either left or right). Will be viewed as right if its inside the stack and viewed as left if not inside the stack.\\n\\nRememeber, collision happens when we have R-L, R-S, S-L. So the code should just handling these 3 conditions. \\n\\nIf we come across R, we directly store that in the stack (view them as righty).\\nElse if we come across L/S (we view them as lefties) and start popping the stack, as the collisons start to happen.\\n\\n(just note that popped values being from stack are righties)\\n\\nIf the popped value is R and current value is L, that means we got ourself a collision. (Now all collision end up as S). Then the result of that becomes S and set the current as S.\\nELse If the popped value happened to be S and current value is L or popped value happend to be R and current value is S, we get + 1 increment and the current will again become S.\\nElse if both popped and current value is S we just pop and ignore. Once we have emptied the stack, we just push one S as the result of collision ends up as S and we need to store that inside the stack. This is when the S act as righty to make collision happen when we come across L.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n\\n        ans = 0\\n        #store righties -> either r or s(only once the collision happens)\\n        stack = []\\n\\n        index = 0\\n\\n        while index < len(directions) :\\n            \\n            d = directions[index]\\n\\n            if stack:\\n                #since r is moving to right we put it in stack\\n                if d == \"R\":\\n                    stack.append(d)\\n                else:\\n                    #if d is L/S that means time for collisions\\n                    #c is a lefty here\\n                    c = d\\n                    while stack:\\n                        #get out righty\\n                        p = stack.pop()\\n\\n                        if p == \"R\" and c == \"L\":\\n                            ans += 2\\n                        elif (p == \"R\" and c == \"S\") or (p == \"S\" and c == \"L\"):\\n                            ans +=1\\n                        #after each collision we will make our lefty to be S so that any previous R that were in the stack can collide and get cleared\\n                        c = \"S\"\\n                    #once all the collisions are done we put S as this will be the roadblock to the future Ls\\n                    stack.append(\"S\") \\n            #if empty and its L then we can just ignore them\\n            #as we can never make collision with them.\\n            elif d != \"L\":\\n                stack.append(d)\\n\\n            index += 1\\n        return ans      \\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n\\n        ans = 0\\n        #store righties -> either r or s(only once the collision happens)\\n        stack = []\\n\\n        index = 0\\n\\n        while index < len(directions) :\\n            \\n            d = directions[index]\\n\\n            if stack:\\n                #since r is moving to right we put it in stack\\n                if d == \"R\":\\n                    stack.append(d)\\n                else:\\n                    #if d is L/S that means time for collisions\\n                    #c is a lefty here\\n                    c = d\\n                    while stack:\\n                        #get out righty\\n                        p = stack.pop()\\n\\n                        if p == \"R\" and c == \"L\":\\n                            ans += 2\\n                        elif (p == \"R\" and c == \"S\") or (p == \"S\" and c == \"L\"):\\n                            ans +=1\\n                        #after each collision we will make our lefty to be S so that any previous R that were in the stack can collide and get cleared\\n                        c = \"S\"\\n                    #once all the collisions are done we put S as this will be the roadblock to the future Ls\\n                    stack.append(\"S\") \\n            #if empty and its L then we can just ignore them\\n            #as we can never make collision with them.\\n            elif d != \"L\":\\n                stack.append(d)\\n\\n            index += 1\\n        return ans      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834043,
                "title": "swift-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. keeping track of previous direction when not collided\\n2. changing state of two collided cars to one stationary\\n3. after collision, check previous directions if it\\'s coming towards Right\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Make stack to keep record of previous uncollided direction\\n2. Traverse through all the directions char by char\\n3. if last is R --> then it will collide with <-- and . stationary\\n4. after collision pop stack if last direction is -->\\n5. if last is stationary . then it will collide with <-- left\\n6. if last is left, then it wont collide wiht next direction\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func countCollisions(_ directions: String) -> Int {\\n        var stack = [Character]()\\n        var collision = 0\\n        for ch in directions {\\n            if stack.isEmpty {\\n                stack.append(ch)\\n            } else {\\n                if stack.last! == \"R\" {\\n                    if ch == \"L\" || ch == \"S\" {\\n                        collision += (ch == \"L\" ? 2 : 1)\\n                        stack.removeLast()\\n                        while !stack.isEmpty && stack.last! == \"R\" {\\n                            collision += 1\\n                            stack.removeLast()\\n                        }\\n                        stack.append(\"S\")\\n                    } else {\\n                        stack.append(ch)\\n                    }\\n                } else if stack.last! == \"L\" {\\n                    stack.append(ch)\\n                } else if stack.last! == \"S\" {\\n                    if ch == \"L\" {\\n                        collision += 1\\n                    } else {\\n                        stack.append(ch)\\n                    }\\n                }\\n            }\\n        }\\n        return collision\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countCollisions(_ directions: String) -> Int {\\n        var stack = [Character]()\\n        var collision = 0\\n        for ch in directions {\\n            if stack.isEmpty {\\n                stack.append(ch)\\n            } else {\\n                if stack.last! == \"R\" {\\n                    if ch == \"L\" || ch == \"S\" {\\n                        collision += (ch == \"L\" ? 2 : 1)\\n                        stack.removeLast()\\n                        while !stack.isEmpty && stack.last! == \"R\" {\\n                            collision += 1\\n                            stack.removeLast()\\n                        }\\n                        stack.append(\"S\")\\n                    } else {\\n                        stack.append(ch)\\n                    }\\n                } else if stack.last! == \"L\" {\\n                    stack.append(ch)\\n                } else if stack.last! == \"S\" {\\n                    if ch == \"L\" {\\n                        collision += 1\\n                    } else {\\n                        stack.append(ch)\\n                    }\\n                }\\n            }\\n        }\\n        return collision\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815385,
                "title": "easy-c-code-time-o-n-and-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n      int n=s.size(),cnt=0,i=0;\\n      bool c=0;\\n      // stack<char>st;\\n      int cr=0;\\n      while(i<n){\\n        if(s[i]!=\\'R\\'){\\n          if(s[i]==\\'L\\'){\\n            if(cr>0){\\n              cnt+=2;\\n              cr--;\\n              c=1;\\n             cnt+=cr;\\n             cr=0;\\n            }\\n            else if(c) cnt++;\\n          }\\n          else {\\n          cnt+=cr;\\n          cr=0;\\n            c=1;\\n          }\\n        }\\n        else cr++;\\n        i++;\\n      }\\n\\n      return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n      int n=s.size(),cnt=0,i=0;\\n      bool c=0;\\n      // stack<char>st;\\n      int cr=0;\\n      while(i<n){\\n        if(s[i]!=\\'R\\'){\\n          if(s[i]==\\'L\\'){\\n            if(cr>0){\\n              cnt+=2;\\n              cr--;\\n              c=1;\\n             cnt+=cr;\\n             cr=0;\\n            }\\n            else if(c) cnt++;\\n          }\\n          else {\\n          cnt+=cr;\\n          cr=0;\\n            c=1;\\n          }\\n        }\\n        else cr++;\\n        i++;\\n      }\\n\\n      return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796626,
                "title": "o-n-time-complexity-with-no-extra-space-solution-very-simple-logic-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfrom start while (left moving cars )  will never collide\\nfrom end while(right moving cars ) will never collide\\n\\nLLLRLLRSRRR\\n   i   j                (shown pointers after above while operation)\\n\\nso the collsion (surely) will happen between i and j \\n\\n\\n\\niterating from i to j \\nchecking element[i] element[i+1]\\n\\n    if(R   &  L ) then collisonSum=collisonSum+2;\\n    else if RR --> collisonSum+=1;\\n    else if RS--->collisonSum+=1;\\n\\n    else if LL-->collisonSum+=1;\\n    (Note LR-->no sum    ,    LS no sum   .....The idea is that we   have run the 1st while loop so its sure the first i element  will not be L therefore LL will make contribution of 1 to sum  )\\n\\n    similarly for \\n    SL -->collisonSum+=1\\n(no contribution from SS and SR )\\n\\n\\n\\natlast return collsionSum;\\n\\n\\n\\n\\n\\n\\nThe working code is below ...\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int n=dir.size();\\n        int col=0;\\n        int i=0;\\n        while(i<n && dir[i]==\\'L\\'){\\n            i++;\\n        }\\n        int j=n-1;\\n        while(j>0 && dir[j]==\\'R\\'){\\n            j--;\\n        }\\n\\n        for(;i<j;i++){\\n            if(dir[i]==\\'S\\' && dir[i+1]==\\'L\\') col+=1;\\n            else if(dir[i]==\\'R\\' && dir[i+1]==\\'L\\') col+=2;\\n            else if(dir[i]==\\'L\\' && dir[i+1]==\\'L\\') col+=1;\\n            // else if(dir[i]==\\'L\\' && dir[i+1]==\\'S\\') col+=1;\\n            else if(dir[i]==\\'R\\' && dir[i+1]==\\'R\\') col+=1;\\n            else if(dir[i]==\\'R\\' && dir[i+1]==\\'S\\') col+=1;\\n            else if(dir[i]==\\'S\\' && dir[i+1]==\\'L\\') col+=1;\\n\\n        }\\n\\n        return col;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int n=dir.size();\\n        int col=0;\\n        int i=0;\\n        while(i<n && dir[i]==\\'L\\'){\\n            i++;\\n        }\\n        int j=n-1;\\n        while(j>0 && dir[j]==\\'R\\'){\\n            j--;\\n        }\\n\\n        for(;i<j;i++){\\n            if(dir[i]==\\'S\\' && dir[i+1]==\\'L\\') col+=1;\\n            else if(dir[i]==\\'R\\' && dir[i+1]==\\'L\\') col+=2;\\n            else if(dir[i]==\\'L\\' && dir[i+1]==\\'L\\') col+=1;\\n            // else if(dir[i]==\\'L\\' && dir[i+1]==\\'S\\') col+=1;\\n            else if(dir[i]==\\'R\\' && dir[i+1]==\\'R\\') col+=1;\\n            else if(dir[i]==\\'R\\' && dir[i+1]==\\'S\\') col+=1;\\n            else if(dir[i]==\\'S\\' && dir[i+1]==\\'L\\') col+=1;\\n\\n        }\\n\\n        return col;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794340,
                "title": "stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> s;\\n        int count = 0;\\n\\n        for(char direc : directions) {\\n               while(!s.empty() && (s.top() == \\'R\\' || s.top() == \\'S\\') && (direc == \\'S\\' || direc == \\'L\\')) {\\n                    char left = s.top(); s.pop();\\n                    colission(left, direc, count);\\n               }\\n\\n               s.push(direc);\\n            } \\n     \\n        return count;\\n    }\\n\\nprivate:\\n    void colission(char s, char& t, int& count) {\\n        if(t == \\'L\\') {\\n            if(s == \\'S\\' || s == \\'R\\') {\\n                count++;\\n                if(s == \\'R\\') count++;\\n                t = \\'S\\';\\n            }\\n        } else if(t == \\'S\\') {\\n            if(s == \\'R\\') {\\n                count++;\\n            }\\n        } \\n    }        \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> s;\\n        int count = 0;\\n\\n        for(char direc : directions) {\\n               while(!s.empty() && (s.top() == \\'R\\' || s.top() == \\'S\\') && (direc == \\'S\\' || direc == \\'L\\')) {\\n                    char left = s.top(); s.pop();\\n                    colission(left, direc, count);\\n               }\\n\\n               s.push(direc);\\n            } \\n     \\n        return count;\\n    }\\n\\nprivate:\\n    void colission(char s, char& t, int& count) {\\n        if(t == \\'L\\') {\\n            if(s == \\'S\\' || s == \\'R\\') {\\n                count++;\\n                if(s == \\'R\\') count++;\\n                t = \\'S\\';\\n            }\\n        } else if(t == \\'S\\') {\\n            if(s == \\'R\\') {\\n                count++;\\n            }\\n        } \\n    }        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793583,
                "title": "go-deep-thinking-about-how-the-collisions-are-computed",
                "content": "# Intuition\\n\\n##### - Come up with a simpler model\\nFirstly, I think the counting of collisions are very interesting.\\nWe can simplify it as the following rules:\\nL + R == 2  (score 2 points)\\nL + S == 1  (score 1 point)\\nS + R == 1  (score 1 point)\\nIt is actually a question about how many scores we can get. \\n\\n##### - observe the simple situations\\nL:      0 score\\nLL:     0 score\\nR:      0\\nLR:     0\\nLLR:    0\\nLLRRRR: 0\\nLLSRR:  0\\n\\nWhat can we learn from the above?\\n\\nThe rightmost\\'s R DO NOT contribute to the final scores.\\nIn the same way,\\nThe leftmost\\'s L DO NOT contribute to the final scores.\\n\\n##### - one more step\\nSo what can contribute to the final scores?\\nThere are two situations which could meet the requiremets\\n(1)\\n=====R=====R========= L/S\\n(we find the rightmost\\'s elem that is not `R`, we mark it `L/S`, so it is a `L` or a `S`)\\nor (2)\\nR/S======L=======L======\\n(we find the leftmost\\'s elem that is not `L`, we mark it `R/S`, so it is a `R` or a `S`)\\n\\nSo we count the number of `R` before the rightmost\\'s `L/S`, all the `R` contribute 1 score to the final results.\\n\\nSimilarily, we count the number of `L` after the leftmost\\'s `R/S`, all the `L` also contribute 1 score to the final results\\n\\n# code\\n```\\nfunc countCollisions(directions string) int {\\n    n, ans := len(directions), 0\\n    i := n-1\\n    for ; i>=0 && directions[i]==\\'R\\'; i-- {}\\n    for ; i>= 0; i-- {\\n        if directions[i] == \\'R\\' {ans++}\\n    }\\n    for i=0; i<n && directions[i]==\\'L\\'; i++ {}\\n    for ;i<n; i++ {\\n        if directions[i] == \\'L\\' {ans++}\\n    }\\n    return ans\\n}\\n```\\n# Optimization\\n=====R=====R========= L/S\\nis actually \\n=====R=====R========= L/S RRR...\\n\\nand \\nR/S======L=======L======\\nis actually\\nLLL...R/S======L=======L======\\n\\nwe merge this two together\\n=====R=====R========= L/S RRR...\\nLLL... R/S======L=======L======\\n\\nSo you see, the `L` or `R` that really contribue to the results,\\nare between R/S and L/S\\n\\nBecause there are no `R` before `R/S`(this is how we define `R/S`),\\nand no `L` after `L/S`\\n\\nR/S ========L====R====L==R=============L/S\\n\\nSo the code is\\n\\n```\\nfunc countCollisions(directions string) int {\\n    n, ans := len(directions), 0\\n    i, j := n-1, 0\\n    for ; i>=0 && directions[i]==\\'R\\'; i-- {}\\n    for ; j<n && directions[j]==\\'L\\'; j++ {}\\n    for ; j<=i; j++ {\\n        if directions[j] != \\'S\\' {ans++}\\n    }\\n    return ans\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countCollisions(directions string) int {\\n    n, ans := len(directions), 0\\n    i := n-1\\n    for ; i>=0 && directions[i]==\\'R\\'; i-- {}\\n    for ; i>= 0; i-- {\\n        if directions[i] == \\'R\\' {ans++}\\n    }\\n    for i=0; i<n && directions[i]==\\'L\\'; i++ {}\\n    for ;i<n; i++ {\\n        if directions[i] == \\'L\\' {ans++}\\n    }\\n    return ans\\n}\\n```\n```\\nfunc countCollisions(directions string) int {\\n    n, ans := len(directions), 0\\n    i, j := n-1, 0\\n    for ; i>=0 && directions[i]==\\'R\\'; i-- {}\\n    for ; j<n && directions[j]==\\'L\\'; j++ {}\\n    for ; j<=i; j++ {\\n        if directions[j] != \\'S\\' {ans++}\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3792842,
                "title": "easy-cpp-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int collisionCount = 0;\\n        stack<char> dirStack;\\n        int Right_way = 0;\\n\\n        for (auto dir : directions) {\\n            \\n            if(dir == \\'R\\') Right_way++;\\n            bool noRoute = false; \\n            \\n            if (dirStack.empty()) dirStack.push(dir); \\n    \\n            else if (dirStack.top() == \\'S\\' && dir == \\'L\\') collisionCount++; \\n\\n            else if (dirStack.top() == \\'R\\' && dir == \\'L\\') {\\n                collisionCount += 2 ; dirStack.pop(); \\n                noRoute = true;Right_way--;\\n            }\\n            else dirStack.push(dir);\\n            \\n            if (noRoute || dir == \\'S\\') {\\n               collisionCount += (Right_way); \\n               Right_way = 0;\\n               dirStack.push(\\'S\\'); \\n            }\\n        }\\n        \\n        return collisionCount; // Return the total collision count\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int collisionCount = 0;\\n        stack<char> dirStack;\\n        int Right_way = 0;\\n\\n        for (auto dir : directions) {\\n            \\n            if(dir == \\'R\\') Right_way++;\\n            bool noRoute = false; \\n            \\n            if (dirStack.empty()) dirStack.push(dir); \\n    \\n            else if (dirStack.top() == \\'S\\' && dir == \\'L\\') collisionCount++; \\n\\n            else if (dirStack.top() == \\'R\\' && dir == \\'L\\') {\\n                collisionCount += 2 ; dirStack.pop(); \\n                noRoute = true;Right_way--;\\n            }\\n            else dirStack.push(dir);\\n            \\n            if (noRoute || dir == \\'S\\') {\\n               collisionCount += (Right_way); \\n               Right_way = 0;\\n               dirStack.push(\\'S\\'); \\n            }\\n        }\\n        \\n        return collisionCount; // Return the total collision count\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792356,
                "title": "c-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nR L 2\\nS L 1\\nR S 1\\n*/\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int count = 0;\\n        int n = dir.size();\\n        for (int i = 1; i < n; i++) {\\n            int j = i;\\n            if (dir[j] == \\'L\\' && dir[j-1] == \\'R\\') {\\n                dir[j]   = \\'S\\';\\n                dir[j-1] = \\'S\\';\\n                count += 2;\\n                j--;\\n                while((j > 0) && (dir[j] == \\'S\\' && dir[j-1] == \\'R\\')) {\\n                    j--;\\n                    dir[j] = \\'S\\';\\n                    count++;\\n                }\\n            }\\n            else if (dir[j] == \\'S\\' && dir[j-1] == \\'R\\') {\\n                dir[j-1] = \\'S\\';\\n                count += 1;\\n                j--;\\n                while((j > 0) && (dir[j] == \\'S\\' && dir[j-1] == \\'R\\')) {\\n                    j--;\\n                    dir[j] = \\'S\\';\\n                    count++;\\n                }\\n            }\\n            else if (dir[j] == \\'L\\' && dir[j-1] == \\'S\\') {\\n                dir[j] = \\'S\\';\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nR L 2\\nS L 1\\nR S 1\\n*/\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        int count = 0;\\n        int n = dir.size();\\n        for (int i = 1; i < n; i++) {\\n            int j = i;\\n            if (dir[j] == \\'L\\' && dir[j-1] == \\'R\\') {\\n                dir[j]   = \\'S\\';\\n                dir[j-1] = \\'S\\';\\n                count += 2;\\n                j--;\\n                while((j > 0) && (dir[j] == \\'S\\' && dir[j-1] == \\'R\\')) {\\n                    j--;\\n                    dir[j] = \\'S\\';\\n                    count++;\\n                }\\n            }\\n            else if (dir[j] == \\'S\\' && dir[j-1] == \\'R\\') {\\n                dir[j-1] = \\'S\\';\\n                count += 1;\\n                j--;\\n                while((j > 0) && (dir[j] == \\'S\\' && dir[j-1] == \\'R\\')) {\\n                    j--;\\n                    dir[j] = \\'S\\';\\n                    count++;\\n                }\\n            }\\n            else if (dir[j] == \\'L\\' && dir[j-1] == \\'S\\') {\\n                dir[j] = \\'S\\';\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792297,
                "title": "simple-approach-with-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- For any car, collision depends on whether it can be stopped or not.\\n- Now when can a moving car be stopped? =>When along its direction there is a car that can stop it.\\nEx: For car A thats moving to L if there is a car on the left that is either stopped or moving along R then car A can be stopped.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Find out the left stopping point for cars moving left and right stopping point for cars moving right.\\n- Now keep iterating over i from 0 to N and check whether it can be stopped along its directions and add 1 to count if conditions satisfies.\\n- If its already stopped then don\\'t do anything, as it is not colliding by itself.\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int n=directions.size();\\n        int left_stop=n,right_stop=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            if(left_stop==n&&(directions[i]==\\'S\\'||directions[i]==\\'R\\')){\\n                left_stop=i;\\n            }\\n            if(right_stop==-1&&(directions[n-1-i]==\\'S\\'||directions[n-1-i]==\\'L\\')){\\n                right_stop=n-1-i;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(directions[i]==\\'S\\')continue;\\n\\n            if(i-1>=0&&directions[i]==\\'L\\'&&left_stop<i){\\n                count++;\\n            }\\n\\n            if(i+1<n&&directions[i]==\\'R\\'&&right_stop>i){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int n=directions.size();\\n        int left_stop=n,right_stop=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            if(left_stop==n&&(directions[i]==\\'S\\'||directions[i]==\\'R\\')){\\n                left_stop=i;\\n            }\\n            if(right_stop==-1&&(directions[n-1-i]==\\'S\\'||directions[n-1-i]==\\'L\\')){\\n                right_stop=n-1-i;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(directions[i]==\\'S\\')continue;\\n\\n            if(i-1>=0&&directions[i]==\\'L\\'&&left_stop<i){\\n                count++;\\n            }\\n\\n            if(i+1<n&&directions[i]==\\'R\\'&&right_stop>i){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791807,
                "title": "easy-3-line-logic-with-intuition",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLook at the problem in another way like possiblities for having a collision is a lot and complex to make it simple what if we ignore the cases where we cannot have collision.\\n    Think of that we only have two cases for not having collision which are ignored in first two lines of code and remaining moving cars will surely invlove in collision.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int n=s.size(),i=0,j=n-1,ans=0;\\n        while(i<n && s[i]==\\'L\\')i++;\\n        while(j>=0 && s[j]==\\'R\\')j--;\\n        while(i<=j)if(s[i++]!=\\'S\\')ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int n=s.size(),i=0,j=n-1,ans=0;\\n        while(i<n && s[i]==\\'L\\')i++;\\n        while(j>=0 && s[j]==\\'R\\')j--;\\n        while(i<=j)if(s[i++]!=\\'S\\')ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791755,
                "title": "short-easy-c-code-properly-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is just a long if-else problem, where you have a variety of possibilities. Can be solved greedily. Best we can do is narrow it down so the code looks less junky and readable.\\nConsidering there are `N` cars, for every car at position `i`, we will calculate possible collisions **before** `i`.\\n- If a car is going towards right, it hasn\\'t been in a collision yet.\\n- If a car is stationary, cars going towards right will collide.\\n    - a single car going to right will result in `1` collision //***`RS`***\\n    - similarly `k` cars going to right will result in `k` collisions // ***`RR..RS`***\\n- If a car is going towards left, it will collide with cars that are going to right or stationary cars.\\n    - Collision with a stationary car will increase collisions by `1`. // ***`SL`***\\n    - Collision with a car going towards right will increase collisions by `2`. Since both cars are moving. // ***`RL`***\\n    - Collision with `k` cars going right will increase collisions by `k+1`. // ***`RR..RL`***\\n\\n---\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**`countCollisions` function:** As we are greedily traversing `directions` string, and counting collisions where `i`th car was involved. It is necessary to keep track of what we encountered before, that\\'s where we define the `state` variable.\\n- value of `state` tells us : \\n    - `-1`: There are either cars going to left, or no cars at all. No possible collision at this point.\\n    - `0`: There is a stationary car ( could have been a moving car stopped in a  collision ). If current car is going towards left, it will cause `1` collision.\\n    - `k (non-zero positive)`: There are `k` cars coming from left. It will cause `k` collisions. If current car is also going towards left then there will be an extra collision.\\n\\nDepending on the value of `state` we can calculate `collisions`.\\nIf current car is going to:\\n- Right : \\n    - If `state` is greater than 0, increase it by 1, meaning there is one more car coming towards right.\\n    - else change it to 1, because now there is 1 car coming towards right.\\n- Stationary :\\n    - If `state` is greater than 0, add `state` to `collisions`.\\n    - Change `state` to 0, because those cars going to right have stopped due to collision.\\n- Left :\\n    - If `state` is greater then 0, the first pair will be `RL`, which yields `2` collisions. `state - 1` collision after that are stationary collisions. So total collisions are `state + 1`.\\n    - If current car is not in a collision then change `state` to `-1`, else change it to `0`.  \\n\\nBy the end of traversing the whole string we would have the total number of collisions.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int collisions = 0, state = -1;\\n        for(const char& d : directions) {\\n            if(d == \\'R\\') \\n                state = max(1, state+1);\\n            else if(d == \\'S\\') {\\n                collisions += max(0, state);\\n                state = 0;\\n            }\\n            else if(d == \\'L\\') {\\n                collisions += state+1;\\n                state = min(0, state);\\n            }\\n        }   return collisions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int collisions = 0, state = -1;\\n        for(const char& d : directions) {\\n            if(d == \\'R\\') \\n                state = max(1, state+1);\\n            else if(d == \\'S\\') {\\n                collisions += max(0, state);\\n                state = 0;\\n            }\\n            else if(d == \\'L\\') {\\n                collisions += state+1;\\n                state = min(0, state);\\n            }\\n        }   return collisions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779032,
                "title": "might-seem-lengthy-but-is-easy-to-understand-and-covers-all-possible-cases-tc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> st;\\n        int ans = 0;\\n        for (auto &it : directions) {\\n            if (it == \\'L\\') {\\n                if (st.empty()) {\\n                    st.push(it);\\n                } else if (st.top() == \\'S\\') {\\n                    ans++;  // remove (S + L)\\'s collisions\\n                } else if (st.top() == \\'L\\') {\\n                    st.push(it);\\n                } else {   // (R + L) --> S\\n                    ans += 2; \\n                    st.pop();  // further (R + S)\\'s collisions\\n                    while (st.size() && st.top() == \\'R\\') {\\n                        ans++;\\n                        st.pop();\\n                    }\\n                    st.push(\\'S\\');\\n                }\\n            } else if (it == \\'R\\') { // no collisions at the moment\\n                st.push(it);\\n            } else {  // remove (R + S)\\'s collisions\\n                while (st.size() && st.top() == \\'R\\') {\\n                    ans++;\\n                    st.pop();\\n                }\\n                st.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        stack<char> st;\\n        int ans = 0;\\n        for (auto &it : directions) {\\n            if (it == \\'L\\') {\\n                if (st.empty()) {\\n                    st.push(it);\\n                } else if (st.top() == \\'S\\') {\\n                    ans++;  // remove (S + L)\\'s collisions\\n                } else if (st.top() == \\'L\\') {\\n                    st.push(it);\\n                } else {   // (R + L) --> S\\n                    ans += 2; \\n                    st.pop();  // further (R + S)\\'s collisions\\n                    while (st.size() && st.top() == \\'R\\') {\\n                        ans++;\\n                        st.pop();\\n                    }\\n                    st.push(\\'S\\');\\n                }\\n            } else if (it == \\'R\\') { // no collisions at the moment\\n                st.push(it);\\n            } else {  // remove (R + S)\\'s collisions\\n                while (st.size() && st.top() == \\'R\\') {\\n                    ans++;\\n                    st.pop();\\n                }\\n                st.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774184,
                "title": "java-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Stack;\\n\\nclass Solution {\\n\\tpublic int countCollisions(String s) {\\n\\n\\t\\tint n = s.length();\\n\\t\\tint count=0;\\n\\t\\tStack<Character> st = new Stack<>();\\n\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\tif (s.charAt(i)==\\'R\\'){\\n\\t\\t\\t\\tif (!st.isEmpty()&&st.peek()==\\'S\\'){\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.add(\\'R\\');\\n\\t\\t\\t}else if(s.charAt(i)==\\'L\\'){\\n\\t\\t\\t\\tif (!st.isEmpty()){\\n\\t\\t\\t\\t\\tif (st.peek()==\\'S\\'){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tcount +=st.size()+1;\\n\\t\\t\\t\\t\\t\\tst.clear();\\n\\t\\t\\t\\t\\t\\tst.add(\\'S\\');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tif (!st.isEmpty()&&st.peek()!=\\'S\\') {\\n\\t\\t\\t\\t\\tcount += st.size();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t\\tst.add(\\'S\\');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Stack;\\n\\nclass Solution {\\n\\tpublic int countCollisions(String s) {\\n\\n\\t\\tint n = s.length();\\n\\t\\tint count=0;\\n\\t\\tStack<Character> st = new Stack<>();\\n\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\tif (s.charAt(i)==\\'R\\'){\\n\\t\\t\\t\\tif (!st.isEmpty()&&st.peek()==\\'S\\'){\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.add(\\'R\\');\\n\\t\\t\\t}else if(s.charAt(i)==\\'L\\'){\\n\\t\\t\\t\\tif (!st.isEmpty()){\\n\\t\\t\\t\\t\\tif (st.peek()==\\'S\\'){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tcount +=st.size()+1;\\n\\t\\t\\t\\t\\t\\tst.clear();\\n\\t\\t\\t\\t\\t\\tst.add(\\'S\\');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tif (!st.isEmpty()&&st.peek()!=\\'S\\') {\\n\\t\\t\\t\\t\\tcount += st.size();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t\\tst.add(\\'S\\');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720707,
                "title": "easy-to-understand-java-solution-stack-upvote",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCollisions(String dir) {\\n        int cnt = 0;\\n        Stack<Character> st = new Stack<>();\\n        st.add(dir.charAt(0));\\n\\n        for(int i = 1; i < dir.length(); i++){\\n            char curr = dir.charAt(i);\\n\\n            if(!st.isEmpty() && (st.peek() == \\'R\\' && curr == \\'L\\')){\\n                cnt = cnt + 2;\\n                curr = \\'S\\';\\n                st.pop();\\n            }\\n            else if(!st.isEmpty() && (st.peek() == \\'S\\' && curr == \\'L\\')){\\n                cnt++;\\n                curr = \\'S\\';\\n            }\\n\\n            while(!st.isEmpty() && (st.peek() == \\'R\\' && curr == \\'S\\')){\\n                cnt++;\\n                st.pop();\\n            }\\n            st.add(curr);\\n        }\\n\\n        return cnt;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int countCollisions(String dir) {\\n        int cnt = 0;\\n        Stack<Character> st = new Stack<>();\\n        st.add(dir.charAt(0));\\n\\n        for(int i = 1; i < dir.length(); i++){\\n            char curr = dir.charAt(i);\\n\\n            if(!st.isEmpty() && (st.peek() == \\'R\\' && curr == \\'L\\')){\\n                cnt = cnt + 2;\\n                curr = \\'S\\';\\n                st.pop();\\n            }\\n            else if(!st.isEmpty() && (st.peek() == \\'S\\' && curr == \\'L\\')){\\n                cnt++;\\n                curr = \\'S\\';\\n            }\\n\\n            while(!st.isEmpty() && (st.peek() == \\'R\\' && curr == \\'S\\')){\\n                cnt++;\\n                st.pop();\\n            }\\n            st.add(curr);\\n        }\\n\\n        return cnt;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703962,
                "title": "easy-understand-o-n-python-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        Right_Move = 0\\n        Stand_Point = False\\n        res = 0\\n        for cur in directions:\\n            if cur == \"R\":\\n                Right_Move += 1\\n                Stand_Point = True\\n            elif cur == \"L\":\\n                if Stand_Point:\\n                    res += Right_Move + 1\\n                Right_Move = 0\\n            else:\\n                Stand_Point = True\\n                res += Right_Move\\n                Right_Move = 0\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        Right_Move = 0\\n        Stand_Point = False\\n        res = 0\\n        for cur in directions:\\n            if cur == \"R\":\\n                Right_Move += 1\\n                Stand_Point = True\\n            elif cur == \"L\":\\n                if Stand_Point:\\n                    res += Right_Move + 1\\n                Right_Move = 0\\n            else:\\n                Stand_Point = True\\n                res += Right_Move\\n                Right_Move = 0\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660824,
                "title": "c-python-stack-solution-with-explanation",
                "content": "### stack\\nprocess the cars to the left first, then the cars to the right,\\nWhen two moving cars collide, they will not move, so L+R=S\\n\\nWe also go to the right, encounter L, check whether the top of the stack is S or R\\nEncounter R or S and put it on the stack\\n\\nThen traverse the stack from the right to process the cars traversed to the left,\\nEncounter R, check whether the top of the stack is S or L\\nEncounter L or S and put it on the stack\\ntc O(n), sc O(n)\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        string left_stack;\\n        int cnt = 0;\\n        for (auto& car: directions) {\\n            if (car == \\'L\\') {\\n                if (left_stack.empty()) continue;\\n                else if (left_stack.back() == \\'S\\') cnt += 1;\\n                else if (left_stack.back() == \\'R\\') {\\n                    cnt += 2;\\n                    left_stack.pop_back();\\n                    left_stack += \\'S\\';\\n                } \\n            } else left_stack += car;\\n        }\\n        string right_stack;\\n        for (int i = left_stack.size()-1; i >= 0; i-=1) {\\n            if (left_stack[i] == \\'R\\') {\\n                if (right_stack.empty()) continue;\\n                else if (right_stack.back() == \\'S\\') cnt += 1;\\n                else if (right_stack.back() == \\'L\\') {\\n                    cnt += 2;\\n                    right_stack.pop_back();\\n                    right_stack += \\'S\\';\\n                } \\n            } else right_stack += left_stack[i];\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n### python\\n```python\\n\\'\\'\\'\\n\\u5148\\u8655\\u7406\\u5F80\\u5DE6\\u908A\\u7684\\u8ECA, \\u518D\\u8655\\u7406\\u5F80\\u53F3\\u908A\\u7684\\u8ECA,\\n\\u7576\\u5169\\u500B\\u79FB\\u52D5\\u7684\\u8ECA\\u78B0\\u649E\\u5C31\\u4E0D\\u6703\\u52D5, \\u6240\\u4EE5L+R=S\\n\\n\\u6211\\u5011\\u5148\\u5F80\\u53F3\\u908A\\u8D70, \\u9047\\u5230L, \\u6AA2\\u67E5\\u68E7\\u9802\\u662FS\\u9084\\u662FR\\n\\u9047\\u5230R\\u6216S\\u653E\\u9032\\u68E7\\u88E1\\n\\n\\u518D\\u7531\\u53F3\\u5F80\\u5DE6\\u904D\\u6B77\\u68E7, \\u8655\\u7406\\u5F80\\u53F3\\u908A\\u7684\\u8ECA,\\n\\u9047\\u5230R, \\u6AA2\\u67E5\\u68E7\\u9802\\u662FS\\u9084\\u662FL\\n\\u9047\\u5230L\\u6216S\\u653E\\u9032\\u68E7\\u88E1\\ntc O(n), sc O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        left_stack = []\\n        cnt = 0\\n        for car in directions:\\n            if car == \\'L\\': \\n                if not left_stack: continue\\n                elif left_stack[-1] == \\'S\\': cnt += 1\\n                elif left_stack[-1] == \\'R\\':\\n                    cnt += 2\\n                    left_stack.pop()\\n                    left_stack.append(\\'S\\')\\n            else:\\n                left_stack.append(car)\\n        right_stack = []\\n        for i in range(len(left_stack)-1,-1,-1):\\n            if left_stack[i] == \\'R\\':\\n                if not right_stack: continue\\n                elif right_stack[-1] == \\'S\\': cnt += 1\\n                elif right_stack[-1] == \\'L\\':\\n                    cnt += 2\\n                    right_stack.pop()\\n                    right_stack.append(\\'S\\')\\n            else:\\n                right_stack.append(left_stack[i])\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        string left_stack;\\n        int cnt = 0;\\n        for (auto& car: directions) {\\n            if (car == \\'L\\') {\\n                if (left_stack.empty()) continue;\\n                else if (left_stack.back() == \\'S\\') cnt += 1;\\n                else if (left_stack.back() == \\'R\\') {\\n                    cnt += 2;\\n                    left_stack.pop_back();\\n                    left_stack += \\'S\\';\\n                } \\n            } else left_stack += car;\\n        }\\n        string right_stack;\\n        for (int i = left_stack.size()-1; i >= 0; i-=1) {\\n            if (left_stack[i] == \\'R\\') {\\n                if (right_stack.empty()) continue;\\n                else if (right_stack.back() == \\'S\\') cnt += 1;\\n                else if (right_stack.back() == \\'L\\') {\\n                    cnt += 2;\\n                    right_stack.pop_back();\\n                    right_stack += \\'S\\';\\n                } \\n            } else right_stack += left_stack[i];\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```python\\n\\'\\'\\'\\n\\u5148\\u8655\\u7406\\u5F80\\u5DE6\\u908A\\u7684\\u8ECA, \\u518D\\u8655\\u7406\\u5F80\\u53F3\\u908A\\u7684\\u8ECA,\\n\\u7576\\u5169\\u500B\\u79FB\\u52D5\\u7684\\u8ECA\\u78B0\\u649E\\u5C31\\u4E0D\\u6703\\u52D5, \\u6240\\u4EE5L+R=S\\n\\n\\u6211\\u5011\\u5148\\u5F80\\u53F3\\u908A\\u8D70, \\u9047\\u5230L, \\u6AA2\\u67E5\\u68E7\\u9802\\u662FS\\u9084\\u662FR\\n\\u9047\\u5230R\\u6216S\\u653E\\u9032\\u68E7\\u88E1\\n\\n\\u518D\\u7531\\u53F3\\u5F80\\u5DE6\\u904D\\u6B77\\u68E7, \\u8655\\u7406\\u5F80\\u53F3\\u908A\\u7684\\u8ECA,\\n\\u9047\\u5230R, \\u6AA2\\u67E5\\u68E7\\u9802\\u662FS\\u9084\\u662FL\\n\\u9047\\u5230L\\u6216S\\u653E\\u9032\\u68E7\\u88E1\\ntc O(n), sc O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        left_stack = []\\n        cnt = 0\\n        for car in directions:\\n            if car == \\'L\\': \\n                if not left_stack: continue\\n                elif left_stack[-1] == \\'S\\': cnt += 1\\n                elif left_stack[-1] == \\'R\\':\\n                    cnt += 2\\n                    left_stack.pop()\\n                    left_stack.append(\\'S\\')\\n            else:\\n                left_stack.append(car)\\n        right_stack = []\\n        for i in range(len(left_stack)-1,-1,-1):\\n            if left_stack[i] == \\'R\\':\\n                if not right_stack: continue\\n                elif right_stack[-1] == \\'S\\': cnt += 1\\n                elif right_stack[-1] == \\'L\\':\\n                    cnt += 2\\n                    right_stack.pop()\\n                    right_stack.append(\\'S\\')\\n            else:\\n                right_stack.append(left_stack[i])\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555579,
                "title": "two-solution-1-using-stack-and-2-using-logic",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string dirs) {\\n        <!-- 1st Approach O(N) SC -->\\n        stack<char> s;\\n        int n = dirs.size(), ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(s.empty()) s.push(dirs[i]);\\n            \\n            else if(s.top() == \\'R\\' and dirs[i] == \\'L\\') {\\n                ans += 2;\\n                s.pop();\\n                dirs[i] = \\'S\\';\\n                i--;\\n            }\\n            \\n            else if(s.top() == \\'R\\' and dirs[i] == \\'S\\') {\\n                s.pop();\\n                ans++;\\n                dirs[i] = \\'S\\';\\n                i--;\\n            }\\n            \\n            else if(s.top() == \\'S\\' and dirs[i] == \\'L\\') \\n                ans++;\\n            \\n            else \\n                s.push(dirs[i]); \\n        }\\n        return ans; \\n\\n        <!-- 2nd Approach O(1) SC -->\\n        int carsFromRight = 0, n = dirs.size();\\n        int i = 0, count = 0;\\n\\n        while(i < n and dirs[i] == \\'L\\') i++;\\n\\n        for(; i < n; i++) {\\n            if(dirs[i] == \\'R\\') carsFromRight++;\\n            else {\\n                count += dirs[i] == \\'L\\' ? carsFromRight + 1 : carsFromRight;\\n                carsFromRight = 0;\\n            }\\n        }    \\n\\n        return count;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string dirs) {\\n        <!-- 1st Approach O(N) SC -->\\n        stack<char> s;\\n        int n = dirs.size(), ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(s.empty()) s.push(dirs[i]);\\n            \\n            else if(s.top() == \\'R\\' and dirs[i] == \\'L\\') {\\n                ans += 2;\\n                s.pop();\\n                dirs[i] = \\'S\\';\\n                i--;\\n            }\\n            \\n            else if(s.top() == \\'R\\' and dirs[i] == \\'S\\') {\\n                s.pop();\\n                ans++;\\n                dirs[i] = \\'S\\';\\n                i--;\\n            }\\n            \\n            else if(s.top() == \\'S\\' and dirs[i] == \\'L\\') \\n                ans++;\\n            \\n            else \\n                s.push(dirs[i]); \\n        }\\n        return ans; \\n\\n        <!-- 2nd Approach O(1) SC -->\\n        int carsFromRight = 0, n = dirs.size();\\n        int i = 0, count = 0;\\n\\n        while(i < n and dirs[i] == \\'L\\') i++;\\n\\n        for(; i < n; i++) {\\n            if(dirs[i] == \\'R\\') carsFromRight++;\\n            else {\\n                count += dirs[i] == \\'L\\' ? carsFromRight + 1 : carsFromRight;\\n                carsFromRight = 0;\\n            }\\n        }    \\n\\n        return count;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544295,
                "title": "direction-question-c-one-of-the-best-question-for-acc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int count = 0;\\n        int n =directions.size();\\n        int right = 0;\\n        int getstationary = 0;\\n        for(int i=0;i<n;i++){\\n            if(directions[i] ==\\'R\\'){\\n                right++;\\n            }\\n            else if(directions[i] == \\'S\\'){\\n                count+=right;\\n                //all the cars who are coming from the right directions will halt\\n                right = 0;\\n                getstationary = 1;\\n            }\\n            else{//current car is moving towards left \\'L\\'\\n                if(right>0){\\n                    count+=2;\\n                    right--;\\n                    if(right>0)count+=right;\\n                    right = 0;\\n                    getstationary = 1;\\n                }\\n                else if(getstationary == 1){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int count = 0;\\n        int n =directions.size();\\n        int right = 0;\\n        int getstationary = 0;\\n        for(int i=0;i<n;i++){\\n            if(directions[i] ==\\'R\\'){\\n                right++;\\n            }\\n            else if(directions[i] == \\'S\\'){\\n                count+=right;\\n                //all the cars who are coming from the right directions will halt\\n                right = 0;\\n                getstationary = 1;\\n            }\\n            else{//current car is moving towards left \\'L\\'\\n                if(right>0){\\n                    count+=2;\\n                    right--;\\n                    if(right>0)count+=right;\\n                    right = 0;\\n                    getstationary = 1;\\n                }\\n                else if(getstationary == 1){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541720,
                "title": "one-pass-c-solution-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\'L\\' will always collide with any \\'S\\' or \\'R\\' to its left.\\n\\'R\\' will always collide with any \\'S\\' or \\'L\\' to its right.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet:\\n- ct = the answer.\\n- l = the left most \\'R\\' or \\'S\\' has appeared. (boolean).\\n- tmp = the number of \\'R\\' that has not yet collided.\\n\\nWhen l = 1 and come out any \\'L\\' --> ++ct.\\nWhen come out any \\'L\\' or \\'S\\' --> ct += tmp because all the \\'R\\'s of tmp stay on the left hand side of this \\'L\\'/\\'S\\'.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        int n=d.size(),l=0,ct=0,tmp=0;\\n        for(int i=0;i<n;++i){\\n            if(d[i]==\\'R\\'||d[i]==\\'S\\'){\\n                if(!l)l=1;\\n                if(d[i]==\\'R\\')++tmp;\\n            }\\n            if(d[i]==\\'L\\'||d[i]==\\'S\\'){\\n                if(l&&d[i]==\\'L\\')++ct;\\n                ct+=tmp;\\n                tmp=0;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        int n=d.size(),l=0,ct=0,tmp=0;\\n        for(int i=0;i<n;++i){\\n            if(d[i]==\\'R\\'||d[i]==\\'S\\'){\\n                if(!l)l=1;\\n                if(d[i]==\\'R\\')++tmp;\\n            }\\n            if(d[i]==\\'L\\'||d[i]==\\'S\\'){\\n                if(l&&d[i]==\\'L\\')++ct;\\n                ct+=tmp;\\n                tmp=0;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519560,
                "title": "python-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        stack = [directions[0]]\\n        ans = 0\\n        \\n        def check(c1, c2):\\n            if c1 == \\'R\\' and c2 == \\'L\\':\\n                return 2\\n            if c1 == \\'R\\' and c2 == \\'S\\':\\n                return 1\\n            if c1 == \\'S\\' and c2 == \\'L\\':\\n                return 1\\n            return False\\n        \\n        for i in range(1, len(directions)):\\n            stack.append(directions[i])\\n            check_result = check(stack[-2], stack[-1])\\n            while check_result is not False:\\n                ans += check_result\\n                if check_result == 2:\\n                    stack.pop()\\n                    stack.pop()\\n                    stack.append(\\'S\\')\\n                elif check_result == 1:\\n                    stack.pop()\\n                    stack.pop()\\n                    stack.append(\\'S\\')\\n                if len(stack) >= 2:\\n                    check_result = check(stack[-2], stack[-1])\\n                else:\\n                    check_result = False\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        stack = [directions[0]]\\n        ans = 0\\n        \\n        def check(c1, c2):\\n            if c1 == \\'R\\' and c2 == \\'L\\':\\n                return 2\\n            if c1 == \\'R\\' and c2 == \\'S\\':\\n                return 1\\n            if c1 == \\'S\\' and c2 == \\'L\\':\\n                return 1\\n            return False\\n        \\n        for i in range(1, len(directions)):\\n            stack.append(directions[i])\\n            check_result = check(stack[-2], stack[-1])\\n            while check_result is not False:\\n                ans += check_result\\n                if check_result == 2:\\n                    stack.pop()\\n                    stack.pop()\\n                    stack.append(\\'S\\')\\n                elif check_result == 1:\\n                    stack.pop()\\n                    stack.pop()\\n                    stack.append(\\'S\\')\\n                if len(stack) >= 2:\\n                    check_result = check(stack[-2], stack[-1])\\n                else:\\n                    check_result = False\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490650,
                "title": "c-easy-solution-using-stack-with-explanation",
                "content": "# EXPLANATION\\nWe used stack to solve this problem.\\nIn first traversal we skipped all the **\\'L\\'** which is in front of string **directions**.\\nWe kept 3 condition:\\n1. Push in stack the first letter in stack if stack is empty(i.e., **\\'R\\'** or **\\'S\\'**).\\n2. If top of stack is equal to the position of pointer in string, push that character in stack.\\n3. After above conditions only two possibilities are left, either **\\'R\\'** or **\\'S\\'** will be there.\\n3.1 If top of stack is **\\'R\\'**, we pop every \\'R\\' and then kept the count of all collision(check both conditions count of collision).\\n3.2 If top of stack is **\\'S\\'**, we added the collision if **\\'L\\'** is the pointer on string and if **\\'R\\'** then \\'R\\' is added to stack.\\n\\nFinally returned the answer.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int n=directions.size(),ans=0,i;\\n        for(i=0;i<n;i++){\\n            if(directions[i]!=\\'L\\')\\n                break;\\n        }\\n        stack<char> s;\\n        for(;i<n;i++){\\n            if(s.empty())\\n                s.push(directions[i]);\\n            else if(s.top()==directions[i])\\n                s.push(directions[i]);\\n            else{\\n                if(s.top()==\\'R\\'){\\n                    if(directions[i]==\\'L\\'){\\n                        while(!s.empty() && s.top()==\\'R\\'){\\n                            ans++;\\n                            s.pop();\\n                        }\\n                        ans++;\\n                    }\\n                    else{\\n                        while(!s.empty() && s.top()==\\'R\\'){\\n                            ans++;\\n                            s.pop();\\n                        }\\n                    }\\n                    s.push(\\'S\\');\\n                }\\n                else{\\n                    if(directions[i]==\\'L\\'){\\n                        ans++;\\n                    }\\n                    else\\n                        s.push(\\'R\\');\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int n=directions.size(),ans=0,i;\\n        for(i=0;i<n;i++){\\n            if(directions[i]!=\\'L\\')\\n                break;\\n        }\\n        stack<char> s;\\n        for(;i<n;i++){\\n            if(s.empty())\\n                s.push(directions[i]);\\n            else if(s.top()==directions[i])\\n                s.push(directions[i]);\\n            else{\\n                if(s.top()==\\'R\\'){\\n                    if(directions[i]==\\'L\\'){\\n                        while(!s.empty() && s.top()==\\'R\\'){\\n                            ans++;\\n                            s.pop();\\n                        }\\n                        ans++;\\n                    }\\n                    else{\\n                        while(!s.empty() && s.top()==\\'R\\'){\\n                            ans++;\\n                            s.pop();\\n                        }\\n                    }\\n                    s.push(\\'S\\');\\n                }\\n                else{\\n                    if(directions[i]==\\'L\\'){\\n                        ans++;\\n                    }\\n                    else\\n                        s.push(\\'R\\');\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417660,
                "title": "python-actual-stack-solution",
                "content": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        stack, res = [], 0\\n        for c in directions:\\n            if c == \\'S\\':\\n                while len(stack) != 0 and stack[-1] == \\'R\\':\\n                    stack.pop()\\n                    res+=1\\n                stack.append(\\'S\\')\\n            elif c == \\'L\\':\\n                if len(stack) != 0 and stack[-1] == \\'S\\':\\n                    res+=1\\n                elif len(stack) != 0 and stack[-1] == \\'R\\':\\n                    while len(stack) != 0 and stack[-1] == \\'R\\':\\n                        res+=1\\n                        stack.pop()\\n                    res+=1\\n                    stack.append(\\'S\\')\\n            else: stack.append(c)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCollisions(self, directions: str) -> int:\\n        stack, res = [], 0\\n        for c in directions:\\n            if c == \\'S\\':\\n                while len(stack) != 0 and stack[-1] == \\'R\\':\\n                    stack.pop()\\n                    res+=1\\n                stack.append(\\'S\\')\\n            elif c == \\'L\\':\\n                if len(stack) != 0 and stack[-1] == \\'S\\':\\n                    res+=1\\n                elif len(stack) != 0 and stack[-1] == \\'R\\':\\n                    while len(stack) != 0 and stack[-1] == \\'R\\':\\n                        res+=1\\n                        stack.pop()\\n                    res+=1\\n                    stack.append(\\'S\\')\\n            else: stack.append(c)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413368,
                "title": "without-stack-in-o-1-space-and-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int n = s.size();\\n        char prev = \\'a\\';\\n        int countr = 0;\\n        int ans = 0;\\n        for(int i=0 ; i<n ; i++){\\n            if(s[i]==\\'R\\'){\\n                prev = \\'R\\';\\n                countr++;\\n            }else if(s[i]==\\'L\\'){\\n                if(prev==\\'R\\'){\\n                    ans += 2;\\n                    countr--;\\n                    ans += countr;\\n                    prev = \\'S\\';\\n                }else if(prev==\\'S\\'){\\n                    ans += 1;\\n                    prev = \\'S\\';\\n                }\\n                countr = 0;\\n            }else if(s[i]==\\'S\\'){\\n                if(prev==\\'R\\'){\\n                    ans += countr;\\n                }\\n                prev = \\'S\\';\\n                countr = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int n = s.size();\\n        char prev = \\'a\\';\\n        int countr = 0;\\n        int ans = 0;\\n        for(int i=0 ; i<n ; i++){\\n            if(s[i]==\\'R\\'){\\n                prev = \\'R\\';\\n                countr++;\\n            }else if(s[i]==\\'L\\'){\\n                if(prev==\\'R\\'){\\n                    ans += 2;\\n                    countr--;\\n                    ans += countr;\\n                    prev = \\'S\\';\\n                }else if(prev==\\'S\\'){\\n                    ans += 1;\\n                    prev = \\'S\\';\\n                }\\n                countr = 0;\\n            }else if(s[i]==\\'S\\'){\\n                if(prev==\\'R\\'){\\n                    ans += countr;\\n                }\\n                prev = \\'S\\';\\n                countr = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398431,
                "title": "easy-stack-implementation-easy-java-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Easy Stack Implementation**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply create a char Stack push the very first letter of the string \"directions\". From the second letter implement a loop check the current element and do the operatins according to the question.\\n\\n**UPVOTE if you find it helpfull.** \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        \\n        int collision =0;\\n        Stack<Character> stack = new Stack();\\n        stack.push(directions.charAt(0));\\n        for (int i=1;i<directions.length();i++)\\n        {\\n            char curr = directions.charAt(i);\\n\\n            if (stack.peek()==\\'R\\' && curr==\\'L\\')\\n            {\\n                collision+=2;\\n                stack.pop();\\n                curr=\\'S\\';\\n            }\\n            else if (stack.peek()==\\'S\\' && curr==\\'L\\')\\n            {\\n                curr=\\'S\\';\\n                collision+=1;\\n            }\\n\\n            while (!stack.isEmpty() && ((stack.peek()==\\'R\\' && curr==\\'S\\')))\\n            {\\n                collision+=1;\\n                stack.pop();\\n            }\\n\\n            stack.push(curr);\\n        }\\n        return collision;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        \\n        int collision =0;\\n        Stack<Character> stack = new Stack();\\n        stack.push(directions.charAt(0));\\n        for (int i=1;i<directions.length();i++)\\n        {\\n            char curr = directions.charAt(i);\\n\\n            if (stack.peek()==\\'R\\' && curr==\\'L\\')\\n            {\\n                collision+=2;\\n                stack.pop();\\n                curr=\\'S\\';\\n            }\\n            else if (stack.peek()==\\'S\\' && curr==\\'L\\')\\n            {\\n                curr=\\'S\\';\\n                collision+=1;\\n            }\\n\\n            while (!stack.isEmpty() && ((stack.peek()==\\'R\\' && curr==\\'S\\')))\\n            {\\n                collision+=1;\\n                stack.pop();\\n            }\\n\\n            stack.push(curr);\\n        }\\n        return collision;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394833,
                "title": "simple-o-n-solution-string-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string str) {\\n\\n        int ans = 0;\\n        int n = str.size();\\n        string data = \"\";\\n\\n        for(int i = 0;i<n;i++){\\n            if(str[i]==\\'R\\' and (i+1<n and str[i+1]==\\'L\\')){\\n                data+=\\'S\\';\\n                i++;\\n                ans+=2;\\n            }\\n            else{\\n                data+=str[i];\\n            }\\n        }\\n\\n        int flag = 0;\\n        int m = data.size();\\n        for(int i = 0;i<m;i++){\\n            if(data[i]==\\'L\\'){\\n                if(flag) ans++;\\n            }\\n            if(data[i]==\\'S\\'){\\n                flag = 1;\\n            }\\n        }\\n        flag = 0;\\n        for(int i = m-1;i>=0;i--){\\n            if(data[i]==\\'R\\'){\\n                if(flag) ans++;\\n            }\\n            if(data[i]==\\'S\\'){\\n                flag = 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string str) {\\n\\n        int ans = 0;\\n        int n = str.size();\\n        string data = \"\";\\n\\n        for(int i = 0;i<n;i++){\\n            if(str[i]==\\'R\\' and (i+1<n and str[i+1]==\\'L\\')){\\n                data+=\\'S\\';\\n                i++;\\n                ans+=2;\\n            }\\n            else{\\n                data+=str[i];\\n            }\\n        }\\n\\n        int flag = 0;\\n        int m = data.size();\\n        for(int i = 0;i<m;i++){\\n            if(data[i]==\\'L\\'){\\n                if(flag) ans++;\\n            }\\n            if(data[i]==\\'S\\'){\\n                flag = 1;\\n            }\\n        }\\n        flag = 0;\\n        for(int i = m-1;i>=0;i--){\\n            if(data[i]==\\'R\\'){\\n                if(flag) ans++;\\n            }\\n            if(data[i]==\\'S\\'){\\n                flag = 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355779,
                "title": "c-golang-1-pass-sc-o-1",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int n = directions.size(), ans = 0;\\n        char prev = \\'L\\';\\n        for(int i = 0; i < n; i++) {\\n            int rlen = 0;\\n            while(i < n && directions[i] == \\'R\\') {\\n                i++;\\n                rlen++;\\n                prev = directions[i - 1];\\n            }\\n            if(i < n) {\\n                if(directions[i] == \\'S\\') {\\n                    if(prev == \\'R\\') ans += rlen;\\n                    prev = directions[i];\\n                } else {\\n                    if(prev == \\'S\\') ans++;\\n                    if(prev == \\'R\\') {\\n                        ans += rlen + 1;\\n                        prev = \\'S\\';\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countCollisions(directions string) int {\\n    var n, ans int = len(directions), 0\\n    var prev byte = \\'L\\'\\n    for i := 0; i < n; i++ {\\n        rlen := 0\\n        for i < n && directions[i] == \\'R\\' {\\n            i++\\n            rlen++\\n            prev = directions[i - 1]\\n        }\\n        if i < n {\\n            if directions[i] == \\'S\\' {\\n                if prev == \\'R\\' {ans += rlen}\\n                prev = directions[i]\\n            } else {\\n                if prev == \\'S\\' {ans++}\\n                if prev == \\'R\\' {\\n                    ans += rlen + 1\\n                    prev = \\'S\\'\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "String"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int n = directions.size(), ans = 0;\\n        char prev = \\'L\\';\\n        for(int i = 0; i < n; i++) {\\n            int rlen = 0;\\n            while(i < n && directions[i] == \\'R\\') {\\n                i++;\\n                rlen++;\\n                prev = directions[i - 1];\\n            }\\n            if(i < n) {\\n                if(directions[i] == \\'S\\') {\\n                    if(prev == \\'R\\') ans += rlen;\\n                    prev = directions[i];\\n                } else {\\n                    if(prev == \\'S\\') ans++;\\n                    if(prev == \\'R\\') {\\n                        ans += rlen + 1;\\n                        prev = \\'S\\';\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countCollisions(directions string) int {\\n    var n, ans int = len(directions), 0\\n    var prev byte = \\'L\\'\\n    for i := 0; i < n; i++ {\\n        rlen := 0\\n        for i < n && directions[i] == \\'R\\' {\\n            i++\\n            rlen++\\n            prev = directions[i - 1]\\n        }\\n        if i < n {\\n            if directions[i] == \\'S\\' {\\n                if prev == \\'R\\' {ans += rlen}\\n                prev = directions[i]\\n            } else {\\n                if prev == \\'S\\' {ans++}\\n                if prev == \\'R\\' {\\n                    ans += rlen + 1\\n                    prev = \\'S\\'\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352728,
                "title": "c-using-stack",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int i=0,count=0;\\n        stack <char> s;\\n        while(directions[i] == \\'L\\')i++;\\n        for(i;i<directions.size();i++){\\n            if(s.empty() || directions[i]==s.top()){\\n                s.push(directions[i]);\\n            }\\n            else if(directions[i]==\\'L\\' && s.top()==\\'R\\'){\\n                count+=2;\\n                s.pop();\\n                s.push(\\'S\\');\\n            }\\n            else if(directions[i]==\\'S\\' && s.top()==\\'R\\'){\\n                while(!s.empty() && s.top()==\\'R\\'){\\n                    count+=1;\\n                    s.pop();\\n                }\\n                s.push(\\'S\\');\\n            }\\n            else if(directions[i]==\\'L\\' && s.top()==\\'S\\'){\\n                 count+=1;\\n            }\\n            else if(directions[i]==\\'R\\' || directions[i]==\\'S\\'){\\n                s.push(\\'R\\');\\n            }\\n        }\\n        while(!s.empty() && s.top()==\\'R\\')s.pop();\\n        while(!s.empty()){\\n            if(s.top()==\\'R\\'){\\n                count++;\\n            }\\n            s.pop();\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int i=0,count=0;\\n        stack <char> s;\\n        while(directions[i] == \\'L\\')i++;\\n        for(i;i<directions.size();i++){\\n            if(s.empty() || directions[i]==s.top()){\\n                s.push(directions[i]);\\n            }\\n            else if(directions[i]==\\'L\\' && s.top()==\\'R\\'){\\n                count+=2;\\n                s.pop();\\n                s.push(\\'S\\');\\n            }\\n            else if(directions[i]==\\'S\\' && s.top()==\\'R\\'){\\n                while(!s.empty() && s.top()==\\'R\\'){\\n                    count+=1;\\n                    s.pop();\\n                }\\n                s.push(\\'S\\');\\n            }\\n            else if(directions[i]==\\'L\\' && s.top()==\\'S\\'){\\n                 count+=1;\\n            }\\n            else if(directions[i]==\\'R\\' || directions[i]==\\'S\\'){\\n                s.push(\\'R\\');\\n            }\\n        }\\n        while(!s.empty() && s.top()==\\'R\\')s.pop();\\n        while(!s.empty()){\\n            if(s.top()==\\'R\\'){\\n                count++;\\n            }\\n            s.pop();\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348818,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} directions\\n * @return {number}\\n */\\nvar countCollisions = function(directions) {\\n\\n    let count =0;\\n    let stack = [];\\n\\n    for(let i=0;i<directions.length;i++){\\n        let stackSize = stack.length;\\n        let current = directions.charAt(i);\\n\\n        if(stackSize != 0 && stack[stackSize-1] == \\'R\\' && current==\\'L\\' ){\\n           stack.pop();\\n           count+=2;\\n           current = \\'S\\';\\n           stackSize = stack.length;\\n        }\\n        else if(stackSize != 0 && stack[stackSize-1] == \\'S\\' && current == \\'L\\'){\\n           count+=1;\\n           current = \\'S\\';\\n        }\\n        while(stackSize != 0 && stack[stackSize-1] == \\'R\\' && current == \\'S\\'){\\n           count+=1;\\n           stack.pop();\\n           stackSize = stack.length;\\n        }\\n        stack.push(current);\\n   }\\n   //TC: O(n)\\n   //SC: O(n)\\n   return count;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} directions\\n * @return {number}\\n */\\nvar countCollisions = function(directions) {\\n\\n    let count =0;\\n    let stack = [];\\n\\n    for(let i=0;i<directions.length;i++){\\n        let stackSize = stack.length;\\n        let current = directions.charAt(i);\\n\\n        if(stackSize != 0 && stack[stackSize-1] == \\'R\\' && current==\\'L\\' ){\\n           stack.pop();\\n           count+=2;\\n           current = \\'S\\';\\n           stackSize = stack.length;\\n        }\\n        else if(stackSize != 0 && stack[stackSize-1] == \\'S\\' && current == \\'L\\'){\\n           count+=1;\\n           current = \\'S\\';\\n        }\\n        while(stackSize != 0 && stack[stackSize-1] == \\'R\\' && current == \\'S\\'){\\n           count+=1;\\n           stack.pop();\\n           stackSize = stack.length;\\n        }\\n        stack.push(current);\\n   }\\n   //TC: O(n)\\n   //SC: O(n)\\n   return count;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3331664,
                "title": "easy-c-solutio-using-stack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string str) {\\n        int n = str.size(), numCollisions = 0;\\n    stack<char> lastCarStatus;\\n    for (int i = 0; i < n; ++i)\\n    {\\n        if (str[i] == \\'L\\')\\n        {\\n            if (!lastCarStatus.empty() && lastCarStatus.top() == \\'R\\')\\n            {\\n                lastCarStatus.pop();\\n                lastCarStatus.push(\\'S\\');\\n                numCollisions += 2;\\n            }\\n            else if (!lastCarStatus.empty() && lastCarStatus.top() == \\'S\\')\\n            {\\n                numCollisions += 1;\\n            }\\n            else\\n            {\\n                lastCarStatus.push(\\'L\\');\\n            }\\n        }\\n        else if (str[i] == \\'R\\')\\n        {\\n            lastCarStatus.push(\\'R\\');\\n        }\\n        else\\n        {\\n            if (!lastCarStatus.empty() && lastCarStatus.top() == \\'R\\')\\n            {\\n                lastCarStatus.pop();\\n                lastCarStatus.push(\\'S\\');\\n                numCollisions += 1;\\n            }\\n            else\\n                lastCarStatus.push(\\'S\\');\\n        }\\n    }\\n    int cnt = 0;\\n    while (!lastCarStatus.empty())\\n    {\\n        char dir = lastCarStatus.top();\\n        lastCarStatus.pop();\\n        if (dir == \\'S\\')\\n            cnt = 1;\\n        else if (dir == \\'R\\')\\n        {\\n            numCollisions += cnt;\\n        }\\n    }\\n    return numCollisions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string str) {\\n        int n = str.size(), numCollisions = 0;\\n    stack<char> lastCarStatus;\\n    for (int i = 0; i < n; ++i)\\n    {\\n        if (str[i] == \\'L\\')\\n        {\\n            if (!lastCarStatus.empty() && lastCarStatus.top() == \\'R\\')\\n            {\\n                lastCarStatus.pop();\\n                lastCarStatus.push(\\'S\\');\\n                numCollisions += 2;\\n            }\\n            else if (!lastCarStatus.empty() && lastCarStatus.top() == \\'S\\')\\n            {\\n                numCollisions += 1;\\n            }\\n            else\\n            {\\n                lastCarStatus.push(\\'L\\');\\n            }\\n        }\\n        else if (str[i] == \\'R\\')\\n        {\\n            lastCarStatus.push(\\'R\\');\\n        }\\n        else\\n        {\\n            if (!lastCarStatus.empty() && lastCarStatus.top() == \\'R\\')\\n            {\\n                lastCarStatus.pop();\\n                lastCarStatus.push(\\'S\\');\\n                numCollisions += 1;\\n            }\\n            else\\n                lastCarStatus.push(\\'S\\');\\n        }\\n    }\\n    int cnt = 0;\\n    while (!lastCarStatus.empty())\\n    {\\n        char dir = lastCarStatus.top();\\n        lastCarStatus.pop();\\n        if (dir == \\'S\\')\\n            cnt = 1;\\n        else if (dir == \\'R\\')\\n        {\\n            numCollisions += cnt;\\n        }\\n    }\\n    return numCollisions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319918,
                "title": "c-stack-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        stack<char> st;\\n        st.push(dir[0]);\\n        int cnt=0;\\n        for(int i=1;i<dir.size();i++)\\n        {\\n            if(st.top()==\\'R\\' && dir[i]==\\'L\\')\\n            {\\n                cnt+=2;\\n                st.pop();\\n                while(!st.empty() && st.top()==\\'R\\')\\n                {\\n                    cnt++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n            else if(st.top()==\\'R\\' && dir[i]==\\'S\\')\\n            {\\n                while(!st.empty() && st.top()==\\'R\\')\\n                {\\n                    cnt++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n            else if(st.top()==\\'S\\' && dir[i]==\\'L\\')\\n            {\\n                cnt++;\\n            }\\n            else \\n            st.push(dir[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string dir) {\\n        stack<char> st;\\n        st.push(dir[0]);\\n        int cnt=0;\\n        for(int i=1;i<dir.size();i++)\\n        {\\n            if(st.top()==\\'R\\' && dir[i]==\\'L\\')\\n            {\\n                cnt+=2;\\n                st.pop();\\n                while(!st.empty() && st.top()==\\'R\\')\\n                {\\n                    cnt++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n            else if(st.top()==\\'R\\' && dir[i]==\\'S\\')\\n            {\\n                while(!st.empty() && st.top()==\\'R\\')\\n                {\\n                    cnt++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n            else if(st.top()==\\'S\\' && dir[i]==\\'L\\')\\n            {\\n                cnt++;\\n            }\\n            else \\n            st.push(dir[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318888,
                "title": "count-collisions-on-a-road-c-explained-solution",
                "content": "**Do Upvote If Found Helpful !!!**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given below approach to problem is quite easy to understand. Its simple to observe some cases and to come up with below algorithm. Remember that this algorithm works from end of string to front of string.\\n**Case 1 : dir[i] = \\'L\\'** , just keep on counting number of lefts and make **curr = \\'.\\'**\\n**Case 2 : dir[i] = \\'R\\'**, if curr is \\'S\\', then this car will collide with stationary car, hence update ans by 1. If curr is \\'.\\', then check if there are any cars coming to left direction from right of current car. In such case, the first colliding car will from left will become stationary and rest collisions will take place with this stationary car. In such case update ans by 2 + left - 1 = **left + 1** and curr = **\\'S\\'** as a stoppage is created.\\n**Case 3 : dir[i] = \\'S\\'**, just add number of cars coming to left from right and update curr to **\\'S\\'**.\\nRest no case cover any type of collisions, hence no use to consider them. The implementation goes below :\\n\\n# Complexity\\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        ios_base::sync_with_stdio(0);\\n        int n = directions.size(),ans = 0,left = 0; char curr = \\'.\\';\\n        for(int i = n-1; i >= 0; i--){\\n            if(directions[i] == \\'L\\'){\\n                curr = \\'.\\';\\n                left++;\\n            }\\n            else if(directions[i] == \\'R\\'){\\n                if(curr == \\'S\\'){\\n                    ans++;\\n                }\\n                if(left){\\n                    ans += left + 1;\\n                    curr = \\'S\\';\\n                    left = 0;\\n                }\\n            }\\n            else if(directions[i] == \\'S\\'){\\n                ans += left;\\n                left = 0;\\n                curr = \\'S\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        ios_base::sync_with_stdio(0);\\n        int n = directions.size(),ans = 0,left = 0; char curr = \\'.\\';\\n        for(int i = n-1; i >= 0; i--){\\n            if(directions[i] == \\'L\\'){\\n                curr = \\'.\\';\\n                left++;\\n            }\\n            else if(directions[i] == \\'R\\'){\\n                if(curr == \\'S\\'){\\n                    ans++;\\n                }\\n                if(left){\\n                    ans += left + 1;\\n                    curr = \\'S\\';\\n                    left = 0;\\n                }\\n            }\\n            else if(directions[i] == \\'S\\'){\\n                ans += left;\\n                left = 0;\\n                curr = \\'S\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318486,
                "title": "o-1-space-easy-c-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int score=0;\\n        int i=0;\\n        while(directions[i]==\\'L\\') i++;\\n        int cntr=0;\\n        for(i;i<directions.size();i++){\\n            if(directions[i]==\\'R\\') cntr++;\\n            else if(directions[i]==\\'S\\') {\\n                score += cntr;\\n                cntr=0;\\n            }\\n            else{\\n                score += cntr+1;\\n                cntr=0;\\n            }\\n        }        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        int score=0;\\n        int i=0;\\n        while(directions[i]==\\'L\\') i++;\\n        int cntr=0;\\n        for(i;i<directions.size();i++){\\n            if(directions[i]==\\'R\\') cntr++;\\n            else if(directions[i]==\\'S\\') {\\n                score += cntr;\\n                cntr=0;\\n            }\\n            else{\\n                score += cntr+1;\\n                cntr=0;\\n            }\\n        }        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302526,
                "title": "very-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        int n=d.size();\\n        int carright=0;\\n        int ans=0;\\n        int i=0;\\n        while(i<n && d[i]==\\'L\\')i++;\\n        for(;i<n;i++){\\n            if(d[i]==\\'R\\')carright++;\\n            else{\\n                if(d[i]==\\'S\\'){\\n                    ans+=carright;\\n                }\\n                else{\\n                    ans+=carright+1;\\n                }\\n                carright=0;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        int n=d.size();\\n        int carright=0;\\n        int ans=0;\\n        int i=0;\\n        while(i<n && d[i]==\\'L\\')i++;\\n        for(;i<n;i++){\\n            if(d[i]==\\'R\\')carright++;\\n            else{\\n                if(d[i]==\\'S\\'){\\n                    ans+=carright;\\n                }\\n                else{\\n                    ans+=carright+1;\\n                }\\n                carright=0;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297557,
                "title": "stack-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int collisions=0;\\n        Stack<Character> st = new Stack<>();\\n        int n = directions.length();\\n        st.push(directions.charAt(0));\\n        for(int i=1;i<n;i++){\\n           if(st.peek()==\\'R\\' && directions.charAt(i)==\\'L\\'){\\n               st.pop();\\n               collisions += 2;\\n                while(st.size()>0 && st.peek()==\\'R\\'){\\n                 collisions += 1;\\n                 st.pop();\\n               }\\n               st.push(\\'S\\');\\n           }\\n           else if(st.peek()==\\'R\\' && directions.charAt(i)==\\'R\\'){\\n               st.push(\\'R\\');\\n           }\\n           else if(st.peek()==\\'R\\' && directions.charAt(i)==\\'S\\'){\\n               while(st.size()>0 && st.peek()==\\'R\\'){\\n                 collisions += 1;\\n                 st.pop();\\n               }\\n               st.push(\\'S\\');\\n           }\\n           else if(st.peek()==\\'L\\'){\\n               st.push(directions.charAt(i));\\n           }\\n           else if(st.peek()==\\'S\\' && directions.charAt(i)==\\'L\\'){\\n               collisions += 1;\\n           }\\n           else if(st.peek()==\\'S\\' && directions.charAt(i)==\\'R\\'){\\n               st.push(\\'R\\');\\n           }\\n        }\\n        return collisions;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int countCollisions(String directions) {\\n        int collisions=0;\\n        Stack<Character> st = new Stack<>();\\n        int n = directions.length();\\n        st.push(directions.charAt(0));\\n        for(int i=1;i<n;i++){\\n           if(st.peek()==\\'R\\' && directions.charAt(i)==\\'L\\'){\\n               st.pop();\\n               collisions += 2;\\n                while(st.size()>0 && st.peek()==\\'R\\'){\\n                 collisions += 1;\\n                 st.pop();\\n               }\\n               st.push(\\'S\\');\\n           }\\n           else if(st.peek()==\\'R\\' && directions.charAt(i)==\\'R\\'){\\n               st.push(\\'R\\');\\n           }\\n           else if(st.peek()==\\'R\\' && directions.charAt(i)==\\'S\\'){\\n               while(st.size()>0 && st.peek()==\\'R\\'){\\n                 collisions += 1;\\n                 st.pop();\\n               }\\n               st.push(\\'S\\');\\n           }\\n           else if(st.peek()==\\'L\\'){\\n               st.push(directions.charAt(i));\\n           }\\n           else if(st.peek()==\\'S\\' && directions.charAt(i)==\\'L\\'){\\n               collisions += 1;\\n           }\\n           else if(st.peek()==\\'S\\' && directions.charAt(i)==\\'R\\'){\\n               st.push(\\'R\\');\\n           }\\n        }\\n        return collisions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296324,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int countCollisions(string dir) \\n    {\\n        int r=0;\\n        int cs=0;\\n        bool s=false;\\n        for(int i=0;i<dir.length();++i)\\n        {\\n           if(dir[i]==\\'L\\') \\n           {\\n            if(cs==0 && r==0 && s==false)\\n            {\\n                continue;\\n            }\\n            else\\n            {    s=true;\\n                cs=cs+r+1;\\n                r=0;\\n            }\\n           }\\n           else if(dir[i]==\\'S\\')\\n           {\\n               s=true;\\n               cs+=r;\\n               r=0;\\n           }\\n           else\\n           {\\n               r++;\\n           }\\n        }\\n        return cs;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countCollisions(string dir) \\n    {\\n        int r=0;\\n        int cs=0;\\n        bool s=false;\\n        for(int i=0;i<dir.length();++i)\\n        {\\n           if(dir[i]==\\'L\\') \\n           {\\n            if(cs==0 && r==0 && s==false)\\n            {\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3284638,
                "title": "cpp-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\ncars on left side which are moving in left direction are never going to collide,\\nSimilarly, cars on right side which are moving right side are never going to collide.\\n\\nIn between them every car is going to collide.\\n*/\\n\\nclass Solution {\\n    public :\\n    int countCollisions(string directions) {\\n        int left = 0, right = directions.size() - 1;\\n        while (left < directions.size() && directions[left] == \\'L\\') {left++; }\\n        while (right >= 0 && directions[right] == \\'R\\') {  right--; }\\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (directions[i]!= \\'S\\') {\\n                count++;\\n            }\\n        }\\n\\t\\t//combining these three loops - TC : O(N).\\n        \\n        return count;\\n    }\\n};\\n\\n\\n/*I WAS NOT ABLE TO DO THIS ON BY ONE AND DONE THIS WITH THE HELP OF THE SOLUTON AND THUS GOT UNDERSTOOD CLEARLY*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\ncars on left side which are moving in left direction are never going to collide,\\nSimilarly, cars on right side which are moving right side are never going to collide.\\n\\nIn between them every car is going to collide.\\n*/\\n\\nclass Solution {\\n    public :\\n    int countCollisions(string directions) {\\n        int left = 0, right = directions.size() - 1;\\n        while (left < directions.size() && directions[left] == \\'L\\') {left++; }\\n        while (right >= 0 && directions[right] == \\'R\\') {  right--; }\\n        int count = 0;\\n        for (int i = left; i <= right; i++) {\\n            if (directions[i]!= \\'S\\') {\\n                count++;\\n            }\\n        }\\n\\t\\t//combining these three loops - TC : O(N).\\n        \\n        return count;\\n    }\\n};\\n\\n\\n/*I WAS NOT ABLE TO DO THIS ON BY ONE AND DONE THIS WITH THE HELP OF THE SOLUTON AND THUS GOT UNDERSTOOD CLEARLY*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283450,
                "title": "beats-100-run-time-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the direction of the car `i`, check if previous cars coming towards right is going to cause a collision. Else, check if this car is going to cause any collision\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain two variables - car coming From Right and Obstacle on Left. Loop through all the directions and update these variables and count collisions\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountCollisions(string directions) {\\n        var carComingRight = 0;\\n        var leftObstacle = 0;\\n        var collisions = 0;\\n        foreach(char ch in directions){\\n            if(ch == \\'R\\'){\\n                carComingRight++;\\n            } else if (ch == \\'S\\'){\\n                if(carComingRight > 0){\\n                    collisions += carComingRight;\\n                    carComingRight = 0;\\n                }\\n                leftObstacle++;\\n            } else {\\n                if(carComingRight > 0){\\n                    \\n                    collisions+=2;\\n                    carComingRight--;\\n                    collisions+=carComingRight;\\n                    carComingRight = 0;\\n                    leftObstacle++;\\n                }\\n                else if(leftObstacle > 0){\\n                    collisions++;\\n                }\\n                \\n            }\\n        }\\n        return collisions;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountCollisions(string directions) {\\n        var carComingRight = 0;\\n        var leftObstacle = 0;\\n        var collisions = 0;\\n        foreach(char ch in directions){\\n            if(ch == \\'R\\'){\\n                carComingRight++;\\n            } else if (ch == \\'S\\'){\\n                if(carComingRight > 0){\\n                    collisions += carComingRight;\\n                    carComingRight = 0;\\n                }\\n                leftObstacle++;\\n            } else {\\n                if(carComingRight > 0){\\n                    \\n                    collisions+=2;\\n                    carComingRight--;\\n                    collisions+=carComingRight;\\n                    carComingRight = 0;\\n                    leftObstacle++;\\n                }\\n                else if(leftObstacle > 0){\\n                    collisions++;\\n                }\\n                \\n            }\\n        }\\n        return collisions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281848,
                "title": "easy-to-understand-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int n=s.size();\\n        stack<char>st;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(s[i]==\\'L\\'){\\n                if(st.top()==\\'S\\'){\\n                    cnt++;\\n                }\\n                if(st.top()==\\'R\\'){\\n                    cnt+=2;\\n                    st.pop();\\n                    st.push(\\'S\\');\\n                }\\n            }\\n            else if(s[i]==\\'R\\'){\\n                st.push(\\'R\\');\\n            }\\n            else{\\n                st.push(\\'S\\');\\n            }\\n        }\\n        int h=0;\\n        while(st.size()){\\n            char a=st.top();\\n            st.pop();\\n            if(a==\\'R\\' and h>0)cnt++;\\n            if(a==\\'S\\')h++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string s) {\\n        int n=s.size();\\n        stack<char>st;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            if(s[i]==\\'L\\'){\\n                if(st.top()==\\'S\\'){\\n                    cnt++;\\n                }\\n                if(st.top()==\\'R\\'){\\n                    cnt+=2;\\n                    st.pop();\\n                    st.push(\\'S\\');\\n                }\\n            }\\n            else if(s[i]==\\'R\\'){\\n                st.push(\\'R\\');\\n            }\\n            else{\\n                st.push(\\'S\\');\\n            }\\n        }\\n        int h=0;\\n        while(st.size()){\\n            char a=st.top();\\n            st.pop();\\n            if(a==\\'R\\' and h>0)cnt++;\\n            if(a==\\'S\\')h++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276136,
                "title": "127-ms",
                "content": "```ruby\\ndef count_collisions s\\n    s = s.bytes\\n    s.shift while s.first == 76\\n    s.pop while s.last == 82\\n    s.size - s.count(83)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef count_collisions s\\n    s = s.bytes\\n    s.shift while s.first == 76\\n    s.pop while s.last == 82\\n    s.size - s.count(83)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3275623,
                "title": "kotlin-simple-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun countCollisions(dir: String): Int {\\n        var i = 0\\n        var j = dir.length - 1\\n\\n        while (i < dir.length && dir[i] == \\'L\\') i++\\n        while (j >= 0 && dir[j] == \\'R\\') j--\\n\\n        var result = 0\\n        for (k in i..j) {\\n            if (dir[k] != \\'S\\') result++\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countCollisions(dir: String): Int {\\n        var i = 0\\n        var j = dir.length - 1\\n\\n        while (i < dir.length && dir[i] == \\'L\\') i++\\n        while (j >= 0 && dir[j] == \\'R\\') j--\\n\\n        var result = 0\\n        for (k in i..j) {\\n            if (dir[k] != \\'S\\') result++\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253471,
                "title": "explanation-approach-complexity-analysis-code",
                "content": "\\n# Approach\\nWe can clearly see that, there will be a collision in following cases :\\n### [R-> <-L], [R-> S], [S<- L]\\n\\nWe simply iterate over the string, incrementing counter by 2 when we encounter R->L case and make those cars stationary. When we encounter the R->S and S<-L case, we increment the counter by 1 and make the moving cars stationary.\\n\\n## Extra Case to be Considered :\\nConsider the Test Case \\nR R R L R \\nIn this case, after above explanation, string becomes,\\nR R R S S\\nNote that collisions are still possible !\\nConsider Another Test Case\\nR R L\\nAfter our implementation,\\nR S S\\nCollision is still possible !\\nHence the missing condition to check is that after above implementation, we traverse the array again from right to left and check if there are any further collisions possible.\\nWhy do we check from right to left ?\\nConsider the case :\\nR R R R S\\nWe can have the correct count of collisions, only if the rightmost collision is resolved first.\\nHence, we traverse from right to left.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity Analysis \\n# Time Complexity : O(2N)\\nWe traverse the string twice, once from left to right and once from right to left.\\nN is the length of given string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space Complexity : O(1)\\nWe haven\\'t used any extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions)\\n    {\\n        // Moving from Left to Right\\n        // Detect RL collisions\\n\\n        long long int counter = 0;\\n\\n        for(int i=0; i<directions.size(); i++)\\n        {\\n            if(i+1 < directions.size() && directions[i]==\\'R\\' && directions[i+1]==\\'L\\')\\n            {\\n                counter+=2;\\n                directions[i] = \\'S\\';\\n                directions[i+1] = \\'S\\';\\n            }\\n            if(i+1< directions.size() && directions[i]==\\'R\\' && directions[i+1]==\\'S\\')\\n            {\\n                counter+=1;\\n                directions[i]= \\'S\\';\\n            }\\n            if(i+1 < directions.size() && directions[i]==\\'S\\' && directions[i+1]==\\'L\\')\\n            {\\n                counter+=1;\\n                directions[i+1] = \\'S\\';\\n            }\\n        }    \\n\\n        for(int i=directions.size()-1; i>0; i--)\\n        {\\n            if(directions[i]==\\'S\\' && directions[i-1]==\\'R\\')\\n            {\\n                counter+=1;\\n                directions[i-1]=\\'S\\';\\n            }\\n\\n        }\\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions)\\n    {\\n        // Moving from Left to Right\\n        // Detect RL collisions\\n\\n        long long int counter = 0;\\n\\n        for(int i=0; i<directions.size(); i++)\\n        {\\n            if(i+1 < directions.size() && directions[i]==\\'R\\' && directions[i+1]==\\'L\\')\\n            {\\n                counter+=2;\\n                directions[i] = \\'S\\';\\n                directions[i+1] = \\'S\\';\\n            }\\n            if(i+1< directions.size() && directions[i]==\\'R\\' && directions[i+1]==\\'S\\')\\n            {\\n                counter+=1;\\n                directions[i]= \\'S\\';\\n            }\\n            if(i+1 < directions.size() && directions[i]==\\'S\\' && directions[i+1]==\\'L\\')\\n            {\\n                counter+=1;\\n                directions[i+1] = \\'S\\';\\n            }\\n        }    \\n\\n        for(int i=directions.size()-1; i>0; i--)\\n        {\\n            if(directions[i]==\\'S\\' && directions[i-1]==\\'R\\')\\n            {\\n                counter+=1;\\n                directions[i-1]=\\'S\\';\\n            }\\n\\n        }\\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234635,
                "title": "count-collisions-on-a-road",
                "content": "# Intuition\\ncars on the left end moving to the left side wont ever contribute to the answer since they are not gonna\\n    collide with anyone, the same way, cars on the right end and moving to the right side wont ever contribute \\n    to the answer.\\n    Keep note that all the cars in between will contribute to the answer\\n    any pattern forming an RL pair will contribute to 2 points whereas an RS or SR or LS or SL will contribute\\n    1 point.\\n    Hence the answer will be 2*rlPairs+(n-2*rlPairs-sNum)\\n    here n is basically the new size after ignoring the left ends\\' left cars and vice versa for right.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*int countCollisions(string d) {\\n    int l = d.find_first_not_of(\"L\"), r = d.find_last_not_of(\"R\");\\n    return l == string::npos || r == string::npos ? 0 : \\n        count_if(begin(d) + l, begin(d) + r + 1, [](char ch){ return ch != \\'S\\';});\\n}*/\\n    int countCollisions(string directions) {\\n        int right = 0, res = 0, obstacle = false;\\n    for (char d : directions)\\n        if (d == \\'R\\')\\n            ++right;\\n        else if (d == \\'S\\') {\\n            res += right;\\n            right = 0;\\n            obstacle = true;\\n        }\\n        else {\\n            if (right > 0) {\\n                res += right + 1;\\n                right = 0;\\n                obstacle = true;\\n            }\\n            else if (obstacle)\\n                ++res;\\n        }\\n    return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*int countCollisions(string d) {\\n    int l = d.find_first_not_of(\"L\"), r = d.find_last_not_of(\"R\");\\n    return l == string::npos || r == string::npos ? 0 : \\n        count_if(begin(d) + l, begin(d) + r + 1, [](char ch){ return ch != \\'S\\';});\\n}*/\\n    int countCollisions(string directions) {\\n        int right = 0, res = 0, obstacle = false;\\n    for (char d : directions)\\n        if (d == \\'R\\')\\n            ++right;\\n        else if (d == \\'S\\') {\\n            res += right;\\n            right = 0;\\n            obstacle = true;\\n        }\\n        else {\\n            if (right > 0) {\\n                res += right + 1;\\n                right = 0;\\n                obstacle = true;\\n            }\\n            else if (obstacle)\\n                ++res;\\n        }\\n    return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229101,
                "title": "python-from-o-n-space-to-o-1-space",
                "content": "# **1. USING A STACK - O(N) TIME & O(N) SPACE**\\n\\nThe code below is well commented but still, here is what we are doing - \\n\\n\\t1. If a car is stationary and there are cars before it that are moving towards right, all will collide with it\\n\\t2. If a car is moving towards left and previous car is moving towards right, both will collide\\n\\t\\t2.1. And after collision both become stationary. Which again means the same as first point. \\n\\t\\t\\t That is, if there are cars before these two and they are moving towards right, all of them will collide\\n\\t3. If a car is moving towards left and previous car is stationary, both will collide.\\n\\nSo we see that points 1 and 2 are the same and the only thing that\\'s different is the initial directions of the two cars and the count by which we have to increment our number of collisions.\\n\\n\\n```\\ndef countCollisions(self, directions: str) -> int:\\n        \\n        # Count of collisions\\n        count = 0\\n        \\n        # Stack to keep track of previous car\\'s direction\\n        stack = []\\n        \\n        # Loop starts\\n        for direction in directions:\\n            # If stack is not empty\\n            if stack:\\n                \\n                # What are the conditions for a collision?\\n                \\n                # 1. Current car is stationary and previous car is coming towards it\\n                condition1 = stack[-1] == \"R\" and direction == \"S\"\\n                \\n                # 2. Current car is going towards left and previous car is going towards right\\n                condition2 = stack[-1] == \"R\" and direction == \"L\"\\n                \\n                # 3. Current car is going towards left and previous car is stationary\\n                condition3 = stack[-1] == \"S\" and direction == \"L\"\\n                \\n                # If any of the three conditions are true, there will be a collision\\n                if condition1 or condition2 or condition3:\\n                \\n                    # Let\\'s take conditions 1 and 2\\n                    # That is, either current car is stationary and previous car is going towards right\\n                    # Or, current car is going towards left and previous car towards right\\n                    # In both cases there will be a collision\\n                    if condition1 or condition2:\\n                        \\n                        # Increment the count accordingly\\n                        count += 1 if condition1 else 2\\n                        \\n                        # Remove the previous car since it has already collided with current car\\n                        stack.pop()\\n\\n                        # Also, if there are more cars coming towards right before previous car, they all will collide\\n                        # And that will further contribute to the number of collisions\\n                        while stack and stack[-1] == \"R\": \\n                            count += 1\\n                            stack.pop()\\n\\n                        # Finally, after we are sure that there won\\'t be any more collisions from previous cars\\n                        # We can push \"S\" to the stack\\n                        stack.append(\"S\")\\n                \\n                    # Let\\'s take condition3 -> Current car is going towards left and previous car is stationary\\n                    # There will be a collision between the two and number of collisions increase by 1\\n                    else: count += 1\\n\\n                    \\n                # If collision does not happen with the previous car, push the current car\\'s direction to stack\\n                else: stack.append(direction)\\n                    \\n            # If stack is empty\\n            else: stack.append(direction)\\n                    \\n        # Finally, return the number of collisions\\n        return count\\n```\\n\\n# **2. WITHOUT STACK - O(N) TIME & O(1) SPACE**\\n\\nFrom the stack approach, what did we understand?\\n\\n\\tIf a Car is stationary, all the cars moving towards it previously will collide\\n\\tIf a car is moving towards left, all the cars moving towards right will collide with it\\n\\tIf a car is moving towards left and previous car is stationary, there will be only one collision\\n\\t\\nSo, do we even need a stack for this? We can easily keep track of how many cars are moving towards right at any time using a simple counter variable.\\n\\nAnd similarly, we can use a variable to keep track of what was the previous car\\'s direction.\\n\\nAnd that\\'s the idea of the O(1) space approach.\\n\\nDO note that when current car is moving towards left and previous car is moving towards right, the total number of collisions will be - \\n\\t\\t\\n\\t\\t\\tCount of cars moving towards right + 1\\n\\t\\t\\t\\nExample: If we have \"RRRL\"\\n\\nThen, when the last car collides, count will be incremented by \"2\" and now cars will become stationary.\\n\\nIn other words, the string will now be \"RRSS\"\\n\\nThis means, the previous cars that were moving towards right will now increment the count of collisions by only 1, not by 2. \\n\\nSo for this case, total number of collisions -> 2 + 1 + 1 => 4 => (Count of Cars moving towards right + 1)\\n\\t\\n\\n```\\ndef countCollisions(self, directions: str) -> int:\\n        \\n        # Count of collisions\\n        count = 0\\n        \\n        # From stack approach, we understood that, \\n        \\n        # if a car is stationary, all the cars moving towards right before it will collide with it\\n        # if a car is moving towards left, all the cars moving towards right before it will collide with it\\n        \\n        # Counter to keep track of cars moving towards rigt\\n        carsMovingTowardsRight = 0\\n        \\n        # Variable to keep track of the previous car\\'s direction\\n        previousDirection = \"\"\\n        \\n        # Go through each car\\'s direction\\n        for direction in directions:\\n            \\n            # If current car is moving towards right\\n            if direction == \"R\": \\n                \\n                # Increment the count\\n                carsMovingTowardsRight += 1\\n                \\n                # Also update the previous car\\'s direction as \"R\"\\n                previousDirection = \"R\"\\n            \\n            # If current car is stationary\\n            elif direction == \"S\":\\n                # All the cars coming towards it will collide with it\\n                count += carsMovingTowardsRight\\n                \\n                # Also update the previous car\\'s direction as \"R\"\\n                # Since after collision, all cars will be stationary\\n                previousDirection = \"S\"\\n                \\n                # Reset the count for cars moving towards right\\n                carsMovingTowardsRight = 0\\n                \\n            # If current car is moving towards left\\n            else:\\n                # If the previous car was stationary\\n                # There will be only one collision\\n                if previousDirection == \"S\": \\n                    count += 1\\n                    \\n                # If the previous car was moving towards Right\\n                # All cars moving towards right before it will also collide\\n                elif previousDirection == \"R\": \\n                    \\n                    count += carsMovingTowardsRight + 1\\n                    \\n                    # Also update the previous car\\'s direction as \"R\"\\n                    # Since after collision, all cars will be stationary\\n                    previousDirection = \"S\"\\n                    \\n                    # Reset the count for cars moving towards right\\n                    carsMovingTowardsRight = 0\\n                    \\n                # If previous car was also moving towards left, there will be no collision\\n                # So we can simply update the previous car\\'s direction and nothing else needs to be done\\n                else: previousDirection == \"L\"\\n                    \\n        # Finally, return the number of collisions\\n        return count\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef countCollisions(self, directions: str) -> int:\\n        \\n        # Count of collisions\\n        count = 0\\n        \\n        # Stack to keep track of previous car\\'s direction\\n        stack = []\\n        \\n        # Loop starts\\n        for direction in directions:\\n            # If stack is not empty\\n            if stack:\\n                \\n                # What are the conditions for a collision?\\n                \\n                # 1. Current car is stationary and previous car is coming towards it\\n                condition1 = stack[-1] == \"R\" and direction == \"S\"\\n                \\n                # 2. Current car is going towards left and previous car is going towards right\\n                condition2 = stack[-1] == \"R\" and direction == \"L\"\\n                \\n                # 3. Current car is going towards left and previous car is stationary\\n                condition3 = stack[-1] == \"S\" and direction == \"L\"\\n                \\n                # If any of the three conditions are true, there will be a collision\\n                if condition1 or condition2 or condition3:\\n                \\n                    # Let\\'s take conditions 1 and 2\\n                    # That is, either current car is stationary and previous car is going towards right\\n                    # Or, current car is going towards left and previous car towards right\\n                    # In both cases there will be a collision\\n                    if condition1 or condition2:\\n                        \\n                        # Increment the count accordingly\\n                        count += 1 if condition1 else 2\\n                        \\n                        # Remove the previous car since it has already collided with current car\\n                        stack.pop()\\n\\n                        # Also, if there are more cars coming towards right before previous car, they all will collide\\n                        # And that will further contribute to the number of collisions\\n                        while stack and stack[-1] == \"R\": \\n                            count += 1\\n                            stack.pop()\\n\\n                        # Finally, after we are sure that there won\\'t be any more collisions from previous cars\\n                        # We can push \"S\" to the stack\\n                        stack.append(\"S\")\\n                \\n                    # Let\\'s take condition3 -> Current car is going towards left and previous car is stationary\\n                    # There will be a collision between the two and number of collisions increase by 1\\n                    else: count += 1\\n\\n                    \\n                # If collision does not happen with the previous car, push the current car\\'s direction to stack\\n                else: stack.append(direction)\\n                    \\n            # If stack is empty\\n            else: stack.append(direction)\\n                    \\n        # Finally, return the number of collisions\\n        return count\\n```\n```\\ndef countCollisions(self, directions: str) -> int:\\n        \\n        # Count of collisions\\n        count = 0\\n        \\n        # From stack approach, we understood that, \\n        \\n        # if a car is stationary, all the cars moving towards right before it will collide with it\\n        # if a car is moving towards left, all the cars moving towards right before it will collide with it\\n        \\n        # Counter to keep track of cars moving towards rigt\\n        carsMovingTowardsRight = 0\\n        \\n        # Variable to keep track of the previous car\\'s direction\\n        previousDirection = \"\"\\n        \\n        # Go through each car\\'s direction\\n        for direction in directions:\\n            \\n            # If current car is moving towards right\\n            if direction == \"R\": \\n                \\n                # Increment the count\\n                carsMovingTowardsRight += 1\\n                \\n                # Also update the previous car\\'s direction as \"R\"\\n                previousDirection = \"R\"\\n            \\n            # If current car is stationary\\n            elif direction == \"S\":\\n                # All the cars coming towards it will collide with it\\n                count += carsMovingTowardsRight\\n                \\n                # Also update the previous car\\'s direction as \"R\"\\n                # Since after collision, all cars will be stationary\\n                previousDirection = \"S\"\\n                \\n                # Reset the count for cars moving towards right\\n                carsMovingTowardsRight = 0\\n                \\n            # If current car is moving towards left\\n            else:\\n                # If the previous car was stationary\\n                # There will be only one collision\\n                if previousDirection == \"S\": \\n                    count += 1\\n                    \\n                # If the previous car was moving towards Right\\n                # All cars moving towards right before it will also collide\\n                elif previousDirection == \"R\": \\n                    \\n                    count += carsMovingTowardsRight + 1\\n                    \\n                    # Also update the previous car\\'s direction as \"R\"\\n                    # Since after collision, all cars will be stationary\\n                    previousDirection = \"S\"\\n                    \\n                    # Reset the count for cars moving towards right\\n                    carsMovingTowardsRight = 0\\n                    \\n                # If previous car was also moving towards left, there will be no collision\\n                # So we can simply update the previous car\\'s direction and nothing else needs to be done\\n                else: previousDirection == \"L\"\\n                    \\n        # Finally, return the number of collisions\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3214698,
                "title": "c-simple-o-n-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        int ans=0;\\n        bool s=0;   //stationary\\n        int i=0;\\n        int c=0;   //count of R\\n        while(i<d.size())\\n        {\\n            if(d[i]==\\'L\\')\\n            {\\n                if(s)\\n                    ans++;\\n                else if(c!=0)\\n                    ans+=(c+1),c=0,s=1;\\n            }\\n            else if(d[i]==\\'S\\')\\n                ans+=(c),s=1,c=0;\\n            else\\n                c++,s=0;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string d) {\\n        int ans=0;\\n        bool s=0;   //stationary\\n        int i=0;\\n        int c=0;   //count of R\\n        while(i<d.size())\\n        {\\n            if(d[i]==\\'L\\')\\n            {\\n                if(s)\\n                    ans++;\\n                else if(c!=0)\\n                    ans+=(c+1),c=0,s=1;\\n            }\\n            else if(d[i]==\\'S\\')\\n                ans+=(c),s=1,c=0;\\n            else\\n                c++,s=0;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200190,
                "title": "easy-java-solution-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere two possible collesion if previous char is \\'R\\' or \\'S\\' so there are two condition and all time we incraese come at the basis of R beacuse R car can be any time collision.. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2);\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCollisions(String dict) {\\n    char st=\\' \\';\\n    int count=0;\\n    int come=0;\\n        for(int i=0; i<dict.length();i++){\\n            char ch =dict.charAt(i);\\n            if(st==\\'R\\'){\\n                if(ch==\\'L\\'){\\n                    count+=come;\\n                    count++;\\n                    come=0;\\n                    st=\\'S\\';\\n                }else if(ch==\\'S\\'){\\n                    count+=come;\\n                    come=0;\\n                    st=\\'S\\';\\n                }else{\\n                    come++;\\n                    st=ch;\\n\\n                }\\n            }else if(st==\\'S\\'){\\n                if(ch==\\'L\\'){\\n                    count++;\\n                    st=\\'S\\';\\n                }else if(ch==\\'R\\'){\\n                    come++;\\n                      st=\\'R\\';\\n                }\\n            }else{\\n            if(ch==\\'R\\'){\\n                come++;\\n                st=ch;\\n            }else{\\n                st=ch;\\n            }\\n        }\\n    }\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCollisions(String dict) {\\n    char st=\\' \\';\\n    int count=0;\\n    int come=0;\\n        for(int i=0; i<dict.length();i++){\\n            char ch =dict.charAt(i);\\n            if(st==\\'R\\'){\\n                if(ch==\\'L\\'){\\n                    count+=come;\\n                    count++;\\n                    come=0;\\n                    st=\\'S\\';\\n                }else if(ch==\\'S\\'){\\n                    count+=come;\\n                    come=0;\\n                    st=\\'S\\';\\n                }else{\\n                    come++;\\n                    st=ch;\\n\\n                }\\n            }else if(st==\\'S\\'){\\n                if(ch==\\'L\\'){\\n                    count++;\\n                    st=\\'S\\';\\n                }else if(ch==\\'R\\'){\\n                    come++;\\n                      st=\\'R\\';\\n                }\\n            }else{\\n            if(ch==\\'R\\'){\\n                come++;\\n                st=ch;\\n            }else{\\n                st=ch;\\n            }\\n        }\\n    }\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171953,
                "title": "simple-java-stack-solution",
                "content": "class Solution {\\n    public int countCollisions(String directions) {\\n     if(directions.length()<2)\\n     {\\n         return 0;\\n     }\\n     Deque<Character> st=new LinkedList<>();\\n     st.push(directions.charAt(0));\\n     int count=0;\\n     int index=1;\\n     int len=directions.length();   \\n     while(index<=len)\\n     {\\n         if(st.size()<2)\\n         {\\n             if(index<len)\\n             {\\n              st.push(directions.charAt(index++));\\n             }\\n             else\\n             {\\n                 break;\\n             }\\n         }\\n         else\\n         {\\n             char dir=st.pop();\\n             if(dir==\\'L\\'&&st.peek()==\\'R\\')\\n             {\\n                 count+=2;\\n                 st.pop();\\n                 st.push(\\'S\\');\\n             }\\n             else if(dir==\\'L\\'&&st.peek()==\\'S\\')\\n             {\\n                 count+=1;\\n                 st.pop();\\n                 st.push(\\'S\\');\\n             }\\n             else if(dir==\\'S\\'&&st.peek()==\\'R\\')\\n             {\\n                 count+=1;\\n                 st.pop();\\n                 st.push(\\'S\\');\\n             }\\n             else\\n             {\\n                 st.push(dir);\\n                 if(index<len)\\n                 {\\n                 st.push(directions.charAt(index++));\\n                 }\\n                 else\\n                 {\\n                     break;\\n                 }\\n             }\\n                 \\n         }\\n     }\\n         return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countCollisions(String directions) {\\n     if(directions.length()<2)\\n     {\\n         return 0;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 3163669,
                "title": "c-3-cases-o-n-runtime-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        bool foundLeft = false;\\n        int ans = 0;\\n        int numRight = 0;\\n        for (auto& c : directions){\\n            if (c == \\'R\\'){\\n                ++numRight;\\n                foundLeft = true;\\n            }\\n            else if (c == \\'S\\'){\\n                foundLeft = true;\\n                ans += numRight;\\n                numRight = 0;\\n            }\\n            else if (c == \\'L\\'){\\n                if (numRight > 0){\\n                    ans += 2;\\n                    ans += numRight - 1;\\n                    numRight = 0;\\n                }\\n                else ans += foundLeft;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string directions) {\\n        bool foundLeft = false;\\n        int ans = 0;\\n        int numRight = 0;\\n        for (auto& c : directions){\\n            if (c == \\'R\\'){\\n                ++numRight;\\n                foundLeft = true;\\n            }\\n            else if (c == \\'S\\'){\\n                foundLeft = true;\\n                ans += numRight;\\n                numRight = 0;\\n            }\\n            else if (c == \\'L\\'){\\n                if (numRight > 0){\\n                    ans += 2;\\n                    ans += numRight - 1;\\n                    numRight = 0;\\n                }\\n                else ans += foundLeft;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147966,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int countCollisions(string arr) {\\n        \\n        stack<char> st;\\n        long long count=0;\\n        for(int i=0;i<arr.size();i++){\\n            \\n            if(st.size()!=0 && st.top()==\\'R\\' && arr[i]==\\'L\\'){\\n                count=count+2;\\n                st.pop();\\n                while(st.size()!=0 && st.top()==\\'R\\'){\\n                    count++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n            else if(st.size()!=0 && st.top()==\\'S\\' && arr[i]==\\'L\\'){\\n                \\n                count=count+1;\\n                while(st.size()!=0 && st.top()==\\'R\\'){\\n                    count++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n            else if(st.size()!=0 && st.top()==\\'R\\' && arr[i]==\\'S\\'){\\n                \\n                count=count+1;\\n                st.pop();\\n                while(st.size()!=0 && st.top()==\\'R\\'){\\n                    count++;\\n                    st.pop();\\n                }\\n                st.push(\\'S\\');\\n            }\\n            else{\\n                st.push(arr[i]);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int countCollisions(string arr) {\\n        \\n        stack<char> st;\\n        long long count=0;\\n        for(int i=0;i<arr.size();i++){\\n            \\n            if(st.size()!=0 && st.top()==\\'R\\' && arr[i]==\\'L\\'){\\n                count=count+2;\\n                st.pop();\\n                while(st.size()!=0 && st.top()==\\'R\\'){\\n                    count++;\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3137488,
                "title": "c-3-lines-multiple-solutions-main-solution-based-on-std-functions-and-iterators",
                "content": "*(I realise that it is easy enough to transform my 3 line solution down into a two or even 1 line solution. However it would greatly reduce readablity.)*\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCars are ordered left to right on the road. They all travel at the same speed. This means that all cars that will crash are in a continues group of cars that are eather stopt or that will crash on some point. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLets say you have the following situation(here S is replaced by .):\\n```text\\n   |   group that crashes   |\\nLLL...LRRLRLRLR......LRL..RRLRR\\n```\\nYou start of on the left looking for a character that does not go to the left. In this case that is the first \\'.\\' .\\nThen you start on the right and start looking for the first character that is not an R. I  this case that is the first L.\\n\\nThe positions at which you stopped are the bounds. All the cars on and inbetween these positions that are not already stopt will crash. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) extra. O(n) total. \\n\\n# Code\\n**Iterator based methods using std functions**\\nI tried using c++ standard functions instead of for loops. First I went for an iterator based approach. \\n```\\nclass Solution {\\npublic:\\n    int countCollisions(const string& directions) {\\n        auto l = find_if(directions.cbegin(), directions.cend(), [](const char& c){return c != \\'L\\';});//Find that first iterator that is not \\'L\\'\\n        auto r = find_if(directions.crbegin(), make_reverse_iterator(l), [](const char& c){return c != \\'R\\';}).base();   //reverse iterators are used so that it starts at the end. Then .base() converts it to a normal iterator.\\n        return count_if(l,r,[](const char&c){return c != \\'S\\';});\\n    }\\n};\\n```\\nSadly this forced me to use allot of subFunctions(here they are Lambdas). \\n\\n\\n**String based functions and a forloop.**\\nI also tried a approach based on strings but I could not find a count_if function for strings thus I used a for loop in the end..\\n```\\nclass Solution {\\npublic:\\n    int countCollisions(const string& directions) {\\n        auto l = directions.find_first_not_of(\\'L\\');\\n        if(l == directions.npos)return 0;   //check if a non \\'L\\' char was found\\n        auto r = directions.find_last_not_of(\\'R\\');\\n        if(r == directions.npos)return 0;   //check if a non \\'R\\' char was found\\n\\n        //could not find a count_if like function for strings so I used a simple for loop.\\n        int count = 0;\\n        for(;l<=r; l++)\\n            if(directions[l] != \\'S\\')\\n                count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```text\\n   |   group that crashes   |\\nLLL...LRRLRLRLR......LRL..RRLRR\\n```\n```\\nclass Solution {\\npublic:\\n    int countCollisions(const string& directions) {\\n        auto l = find_if(directions.cbegin(), directions.cend(), [](const char& c){return c != \\'L\\';});//Find that first iterator that is not \\'L\\'\\n        auto r = find_if(directions.crbegin(), make_reverse_iterator(l), [](const char& c){return c != \\'R\\';}).base();   //reverse iterators are used so that it starts at the end. Then .base() converts it to a normal iterator.\\n        return count_if(l,r,[](const char&c){return c != \\'S\\';});\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countCollisions(const string& directions) {\\n        auto l = directions.find_first_not_of(\\'L\\');\\n        if(l == directions.npos)return 0;   //check if a non \\'L\\' char was found\\n        auto r = directions.find_last_not_of(\\'R\\');\\n        if(r == directions.npos)return 0;   //check if a non \\'R\\' char was found\\n\\n        //could not find a count_if like function for strings so I used a simple for loop.\\n        int count = 0;\\n        for(;l<=r; l++)\\n            if(directions[l] != \\'S\\')\\n                count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1947684,
                "content": [
                    {
                        "username": "haowenxue59",
                        "content": "The problem description is not clear. It should say: There are n cars on an infinitely wide road. "
                    },
                    {
                        "username": "vanderpuye",
                        "content": "this was the tip I needed. Finally made the whole thing clear for me."
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "why am i first one to comment(even after this many days of question release). is this question not popular?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@Raunak Mishra](/raunakmishra1243) Here the fourth one \\u270C"
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "[@Prajju22](/Prajju22) i am the third one..."
                    },
                    {
                        "username": "Prajju22",
                        "content": "i am the second one.."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Think of the case where we cannot have collision that is prefix with left moving cars and suffix with right moving cars.\nExample :\nDirection : LLLLLLRSRSLLLRSRSSRRLRRRRRRRRRR\nhere all starting L and ending R can be ignore as they are not at all involved in collision coz they are having no objects to collide remaining L and R we need to increment our answer by 1 as they are involved in collision.\nThis can be easily solve using to pointer."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "After reading question, I an understand it easily but those examples are getting into my nerves, examples 1 and 2 are bit confusing. Could someone explain?"
                    }
                ]
            },
            {
                "id": 1928245,
                "content": [
                    {
                        "username": "haowenxue59",
                        "content": "The problem description is not clear. It should say: There are n cars on an infinitely wide road. "
                    },
                    {
                        "username": "vanderpuye",
                        "content": "this was the tip I needed. Finally made the whole thing clear for me."
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "why am i first one to comment(even after this many days of question release). is this question not popular?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@Raunak Mishra](/raunakmishra1243) Here the fourth one \\u270C"
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "[@Prajju22](/Prajju22) i am the third one..."
                    },
                    {
                        "username": "Prajju22",
                        "content": "i am the second one.."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Think of the case where we cannot have collision that is prefix with left moving cars and suffix with right moving cars.\nExample :\nDirection : LLLLLLRSRSLLLRSRSSRRLRRRRRRRRRR\nhere all starting L and ending R can be ignore as they are not at all involved in collision coz they are having no objects to collide remaining L and R we need to increment our answer by 1 as they are involved in collision.\nThis can be easily solve using to pointer."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "After reading question, I an understand it easily but those examples are getting into my nerves, examples 1 and 2 are bit confusing. Could someone explain?"
                    }
                ]
            },
            {
                "id": 1978397,
                "content": [
                    {
                        "username": "haowenxue59",
                        "content": "The problem description is not clear. It should say: There are n cars on an infinitely wide road. "
                    },
                    {
                        "username": "vanderpuye",
                        "content": "this was the tip I needed. Finally made the whole thing clear for me."
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "why am i first one to comment(even after this many days of question release). is this question not popular?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@Raunak Mishra](/raunakmishra1243) Here the fourth one \\u270C"
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "[@Prajju22](/Prajju22) i am the third one..."
                    },
                    {
                        "username": "Prajju22",
                        "content": "i am the second one.."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Think of the case where we cannot have collision that is prefix with left moving cars and suffix with right moving cars.\nExample :\nDirection : LLLLLLRSRSLLLRSRSSRRLRRRRRRRRRR\nhere all starting L and ending R can be ignore as they are not at all involved in collision coz they are having no objects to collide remaining L and R we need to increment our answer by 1 as they are involved in collision.\nThis can be easily solve using to pointer."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "After reading question, I an understand it easily but those examples are getting into my nerves, examples 1 and 2 are bit confusing. Could someone explain?"
                    }
                ]
            },
            {
                "id": 1946721,
                "content": [
                    {
                        "username": "haowenxue59",
                        "content": "The problem description is not clear. It should say: There are n cars on an infinitely wide road. "
                    },
                    {
                        "username": "vanderpuye",
                        "content": "this was the tip I needed. Finally made the whole thing clear for me."
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "why am i first one to comment(even after this many days of question release). is this question not popular?"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "[@Raunak Mishra](/raunakmishra1243) Here the fourth one \\u270C"
                    },
                    {
                        "username": "raunakmishra1243",
                        "content": "[@Prajju22](/Prajju22) i am the third one..."
                    },
                    {
                        "username": "Prajju22",
                        "content": "i am the second one.."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Think of the case where we cannot have collision that is prefix with left moving cars and suffix with right moving cars.\nExample :\nDirection : LLLLLLRSRSLLLRSRSSRRLRRRRRRRRRR\nhere all starting L and ending R can be ignore as they are not at all involved in collision coz they are having no objects to collide remaining L and R we need to increment our answer by 1 as they are involved in collision.\nThis can be easily solve using to pointer."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "After reading question, I an understand it easily but those examples are getting into my nerves, examples 1 and 2 are bit confusing. Could someone explain?"
                    }
                ]
            }
        ]
    }
]