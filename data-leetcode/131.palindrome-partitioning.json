[
    {
        "title": "Next Permutation",
        "question_content": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\tFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\tFor example, the next permutation of arr = [1,2,3] is [1,3,2].\n\tSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\n\tWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\nExample 3:\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 100",
        "solutions": [
            {
                "id": 13867,
                "title": "c-from-wikipedia",
                "content": "According to [Wikipedia](https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order), a man named Narayana Pandita presented the following simple algorithm to solve this problem in the 14th century.\\n\\n1. Find the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, just reverse `nums` and done.\\n2. Find the largest index `l > k` such that `nums[k] < nums[l]`.\\n3. Swap `nums[k]` and `nums[l]`.\\n4. Reverse the sub-array `nums[k + 1:]`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n}; \\n```\\n\\nThe above algorithm can also handle duplicates and thus can be further used to solve [Permutations](https://leetcode.com/problems/permutations/) and [Permutations II](https://leetcode.com/problems/permutations-ii/).",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 13994,
                "title": "readable-code-without-confusing-i-j-and-with-explanation",
                "content": "Implementation based on description from [Project Nayuki](http://www.nayuki.io/page/next-lexicographical-permutation-algorithm). I cannot describe it better than them:\\n\\n![next permutation steps][1]\\n\\n\\tpublic class Solution {\\n\\t/*0*/ public void nextPermutation(int[] nums) {\\n\\t        // pivot is the element just before the non-increasing (weakly decreasing) suffix\\n\\t/*2*/   int pivot = indexOfLastPeak(nums) - 1;\\n\\t        // paritions nums into [prefix pivot suffix]\\n\\t        if (pivot != -1) {\\n\\t            int nextPrefix = lastIndexOfGreater(nums, nums[pivot]); // in the worst case it\\'s suffix[0]\\n\\t            // next prefix must exist because pivot < suffix[0], otherwise pivot would be part of suffix\\n\\t/*4*/       swap(nums, pivot, nextPrefix); // this minimizes the change in prefix\\n\\t        }\\n\\t/*5*/   reverseSuffix(nums, pivot + 1); // reverses the whole list if there was no pivot\\n\\t/*6*/ }\\n\\t    \\n\\t    /**\\n\\t     * Find the last element which is a peak.\\n\\t     * In case there are multiple equal peaks, return the first of those.\\n\\t     * @return first index of last peak\\n\\t     */\\n\\t/*1*/ int indexOfLastPeak(int[] nums) {\\n\\t        for (int i = nums.length - 1; 0 < i; --i) {\\n\\t            if (nums[i - 1] < nums[i]) return i;\\n\\t        }\\n\\t        return 0;\\n\\t    }\\n\\n\\t    /** @return last index where the {@code num > threshold} or -1 if not found */\\n\\t/*3*/ int lastIndexOfGreater(int[] nums, int threshold) {\\n\\t        for (int i = nums.length - 1; 0 <= i; --i) {\\n\\t            if (threshold < nums[i]) return i;\\n\\t        }\\n\\t        return -1;\\n\\t    }\\n\\n\\t    /** Reverse numbers starting from an index till the end. */\\n\\t    void reverseSuffix(int[] nums, int start) {\\n\\t        int end = nums.length - 1;\\n\\t        while (start < end) {\\n\\t            swap(nums, start++, end--);\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    void swap(int[] nums, int i, int j) {\\n\\t        int temp = nums[i];\\n\\t        nums[i] = nums[j];\\n\\t        nums[j] = temp;\\n\\t    }\\n\\t}\\n\\n\\n  [1]: https://www.nayuki.io/res/next-lexicographical-permutation-algorithm/next-permutation-algorithm.svg",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\t/*0*/ public void nextPermutation(int[] nums) {\\n\\t        // pivot is the element just before the non-increasing (weakly decreasing) suffix\\n\\t/*2*/   int pivot = indexOfLastPeak(nums) - 1;\\n\\t        // paritions nums into [prefix pivot suffix]\\n\\t        if (pivot != -1) {\\n\\t            int nextPrefix = lastIndexOfGreater(nums, nums[pivot]); // in the worst case it\\'s suffix[0]\\n\\t            // next prefix must exist because pivot < suffix[0], otherwise pivot would be part of suffix\\n\\t/*4*/       swap(nums, pivot, nextPrefix); // this minimizes the change in prefix\\n\\t        }",
                "codeTag": "Java"
            },
            {
                "id": 14054,
                "title": "python-solution-with-comments",
                "content": "        \\n    def nextPermutation(self, nums):\\n        i = j = len(nums)-1\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        if i == 0:   # nums are in descending order\\n            nums.reverse()\\n            return \\n        k = i - 1    # find the last \"ascending\" position\\n        while nums[j] <= nums[k]:\\n            j -= 1\\n        nums[k], nums[j] = nums[j], nums[k]  \\n        l, r = k+1, len(nums)-1  # reverse the second part\\n        while l < r:\\n            nums[l], nums[r] = nums[r], nums[l]\\n            l +=1 ; r -= 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def nextPermutation(self, nums):\\n        i = j = len(nums)-1\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        if i == 0:   # nums are in descending order\\n            nums.reverse()\\n            return \\n        k = i - 1    # find the last \"ascending\" position\\n        while nums[j] <= nums[k]:\\n            j -= 1\\n        nums[k], nums[j] = nums[j], nums[k]  \\n        l, r = k+1, len(nums)-1  # reverse the second part\\n        while l < r:\\n            nums[l], nums[r] = nums[r], nums[l]\\n            l +=1 ; r -= 1",
                "codeTag": "Python3"
            },
            {
                "id": 13866,
                "title": "share-my-o-n-time-solution",
                "content": "My idea is for an array:\\n\\n 1. Start from its last element, traverse backward to find the first one with index i that satisfy  num[i-1] < num[i]. So, elements from num[i] to num[n-1] is reversely sorted. \\n 2. To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the '1' at position 2 with '2' at position 7. \\n 3. The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1]\\n\\nThe following is my code:\\n\\n        \\n    public void nextPermutation(int[] num) {\\n        int n=num.length;\\n        if(n<2)\\n            return;\\n        int index=n-1;        \\n        while(index>0){\\n            if(num[index-1]<num[index])\\n                break;\\n            index--;\\n        }\\n        if(index==0){\\n            reverseSort(num,0,n-1);\\n            return;\\n        }\\n        else{\\n            int val=num[index-1];\\n            int j=n-1;\\n            while(j>=index){\\n                if(num[j]>val)\\n                    break;\\n                j--;\\n            }\\n            swap(num,j,index-1);\\n            reverseSort(num,index,n-1);\\n            return;\\n        }\\n    }\\n    \\n    public void swap(int[] num, int i, int j){\\n        int temp=0;\\n        temp=num[i];\\n        num[i]=num[j];\\n        num[j]=temp;\\n    }\\n    \\n    public void reverseSort(int[] num, int start, int end){   \\n        if(start>end)\\n            return;\\n        for(int i=start;i<=(end+start)/2;i++)\\n            swap(num,i,start+end-i);\\n    }",
                "solutionTags": [],
                "code": "My idea is for an array:\\n\\n 1. Start from its last element, traverse backward to find the first one with index i that satisfy  num[i-1] < num[i]. So, elements from num[i] to num[n-1] is reversely sorted. \\n 2. To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the '1' at position 2 with '2' at position 7. \\n 3. The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1]\\n\\nThe following is my code:\\n\\n        \\n    public void nextPermutation(int[] num) {\\n        int n=num.length;\\n        if(n<2)\\n            return;\\n        int index=n-1;        \\n        while(index>0){\\n            if(num[index-1]<num[index])\\n                break;\\n            index--;\\n        }\\n        if(index==0){\\n            reverseSort(num,0,n-1);\\n            return;\\n        }\\n        else{\\n            int val=num[index-1];\\n            int j=n-1;\\n            while(j>=index){\\n                if(num[j]>val)\\n                    break;\\n                j--;\\n            }\\n            swap(num,j,index-1);\\n            reverseSort(num,index,n-1);\\n            return;\\n        }\\n    }\\n    \\n    public void swap(int[] num, int i, int j){\\n        int temp=0;\\n        temp=num[i];\\n        num[i]=num[j];\\n        num[j]=temp;\\n    }\\n    \\n    public void reverseSort(int[] num, int start, int end){   \\n        if(start>end)\\n            return;\\n        for(int i=start;i<=(end+start)/2;i++)\\n            swap(num,i,start+end-i);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3473399,
                "title": "beats-100-full-explanation-in-steps",
                "content": "\\n\\n# Approach\\n The steps are the following:\\n\\n1. Find the break-point, i: Break-point means the first index i from the back of the given array where arr[i] becomes smaller than arr[i+1].\\nFor example, if the given array is {2,1,5,4,3,0,0}, the break-point will be index 1(0-based indexing). Here from the back of the array, index 1 is the first index where arr[1] i.e. 1 is smaller than arr[i+1] i.e. 5.\\n2. To find the break-point, using a loop we will traverse the array backward and store the index i where arr[i] is less than the value at index (i+1) i.e. arr[i+1].\\nIf such a break-point does not exist i.e. if the array is sorted in decreasing order, the given permutation is the last one in the sorted order of all possible permutations. So, the next permutation must be the first i.e. the permutation in increasing order.\\nSo, in this case, we will reverse the whole array and will return it as our answer.\\n3. If a break-point exists:\\nFind the smallest number i.e. > arr[i] and in the right half of index i(i.e. from index i+1 to n-1) and swap it with arr[i].\\nReverse the entire right half(i.e. from index i+1 to n-1) of index i. And finally, return the array.\\n\\n![image.png](https://assets.leetcode.com/users/images/ec3b008b-3542-429e-aefe-07d870e88e5d_1682940260.9485922.png)\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        // step 1 find breaking point \\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        // if there is no breaking  point \\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        \\n        else{\\n            // step 2 find next greater element and swap with ind2\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n\\n            swap(nums,ind1,ind2);\\n            // step 3 reverse the rest right half\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/7c17f983-3b8b-4738-b722-c1c1466f9510_1682940288.2823734.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        // step 1 find breaking point \\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        // if there is no breaking  point \\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        \\n        else{\\n            // step 2 find next greater element and swap with ind2\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n\\n            swap(nums,ind1,ind2);\\n            // step 3 reverse the rest right half\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13872,
                "title": "easiest-java-solution",
                "content": "Using a simple example, we can derive the following steps:\\n\\n    public void nextPermutation(int[] A) {\\n        if(A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while(i >= 0 && A[i] >= A[i + 1]) i--; // Find 1st id i that breaks descending order\\n        if(i >= 0) {                           // If not entirely descending\\n            int j = A.length - 1;              // Start from the end\\n            while(A[j] <= A[i]) j--;           // Find rightmost first larger id j\\n            swap(A, i, j);                     // Switch i and j\\n        }\\n        reverse(A, i + 1, A.length - 1);       // Reverse the descending sequence\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while(i < j) swap(A, i++, j--);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Using a simple example, we can derive the following steps:\\n\\n    public void nextPermutation(int[] A) {\\n        if(A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while(i >= 0 && A[i] >= A[i + 1]) i--; // Find 1st id i that breaks descending order\\n        if(i >= 0) {                           // If not entirely descending\\n            int j = A.length - 1;              // Start from the end\\n            while(A[j] <= A[i]) j--;           // Find rightmost first larger id j\\n            swap(A, i, j);                     // Switch i and j\\n        }\\n        reverse(A, i + 1, A.length - 1);       // Reverse the descending sequence\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while(i < j) swap(A, i++, j--);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 13921,
                "title": "1-4-11-lines-c",
                "content": "**Solution 1**\\n\\nJust for info: There's a library function that does the job, even going from totally reverse sorted to sorted:\\n\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums), end(nums));\\n    }\\n\\n---\\n\\n**Solution 2**\\n\\nUsing library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of `+1`/`-1`, it all fits exactly.\\n\\n    void nextPermutation(vector<int>& nums) {\\n        auto i = is_sorted_until(nums.rbegin(), nums.rend());\\n        if (i != nums.rend())\\n            swap(*i, *upper_bound(nums.rbegin(), i, *i));\\n        reverse(nums.rbegin(), i);\\n    }\\n\\n---\\n\\n**Solution 3**\\n\\nDoing it all on my own (except `swap`, let's not be silly):\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            swap(nums[j], nums[k]);\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            swap(nums[i], nums[k]);\\n        }\\n    }\\n\\n---\\n\\n**Solution 4**\\n\\nOk, let's be silly after all and not even use `swap` :-)\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i, tmp;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            tmp = nums[j], nums[j] = nums[k], nums[k] = tmp;\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            tmp = nums[i], nums[i] = nums[k], nums[k] = tmp;\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "**Solution 1**\\n\\nJust for info: There's a library function that does the job, even going from totally reverse sorted to sorted:\\n\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums), end(nums));\\n    }\\n\\n---\\n\\n**Solution 2**\\n\\nUsing library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of `+1`/`-1`, it all fits exactly.\\n\\n    void nextPermutation(vector<int>& nums) {\\n        auto i = is_sorted_until(nums.rbegin(), nums.rend());\\n        if (i != nums.rend())\\n            swap(*i, *upper_bound(nums.rbegin(), i, *i));\\n        reverse(nums.rbegin(), i);\\n    }\\n\\n---\\n\\n**Solution 3**\\n\\nDoing it all on my own (except `swap`, let's not be silly):\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            swap(nums[j], nums[k]);\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            swap(nums[i], nums[k]);\\n        }\\n    }\\n\\n---\\n\\n**Solution 4**\\n\\nOk, let's be silly after all and not even use `swap` :-)\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i, tmp;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            tmp = nums[j], nums[j] = nums[k], nums[k] = tmp;\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            tmp = nums[i], nums[i] = nums[k], nums[k] = tmp;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3169948,
                "title": "best-c-2-solution-two-pointers-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using 3 ways.\\n\\n1. Find all the permutation of Array(nums) then we can easily find next permutation.\\n2. Solved using Array + Two Pointers.\\n3. Solved using next_permutation (inbuilt) function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N), Since we traverse the entire Array(nums) once in the worst case. Where N = size of the Array(nums).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), Constant Space.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), Since we traverse the entire Array(nums) once in the worst case. Where N = size of\\n    the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space.\\n\\n    Solved using Array + Two Pointers.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), Since we traverse the entire Array(nums) once in the worst case. Where N = size of\\n    the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space.\\n\\n    Solved using Array + Two Pointers.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909229,
                "title": "simple-easy-c-solution-explain-with-image",
                "content": "![image](https://assets.leetcode.com/users/images/d2dfaab0-542d-4cc8-a32a-d82dd29c4c95_1648961158.0012193.png)\\n\\n```\\nvoid nextPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int l,r;\\n        for(l=n-2;l>=0;l--)                           // find decreasing sequence\\n        {\\n            if(nums[l]<nums[l+1]) break;\\n        }\\n        if(l<0) reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(r=n-1;r>l;r--)                       // find rightmost successor to pivot\\n            {\\n                if(nums[r]>nums[l]) break;\\n            }\\n            swap(nums[l],nums[r]);                  // swap l,r\\n            \\n            reverse(nums.begin()+l+1,nums.end());   // reverse from l+1 to end\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid nextPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int l,r;\\n        for(l=n-2;l>=0;l--)                           // find decreasing sequence\\n        {\\n            if(nums[l]<nums[l+1]) break;\\n        }\\n        if(l<0) reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(r=n-1;r>l;r--)                       // find rightmost successor to pivot\\n            {\\n                if(nums[r]>nums[l]) break;\\n            }\\n            swap(nums[l],nums[r]);                  // swap l,r\\n            \\n            reverse(nums.begin()+l+1,nums.end());   // reverse from l+1 to end\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1241286,
                "title": "c-simple-to-understand",
                "content": "# Find next permutation:\\n\\n### Algorithm:\\n\\n**step 1:** Linearly traverse given array from the end and find a number that is greater than its adjacent `nums[i] > nums[i-1]`. Store the index of smaller number in `breakPoint` variable. If there is no such element, reverse entire array and return.\\n\\n**step 2:** Linearly traverse from the end and this time find a number larger than `nums[breakPoint]`. Let\\'s call it `nums[i]`.\\n\\n**step 3:** Swap `nums[i] and nums[breakPoint]`.\\n\\n**step 4:** Reverse the array from index `breakPoint + 1` to `nums.size()`.\\n\\n### Example:\\n* Consider `nums[] = [1, 3, 5, 4, 2]`.\\n* Traverse from back and find a breakpoint. Here, index `breakPoint = 1` and `nums[breakPoint] = 3`\\n* Traverse from back and find a number larger than this. Here this number is: `nums[i] = 4`\\n* Swap `nums[breakPoint] and nums[i]`. Value after swapping: nums[] = [1, **4**, 5, **3**, 2].\\n* Reverse array from `breakPoint + 1` to `nums.size()` i.e. these elements: [1, 4, **5**, **3**, **2**]\\n* **`Final answer = [1, 4, 2, 3, 5]`.**\\n\\n**code:**\\n```\\n// find next permutation\\nvoid nextPermutation(vector<int> &nums)\\n{\\n    // initialize variable:\\n    int breakPoint = -1;\\n\\n    // find a breakpoint:\\n    for (int i = nums.size() - 1; i > 0; i--)\\n    {\\n        if (nums[i] > nums[i - 1])\\n        {\\n            breakPoint = i - 1;\\n            break;\\n        }\\n    }\\n\\n    // if no breakpoint\\n    if (breakPoint < 0)\\n    {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n\\n    // if found a breakpoint\\n    for (int i = nums.size() - 1; i >= 0; i--)\\n    {\\n        if (nums[i] > nums[breakPoint])\\n        {\\n            swap(nums[breakPoint], nums[i]);\\n            reverse(nums.begin() + breakPoint + 1, nums.end());\\n            break;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// find next permutation\\nvoid nextPermutation(vector<int> &nums)\\n{\\n    // initialize variable:\\n    int breakPoint = -1;\\n\\n    // find a breakpoint:\\n    for (int i = nums.size() - 1; i > 0; i--)\\n    {\\n        if (nums[i] > nums[i - 1])\\n        {\\n            breakPoint = i - 1;\\n            break;\\n        }\\n    }\\n\\n    // if no breakpoint\\n    if (breakPoint < 0)\\n    {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n\\n    // if found a breakpoint\\n    for (int i = nums.size() - 1; i >= 0; i--)\\n    {\\n        if (nums[i] > nums[breakPoint])\\n        {\\n            swap(nums[breakPoint], nums[i]);\\n            reverse(nums.begin() + breakPoint + 1, nums.end());\\n            break;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909728,
                "title": "simple-9-line-python-solution-with-detailed-explanation-easy-understand-for-beginners",
                "content": "```\\n    def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            # find the index of the last peak\\n            if nums[i - 1] < nums[i]:\\n                nums[i:] = sorted(nums[i:])\\n                \\n                # get the index before the last peak\\n                j = i - 1\\n                \\n                # swap the pre-last peak index with the value just large than it\\n                for k in range(i, len(nums)):\\n                    if nums[j] < nums[k]:\\n                        nums[k], nums[j] = nums[j], nums[k]\\n                        return nums\\n        return nums.reverse()\\n```\\n\\n**Please upvote me if you think this is useful! Much appreciated!**\\n\\nImagine this as a wave or signal, what we want to do is to move the last peak one-bit forward with equal or smaller peak\\n\\nConsider the following example [1, 2, 3, 5, 2, 3, 7, 5, 4, 3, 0]\\n![image](https://assets.leetcode.com/users/images/f3d1862c-f3a1-4a4b-9910-b784b7bdb818_1648968377.4465942.png)\\n\\nThe last peak is the red dot (index = 6), the index before the last peak (aka the pre-last peak index) is the green dot (index = 5)\\n![image](https://assets.leetcode.com/users/images/450b8952-98cc-4cc1-ac26-7cb1e1df72c0_1648968377.4618545.png)\\n\\nThen sort the region after the pre-peak index (green dot), the sorted region is shown in yellow dots\\n![image](https://assets.leetcode.com/users/images/6e92ec4f-6bb3-4e95-a44f-0d3f1488201a_1648968735.369267.png)\\n\\nThen find the point where its value is just above the pre-peak index (green dot)\\nIn this example, it is the pink dot with index = 8\\n![image](https://assets.leetcode.com/users/images/3db777e4-ff85-420b-99b7-4070ff207579_1648968871.7919884.png)\\n\\nSwap the green dot and the pink dot\\n![image](https://assets.leetcode.com/users/images/cb34be94-d97d-447a-be46-3f762876d33f_1648969056.4870846.png)\\n\\n**Done!** Output the final list\\nIn this case, it is [1,2,3,5,2,4,0,3,3,5,7]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            # find the index of the last peak\\n            if nums[i - 1] < nums[i]:\\n                nums[i:] = sorted(nums[i:])\\n                \\n                # get the index before the last peak\\n                j = i - 1\\n                \\n                # swap the pre-last peak index with the value just large than it\\n                for k in range(i, len(nums)):\\n                    if nums[j] < nums[k]:\\n                        nums[k], nums[j] = nums[j], nums[k]\\n                        return nums\\n        return nums.reverse()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13907,
                "title": "easy-python-solution-based-on-lexicographical-permutation-algorithm",
                "content": "For the detailed algorithm and demonstration, please go to https://www.nayuki.io/page/next-lexicographical-permutation-algorithm\\n\\nThe steps are shown in the picture below.\\n![alt text](https://www.nayuki.io/res/next-lexicographical-permutation-algorithm/next-permutation-algorithm.png)\\n\\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # find longest non-increasing suffix\\n        right = len(nums)-1\\n        while nums[right] <= nums[right-1] and right-1 >=0:\\n            right -= 1\\n        if right == 0:\\n            return self.reverse(nums,0,len(nums)-1)\\n        # find pivot\\n        pivot = right-1\\n        successor = 0\\n        # find rightmost succesor\\n        for i in range(len(nums)-1,pivot,-1):\\n            if nums[i] > nums[pivot]:\\n                successor = i\\n                break\\n        # swap pivot and successor\\n        nums[pivot],nums[successor] = nums[successor],nums[pivot]  \\n        # reverse suffix\\n        self.reverse(nums,pivot+1,len(nums)-1)\\n        \\n    def reverse(self,nums,l,r):\\n        while l < r:\\n            nums[l],nums[r] = nums[r],nums[l]\\n            l += 1\\n            r -= 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # find longest non-increasing suffix\\n        right = len(nums)-1\\n        while nums[right] <= nums[right-1] and right-1 >=0:\\n            right -= 1\\n        if right == 0:\\n            return self.reverse(nums,0,len(nums)-1)\\n        # find pivot\\n        pivot = right-1\\n        successor = 0\\n        # find rightmost succesor\\n        for i in range(len(nums)-1,pivot,-1):\\n            if nums[i] > nums[pivot]:\\n                successor = i\\n                break\\n        # swap pivot and successor\\n        nums[pivot],nums[successor] = nums[successor],nums[pivot]  \\n        # reverse suffix\\n        self.reverse(nums,pivot+1,len(nums)-1)\\n        \\n    def reverse(self,nums,l,r):\\n        while l < r:\\n            nums[l],nums[r] = nums[r],nums[l]\\n            l += 1\\n            r -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179544,
                "title": "python-solution-with-easy-understanding-and-comments-bonus-related-links",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # To find next permutations, we\\'ll start from the end\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number grater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now out pointer is pointing at two different positions\\n        # i. first non-assending number from end\\n        # j. first number greater than nums[i-1]\\n        \\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place\\n        \\'\\'\\'\\n            Dhruval\\n        \\'\\'\\'\\n```\\n\\nTake an example from this site and try to re-run above code manually. This will better help to understand the code\\nhttps://www.nayuki.io/page/next-lexicographical-permutation-algorithm\\n\\nRelated Link: \\nhttps://www.nayuki.io/res/next-lexicographical-permutation-algorithm/nextperm.py\\nhttps://en.wikipedia.org/wiki/Lexicographic_order",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # To find next permutations, we\\'ll start from the end\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number grater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now out pointer is pointing at two different positions\\n        # i. first non-assending number from end\\n        # j. first number greater than nums[i-1]\\n        \\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place\\n        \\'\\'\\'\\n            Dhruval\\n        \\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13885,
                "title": "9-lines-of-c-code-with-comments",
                "content": "    class Solution {\\n    public:\\n        void nextPermutation(vector<int> &num) \\n        {\\n            if (num.empty()) return;\\n            \\n            // in reverse order, find the first number which is in increasing trend (we call it violated number here)\\n            int i;\\n            for (i = num.size()-2; i >= 0; --i)\\n            {\\n                if (num[i] < num[i+1]) break;\\n            }\\n            \\n            // reverse all the numbers after violated number\\n            reverse(begin(num)+i+1, end(num));\\n            // if violated number not found, because we have reversed the whole array, then we are done!\\n            if (i == -1) return;\\n            // else binary search find the first number larger than the violated number\\n            auto itr = upper_bound(begin(num)+i+1, end(num), num[i]);\\n            // swap them, done!\\n            swap(num[i], *itr);\\n        }\\n    };\\n\\nYou might need to think for a while why this would work.",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        void nextPermutation(vector<int> &num) \\n        {\\n            if (num.empty()) return;\\n            \\n            // in reverse order, find the first number which is in increasing trend (we call it violated number here)\\n            int i;\\n            for (i = num.size()-2; i >= 0; --i)\\n            {\\n                if (num[i] < num[i+1]) break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 669387,
                "title": "javascript-clean-solution",
                "content": "Approach\\n*  Find the first decreasing index moving from end to start \\n\\t*  E.g. [7, 2, 3, 1, 5, 4, 3, 2, 0] num `1` is the first decreasing index going from the end backwards\\n*  Swap num `1` with the next large num to its right which is `2`\\n\\t*  [7, 2, 3, 2, 5, 4, 3, 1, 0]\\n*  Reverse/sort nums to the right\\n\\t*  [7, 2, 3, 2, 0, 1, 3, 4, 5]\\n*  If there is no next permutation reverse the array\\n\\n```javascript\\nvar nextPermutation = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--) {\\n        if(nums[i] < nums[i+1]) {\\n            const large = nextLarge(i);\\n            swap(i, large);\\n            reverse(i+1);\\n            return;\\n        }\\n    }\\n\\t\\n\\t// If there is no next permutation reverse the arr\\n    nums.reverse()\\n    \\n    function swap(i, j) {\\n        [nums[i], nums[j]] = [nums[j], nums[i]];\\n    }\\n    \\n    function reverse(idx) {\\n        let start = idx, end = nums.length-1;\\n        \\n        while(start < end) {\\n            swap(start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    function nextLarge(idx) {\\n        for(let i = nums.length-1; i > idx; i--) {\\n            if(nums[i] > nums[idx]) return i;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar nextPermutation = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--) {\\n        if(nums[i] < nums[i+1]) {\\n            const large = nextLarge(i);\\n            swap(i, large);\\n            reverse(i+1);\\n            return;\\n        }\\n    }\\n\\t\\n\\t// If there is no next permutation reverse the arr\\n    nums.reverse()\\n    \\n    function swap(i, j) {\\n        [nums[i], nums[j]] = [nums[j], nums[i]];\\n    }\\n    \\n    function reverse(idx) {\\n        let start = idx, end = nums.length-1;\\n        \\n        while(start < end) {\\n            swap(start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    function nextLarge(idx) {\\n        for(let i = nums.length-1; i > idx; i--) {\\n            if(nums[i] > nums[idx]) return i;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229211,
                "title": "python-solution",
                "content": "First observe that if a list of numbers is in descending order, then there is no lexicographically next greater permutation. Hence `for i in range(n-1,0,-1)`, we search for the first occurrence of i such that `nums[i] < nums[i+1]`. If no such i exists, the list is in descending order, and we use `nums.reverse()` to reverse the list in-place. Otherwise, if such i exists, then `nums[i-1]` will be updated to get the lexicographically next greater permutation. Next, we need to search for the smallest number in `nums[i:]` that\\'s larger than `nums[i-1]`, and swap it with `nums[i-1]`. Note that `nums[i:]` is sorted in descending order. Hence we start with `j = i`, and `while j < n and nums[j] > nums[i-1]`, we do `idx = j, j += 1`. When we are out of the while loop, `nums[idx]` will be the smallest number in `nums[i:]` that\\'s larger than `nums[i]`. We then swap `nums[idx]` and `nums[i-1]`. After the swap, we just need to sort `nums[i:]` in ascending order to get the lexicographically next greater permutation. This can be achieved fairly easily in-place, because `nums[i:]` is already in descending order, and we just need to invert `nums[i:]` in-place to sort `nums[i:]` in ascending order. \\n\\nTo illustrate the algorithm with an example, consider `nums = [2,3,1,5,4,2]`. It is easy to see that `i = 2` is the first i (from the right) such that `nums[i] < nums[i+1]`. Then we swap `nums[2] = 1` with the smallest number in `nums[3:]` that is larger than 1, which is `nums[5] = 2`, after which we get `nums = [2,3,2,5,4,1]`. To get the lexicographically next greater permutation of `nums`, we just need to sort `nums[3:] = [5,4,1]` in-place. Finally, we reach `nums = [2,3,2,1,4,5]`.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        for i in range(n-1, 0, -1):\\n            if nums[i] > nums[i-1]:\\n                j = i\\n                while j < n and nums[j] > nums[i-1]:\\n                    idx = j\\n                    j += 1\\n                nums[idx], nums[i-1] = nums[i-1], nums[idx]\\n                for k in range((n-i)//2):\\n                    nums[i+k], nums[n-1-k] = nums[n-1-k], nums[i+k]\\n                break\\n        else:\\n            nums.reverse()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        for i in range(n-1, 0, -1):\\n            if nums[i] > nums[i-1]:\\n                j = i\\n                while j < n and nums[j] > nums[i-1]:\\n                    idx = j\\n                    j += 1\\n                nums[idx], nums[i-1] = nums[i-1], nums[idx]\\n                for k in range((n-i)//2):\\n                    nums[i+k], nums[n-1-k] = nums[n-1-k], nums[i+k]\\n                break\\n        else:\\n            nums.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13890,
                "title": "sharing-my-really-simple-solution-with-explanation",
                "content": "    void nextPermutation(vector<int> &num) {\\n        for(int i = num.size() - 2; i >= 0; i--){\\n            if(num[i] < num[i + 1]){\\n                int pos;\\n                int diff = INT_MAX;\\n                for(int j = i + 1; j < num.size(); j++){\\n                    if(num[j] > num[i] && abs(num[i] - num[j]) < diff){\\n                        diff = abs(num[i] - num[j]);\\n                        pos = j;\\n                    }\\n                }\\n                swap(num[i], num[pos]);\\n                sort(num.begin() + i + 1, num.end());\\n                return;\\n            }\\n        }\\n        sort(num.begin(), num.end());\\n    }\\n\\nFor this problem, coding is not a big deal. Algorithm is!\\n\\nNow let's pick a number, for example, 24387651.\\n\\nwhat is the next permutation? 24513678.\\n\\nHow can I get the answer? \\n\\nFirst step: find the first ascending digit from the back of the number. 3 < 8 > 7 > 6 > 5 > 1. Then 3 is the digit.\\n\\nSecond step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631.\\n\\nThird step: sort 87631 into 13678. The final answer is 24513678.",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "    void nextPermutation(vector<int> &num) {\\n        for(int i = num.size() - 2; i >= 0; i--){\\n            if(num[i] < num[i + 1]){\\n                int pos;\\n                int diff = INT_MAX;\\n                for(int j = i + 1; j < num.size(); j++){\\n                    if(num[j] > num[i] && abs(num[i] - num[j]) < diff){\\n                        diff = abs(num[i] - num[j]);\\n                        pos = j;\\n                    }\\n                }\\n                swap(num[i], num[pos]);\\n                sort(num.begin() + i + 1, num.end());\\n                return;\\n            }\\n        }\\n        sort(num.begin(), num.end());\\n    }\\n\\nFor this problem, coding is not a big deal. Algorithm is!\\n\\nNow let's pick a number, for example, 24387651.\\n\\nwhat is the next permutation? 24513678.\\n\\nHow can I get the answer? \\n\\nFirst step: find the first ascending digit from the back of the number. 3 < 8 > 7 > 6 > 5 > 1. Then 3 is the digit.\\n\\nSecond step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631.\\n\\nThird step: sort 87631 into 13678. The final answer is 24513678.",
                "codeTag": "Unknown"
            },
            {
                "id": 1043577,
                "title": "python-o-n-inplace-solution-explained",
                "content": "This problem is very similar to problem **556. Next Greater Element III**, with exactly the same reasoning:\\n\\nImagine, that we have `nums = [2, 3, 4, 1, 5, 7, 6, 4, 1]` Then next permutation is `[2, 3, 4, 1, 6, 1, 4, 5, 7]`. Idea here is to start to look from the end and find decreasing pattern, like `[7, 6, 4, 1]` here, then look at previous element and insert it in correct place. For more details see https://leetcode.com/problems/next-greater-element-iii/discuss/983076/Python-O(m)-solution-explained.\\n\\n**Complexity**: time complexity it is `O(n)`, where `n` is length of `nums`. Space complexity is `O(1)` here, because we do everything in-place.\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        def reverse(L, start, end):\\n            while start < end:\\n                L[start], L[end] = L[end], L[start]\\n                start, end = start + 1, end - 1\\n        \\n        i, n = len(nums) - 1, len(nums)\\n        while i >= 1 and nums[i] <= nums[i-1]:\\n            i -= 1\\n            \\n        if i != 0:\\n            j = i\\n            while j + 1 < n and nums[j+1] > nums[i - 1]:\\n                j += 1\\n            \\n            nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        reverse(nums, i, n - 1)\\n        \\n        return nums\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        def reverse(L, start, end):\\n            while start < end:\\n                L[start], L[end] = L[end], L[start]\\n                start, end = start + 1, end - 1\\n        \\n        i, n = len(nums) - 1, len(nums)\\n        while i >= 1 and nums[i] <= nums[i-1]:\\n            i -= 1\\n            \\n        if i != 0:\\n            j = i\\n            while j + 1 < n and nums[j+1] > nums[i - 1]:\\n                j += 1\\n            \\n            nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        reverse(nums, i, n - 1)\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152693,
                "title": "c-c-java-python-short-solution-with-comments-just-5-lines-of-clean-stl-c-code",
                "content": "1. Search from right to left for a point where the values stop ascending, that will be the point that must be updated.\\n2. Locate the point furthest right of this point that has a greater value than our destination point found in 1.\\n3. Swap the points found in 1. and 2 and reverse everything to the right of destination found in 1. as it is currently decending left to right and must be ascending.\\n\\n# **TL;DR**\\n**Python**\\n```python\\ndef nextPermutation(self, nums: List[int]) -> None:\\n  # Find the first place moving from right to left that is not assending\\n  dest = len(nums) - 2\\n  while (0 <= dest and nums[dest] >= nums[dest + 1]):\\n    dest = dest - 1\\n\\n  # Found a destination to change\\n  if (0 <= dest):\\n    # Find the first number moving right to left bigger than destination number\\n    target = len(nums) - 1\\n    while (nums[target] <= nums[dest]):\\n      target = target - 1\\n\\n    nums[dest], nums[target] = nums[target], nums[dest]\\n\\n  # Reverse everything right of our destination\\n  nums[dest + 1:] = reversed(nums[dest + 1:])\\n```\\n**Java**\\n```java\\npublic void nextPermutation(int[] num) {\\n  // Find the first place moving from right to left that is not assending\\n  int dest = num.length - 2;\\n  for (; 0 <= dest && num[dest] >= num[dest + 1]; --dest)\\n    ;\\n\\n  // If we found a location that is not sorted\\n  if (0 <= dest) {\\n    // Find the right most value greater than our destination (there must be one)\\n    int target = num.length - 1;\\n    for (; num[dest] >= num[target]; --target)\\n      ;\\n\\n    // Swap the destination with the target\\n    int tmp = num[dest];\\n    num[dest] = num[target];\\n    num[target] = tmp;\\n  }\\n\\n  // Reverse everything right of the destination\\n  for (int end = num.length - 1; dest + 1 < end; ) {\\n    int tmp = num[++dest];\\n    num[dest] = num[end];\\n    num[end--] = tmp;\\n  }\\n}\\n```\\n**C++ STL Solution**\\nDetails below;\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\\n**C**\\n```c\\nvoid nextPermutation(int* nums, int numsSize) {\\n  /* Find the first place moving from right to left that is not assending */\\n  int dest = numsSize - 1;\\n  while (dest-- && nums[dest] >= nums[dest + 1])\\n    ;\\n\\n  if (0 <= dest) /* Found a destination to change */ {\\n    /* Find the right most value greater than our destination (there must be one) */\\n    int target = numsSize;\\n    while (nums[--target] <= nums[dest])\\n      ;\\n\\n    /* Swap the destination with the target */\\n    int tmp = nums[dest];\\n    nums[dest] = nums[target];\\n    nums[target] = tmp;\\n  }\\n  \\n  /* Reverse everything right of our destination */\\n  for (int back = numsSize - 1; dest + 1 < back; ) {\\n    int tmp = nums[++dest];\\n    nums[dest] = nums[back];\\n    nums[back--] = tmp;\\n  }\\n}\\n```\\n\\n# **C++ Details**\\nAn initial solution might be;\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      if (1 < nums.size()) {\\n        auto pos = nums.end() - 1;\\n        do {\\n          if (*pos > *(pos - 1)) {\\n            auto dest = pos - 1;\\n            // Find the first element that is greater then dest, this will be\\n            // the element between [pos, nums.end()] that is just above dest\\n            // Use the fact that [pos, nums.end()] is sorted in descending order to do a binary search\\n            auto target = --std::lower_bound(pos, nums.end(), *dest, std::greater<int>());\\n\\n            // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n            std::iter_swap(dest, target);\\n\\n            // At this point [pos, end) will be sorted descending, we need it to be\\n            // ascending\\n            // [3, 4, 2, 1] -> [3, 1, 2, 4] \\n            std::reverse(pos, nums.end());\\n            return;\\n          }\\n        } \\n        while (--pos != nums.begin());\\n\\n        // At the end of the permutation, reverse everything.\\n        std::reverse(nums.begin(), nums.end());\\n      }\\n    }\\n```\\t\\t\\nOf course, you could cheat and do\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      std::next_permutation(nums.begin(), nums.end());\\n    }\\n```\\nBut where\\'s the fun in that?\\n\\nCan we do better though? Well all we\\'re really trying to do is find the first point where the ordering is no longer ascending when moving right to left. There\\'s an ~~app~~ algorithm for that! `std::is_sorted_until` will return the iterator of the first unsorted element, so using the reverse iterators to search from right to left, we get a one-liner to find the destination element.\\n\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      // Find the first point where the ordering from right to left is not sorted\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        // We found a point, find a candidate to swap with. The range [rbegin, dest) is sorted ascendingly\\n        // so we can binary search for the first element greater than our destination\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        \\n        // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n        std::iter_swap(dest, target);\\n      }\\n      // Reverse everything to the right of our dest point. In the case of not being the whole vector this\\n      // reverses the ordering from being ascending (left to right) to being descending\\n      // [3, 4, 2, 1] -> [3, 1, 2, 4]\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\\t\\t\\nThe actual code without comments is only a few, clean, lines.\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\\t\\t",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```python\\ndef nextPermutation(self, nums: List[int]) -> None:\\n  # Find the first place moving from right to left that is not assending\\n  dest = len(nums) - 2\\n  while (0 <= dest and nums[dest] >= nums[dest + 1]):\\n    dest = dest - 1\\n\\n  # Found a destination to change\\n  if (0 <= dest):\\n    # Find the first number moving right to left bigger than destination number\\n    target = len(nums) - 1\\n    while (nums[target] <= nums[dest]):\\n      target = target - 1\\n\\n    nums[dest], nums[target] = nums[target], nums[dest]\\n\\n  # Reverse everything right of our destination\\n  nums[dest + 1:] = reversed(nums[dest + 1:])\\n```\n```java\\npublic void nextPermutation(int[] num) {\\n  // Find the first place moving from right to left that is not assending\\n  int dest = num.length - 2;\\n  for (; 0 <= dest && num[dest] >= num[dest + 1]; --dest)\\n    ;\\n\\n  // If we found a location that is not sorted\\n  if (0 <= dest) {\\n    // Find the right most value greater than our destination (there must be one)\\n    int target = num.length - 1;\\n    for (; num[dest] >= num[target]; --target)\\n      ;\\n\\n    // Swap the destination with the target\\n    int tmp = num[dest];\\n    num[dest] = num[target];\\n    num[target] = tmp;\\n  }\\n\\n  // Reverse everything right of the destination\\n  for (int end = num.length - 1; dest + 1 < end; ) {\\n    int tmp = num[++dest];\\n    num[dest] = num[end];\\n    num[end--] = tmp;\\n  }\\n}\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\n```c\\nvoid nextPermutation(int* nums, int numsSize) {\\n  /* Find the first place moving from right to left that is not assending */\\n  int dest = numsSize - 1;\\n  while (dest-- && nums[dest] >= nums[dest + 1])\\n    ;\\n\\n  if (0 <= dest) /* Found a destination to change */ {\\n    /* Find the right most value greater than our destination (there must be one) */\\n    int target = numsSize;\\n    while (nums[--target] <= nums[dest])\\n      ;\\n\\n    /* Swap the destination with the target */\\n    int tmp = nums[dest];\\n    nums[dest] = nums[target];\\n    nums[target] = tmp;\\n  }\\n  \\n  /* Reverse everything right of our destination */\\n  for (int back = numsSize - 1; dest + 1 < back; ) {\\n    int tmp = nums[++dest];\\n    nums[dest] = nums[back];\\n    nums[back--] = tmp;\\n  }\\n}\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      if (1 < nums.size()) {\\n        auto pos = nums.end() - 1;\\n        do {\\n          if (*pos > *(pos - 1)) {\\n            auto dest = pos - 1;\\n            // Find the first element that is greater then dest, this will be\\n            // the element between [pos, nums.end()] that is just above dest\\n            // Use the fact that [pos, nums.end()] is sorted in descending order to do a binary search\\n            auto target = --std::lower_bound(pos, nums.end(), *dest, std::greater<int>());\\n\\n            // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n            std::iter_swap(dest, target);\\n\\n            // At this point [pos, end) will be sorted descending, we need it to be\\n            // ascending\\n            // [3, 4, 2, 1] -> [3, 1, 2, 4] \\n            std::reverse(pos, nums.end());\\n            return;\\n          }\\n        } \\n        while (--pos != nums.begin());\\n\\n        // At the end of the permutation, reverse everything.\\n        std::reverse(nums.begin(), nums.end());\\n      }\\n    }\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      std::next_permutation(nums.begin(), nums.end());\\n    }\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      // Find the first point where the ordering from right to left is not sorted\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        // We found a point, find a candidate to swap with. The range [rbegin, dest) is sorted ascendingly\\n        // so we can binary search for the first element greater than our destination\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        \\n        // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n        std::iter_swap(dest, target);\\n      }\\n      // Reverse everything to the right of our dest point. In the case of not being the whole vector this\\n      // reverses the ordering from being ascending (left to right) to being descending\\n      // [3, 4, 2, 1] -> [3, 1, 2, 4]\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1043648,
                "title": "easy-solution-w-detailed-explanation-beats-100-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nChanges made to the left part of an array have more impact on the lexicographical sorting than changes made to the right side, so logically, in order to find the next permutation that is lexicographically greater, we need to find the farthest right-most number that can be swapped for a larger number to its right.\\n\\nWe also then need to make sure that it\\'s not just any larger number, but the *next possible* larger number from the numbers to its right. Then, we\\'ll need to make sure that the remaining numbers to the right of our swapped target are in their lexicographically smallest configuration. (*Think of it like a counter rolling over from **0999** into **1000**.*)\\n\\n---\\n\\n***Implementation:***\\n\\nSo the first order of business is to find the target number we want to swap. As we check from the right to the left, if each number is larger than the one before, then we clearly can\\'t find a lexicographically larger number. Therefore, we have to move left until we find the first time a number is lower than the number to its right.\\n\\nOnce we find that target (**N[i]**), the very important thing to recognize is that the numbers to the target\\'s right are *already* in sorted order, just in the *reverse* order, so we can easily reverse them. (*Even if we don\\'t actually find the target, we still want to reverse the entire array, per the instructions.*)\\n\\nIt\\'s easy then to move from the smallest to largest of the reversed numbers and look for the first number (**N[j]**) that\\'s larger than our target so that we can swap the two. Since **N[j]** is lexicographically nearest to **N[i]**, the subarray to the right of **N[i]** will *still* be in the correct order even after the swap.\\n\\nA simple helper functions to swap array elements will be useful.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 39.3MB** (beats 100% / 100%).\\n```javascript\\nvar nextPermutation = function(N) {\\n    const swap = (a, b) => [N[a],N[b]] = [N[b],N[a]]\\n    let len = N.length - 1, i, j\\n    for (i = len - 1; N[i] >= N[i+1];) i--\\n    for (let k = i+1; len > k; k++, len--) swap(k,len)\\n    if (~i) {\\n        for (j = i + 1; N[i] >= N[j];) j++\\n        swap(i,j)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar nextPermutation = function(N) {\\n    const swap = (a, b) => [N[a],N[b]] = [N[b],N[a]]\\n    let len = N.length - 1, i, j\\n    for (i = len - 1; N[i] >= N[i+1];) i--\\n    for (let k = i+1; len > k; k++, len--) swap(k,len)\\n    if (~i) {\\n        for (j = i + 1; N[i] >= N[j];) j++\\n        swap(i,j)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2777680,
                "title": "easy-simple-o-n-c-code",
                "content": "# Please do upvote if you like the code ..ty\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(),k,l;\\n         \\n        // finding first element from the last which is smaller than\\n        // element next to it\\n        for(k=n-2 ; k>=0 ; k--)\\n            if(nums[k] < nums[k+1]) break;\\n\\n        // if we dont find any such element that means the vector \\n        // is already sorted in descending order\\n\\n        // i.e. It is already the biggest number that can be formed\\n        // using all the integers\\n\\n        // In this case the next Premutation will be the smallest\\n        // permutation that can be formed using the numbers of\\n        // array i.e. all the array elements in ascending order\\n        // which is nothing but the reverse of the current order\\n \\n        if(k<0)\\n            reverse(nums.begin() ,nums.end());\\n\\n        // After finding the index \"k\" of the number which is \\n        // smaller than the number next to it ,\\n        // we will again traverse from the right to \\n        // left and will find the first element which is greater\\n        // the element at index k ....which is indeed the smallest \\n        // of all the numbers right to the index k\\n\\n        // we will then swap both the characters \\n        // after swapping we will just reverse the digits after the\\n        // index k as that is in descending order and reversing it\\n        // will make it in increasing order and will make the whole\\n        // number smallest possible number greater than \\n        // the original number \\n        else{\\n            for(l = n-1; l >k ;l--)\\n                if(nums[l] > nums[k]) break;\\n            swap(nums[k], nums[l]); \\n            reverse(nums.begin()+k+1 ,  nums.end());\\n        }\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(),k,l;\\n         \\n        // finding first element from the last which is smaller than\\n        // element next to it\\n        for(k=n-2 ; k>=0 ; k--)\\n            if(nums[k] < nums[k+1]) break;\\n\\n        // if we dont find any such element that means the vector \\n        // is already sorted in descending order\\n\\n        // i.e. It is already the biggest number that can be formed\\n        // using all the integers\\n\\n        // In this case the next Premutation will be the smallest\\n        // permutation that can be formed using the numbers of\\n        // array i.e. all the array elements in ascending order\\n        // which is nothing but the reverse of the current order\\n \\n        if(k<0)\\n            reverse(nums.begin() ,nums.end());\\n\\n        // After finding the index \"k\" of the number which is \\n        // smaller than the number next to it ,\\n        // we will again traverse from the right to \\n        // left and will find the first element which is greater\\n        // the element at index k ....which is indeed the smallest \\n        // of all the numbers right to the index k\\n\\n        // we will then swap both the characters \\n        // after swapping we will just reverse the digits after the\\n        // index k as that is in descending order and reversing it\\n        // will make it in increasing order and will make the whole\\n        // number smallest possible number greater than \\n        // the original number \\n        else{\\n            for(l = n-1; l >k ;l--)\\n                if(nums[l] > nums[k]) break;\\n            swap(nums[k], nums[l]); \\n            reverse(nums.begin()+k+1 ,  nums.end());\\n        }\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908568,
                "title": "python3-search-swap-sort-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThree steps:\\n1. Starting from the back, search for an element that has at least one element on the right side that is greater than it. [1, **2**, 4, 3, 1]\\n2. Swap the found element and the minimum element from the right side that is greater than the current. [1, **3**, 4, 2, 1]\\n3. Sort element on the right side. [1, 3, **1, 2, 4**]\\n\\nTime: **O(n^2)** - Can be linear if optimize searching for a candidate for swapping, and also instead of insertion sort just reverse the subarray :)\\nSpace: **O(1)**\\n\\nRuntime: 49 ms, faster than **72.04%** of Python3 online submissions for Next Permutation.\\nMemory Usage: 13.9 MB, less than **79.00%** of Python3 online submissions for Next Permutation\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        L = len(nums)\\n        for i in reversed(range(L - 1)):\\n            # Search\\n            cand = -1\\n            for j in range(i + 1, L):\\n                if nums[j] > nums[i]:\\n                    if cand < 0 or nums[j] < nums[cand]: cand = j\\n            if cand < 0: continue\\n\\n            # Swap\\n            nums[i], nums[cand] = nums[cand], nums[i]\\n                        \\n            # Insertion sort\\n            j = i + 2\\n            while j < L:\\n                k = j\\n                while k - 1 > i and nums[k - 1] > nums[k]:\\n                    nums[k - 1], nums[k] = nums[k], nums[k - 1]\\n                    k -= 1\\n                \\n                j += 1\\n\\n            break\\n        else:\\n            nums.reverse()\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        L = len(nums)\\n        for i in reversed(range(L - 1)):\\n            # Search\\n            cand = -1\\n            for j in range(i + 1, L):\\n                if nums[j] > nums[i]:\\n                    if cand < 0 or nums[j] < nums[cand]: cand = j\\n            if cand < 0: continue\\n\\n            # Swap\\n            nums[i], nums[cand] = nums[cand], nums[i]\\n                        \\n            # Insertion sort\\n            j = i + 2\\n            while j < L:\\n                k = j\\n                while k - 1 > i and nums[k - 1] > nums[k]:\\n                    nums[k - 1], nums[k] = nums[k], nums[k - 1]\\n                    k -= 1\\n                \\n                j += 1\\n\\n            break\\n        else:\\n            nums.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394208,
                "title": "c-brute-force-optimal-time-o-n-auxiliary-space-o-1",
                "content": "**Brute Force Solution** \\n![image](https://assets.leetcode.com/users/images/312b7900-f2ea-4324-95b5-2a1c49055cb7_1628647022.5257127.gif)\\nPicture sourced from other coding sources\\n\\n**If n is the size of the array, then total number of permutations is n!. If nums[]={a,b,c} which means n=3, then the permutations are abc, acb, bac, bca, cba, cab. Time complexity of the brute force solution is O(NxN!) where N! is for the total number of permutations and N is for traversing each individual permutation**\\n```\\nclass Solution {\\n\\t    // Brute Force Solution Time O(N!*N) & Auxiliary Space O(N^2)\\n\\t\\t// Recursion & Backtracking\\n\\t    // TLE 64/265 test cases passed\\npublic:\\n\\t// permute function takes time of O(N*N!)\\n    void permute(int p,vector<int>& arr, vector<vector<int>>& res) {\\n        int n=arr.size();\\n        if(p==n) res.push_back(arr);\\n        for(int i=p;i<n;i++) {  // Time O(N) for traversal of each permutation\\n            swap(arr[i],arr[p]);\\n            permute(p+1,arr,res);  // Time O(N!) for total number of permutations\\n            swap(arr[i],arr[p]);\\n        }\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        vector<vector<int>> res; \\n        vector<int> arr=nums; \\n        permute(0,arr,res); \\n        set<vector<int>> s; // set stores unique elements in the sorted order\\n        for(int i=0;i<res.size();i++){\\n            s.insert(res[i]);\\n        }\\n        auto it=s.find(nums);\\n\\t\\t// If nums is last element of the permutation order, \\n\\t\\t// then nums is equal to the first element of the \\n\\t\\t// permutation sequence\\n        if(it==(--s.end())){\\n            it=s.begin();\\n            nums=*it;\\n        }\\n\\t\\t// else make nums equal to the immediate \\n\\t\\t// next element in the permutation sequence\\n        else{\\n            it++;\\n            nums=*it;\\n        }\\n    }\\n};\\n```\\n**Optimal Solution**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Narayana Panditha\\'s Algorithm\\n        int len=nums.size(), k=0, l=0;   // For example, if nums=[2,4,6,5,3]\\n        for(k=len-2;k>=0;k--){\\n            if(nums[k]<nums[k+1])\\n                break;  // k will point to 4 in nums=[2,4,6,5,3]\\n        }\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n            for(l=len-1;l>k;l--){\\n                if(nums[l]>nums[k])\\n                    break; //  l will point to 5 in nums=[2,4,6,5,3]\\n        }\\n            swap(nums[k],nums[l]); // nums=[2,5,6,4,3]\\n            reverse(nums.begin()+k+1,nums.end()); // nums=[2,5,3,4,6]\\n        }\\n    }\\n};\\n```\\n**Optimal Solution(Inbuilt Function)**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Inbuilt Function\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\t    // Brute Force Solution Time O(N!*N) & Auxiliary Space O(N^2)\\n\\t\\t// Recursion & Backtracking\\n\\t    // TLE 64/265 test cases passed\\npublic:\\n\\t// permute function takes time of O(N*N!)\\n    void permute(int p,vector<int>& arr, vector<vector<int>>& res) {\\n        int n=arr.size();\\n        if(p==n) res.push_back(arr);\\n        for(int i=p;i<n;i++) {  // Time O(N) for traversal of each permutation\\n            swap(arr[i],arr[p]);\\n            permute(p+1,arr,res);  // Time O(N!) for total number of permutations\\n            swap(arr[i],arr[p]);\\n        }\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        vector<vector<int>> res; \\n        vector<int> arr=nums; \\n        permute(0,arr,res); \\n        set<vector<int>> s; // set stores unique elements in the sorted order\\n        for(int i=0;i<res.size();i++){\\n            s.insert(res[i]);\\n        }\\n        auto it=s.find(nums);\\n\\t\\t// If nums is last element of the permutation order, \\n\\t\\t// then nums is equal to the first element of the \\n\\t\\t// permutation sequence\\n        if(it==(--s.end())){\\n            it=s.begin();\\n            nums=*it;\\n        }\\n\\t\\t// else make nums equal to the immediate \\n\\t\\t// next element in the permutation sequence\\n        else{\\n            it++;\\n            nums=*it;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Narayana Panditha\\'s Algorithm\\n        int len=nums.size(), k=0, l=0;   // For example, if nums=[2,4,6,5,3]\\n        for(k=len-2;k>=0;k--){\\n            if(nums[k]<nums[k+1])\\n                break;  // k will point to 4 in nums=[2,4,6,5,3]\\n        }\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n            for(l=len-1;l>k;l--){\\n                if(nums[l]>nums[k])\\n                    break; //  l will point to 5 in nums=[2,4,6,5,3]\\n        }\\n            swap(nums[k],nums[l]); // nums=[2,5,6,4,3]\\n            reverse(nums.begin()+k+1,nums.end()); // nums=[2,5,3,4,6]\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Inbuilt Function\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349275,
                "title": "solution-swift-next-permutation-test-cases",
                "content": "```swift\\nclass Solution {\\n    func nextPermutation(_ nums: inout [Int]) {\\n        let len = nums.count\\n        var lhs = -1, rhs = -1, idx = len - 2\\n        while idx >= 0 {\\n            if nums[idx] < nums[idx + 1] { lhs = idx; break }\\n            idx -= 1\\n        }\\n        if lhs == -1 { nums = nums.reversed(); return }\\n        \\n        idx = len - 1\\n        while idx > lhs {\\n            rhs = idx\\n            if nums[idx] > nums[lhs] { break }\\n            idx -= 1\\n        }\\n        nums.swapAt(lhs, rhs)\\n        nums.replaceSubrange(lhs + 1..<len, with: nums[lhs + 1...len - 1].reversed())\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.016 (0.020) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        var nums = [1,2,3]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,3,2])\\n    }\\n    \\n    func test1() {\\n        var nums = [3,2,1]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,2,3])\\n    }\\n    \\n    func test2() {\\n        var nums = [1,1,5]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,5,1])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func nextPermutation(_ nums: inout [Int]) {\\n        let len = nums.count\\n        var lhs = -1, rhs = -1, idx = len - 2\\n        while idx >= 0 {\\n            if nums[idx] < nums[idx + 1] { lhs = idx; break }\\n            idx -= 1\\n        }\\n        if lhs == -1 { nums = nums.reversed(); return }\\n        \\n        idx = len - 1\\n        while idx > lhs {\\n            rhs = idx\\n            if nums[idx] > nums[lhs] { break }\\n            idx -= 1\\n        }\\n        nums.swapAt(lhs, rhs)\\n        nums.replaceSubrange(lhs + 1..<len, with: nums[lhs + 1...len - 1].reversed())\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        var nums = [1,2,3]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,3,2])\\n    }\\n    \\n    func test1() {\\n        var nums = [3,2,1]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,2,3])\\n    }\\n    \\n    func test2() {\\n        var nums = [1,1,5]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,5,1])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908463,
                "title": "two-pointers-solution-with-detailed-explanation-code-commented",
                "content": "[Leetcode](https://leetcode.com/) [31. Next Permutation](https://leetcode.com/problems/next-permutation/).\\n\\n# Intuition\\n\\n- How to make a number **larger**? \\n\\nPick a **larger** number from the **lower** digit and swap it with the **higher** digit smaller number.\\n\\n- How to find the permutation which is **just larger** than the given number?\\n\\nThe increase should be as small as possible.\\n\\n# Two Pointers\\n\\nTake a example, $[3,2,1]$ which is decreasing order, there is no next permutation, it is already stable and cannot get larger.\\n\\nLike $[1,5,2,4,3,2]$, how can it be just larger than the given number?\\n\\n1. Scanning from right to left, find the **first** number which is smaller than the right digit, and swap it to the lower digit;\\n\\t- For example, $1 5 (2) 4 3 2$, the $2$ in the middle is the found one.\\n\\n2. Scanning from right to left, searching for the first number which is larger than it, and **swap** them.\\n\\t- For example, $1 5 (2) 4 (3) 2$, after swap: $1 5 (3) 4 (2) 2$.\\n\\nHowever, it\\'s not over yet!\\n\\nThe magnitude of the increase can be made smaller, the $3rd$ digit from right has become slightly larger, and the last three can be made smaller.\\n\\nThe last three digits are definitely **decreasing**, and they are flipped to become $[1,5,3,2,2,4]$, which is what is required.\\n\\n```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static void nextPermutation_tp(int[] nums) {\\n        if (nums == null || nums.length <= 1) {\\n            return;\\n        }\\n\\n        int len = nums.length;\\n        int left = len - 2;\\n        /**\\n         * from right to left, search for the first one which is smaller than the right digit.\\n         */\\n        while (left >= 0 && nums[left] >= nums[left + 1]) {\\n            left--;\\n        }\\n\\n        /**\\n         *  If the one exists, search a one which is larger than it from right to left.\\n         */\\n        if (left >= 0) {\\n            int right = nums.length - 1;\\n            while (right >= 0 && nums[left] >= nums[right]) {\\n                right--;\\n            }\\n            /**\\n             * swap them.\\n             */\\n            swap(nums, left, right);\\n        }\\n\\n        /**\\n         *  flip the right to make the number smaller.\\n         */\\n        reverse(nums, left + 1);\\n    }\\n\\n    public static void swap(int[] nums, int a, int b) {\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n\\n    public static void reverse(int[] nums, int low) {\\n        int left = low;\\n        int right = nums.length - 1;\\n        while (left < right) {\\n            swap(nums, left, right);\\n            left++;\\n            right--;\\n        }\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static void nextPermutation_tp(int[] nums) {\\n        if (nums == null || nums.length <= 1) {\\n            return;\\n        }\\n\\n        int len = nums.length;\\n        int left = len - 2;\\n        /**\\n         * from right to left, search for the first one which is smaller than the right digit.\\n         */\\n        while (left >= 0 && nums[left] >= nums[left + 1]) {\\n            left--;\\n        }\\n\\n        /**\\n         *  If the one exists, search a one which is larger than it from right to left.\\n         */\\n        if (left >= 0) {\\n            int right = nums.length - 1;\\n            while (right >= 0 && nums[left] >= nums[right]) {\\n                right--;\\n            }\\n            /**\\n             * swap them.\\n             */\\n            swap(nums, left, right);\\n        }\\n\\n        /**\\n         *  flip the right to make the number smaller.\\n         */\\n        reverse(nums, left + 1);\\n    }\\n\\n    public static void swap(int[] nums, int a, int b) {\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n\\n    public static void reverse(int[] nums, int low) {\\n        int left = low;\\n        int right = nums.length - 1;\\n        while (left < right) {\\n            swap(nums, left, right);\\n            left++;\\n            right--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13894,
                "title": "two-pointer-solution-in-python-with-detail-expalanation",
                "content": "Credit goes to http://blog.csdn.net/m6830098/article/details/17291259\\n\\n    class Solution(object):\\n        def nextPermutation(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            # Use two-pointers: two pointers start from back\\n            # first pointer j stop at descending point\\n            # second pointer i stop at value > nums[j]\\n            # swap and sort rest\\n            if not nums: return None\\n            i = len(nums)-1\\n            j = -1 # j is set to -1 for case `4321`, so need to reverse all in following step\\n            while i > 0:\\n                if nums[i-1] < nums[i]: # first one violates the trend\\n                  j = i-1\\n                  break\\n                i-=1\\n            for i in xrange(len(nums)-1, -1, -1):\\n                if nums[i] > nums[j]: # \\n                    nums[i], nums[j] = nums[j], nums[i] # swap position\\n                    nums[j+1:] = sorted(nums[j+1:]) # sort rest\\n                    return",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "Credit goes to http://blog.csdn.net/m6830098/article/details/17291259\\n\\n    class Solution(object):\\n        def nextPermutation(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            # Use two-pointers: two pointers start from back\\n            # first pointer j stop at descending point\\n            # second pointer i stop at value > nums[j]\\n            # swap and sort rest\\n            if not nums: return None\\n            i = len(nums)-1\\n            j = -1 # j is set to -1 for case `4321`, so need to reverse all in following step\\n            while i > 0:\\n                if nums[i-1] < nums[i]: # first one violates the trend\\n                  j = i-1\\n                  break\\n                i-=1\\n            for i in xrange(len(nums)-1, -1, -1):\\n                if nums[i] > nums[j]: # \\n                    nums[i], nums[j] = nums[j], nums[i] # swap position\\n                    nums[j+1:] = sorted(nums[j+1:]) # sort rest\\n                    return",
                "codeTag": "Java"
            },
            {
                "id": 2516442,
                "title": "c-two-simplest-solutions-with-without-stl",
                "content": "Hey Guys,\\nHope you all are doing well!\\nIn this post, I\\'ve provided two simple and easy-to-understand solutions.\\nApproach 1:\\nStep 1: Linearly traverse the array from backwards\\xA0so that the array\\'s ith index value is less than the array\\'s (i+1)th index value. Store \\xA0that index into a variable.\\nStep 2: If the index value obtained in step 1 is less than zero. This indicates that the given input array has already been sorted in descending order. Simply reverse the given array to obtain the next permutation. Otherwise, simply traverse the array backwards to find the index that has\\xA0a value greater than the previously found index. Store index in another variable.\\nStep 3: Swap values present in indices found in the above two steps.\\nStep 4: Reverse array from index+1 where the index is found at step 1 till the end of the array.\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        int n=arr.size(),i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(arr[i]<arr[i+1]) break;\\n        }\\n        if(i<0) reverse(arr.begin(),arr.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(arr[j]>arr[i]) break;\\n            }\\n            swap(arr[i],arr[j]);\\n            reverse(arr.begin()+i+1,arr.end());\\n        }\\n    }\\n};\\n```\\nApproach 2: We can simply use the C++ STL library function ```next_permutation()``` to get the next lexicographically greater permutation.\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        next_permutation(arr.begin(),arr.end());\\n    }\\n};\\n```\\nWhile traversing from backwards we are searching for an element whose value is smaller than the value of its previous element and in each step, we are decrementing the counter i by 1. \\nIf the given array is already sorted in descending order then we will not get a single element.  Eventually, counter i become -1.\\nAs we know to find the next permutation of any integer array which is already sorted in descending order simply take the reverse of it. \\n\\n![sample](https://user-images.githubusercontent.com/106552945/188268610-bb25b8c6-65b6-48a8-a3b6-ad652e6ab0d9.jpg)\\n\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\nPlease upvote if you found the solution useful.\\nHappy Coding!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        int n=arr.size(),i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(arr[i]<arr[i+1]) break;\\n        }\\n        if(i<0) reverse(arr.begin(),arr.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(arr[j]>arr[i]) break;\\n            }\\n            swap(arr[i],arr[j]);\\n            reverse(arr.begin()+i+1,arr.end());\\n        }\\n    }\\n};\\n```\n```next_permutation()```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        next_permutation(arr.begin(),arr.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13878,
                "title": "c-java-clean-code-with-really-simple-explanation",
                "content": "To understand this approach, we need to define 2 concept with a 5 digit example `12543`:\\n- `NCR - No Capacity Range` : the number in that `range` cannot be bigger, Like: \"543\"\\n- `DWC - Digit With Capacity` : A digit bring capacity to the range after it. Like: \"[2]543\"\\n\\nLet's get some hint from finding the Next Decimal:\\n```\\nNext Decimal\\n[5](9 9 9) <- NCR (No Capacity Range)\\n ^\\nDWC (Digit With Capacity)\\n=>\\n[6](0 0 0)\\n```\\nImagine how you increase this number `5999` to `6000`:\\nBecause the first 3 digits from right is a `No Capacity Range`, you have to flip the 4th digits (5, the first `Digit With Capacity`.), to what - The next smallest digits greater than `5`, which is `6`, then make the `rest 3 digits` the smallest combination, which is `\"000\"`, that's how you get this `\"6000\"`;\\n\\nIn an permutation though, the next smallest number for `DWC(Digit With Capacity)` would be whatever is available in that following `NCR(No Capacity Range)`\\n\\n```\\nNext Permutation\\n1[2](5 4 3) <- NCR (No Capacity Range)\\n  ^\\nDWC (Digit With Capacity)\\n=>\\n1[3](2 4 5)\\n```\\nSo we have found the pattern is always to find the first `DWC(Digit With Capacity)`, then minimize the `NCR` after it.\\n\\nTo summarize:\\n1. Find the first `DWC`, which is 2;\\n```\\n1[2](5 4 3)\\n  ^\\n```\\n2. Reverse the `NCR` after it to make the `NCR` in increasing order(because it is already sorted in descending order).\\n```\\n1[2](3 4 5)\\n  ^\\n```\\n3. Swap the `DWC` with the `1st` digit in the reversed range that is slightly bigger than it.\\n```\\n1[3](2 4 5)\\n  ^--^\\n```\\nDONE!\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        if (a.size() <= 1) return;\\n        int dwc = -1; // Digit With Capacity\\n        for (int i = a.size() - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        // if dwc is not found, means this is a max array, reverse whole array and return;\\n        reverse(a.begin() + dwc + 1, a.end());\\n        if (dwc != -1) return;\\n        for (int i = dwc + 1; i < a.size(); i++) {\\n            if (a[i] > a[dwc]) {\\n                swap(a[i], a[dwc]); break;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Java**\\n```\\n/**\\n * 0. For permutation of index, the smallest order is ever increasing, the largest order is ever decreasing.\\n * 1. no-capacity-range: NCR - Start from the end, as long as the next number is bigger, this whole range have no capacity.\\n * 2. First digit-with-capacity: DWC - find the first DWC index. reverse the rest. then switch the index with the first larger than index on the right.\\n */\\npublic class Solution {\\n    public void nextPermutation(int[] a) {\\n        if (a.length < 2) return;\\n        /* Find the first Digit With Capacity */\\n        int dwc = -1;\\n        for (int i = a.length - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        /* Reverse the No Capacity Range after 1st DWC. */\\n        reverse(a, dwc + 1, a.length - 1);\\n        if (dwc != -1) {\\n            for (int i = dwc + 1; i < a.length; i++) {\\n                if (a[i] > a[dwc]) {\\n                    swap(a, dwc, i); break;\\n                }\\n            }\\n        }\\n    }\\n    private void reverse(int[] a, int i, int j) {\\n        for (; i < j; i++, j--) { swap(a, i, j); }\\n    }\\n    private void swap(int[] a, int i, int j) {\\n        int tmp = a[i];\\n        a[i] = a[j];\\n        a[j] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nNext Decimal\\n[5](9 9 9) <- NCR (No Capacity Range)\\n ^\\nDWC (Digit With Capacity)\\n=>\\n[6](0 0 0)\\n```\n```\\nNext Permutation\\n1[2](5 4 3) <- NCR (No Capacity Range)\\n  ^\\nDWC (Digit With Capacity)\\n=>\\n1[3](2 4 5)\\n```\n```\\n1[2](5 4 3)\\n  ^\\n```\n```\\n1[2](3 4 5)\\n  ^\\n```\n```\\n1[3](2 4 5)\\n  ^--^\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        if (a.size() <= 1) return;\\n        int dwc = -1; // Digit With Capacity\\n        for (int i = a.size() - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        // if dwc is not found, means this is a max array, reverse whole array and return;\\n        reverse(a.begin() + dwc + 1, a.end());\\n        if (dwc != -1) return;\\n        for (int i = dwc + 1; i < a.size(); i++) {\\n            if (a[i] > a[dwc]) {\\n                swap(a[i], a[dwc]); break;\\n            }\\n        }\\n    }\\n};\\n```\n```\\n/**\\n * 0. For permutation of index, the smallest order is ever increasing, the largest order is ever decreasing.\\n * 1. no-capacity-range: NCR - Start from the end, as long as the next number is bigger, this whole range have no capacity.\\n * 2. First digit-with-capacity: DWC - find the first DWC index. reverse the rest. then switch the index with the first larger than index on the right.\\n */\\npublic class Solution {\\n    public void nextPermutation(int[] a) {\\n        if (a.length < 2) return;\\n        /* Find the first Digit With Capacity */\\n        int dwc = -1;\\n        for (int i = a.length - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        /* Reverse the No Capacity Range after 1st DWC. */\\n        reverse(a, dwc + 1, a.length - 1);\\n        if (dwc != -1) {\\n            for (int i = dwc + 1; i < a.length; i++) {\\n                if (a[i] > a[dwc]) {\\n                    swap(a, dwc, i); break;\\n                }\\n            }\\n        }\\n    }\\n    private void reverse(int[] a, int i, int j) {\\n        for (; i < j; i++, j--) { swap(a, i, j); }\\n    }\\n    private void swap(int[] a, int i, int j) {\\n        int tmp = a[i];\\n        a[i] = a[j];\\n        a[j] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294256,
                "title": "simple-java-approach-with-100-beats",
                "content": "# Intuition\\nBasic Idealogy about the lexicographical order of permutations to the given input\\n\\n# Approach\\nStep 1:In first for loop, traverse the array from the end to find the first decreasing element from the right.(If any of the element had not been found means, just reverse the loop and exit the program.)\\n\\nStep 2:In second for loop, traverse the array from the end to find the first element which is greater than the element we had found before.\\n\\nStep 3:Swap the two elements we had found and stored previously.\\n\\nStep 4:Just reverse the array from the index next to the first swapped element to the end.\\n\\n\\n                        Do upvote for me!\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n            swap(nums,ind1,ind2);\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n            swap(nums,ind1,ind2);\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564964,
                "title": "c-solution-with-proper-explanation-along-with-time-complexity",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Find the point a[i]<a[i+1] by iterating from last. This is our index1.\\n- If there is no breakpoint that means the array is in descending order. So, simply reverse the full array.\\n- Else again iterate from last and find the element that is great than a[index1]. Store it as index2.\\n- Swap the 2elements at index1 and index2.\\n- Finally reverse the array from index1+1, so that we get the minimum number. Which means the next permutation.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i, j;\\n        int n= nums.size();\\n        int a=0;\\n        for(i=n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1]){\\n                break;\\n            }\\n        }\\n        if(i<0)\\n            reverse(nums.begin(), nums.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(nums[i]<nums[j]){\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin()+i+1, nums.end());\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i, j;\\n        int n= nums.size();\\n        int a=0;\\n        for(i=n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1]){\\n                break;\\n            }\\n        }\\n        if(i<0)\\n            reverse(nums.begin(), nums.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(nums[i]<nums[j]){\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin()+i+1, nums.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910236,
                "title": "python-easy-o-n-solution-explained",
                "content": "**Explaination:**\\nLet\\'s take an example and try to understand.\\n```Example: curr = [1, 2, 4, 3]```\\n```next = [1, 3, 2, 4]``` , So How do we find next? \\n\\n**Step1:** Find the ```breakpoint``` from the end which breaks the non-increasing sequence. Why?\\n```\\n    |-breakpoint\\n    |\\n1,  2, [ 4,  3 ] - right (non increasing sequence)\\n```\\nNow Think, can we swap any element from ```right```? No we can\\'t because it will always result in lower permutation and not greater.\\nSo we find the break point\\n\\n**Step2:** Traverse from end in ```right``` part and find the first element greater than breakpoint. Why?\\nWe need to find the next lexicographically greater permutation, So we can\\'t just swap it with any number, In the above example, ```4``` and ```3``` both are greater than ```2```. Swapping with```4``` will be far greater, So we will swap it with ```3```\\n\\nAfter swapping ```1,  3, [ 4,  2 ] ```\\n\\n**Step3:** Reverse the right part. Why? \\nAfter getting the next greater ```breakpoint```, All the element at ```right``` part must be sorted as we need a next greater permutation\\nwe can\\'t just leave ```[4, 2]``` like this, because it will be far greater and not next greater.\\nSo we will sort the ```right```, but wait do we even need to sort it? No, bcoz right is already non-increasing, So we just need to reverse it in order to get it sorted.\\n```final = 1, 3, [2, 4]``` \\n\\n*Code*\\n```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        bPoint, n = -1, len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i] >= arr[i+1]: continue                   # Skip the non-increasing sequence\\n            bPoint = i                                        # Got our breakpoint\\n            for j in range(n-1,i,-1):                         # again traverse from end\\n                if arr[j] > arr[bPoint]:                      # Search an element greater the element present at the breakPoint.\\n                    arr[j], arr[bPoint] = arr[bPoint], arr[j] # Swap it\\n                    break                                     # We just need to swap once\\n            break                                             # Break this loop too\\n        arr[bPoint+1:] = reversed(arr[bPoint+1:])             # Reverse the element after the breakpoint\\n```\\n***\\n```Time Complexity:  O(n)```\\n```Space Complexity: O(1)```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Example: curr = [1, 2, 4, 3]```\n```next = [1, 3, 2, 4]```\n```breakpoint```\n```\\n    |-breakpoint\\n    |\\n1,  2, [ 4,  3 ] - right (non increasing sequence)\\n```\n```right```\n```right```\n```4```\n```3```\n```2```\n```4```\n```3```\n```1,  3, [ 4,  2 ] ```\n```breakpoint```\n```right```\n```[4, 2]```\n```right```\n```final = 1, 3, [2, 4]```\n```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        bPoint, n = -1, len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i] >= arr[i+1]: continue                   # Skip the non-increasing sequence\\n            bPoint = i                                        # Got our breakpoint\\n            for j in range(n-1,i,-1):                         # again traverse from end\\n                if arr[j] > arr[bPoint]:                      # Search an element greater the element present at the breakPoint.\\n                    arr[j], arr[bPoint] = arr[bPoint], arr[j] # Swap it\\n                    break                                     # We just need to swap once\\n            break                                             # Break this loop too\\n        arr[bPoint+1:] = reversed(arr[bPoint+1:])             # Reverse the element after the breakpoint\\n```\n```Time Complexity:  O(n)```\n```Space Complexity: O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 2187200,
                "title": "c-solution-optimized-solution-tc-o-n",
                "content": "**Explanation:**\\n* Linearly traverse array from backward such that ith index value of the array is less than (i+1)th index value. Store that index in a variable.\\n\\n* If the index value received from step 1 is less than 0. This means the given input array is the largest lexicographical permutation. Hence, we will reverse the input array to get the minimum or starting permutation. Linearly traverse array from backward. Find an index that has a value greater than the previously found index. Store index is another variable.\\n* Swap values present in indices found in the above two steps.\\n* Reverse array from index+1 where the index is found at step 1 till the end of the array.\\n\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```\\nTC -> `O(n)`\\nSC ->` O(1)`\\n**Please upvote if you find the solution useful, means a lot.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044321,
                "title": "c-2-pointer-solution-explained-100-time-90-space",
                "content": "This problem is similar to a few others here on getting the next bigger number with the same digits or the next permutation of a string, etc.\\n\\nThis is just easier since we work directly with a vector, so let\\'s crack on!\\n\\nFirst of all, we will create 2 support variables, our indexes `i` and `j`, respectively set to be pointing to the penultimate element and past the end of the vector.\\n\\nWe will then keep reducing `i` as long as it is non-negative and as long as it points to an element `>=` than the previous one.\\n\\nIf we were to finally end up with `i == -1`, it would mean that the whole vector is set in decreasing order, so no next permutation is possible, and we need to transform the array to the very first one, before leaving the function.\\n\\nNow, you might just opt to sort the vector, but since we know it is already ordered, just reversing it might just save us precious computation: `O(nlogn)` vs. `O(n)` (or, rather `O(n/2)`) is a no brainer.\\n\\nFor any other value of `i`, we will then search with `j` for the very first element that is `<= nums[i]`, which is guaranteed to be there (since all the elements before `i` are in decreasing order).\\n\\nOnce found, we will swap `nums[i]` and `nums[j]`, since `nums[j]` is the next number to go there, and set the rest of the positions from `i + 1` to be in increasing order - I guess here reversing and then using insertion sort would perform better, but I did not feel like going for that overkill just in case.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        // support variables\\n        int i = nums.size() - 2, j = i + 2;\\n        while (i >= 0 && nums[i] >= nums[i + 1]) i--;\\n        // edge case: already the highest permutation you can get\\n        if (i == -1) {\\n            reverse(begin(nums), end(nums));\\n            return;\\n        }\\n        // finding the first element > nums[i]\\n        while (nums[--j] <= nums[i]);\\n        // swapping i and j\\'s values\\n        swap(nums[i], nums[j]);\\n        // ordering the rest\\n        sort(begin(nums) + i + 1, end(nums));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Combinatorics"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        // support variables\\n        int i = nums.size() - 2, j = i + 2;\\n        while (i >= 0 && nums[i] >= nums[i + 1]) i--;\\n        // edge case: already the highest permutation you can get\\n        if (i == -1) {\\n            reverse(begin(nums), end(nums));\\n            return;\\n        }\\n        // finding the first element > nums[i]\\n        while (nums[--j] <= nums[i]);\\n        // swapping i and j\\'s values\\n        swap(nums[i], nums[j]);\\n        // ordering the rest\\n        sort(begin(nums) + i + 1, end(nums));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903596,
                "title": "o-n-js-solution-with-explanation",
                "content": "```\\n/*\\nI will consider given array as a number.\\n\\nIf given array is in descending order, there is no greater number.\\nHence, we reverse the array and return.\\n\\n1. We iterate through given array from the back. We look for the first dip because that is where we can swap numbers and make our number greater.\\n2. However, simply swapping adjacent numbers when a dip is found isn\\'t sufficient.\\nex) Given 1 2 6 8 7, next greater number isn\\'t 1 2 8 6 7. It\\'s 1 2 7 6 8. \\n3. We consider the first dip as the pivot. Then, we iterate again from the back. The first number greater than\\npivot will be swapped with the pivot. This logic works because all numbers up to the pivot (the first dip) are in descending order.\\n4. Then, we reverse arr[pivot+1...end] because we want to change these numbers from descending order to ascending order.\\nThis allows us to get the next greater number. The swap doesn\\'t change the descending order of arr[pivot+1...end].\\n*/\\nvar nextPermutation = function(nums) {\\n    let pivot = -1;\\n    for (let i = nums.length-1; i > 0; i--) {\\n        if (nums[i] > nums[i-1]) {\\n            pivot = i-1;\\n            break;\\n        }\\n    }\\n    if (pivot === -1) { // array is in descending order\\n        nums.reverse();\\n        return;\\n    }\\n    for (let i = nums.length-1; i > pivot; i--) {\\n        if (nums[i] > nums[pivot]) {\\n            swap(nums, i, pivot);\\n            break;\\n        }\\n    }\\n    for (let i = pivot+1, j = nums.length-1; i < j; i++, j--) {\\n        swap(nums, i, j);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nfunction swap(nums, i, j) {\\n    [nums[i], nums[j]] = [nums[j], nums[i]];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nI will consider given array as a number.\\n\\nIf given array is in descending order, there is no greater number.\\nHence, we reverse the array and return.\\n\\n1. We iterate through given array from the back. We look for the first dip because that is where we can swap numbers and make our number greater.\\n2. However, simply swapping adjacent numbers when a dip is found isn\\'t sufficient.\\nex) Given 1 2 6 8 7, next greater number isn\\'t 1 2 8 6 7. It\\'s 1 2 7 6 8. \\n3. We consider the first dip as the pivot. Then, we iterate again from the back. The first number greater than\\npivot will be swapped with the pivot. This logic works because all numbers up to the pivot (the first dip) are in descending order.\\n4. Then, we reverse arr[pivot+1...end] because we want to change these numbers from descending order to ascending order.\\nThis allows us to get the next greater number. The swap doesn\\'t change the descending order of arr[pivot+1...end].\\n*/\\nvar nextPermutation = function(nums) {\\n    let pivot = -1;\\n    for (let i = nums.length-1; i > 0; i--) {\\n        if (nums[i] > nums[i-1]) {\\n            pivot = i-1;\\n            break;\\n        }\\n    }\\n    if (pivot === -1) { // array is in descending order\\n        nums.reverse();\\n        return;\\n    }\\n    for (let i = nums.length-1; i > pivot; i--) {\\n        if (nums[i] > nums[pivot]) {\\n            swap(nums, i, pivot);\\n            break;\\n        }\\n    }\\n    for (let i = pivot+1, j = nums.length-1; i < j; i++, j--) {\\n        swap(nums, i, j);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nfunction swap(nums, i, j) {\\n    [nums[i], nums[j]] = [nums[j], nums[i]];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13926,
                "title": "simple-o-n-java-solution-with-explanation-improved-using-binary-search",
                "content": "```\\n/*\\n    Idea:\\n    1. Reverse find first number which breaks descending order.\\n    2. Exchange this number with the least number that's greater than this number.\\n    3. Reverse sort the numbers after the exchanged number.\\n*/\\n\\npublic class Solution {\\n    public void nextPermutation(int[] nums) {\\n        /* 1. Reverse find first number which breaks descending order. */\\n        int i=nums.length-1;\\n        for(; i>=1; i--)\\n            if(nums[i-1]<nums[i]) break;\\n        \\n        /* if no break found in step 1 */\\n        if(i==0){\\n            /* for case \"1\" and \"1111\" */\\n            if(nums.length==1 || nums[0]==nums[1]) return; \\n            /* for case \"54321\" */\\n            int lo=i, hi=nums.length-1; \\n            while(lo<hi) swap(nums, lo++, hi--);\\n            return;\\n        }\\n        \\n        /* 2. Exchange this number with the least number that's greater than this number. */\\n        /* 2.1 Find the least number that's greater using binary search, O(log(nums.length-i)) */\\n        int j = binarySearchLeastGreater(nums, i, nums.length-1, nums[i-1]);\\n        \\n        /* 2.2 Exchange the numbers */\\n        if(j!=-1) swap(nums, i-1, j);\\n        \\n        /* 3. Reverse sort the numbers after the exchanged number. */\\n        int lo=i, hi=nums.length-1;\\n        while(lo<hi) swap(nums, lo++, hi--);\\n    }\\n    \\n    public int binarySearchLeastGreater(int[] nums, int lo, int hi, int key){\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(nums[mid]>key){\\n                lo = mid+1;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        return hi;\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Idea:\\n    1. Reverse find first number which breaks descending order.\\n    2. Exchange this number with the least number that's greater than this number.\\n    3. Reverse sort the numbers after the exchanged number.\\n*/\\n\\npublic class Solution {\\n    public void nextPermutation(int[] nums) {\\n        /* 1. Reverse find first number which breaks descending order. */\\n        int i=nums.length-1;\\n        for(; i>=1; i--)\\n            if(nums[i-1]<nums[i]) break;\\n        \\n        /* if no break found in step 1 */\\n        if(i==0){\\n            /* for case \"1\" and \"1111\" */\\n            if(nums.length==1 || nums[0]==nums[1]) return; \\n            /* for case \"54321\" */\\n            int lo=i, hi=nums.length-1; \\n            while(lo<hi) swap(nums, lo++, hi--);\\n            return;\\n        }\\n        \\n        /* 2. Exchange this number with the least number that's greater than this number. */\\n        /* 2.1 Find the least number that's greater using binary search, O(log(nums.length-i)) */\\n        int j = binarySearchLeastGreater(nums, i, nums.length-1, nums[i-1]);\\n        \\n        /* 2.2 Exchange the numbers */\\n        if(j!=-1) swap(nums, i-1, j);\\n        \\n        /* 3. Reverse sort the numbers after the exchanged number. */\\n        int lo=i, hi=nums.length-1;\\n        while(lo<hi) swap(nums, lo++, hi--);\\n    }\\n    \\n    public int binarySearchLeastGreater(int[] nums, int lo, int hi, int key){\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(nums[mid]>key){\\n                lo = mid+1;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        return hi;\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362645,
                "title": "amazon-sde-1-interview-o-n-approach",
                "content": "# **\\u2714 Approach-1 (Brute Force Approach ) O(N! N)**\\n*  **Find all the permutations of the given array/string/vector and then loop to find out the given permutation.**\\n* **Further, print its next permutation. If the given permutation is the last one, then print the first permutation.**\\n# **\\u2714 Approach-2  TC:O(N) SC:O(1)**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int k,j;\\n        for(k=nums.size()-2 ; k>=0 ; k--){               //O(n)          \\n            if(nums[k]<nums[k+1])                   \\n                break;\\n        }\\n//No Breakpoint i.e array is in desc. order already, so we print the\\n//1st permutation by reversing it which results in asc. order.\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());  \\n        }\\n        else{\\n            for(j=nums.size()-1 ; j>k ; j--){           //O(n)\\n                if(nums[j]>nums[k])\\n                    break;\\n            }\\n            swap(nums[k],nums[j]);                      //O(1)\\n            reverse(nums.begin()+k+1,nums.end());       //O(n)\\n        }\\n    }\\n};\\n// Total TC:O(3n)~O(n)  SC:O(1)\\n```\\n* Generally the permutations are in such a way that if we start from end, all the elements will be in sorted order till a specific break point. We need to find that break point element.\\n* Loop through the array starting from end till begin and find out such an element such that ele[i]<ele[i+1], where ele[i] is the break point element.\\n* Now, again loop through the end till i such that ele[j]>ele[i]. So basically we find first element from the end which is greater than ele[i].\\n* Now swap ele[i] and ele[j].\\n* Reverse all the elments after i to get the desired next permutation.\\n\\nThis video helped me. Thanks to @TUF and @Striver\\n[https://www.youtube.com/watch?v=LuLCLgMElus&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=9](http://)\\n\\n# **Please Upvote if it helps !  \\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int k,j;\\n        for(k=nums.size()-2 ; k>=0 ; k--){               //O(n)          \\n            if(nums[k]<nums[k+1])                   \\n                break;\\n        }\\n//No Breakpoint i.e array is in desc. order already, so we print the\\n//1st permutation by reversing it which results in asc. order.\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());  \\n        }\\n        else{\\n            for(j=nums.size()-1 ; j>k ; j--){           //O(n)\\n                if(nums[j]>nums[k])\\n                    break;\\n            }\\n            swap(nums[k],nums[j]);                      //O(1)\\n            reverse(nums.begin()+k+1,nums.end());       //O(n)\\n        }\\n    }\\n};\\n// Total TC:O(3n)~O(n)  SC:O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376412,
                "title": "narayana-o-n",
                "content": "The algorithm is designed to generate the next permutation, but it can be made cyclic, thereby generating all permutations.\\n\\n# Algorithm\\n1. Find the maximum index $i$ for which $A_i < A_{i+1}$. *(It is optimal to search from the end of the permutation)*\\n2. Find the maximum index $j$ for which $A_j > A_i$. *(It is optimal to search from the end of the permutation)*\\n3. Swap $A_i$ and $A_j$.\\n4. Write the sequence $A_{i+1},...,A_n$ in reverse order.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int i = a.length - 2, j = a.length - 1;\\n\\n        while (i >= 0) {\\n            if (a[i] < a[i+1]) {\\n                break;\\n            } else {\\n                --i;\\n            }\\n        }\\n\\n        if (i == -1) {\\n            for(i = 0; i < a.length / 2; ++i) {\\n                int temp = a[i];\\n                a[i] = a[a.length - i - 1];\\n                a[a.length - i - 1] = temp;\\n            }\\n        } else {\\n            \\n            while (j >= 0) {\\n                if (a[j] > a[i]) {\\n                    break;\\n                } else {\\n                    --j;\\n                }\\n            }\\n\\n            int temp = a[i];\\n            a[i] = a[j];\\n            a[j] = temp;\\n\\n            int shift = i + 1;\\n\\n            for(int k = 0; k < (a.length - shift) / 2; ++k) {\\n                temp = a[shift + k];\\n                a[shift + k] = a[a.length - k - 1];\\n                a[a.length - k - 1] = temp;\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int i = a.length - 2, j = a.length - 1;\\n\\n        while (i >= 0) {\\n            if (a[i] < a[i+1]) {\\n                break;\\n            } else {\\n                --i;\\n            }\\n        }\\n\\n        if (i == -1) {\\n            for(i = 0; i < a.length / 2; ++i) {\\n                int temp = a[i];\\n                a[i] = a[a.length - i - 1];\\n                a[a.length - i - 1] = temp;\\n            }\\n        } else {\\n            \\n            while (j >= 0) {\\n                if (a[j] > a[i]) {\\n                    break;\\n                } else {\\n                    --j;\\n                }\\n            }\\n\\n            int temp = a[i];\\n            a[i] = a[j];\\n            a[j] = temp;\\n\\n            int shift = i + 1;\\n\\n            for(int k = 0; k < (a.length - shift) / 2; ++k) {\\n                temp = a[shift + k];\\n                a[shift + k] = a[a.length - k - 1];\\n                a[a.length - k - 1] = temp;\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902499,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        let n = nums.count\\n        var i = n - 2\\n        while i >= 0, nums[i + 1] <= nums[i] { i -= 1 }\\n        \\n        guard i >= 0 else {\\n            reverse(&nums, start: i + 1, end: n - 1)\\n            return\\n        }\\n        \\n        var j = n - 1\\n        while j >= 0, nums[j] <= nums[i] { j -= 1 }\\n        nums.swapAt(i, j)\\n        reverse(&nums, start: i + 1, end: n - 1)\\n    }\\n    \\n\\n    private func reverse(_ nums: inout [Int], start: Int, end: Int) {\\n        var i = start\\n        var j = end\\n        while i < j {\\n            nums.swapAt(i, j)\\n            i += 1\\n            j -= 1\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        let n = nums.count\\n        var i = n - 2\\n        while i >= 0, nums[i + 1] <= nums[i] { i -= 1 }\\n        \\n        guard i >= 0 else {\\n            reverse(&nums, start: i + 1, end: n - 1)\\n            return\\n        }\\n        \\n        var j = n - 1\\n        while j >= 0, nums[j] <= nums[i] { j -= 1 }\\n        nums.swapAt(i, j)\\n        reverse(&nums, start: i + 1, end: n - 1)\\n    }\\n    \\n\\n    private func reverse(_ nums: inout [Int], start: Int, end: Int) {\\n        var i = start\\n        var j = end\\n        while i < j {\\n            nums.swapAt(i, j)\\n            i += 1\\n            j -= 1\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448059,
                "title": "c-solution-with-explanation-easy-for-beginners",
                "content": "### Approach: (Without 1 liner XD)\\n\\nLet us start by taking an example of test case = [1 , 2 , 4 , 3]\\n\\nLexicographically next permutation would be [1 , 3 , 2 , 4]. \\n\\nHere, we have done 2 things:\\n- Swapped 2 with 3.\\n- Sorted the array after the swapped index.\\n\\nSo precisely, the generalised approach, which comes here in mind is:\\n\\n- Find the index from where we have to swap its value with its next greater value. For this, start from last, just find the index where number is greater than its next index. Say this index as small. \\n- Find the index of number, just greater than the number at the small.\\n- Swap the both values. And sort the array after the swapped index.\\n\\nEdge case: If array is in descending order, then we have to just sort it to ascending.\\n\\nMy submission:\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& number) {\\n        int i = 0;\\n        for(i = number.size() - 1 ; i > 0; i--){        //Finding the index needed to be swapped.\\n            if(number[i] > number[i - 1]){\\n                break;\\n            }\\n        }\\n        if(i == 0){     \\n            reverse(number.begin() , number.end());     // Permutation is in descending order. Sort it to ascending order.\\n        } else {\\n            int x = number[i - 1], small = i;           \\n            for(int j = i + 1; j < number.size(); j++){     //Finding the number just greater than at index needed to be swapped.\\n                if(number[j] > x && number[j] <= number[small]){\\n                    small = j;\\n                }\\n            }\\n            \\n            swap(number[i - 1] , number[small]);        //Swapping the numbers.\\n        \\n            sort(number.begin() + i, number.end());     // Sorting the array after the swapped index.\\n        }\\n    }\\n};\\n```\\n**PLEASE UPVOTE IF YOU LIKED IT, IT REALLY MOTIVATES :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& number) {\\n        int i = 0;\\n        for(i = number.size() - 1 ; i > 0; i--){        //Finding the index needed to be swapped.\\n            if(number[i] > number[i - 1]){\\n                break;\\n            }\\n        }\\n        if(i == 0){     \\n            reverse(number.begin() , number.end());     // Permutation is in descending order. Sort it to ascending order.\\n        } else {\\n            int x = number[i - 1], small = i;           \\n            for(int j = i + 1; j < number.size(); j++){     //Finding the number just greater than at index needed to be swapped.\\n                if(number[j] > x && number[j] <= number[small]){\\n                    small = j;\\n                }\\n            }\\n            \\n            swap(number[i - 1] , number[small]);        //Swapping the numbers.\\n        \\n            sort(number.begin() + i, number.end());     // Sorting the array after the swapped index.\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510520,
                "title": "next-permutation-100-faster-java-solution",
                "content": "**Time  Complexity : `O(n) + O(n) + O(n) \\u2245 O(n)`\\nSpace Complexity : `O(1)`**\\n\\n**O(n)** is for First traversal to find break point, \\n**O(n**) is for Second traversal to swap,\\n**O(n**) is for to reverse\\n\\n*Next Permutation*\\n![image](https://assets.leetcode.com/users/images/e12165af-45ea-4ce4-ac8f-4516144d77e4_1633695069.3101196.gif)\\n\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null || nums.length <= 1)\\n            return;\\n        \\n        int i = nums.length - 2;\\n        while(i>=0 && nums[i] >= nums[i+1])\\n            i--;\\n        \\n        if(i>=0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i])\\n                j--;\\n            \\n          swap(nums, i, j);  \\n        }\\n        \\n        reverse(nums, i+1, nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i, int j){\\n        while(i<j)\\n            swap(nums, i++, j--);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null || nums.length <= 1)\\n            return;\\n        \\n        int i = nums.length - 2;\\n        while(i>=0 && nums[i] >= nums[i+1])\\n            i--;\\n        \\n        if(i>=0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i])\\n                j--;\\n            \\n          swap(nums, i, j);  \\n        }\\n        \\n        reverse(nums, i+1, nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i, int j){\\n        while(i<j)\\n            swap(nums, i++, j--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043674,
                "title": "c-simple-readable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return;\\n        \\n        int i = n-1, j = n-1;\\n        \\n        // Find the largest index i such that nums[i] < nums[i + 1]:\\n        while (i > 0 && nums[i-1] >= nums[i]) i--;\\n        \\n        // If no such index exists - reverse the array and were done:\\n        if (i == 0) {\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // Find the largest index j > i such that nums[i] < nums[j]:\\n        i--;\\n        while (j > i && nums[j] <= nums[i]) j--;\\n        \\n        // Swap nums[i] and nums[j]:\\n        swap(nums[i], nums[j]);\\n        \\n        // Reverse the array from index i until the end:\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return;\\n        \\n        int i = n-1, j = n-1;\\n        \\n        // Find the largest index i such that nums[i] < nums[i + 1]:\\n        while (i > 0 && nums[i-1] >= nums[i]) i--;\\n        \\n        // If no such index exists - reverse the array and were done:\\n        if (i == 0) {\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // Find the largest index j > i such that nums[i] < nums[j]:\\n        i--;\\n        while (j > i && nums[j] <= nums[i]) j--;\\n        \\n        // Swap nums[i] and nums[j]:\\n        swap(nums[i], nums[j]);\\n        \\n        // Reverse the array from index i until the end:\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910716,
                "title": "python-40-ms-and-beat-100-swap-method",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        i = len(nums)-1\\n        while i>0:\\n            if nums[i-1]<nums[i]:\\n                break\\n            i = i-1\\n        i = i-1\\n        j = len(nums)-1\\n        while j>i:\\n            if nums[j]>nums[i]:\\n                break\\n            j=j-1\\n        nums[i],nums[j]=nums[j],nums[i]  \\n        nums[i+1:]=sorted(nums[i+1:]) \\n# Thanks\\n```\\nSimilar method(Problem 1053):-https://leetcode.com/problems/previous-permutation-with-one-swap/discuss/959167/Swap-Method-Python",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        i = len(nums)-1\\n        while i>0:\\n            if nums[i-1]<nums[i]:\\n                break\\n            i = i-1\\n        i = i-1\\n        j = len(nums)-1\\n        while j>i:\\n            if nums[j]>nums[i]:\\n                break\\n            j=j-1\\n        nums[i],nums[j]=nums[j],nums[i]  \\n        nums[i+1:]=sorted(nums[i+1:]) \\n# Thanks\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466198,
                "title": "easy-to-understand-java-solution-1ms-please-upvote",
                "content": "# Intuition\\nIn dictionary consider the names `sam`, `sai` and `sui`. `sai` would be exactly next to sam because it has **`longest prefix match -sa`**. Similarly `sui` will be after `sam` but exactly not after `sam` because it has **`smaller prefix match - s`**. So the permutation with longest prefix match has higher chances of being the next one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Find the breaking index :** \\n      - Breaking index occurs when a dip point is observered in the\\n        pattern of the nums.\\n        \\n        ![next permutation1.jpg](https://assets.leetcode.com/users/images/2c0a6174-3062-4837-be9d-6e1454b59591_1682771631.79299.jpeg)\\n      - `Base codition` occurs when there is no breaking point, this indicates the given nums array is the last permutation. Hence, `reverse` the nums array which gives us our next permutation.\\n      \\n        ![next permutation2.jpg](https://assets.leetcode.com/users/images/15cdbcdd-5553-455c-8a9c-a1cd41272202_1682771975.8683147.jpeg)\\n\\n1. **Finding num just greater than breaking idx :**\\n    - Traverse the nums array `n-1 to idx`, if `nums[i] > nums[idx]->swap`and exit the loop.\\n      \\n    ![next permutation3.jpg](https://assets.leetcode.com/users/images/0be1c019-bd65-4bb9-9be2-cd98f6fda16b_1682772625.132264.jpeg)\\n\\n1. **Reverse the remaining nums array :**\\n    - Reversing is needed because we need the just next Permutation.\\n    \\n    ![next permutation4.jpg](https://assets.leetcode.com/users/images/f20a7a5d-5af7-44c2-9095-f303b961b718_1682772824.645866.jpeg)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length;\\n        // store the breaking point\\n        int idx = -1;\\n\\n        for(int i = n-2 ; i>=0 ; i--) {\\n            if(nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        // base case - no breakpoint found\\n        if(idx == -1) {\\n            Arrays.sort(nums, 0, n);\\n            return;\\n        }\\n\\n\\n        // finding the greater but closest num\\n        for(int i=n-1 ; i>idx ; i--) {\\n            if(nums[i] > nums[idx]) {\\n                int temp = nums[i];\\n                nums[i] = nums[idx];\\n                nums[idx] = temp;\\n                break;\\n            }\\n        }\\n        // Reversing the remaining array.\\n        Arrays.sort(nums, idx+1, n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length;\\n        // store the breaking point\\n        int idx = -1;\\n\\n        for(int i = n-2 ; i>=0 ; i--) {\\n            if(nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        // base case - no breakpoint found\\n        if(idx == -1) {\\n            Arrays.sort(nums, 0, n);\\n            return;\\n        }\\n\\n\\n        // finding the greater but closest num\\n        for(int i=n-1 ; i>idx ; i--) {\\n            if(nums[i] > nums[idx]) {\\n                int temp = nums[i];\\n                nums[i] = nums[idx];\\n                nums[idx] = temp;\\n                break;\\n            }\\n        }\\n        // Reversing the remaining array.\\n        Arrays.sort(nums, idx+1, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416614,
                "title": "c-java-python-javascript-fully-explained-easy-to-understand",
                "content": "# Intuition:\\nThe problem requires finding the next permutation in lexicographic order of the given array. If the given permutation is the largest possible permutation, then the function should return the smallest possible permutation by rearranging the array in ascending order.\\n\\n# Approach:\\nThe algorithm finds the first pair of adjacent elements in the array that satisfy nums[k] < nums[k+1] from the right end of the array. If such a pair does not exist, then the entire array is sorted in descending order, and we need to reverse the entire array to obtain the smallest possible permutation.\\n\\nOtherwise, the algorithm finds the smallest element nums[l] to the right of nums[k] such that nums[l] > nums[k]. We swap nums[k] and nums[l], and then reverse the subarray starting at nums[k+1] to obtain the next lexicographic permutation of the array.\\n\\n# Complexity:\\n- Time complexity: The algorithm performs two passes over the array. The first pass has time complexity O(n), while the second pass also has time complexity O(n). Therefore, the overall time complexity of the algorithm is O(n).\\n\\n- Space complexity: The algorithm uses constant extra space, hence the space complexity of the algorithm is O(1).\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} \\n        else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n# JAVA\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length, k = n - 2, l = n - 1;\\n        while (k >= 0 && nums[k] >= nums[k + 1]) {\\n            k--;\\n        }\\n        if (k < 0) {\\n            reverse(nums, 0, n - 1);\\n        } else {\\n            while (l > k && nums[l] <= nums[k]) {\\n                l--;\\n            }\\n            swap(nums, k, l);\\n            reverse(nums, k + 1, n - 1);\\n        }\\n    }\\n    \\n    private void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i++, j--);\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n# Python\\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        n = len(nums)\\n        k, l = n - 2, n - 1\\n        while k >= 0 and nums[k] >= nums[k + 1]:\\n            k -= 1\\n        if k < 0:\\n            nums.reverse()\\n        else:\\n            while l > k and nums[l] <= nums[k]:\\n                l -= 1\\n            nums[k], nums[l] = nums[l], nums[k]\\n            nums[k + 1:n] = reversed(nums[k + 1:n])\\n\\n```\\n---\\n\\n# JavaScript \\n```\\nvar nextPermutation = function(nums) {\\n    let n = nums.length;\\n    let k, l;\\n    for (k = n - 2; k >= 0; k--) {\\n        if (nums[k] < nums[k + 1]) {\\n            break;\\n        }\\n    }\\n    if (k < 0) {\\n        nums.reverse();\\n    } else {\\n        for (l = n - 1; l > k; l--) {\\n            if (nums[l] > nums[k]) {\\n                break;\\n            }\\n        }\\n        [nums[k], nums[l]] = [nums[l], nums[k]];\\n        nums.splice(k + 1, n - k - 1, ...nums.slice(k + 1).reverse());\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} \\n        else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length, k = n - 2, l = n - 1;\\n        while (k >= 0 && nums[k] >= nums[k + 1]) {\\n            k--;\\n        }\\n        if (k < 0) {\\n            reverse(nums, 0, n - 1);\\n        } else {\\n            while (l > k && nums[l] <= nums[k]) {\\n                l--;\\n            }\\n            swap(nums, k, l);\\n            reverse(nums, k + 1, n - 1);\\n        }\\n    }\\n    \\n    private void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i++, j--);\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        n = len(nums)\\n        k, l = n - 2, n - 1\\n        while k >= 0 and nums[k] >= nums[k + 1]:\\n            k -= 1\\n        if k < 0:\\n            nums.reverse()\\n        else:\\n            while l > k and nums[l] <= nums[k]:\\n                l -= 1\\n            nums[k], nums[l] = nums[l], nums[k]\\n            nums[k + 1:n] = reversed(nums[k + 1:n])\\n\\n```\n```\\nvar nextPermutation = function(nums) {\\n    let n = nums.length;\\n    let k, l;\\n    for (k = n - 2; k >= 0; k--) {\\n        if (nums[k] < nums[k + 1]) {\\n            break;\\n        }\\n    }\\n    if (k < 0) {\\n        nums.reverse();\\n    } else {\\n        for (l = n - 1; l > k; l--) {\\n            if (nums[l] > nums[k]) {\\n                break;\\n            }\\n        }\\n        [nums[k], nums[l]] = [nums[l], nums[k]];\\n        nums.splice(k + 1, n - k - 1, ...nums.slice(k + 1).reverse());\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163376,
                "title": "python-c-easy-to-understand-no-recursion",
                "content": "# Approach\\n- From the right end of our list, we first discover the first decreasing element here.\\nThe next part is only a little bit bigger than the one we discovered from the right end.\\n- Next, switch the elements.\\n- And the reverse end of it.\\n\\nPlease do check it out because it is easier to understand after seeing the code.\\nIf you find it understandable, please give Heartly an upvote.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code :\\n### Python\\n```\\nclass Solution:\\n    def nextPermutation(self, s: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # s = list(s)\\n        i = len(s) - 2\\n        while i >= 0 and s[i + 1] <= s[i]:\\n            i -= 1\\n\\n        if i >= 0:\\n            j = len(s) - 1\\n            while s[j] <= s[i]:\\n                j -= 1\\n            (s[i], s[j]) = (s[j], s[i])\\n\\n        s[::] = s[:i + 1] + s[i + 1:][::-1]\\n```\\n### C++\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-2;\\n        while(i>=0 && nums[i+1]<=nums[i]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int j=nums.size()-1;\\n            while(nums[j]<=nums[i]){\\n                j--;\\n            }\\n            swap(nums , i ,j);\\n        }\\n        reverse(nums.begin()+i+1,nums.end());\\n    }\\n    void swap(vector<int> &nums , int i,int j){\\n        nums[i]^=nums[j];\\n        nums[j]^=nums[i];\\n        nums[i]^=nums[j];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, s: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # s = list(s)\\n        i = len(s) - 2\\n        while i >= 0 and s[i + 1] <= s[i]:\\n            i -= 1\\n\\n        if i >= 0:\\n            j = len(s) - 1\\n            while s[j] <= s[i]:\\n                j -= 1\\n            (s[i], s[j]) = (s[j], s[i])\\n\\n        s[::] = s[:i + 1] + s[i + 1:][::-1]\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-2;\\n        while(i>=0 && nums[i+1]<=nums[i]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int j=nums.size()-1;\\n            while(nums[j]<=nums[i]){\\n                j--;\\n            }\\n            swap(nums , i ,j);\\n        }\\n        reverse(nums.begin()+i+1,nums.end());\\n    }\\n    void swap(vector<int> &nums , int i,int j){\\n        nums[i]^=nums[j];\\n        nums[j]^=nums[i];\\n        nums[i]^=nums[j];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804608,
                "title": "python-simple-solution-explained-code-video",
                "content": "https://www.youtube.com/watch?v=4wlBBRo4tYY\\n[](https://www.youtube.com/watch?v=4wlBBRo4tYY)\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        if length <= 2:\\n            return nums.reverse()\\n        pointer = length - 2\\n        \\n        while pointer >= 0 and nums[pointer] >= nums[pointer + 1]:\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            return nums.reverse()\\n        \\n        for x in range(length - 1, pointer, -1):\\n            if nums[pointer] < nums[x]:\\n                nums[pointer], nums[x] = nums[x], nums[pointer]\\n                break\\n        \\n        nums[pointer + 1:] = reversed(nums[pointer + 1:])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        if length <= 2:\\n            return nums.reverse()\\n        pointer = length - 2\\n        \\n        while pointer >= 0 and nums[pointer] >= nums[pointer + 1]:\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            return nums.reverse()\\n        \\n        for x in range(length - 1, pointer, -1):\\n            if nums[pointer] < nums[x]:\\n                nums[pointer], nums[x] = nums[x], nums[pointer]\\n                break\\n        \\n        nums[pointer + 1:] = reversed(nums[pointer + 1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213704,
                "title": "rust",
                "content": "```\\nfn next_permutation(nums: &mut [i32]) {\\n    if let Some(i) = (1..nums.len()).rev().find(|&i| nums[i - 1] < nums[i]) {\\n        let j = (i..nums.len()).rev().find(|&j| nums[i - 1] < nums[j]).unwrap();\\n        nums.swap(i - 1, j);\\n        nums[i..].reverse();\\n    } else {\\n        nums.reverse();\\n    };\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfn next_permutation(nums: &mut [i32]) {\\n    if let Some(i) = (1..nums.len()).rev().find(|&i| nums[i - 1] < nums[i]) {\\n        let j = (i..nums.len()).rev().find(|&j| nums[i - 1] < nums[j]).unwrap();\\n        nums.swap(i - 1, j);\\n        nums[i..].reverse();\\n    } else {\\n        nums.reverse();\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228834,
                "title": "one-liner",
                "content": "// C++\\n\\t\\n\\t\\n\\tvoid nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "// C++\\n\\t\\n\\t\\n\\tvoid nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1908665,
                "title": "python-easy-nlogn-solution",
                "content": "Steps I followed:\\n\\t1. Find the **latest peak** in the array *(A peak is an element that is greater that the previous element in the array)*\\n\\t\\t\\t2. If a peak is not found: it means it is in reverse order we just need to revert the array\\n\\t3. If a peak is found: it means we can rearrange the array and build a next permutation\\n\\t\\t4. Iterate from the **latest peak** to the end of the array and find the min value in that subarray that is **greater** than the previous of the latest peak! This because we want to build the next greater permutation\\n\\t\\t5. Swap the min value after the peak and the element previous the peak\\n\\t\\t6. Sort the array from the latest_peak to the end of the array\\n\\nTime complexity = O(nlogn)\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        latest_peak = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                latest_peak = i\\n                \\n        if latest_peak == 0:\\n            nums.reverse()\\n            return\\n        \\n        pre_peak = latest_peak - 1\\n        min_after_peak = latest_peak\\n        for i in range(latest_peak, len(nums)):\\n            if nums[i] > nums[pre_peak] and nums[i] < nums[min_after_peak]:\\n                min_after_peak = i\\n          \\n        temp = nums[pre_peak]\\n        nums[pre_peak] = nums[min_after_peak]\\n        nums[min_after_peak] = temp\\n        \\n        nums[latest_peak:] = sorted(nums[latest_peak:])\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Steps I followed:\\n\\t1. Find the **latest peak** in the array *(A peak is an element that is greater that the previous element in the array)*\\n\\t\\t\\t2. If a peak is not found: it means it is in reverse order we just need to revert the array\\n\\t3. If a peak is found: it means we can rearrange the array and build a next permutation\\n\\t\\t4. Iterate from the **latest peak** to the end of the array and find the min value in that subarray that is **greater** than the previous of the latest peak! This because we want to build the next greater permutation\\n\\t\\t5. Swap the min value after the peak and the element previous the peak\\n\\t\\t6. Sort the array from the latest_peak to the end of the array\\n\\nTime complexity = O(nlogn)\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        latest_peak = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                latest_peak = i\\n                \\n        if latest_peak == 0:\\n            nums.reverse()\\n            return\\n        \\n        pre_peak = latest_peak - 1\\n        min_after_peak = latest_peak\\n        for i in range(latest_peak, len(nums)):\\n            if nums[i] > nums[pre_peak] and nums[i] < nums[min_after_peak]:\\n                min_after_peak = i\\n          \\n        temp = nums[pre_peak]\\n        nums[pre_peak] = nums[min_after_peak]\\n        nums[min_after_peak] = temp\\n        \\n        nums[latest_peak:] = sorted(nums[latest_peak:])\\n",
                "codeTag": "Java"
            },
            {
                "id": 1687454,
                "title": "easy-to-understand-with-comments-c-o-n",
                "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        /*Step and intituitions to be followed:\\n        \\n        Step 1: Find a break point from last where a single element is not in incresing order \\n            i.e, ar[i] < ar[i+1] and keep that index such as ind1\\n        \\n        Step 2: Find again from last that which element is just greater than ind1 \\n            as to follow the dictionary order to place bigger element than ind1 and name ind2\\n            \\n        Step 3: Swap ar[ind1] and ar[ind2]\\n            \\n        Step 4: Reverse from the next elemnt of ind1 i.e, ind1 + 1 to last of the array\\n            \\n        Edge Case: If the array is already increasing order from the last then just reverse it. */\\n        \\n        int n = nums.size();\\n        int k; //to find break point\\n        int l; // to traverse from last and find the greater element han break point\\n        \\n        for(k=n-2; k>=0; k--) //step 1\\n        {\\n            if(nums[k] < nums[k+1])\\n                break;\\n        }\\n        \\n        if(k < 0) //edge case\\n            reverse(nums.begin(), nums.end());\\n        else\\n        {\\n            for(l=n-1; l>k; l--) //step 2\\n            {\\n                if(nums[l] > nums[k])\\n                    break;\\n            }\\n            \\n            swap(nums[k], nums[l]); //step 3\\n        \\n            reverse(nums.begin() + k + 1, nums.end()); //step 4\\n        }              \\n\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        /*Step and intituitions to be followed:\\n        \\n        Step 1: Find a break point from last where a single element is not in incresing order \\n            i.e, ar[i] < ar[i+1] and keep that index such as ind1\\n        \\n        Step 2: Find again from last that which element is just greater than ind1 \\n            as to follow the dictionary order to place bigger element than ind1 and name ind2\\n            \\n        Step 3: Swap ar[ind1] and ar[ind2]\\n            \\n        Step 4: Reverse from the next elemnt of ind1 i.e, ind1 + 1 to last of the array\\n            \\n        Edge Case: If the array is already increasing order from the last then just reverse it. */\\n        \\n        int n = nums.size();\\n        int k; //to find break point\\n        int l; // to traverse from last and find the greater element han break point\\n        \\n        for(k=n-2; k>=0; k--) //step 1\\n        {\\n            if(nums[k] < nums[k+1])\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 557285,
                "title": "what-does-this-problem-mean",
                "content": "I\\'m having trouble understanding what this problem is asking. \\n\\nDoes\\n```\\n[1,2,3] -> [1,3,2]\\n```\\nbecause 3 comes after 2 lexographically?\\n\\nI put in my own example\\n```\\n[2,3,1] -> [3,1,2]\\n```\\n\\nWhy is [3,1,2] the output? a valid permutation is `[2,1,3]` but because this is not lexographically greater than `[2,3,1]` is that why `[3,1,2]` is the answer? Why isn\\'t `[3,2,1]` the lexographically next greater permutation?\\n\\n",
                "solutionTags": [],
                "code": "```\\n[1,2,3] -> [1,3,2]\\n```\n```\\n[2,3,1] -> [3,1,2]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 162049,
                "title": "explanations-java-python",
                "content": "**Thought**\\n* How do we catch the next bigger given current sequence?\\nWe \\u201Cincrease\\u201D the current sequence as little as possible. \\n* Which element should we modify?\\n**The element to the left of the longest suffix that is non-increasing** (becase this suffix is already the biggest so we cannot make a bigger permutation just by modifying it). We call it the `fisrtInc`. \\n* Since `fisrtInc` can only be modified by swapping with another element, which element should it be swapped with? \\n**The smallest element in the suffix that is greater than the fisrtInc** (then the prefix is minimized).\\n* Since we increased the prefix, we want to make the new suffix as low as possible. How ?\\n**We sort the suffix in non-decreasing order**. In fact, we can avoid sorting and simply reverse the suffix, because the replaced element respects the decreasing order.\\n\\n**Java**\\n```\\n    public void nextPermutation(int[] nums) {\\n        \\n        int n = nums.length;\\n        int firstInc = n - 2; // The first index which is smaller than its next element.\\n        \\n        while (firstInc >= 0 && nums[firstInc] >= nums[firstInc + 1]) {\\n            firstInc--;\\n        }\\n        \\n        if (firstInc != -1) { // firstInc == -1 if nums is decreasing.\\n            for (int i = n - 1; i > firstInc; i--)\\n                if (nums[i] > nums[firstInc]) {\\n                    swap(nums, firstInc, i);  \\n                    break;\\n                }\\n        }\\n\\n        reverse(nums, firstInc + 1, n - 1);           \\n    }\\n    \\n    private void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"      \\n        first_inc = len(nums) - 2\\n        \\n        while first_inc >= 0 and nums[first_inc] >= nums[first_inc + 1]:\\n            first_inc -= 1\\n    \\n        if first_inc != -1:  # nums is not non-increasing as a whole\\n            for i in range(len(nums) - 1, first_inc, -1):\\n                if nums[i] > nums[first_inc]:\\n                    nums[first_inc], nums[i] = nums[i], nums[first_inc]\\n                    break\\n    \\n        nums[first_inc + 1: len(nums)] = nums[first_inc + 1: len(nums)][::-1]\\n```\\n\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\n    public void nextPermutation(int[] nums) {\\n        \\n        int n = nums.length;\\n        int firstInc = n - 2; // The first index which is smaller than its next element.\\n        \\n        while (firstInc >= 0 && nums[firstInc] >= nums[firstInc + 1]) {\\n            firstInc--;\\n        }\\n        \\n        if (firstInc != -1) { // firstInc == -1 if nums is decreasing.\\n            for (int i = n - 1; i > firstInc; i--)\\n                if (nums[i] > nums[firstInc]) {\\n                    swap(nums, firstInc, i);  \\n                    break;\\n                }\\n        }\\n\\n        reverse(nums, firstInc + 1, n - 1);           \\n    }\\n    \\n    private void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n```\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"      \\n        first_inc = len(nums) - 2\\n        \\n        while first_inc >= 0 and nums[first_inc] >= nums[first_inc + 1]:\\n            first_inc -= 1\\n    \\n        if first_inc != -1:  # nums is not non-increasing as a whole\\n            for i in range(len(nums) - 1, first_inc, -1):\\n                if nums[i] > nums[first_inc]:\\n                    nums[first_inc], nums[i] = nums[i], nums[first_inc]\\n                    break\\n    \\n        nums[first_inc + 1: len(nums)] = nums[first_inc + 1: len(nums)][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14013,
                "title": "my-12ms-c-solution-only-15lines",
                "content": "    class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int index = 0,swapindex = 0;\\n            for (int i = 1; i < nums.size(); i++)\\n                if  (nums[i - 1] < nums[i])\\n                    index = i;\\n            if (index > 0){\\n                int i = nums.size() - 1;\\n                while (i > (index - 1) && nums[index-1] >= nums[i]) i--;\\n                swap(nums[index - 1],nums[i]);\\n            }\\n            sort(nums.begin() + index,nums.end());\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int index = 0,swapindex = 0;\\n            for (int i = 1; i < nums.size(); i++)\\n                if  (nums[i - 1] < nums[i])\\n                    index = i;\\n            if (index > 0){\\n                int i = nums.size() - 1;\\n                while (i > (index - 1) && nums[index-1] >= nums[i]) i--;\\n                swap(nums[index - 1],nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 14030,
                "title": "simple-java-solution-for-your-reference",
                "content": "    public void nextPermutation(int[] num) {\\n        for(int i = num.length-1; i > 0; i--) {\\n            if(num[i-1] < num[i]) {\\n                Arrays.sort(num, i, num.length);\\n                for(int j = i; j < num.length; j++) {\\n                    if(num[j] > num[i-1]) {\\n                       // swap num[i-1] and num[j]\\n                        num[i-1] = num[i-1] + num[j];\\n                        num[j] = num[i-1] - num[j];\\n                        num[i-1] = num[i-1] - num[j];\\n                        return;\\n                    }\\n                }\\n            }\\n        }\\n        Arrays.sort(num);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void nextPermutation(int[] num) {\\n        for(int i = num.length-1; i > 0; i--) {\\n            if(num[i-1] < num[i]) {\\n                Arrays.sort(num, i, num.length);\\n                for(int j = i; j < num.length; j++) {\\n                    if(num[j] > num[i-1]) {\\n                       // swap num[i-1] and num[j]\\n                        num[i-1] = num[i-1] + num[j];\\n                        num[j] = num[i-1] - num[j];\\n                        num[i-1] = num[i-1] - num[j];\\n                        return;\\n                    }\\n                }\\n            }\\n        }\\n        Arrays.sort(num);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14111,
                "title": "share-my-python-code-and-explain-how-to-get-the-solution",
                "content": "It's not easy to find a rule for this question. \\n\\nAnd I think the example is not good.\\n\\nExamples here:\\n\\n1243\\n=> 12 43 (2 is the first num who is less than the next), and the num split to two parts, left: [1,2], right: [4,3]\\n\\n=> 13 42 (swap 2 with 3, because 3 is the first num greater than 2).\\n\\n=> 13 24 sort right. 13, 42 sorted to 24.\\n\\n=> 1324 merge left, right.\\n\\nAnother more complex example:\\n1342\\n=>13 42 split to left: 13  right: 42 (3 is the first num less than next);\\n\\n=>14 32 swap 3 and 4, because in the right part, 4 is the first num greater than 3, from right ->left scan.\\n\\n=>14 23 sort right part,  (**That's why we need to sort the right part**).\\n\\n=>1423 merge them \\n\\n\\n    class Solution:\\n    # @param num, a list of integer\\n    # @return a list of integer\\n    def nextPermutation(self, num):\\n        if(len(num)<=1):return num;\\n        else:\\n            splitIdx=-1;\\n            for i in range(len(num)-2,-1,-1):\\n                if(num[i]<num[i+1]):\\n                    splitIdx=i;\\n                    break;\\n            replaceIdx=len(num)-1;\\n            while(replaceIdx > splitIdx):\\n                if(num[replaceIdx]>num[splitIdx]):\\n                    break;\\n                replaceIdx-=1;\\n\\n            num[replaceIdx],num[splitIdx]=num[splitIdx],num[replaceIdx];\\n            \\n            right=num[splitIdx+1:];\\n            right=sorted(right);            \\n            return num[0:splitIdx+1]+right;",
                "solutionTags": [
                    "Python"
                ],
                "code": "It's not easy to find a rule for this question. \\n\\nAnd I think the example is not good.\\n\\nExamples here:\\n\\n1243\\n=> 12 43 (2 is the first num who is less than the next), and the num split to two parts, left: [1,2], right: [4,3]\\n\\n=> 13 42 (swap 2 with 3, because 3 is the first num greater than 2).\\n\\n=> 13 24 sort right. 13, 42 sorted to 24.\\n\\n=> 1324 merge left, right.\\n\\nAnother more complex example:\\n1342\\n=>13 42 split to left: 13  right: 42 (3 is the first num less than next);\\n\\n=>14 32 swap 3 and 4, because in the right part, 4 is the first num greater than 3, from right ->left scan.\\n\\n=>14 23 sort right part,  (**That's why we need to sort the right part**).\\n\\n=>1423 merge them \\n\\n\\n    class Solution:\\n    # @param num, a list of integer\\n    # @return a list of integer\\n    def nextPermutation(self, num):\\n        if(len(num)<=1):return num;\\n        else:\\n            splitIdx=-1;\\n            for i in range(len(num)-2,-1,-1):\\n                if(num[i]<num[i+1]):\\n                    splitIdx=i;\\n                    break;\\n            replaceIdx=len(num)-1;\\n            while(replaceIdx > splitIdx):\\n                if(num[replaceIdx]>num[splitIdx]):\\n                    break;\\n                replaceIdx-=1;\\n\\n            num[replaceIdx],num[splitIdx]=num[splitIdx],num[replaceIdx];\\n            \\n            right=num[splitIdx+1:];\\n            right=sorted(right);            \\n            return num[0:splitIdx+1]+right;",
                "codeTag": "Java"
            },
            {
                "id": 3797205,
                "title": "next-permutation-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/f0f088c6-8c8a-47ce-9461-10000fbb3af4_1689949086.1759074.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483577,
                "title": "o-n-time-and-o-1-space-easiest-beginner-friendly-solution",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem :\\n```\\narr : [2,5,8,4,7,6,3] -> nextPermutation : [2,5,8,6,3,4,7]\\n\\n1. In below image arr[i] and arr[i+1] = 4 and 7. so, i = 3.\\n2. In below image arr[i] and arr[j] = 4 and 6. So, j = 5.\\n3. swap arr[i] and arr[j]. So, our new array will be [2,5,8,6,7,4,3]\\n4. reverse i+1 to n-1. So, our final array will be [2,5,8,6,3,4,7] which is the next permutaion of given array \\n\\n**NOTE : THE ABOVE 4 STEPS IS SAME AS BELOW EXPLAINED APPROACH.**\\n                             8\\n                            / \\\\\\n                           /   \\\\       7\\n                          /     \\\\     / \\\\\\n                         /       \\\\   /   6\\n                        5         \\\\ /     \\\\\\n                       /           4       \\\\\\n                      /                     \\\\\\n                     /                       3\\n                    /\\n                   2\\n```\\n1. *Find the first element from the right that is smaller than its adjacent element. This is the first element that can be swapped with a larger element to its right to create a greater permutation.*\\n    - int i = n - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) {\\n            i--;\\n        }\\n2. *If such an element is found, find the smallest element to the right of it that is larger than it.*\\n    - int j = n - 1;\\n        while (j >= 0 && nums[i] >= nums[j]) {\\n            j--;\\n        }\\n3. *Swap these two elements.*\\n    - swap(nums[i], nums[j]); \\n4. *Reverse the subarray to the right of the swapped element. This is because the elements to the right of the swapped element are in descending order, and reversing them creates the smallest possible permutation that is greater than the original one.*\\n    - reverse(nums.begin() + i + 1, nums.end()); \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Find the first element from the right that is smaller(nums[i]) than its adjacent(nums[i+1]) element\\n        int i = n - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) {\\n            i--;\\n        }\\n        \\n        // If such an element(nums[i]) is found, find the smallest element(nums[j]) to the right of it(nums[i]) that is just larger than it(nums[i]).\\n        if (i >= 0) {\\n            int j = n - 1;\\n            while (j >= 0 && nums[i] >= nums[j]) {\\n                j--;\\n            }\\n            // Swap the two elements\\n            swap(nums[i], nums[j]);\\n        }\\n        \\n        // Reverse the subarray to the right of the swapped element\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O(n)**, where n is the length of the input vector nums. This is because we traverse the vector from right to left at most once to find the first element that is smaller than its adjacent element and from right to left again to find the smallest element to the right of the element we found in the previous step. Then we reverse the subarray to the right of the swapped element in O(n/2) time. Therefore, the total time complexity is **O(n) + O(n) + O(n/2) = O(n)**.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(1)**. We use constant extra space throughout the algorithm.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\narr : [2,5,8,4,7,6,3] -> nextPermutation : [2,5,8,6,3,4,7]\\n\\n1. In below image arr[i] and arr[i+1] = 4 and 7. so, i = 3.\\n2. In below image arr[i] and arr[j] = 4 and 6. So, j = 5.\\n3. swap arr[i] and arr[j]. So, our new array will be [2,5,8,6,7,4,3]\\n4. reverse i+1 to n-1. So, our final array will be [2,5,8,6,3,4,7] which is the next permutaion of given array \\n\\n**NOTE : THE ABOVE 4 STEPS IS SAME AS BELOW EXPLAINED APPROACH.**\\n                             8\\n                            / \\\\\\n                           /   \\\\       7\\n                          /     \\\\     / \\\\\\n                         /       \\\\   /   6\\n                        5         \\\\ /     \\\\\\n                       /           4       \\\\\\n                      /                     \\\\\\n                     /                       3\\n                    /\\n                   2\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Find the first element from the right that is smaller(nums[i]) than its adjacent(nums[i+1]) element\\n        int i = n - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) {\\n            i--;\\n        }\\n        \\n        // If such an element(nums[i]) is found, find the smallest element(nums[j]) to the right of it(nums[i]) that is just larger than it(nums[i]).\\n        if (i >= 0) {\\n            int j = n - 1;\\n            while (j >= 0 && nums[i] >= nums[j]) {\\n                j--;\\n            }\\n            // Swap the two elements\\n            swap(nums[i], nums[j]);\\n        }\\n        \\n        // Reverse the subarray to the right of the swapped element\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269908,
                "title": "shortest-2-pointer-5-lines-compact-solution-c-easy-explained",
                "content": "# Intuition\\nEvery lexicographic sequence has increasing order. We aim to get a peak from where the increasing sequence starts.\\n\\n# Approach\\n1. From the right, find an element (i) which is greater than its previous element (i-1).\\n2. If no such number is found, it means that array is in highest possible order. So return the reverse of the array (To rearrange it in lowest possible order).\\n3. Now from the right, find an element (j) which is greater than (i-1).\\n4. Swap (i-1) and (j).\\n5. Reverse the array after (i-1), i.e. From (i) till end. (Here we are resetting the number after finding the peak).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-1,j=nums.size()-1;\\n        while(i && nums[i-1]>=nums[i]) i--;\\n        if(!i) return reverse(nums.begin(),nums.end());\\n        while(nums[i-1]>=nums[j]) j--;\\n        swap(nums[i-1],nums[j]);\\n        return reverse(nums.begin()+i,nums.end());\\n    }\\n};\\n```\\n---\\n---\\n![3bjfi3.jpg](https://assets.leetcode.com/users/images/615d7731-d013-4da8-9502-8af799911cc5_1678215934.355254.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-1,j=nums.size()-1;\\n        while(i && nums[i-1]>=nums[i]) i--;\\n        if(!i) return reverse(nums.begin(),nums.end());\\n        while(nums[i-1]>=nums[j]) j--;\\n        swap(nums[i-1],nums[j]);\\n        return reverse(nums.begin()+i,nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731188,
                "title": "next-permutation-very-easy-to-understand-much-better-in-terms-of-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) \\n    {\\n        \\n    int k=0;\\n    int l=0;\\n        \\n    int n=v.size();\\n        \\n    for(k=n-2;k>=0;k--)\\n    {\\n        if(v[k+1]>v[k])\\n        {\\n            break;\\n        }\\n    }\\n    \\n    if(k<=-1)\\n    {\\n        reverse(v.begin(),v.end());\\n    }\\n    else if(k>=0)\\n    {\\n        \\n        for(l=n-1;l>=0;l--)\\n        {\\n            if(v[l]>v[k])\\n            {\\n                break;\\n            }\\n        }\\n        \\n        swap(v[l],v[k]);\\n        \\n        reverse(v.begin()+k+1,v.end());\\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) \\n    {\\n        \\n    int k=0;\\n    int l=0;\\n        \\n    int n=v.size();\\n        \\n    for(k=n-2;k>=0;k--)\\n    {\\n        if(v[k+1]>v[k])\\n        {\\n            break;\\n        }\\n    }\\n    \\n    if(k<=-1)\\n    {\\n        reverse(v.begin(),v.end());\\n    }\\n    else if(k>=0)\\n    {\\n        \\n        for(l=n-1;l>=0;l--)\\n        {\\n            if(v[l]>v[k])\\n            {\\n                break;\\n            }\\n        }\\n        \\n        swap(v[l],v[k]);\\n        \\n        reverse(v.begin()+k+1,v.end());\\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908381,
                "title": "next-permutation-easy-solution-java",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n      if(nums == null || nums.length <= 1) return;\\n      int i = nums.length - 2;\\n      while(i >= 0 && nums[i] >= nums[i + 1]) i--; \\n      if(i >= 0) {                          \\n        int j = nums.length - 1;           \\n        while(nums[j] <= nums[i]) j--;           \\n        swap(nums, i, j);                     \\n    }\\n    reverse(nums, i + 1, nums.length - 1);       \\n}\\n\\npublic void swap(int[] nums, int i, int j) {\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n\\npublic void reverse(int[] nums, int i, int j) {\\n    while(i < j) \\n      swap(nums, i++, j--);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n      if(nums == null || nums.length <= 1) return;\\n      int i = nums.length - 2;\\n      while(i >= 0 && nums[i] >= nums[i + 1]) i--; \\n      if(i >= 0) {                          \\n        int j = nums.length - 1;           \\n        while(nums[j] <= nums[i]) j--;           \\n        swap(nums, i, j);                     \\n    }\\n    reverse(nums, i + 1, nums.length - 1);       \\n}\\n\\npublic void swap(int[] nums, int i, int j) {\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n\\npublic void reverse(int[] nums, int i, int j) {\\n    while(i < j) \\n      swap(nums, i++, j--);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887933,
                "title": "python-simple-intutive-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \"\"\"\\n            Since we have to find the next greater permutation of array, we can think greedly by modifying only that part of array which will contribute in detemining the next greater permutation.\\n            Now, to determine the contributing sub-array, consider the below examples:\\n                - [1,2,3,4,5] -(next greater permutation)> [1,2,3,5,4]\\n                - [1,2,5,3,4] -(next greater permutation)> [1,2,5,4,3]\\n                - [1,2,4,3,5] -(next greater permutation)> [1,2,4,5,3]\\n                - [1,2,4,5,3] -(next greater permutation)> [1,2,5,4,3]->[1,2,5,3,4]\\n                - [1,3,5,4,2] -(next greater permutation)> [1,4,5,3,2]->[1,4,2,3,5]\\n                - [5,4,3,2,1] -(next greater permutation)> [1,2,3,4,5]\\n            From the above examples, we can see that if we traverse from end and check for the index(from right) from where the elements are not in descending order-\\n                - If found, it means that this index needs to be updated with the firs greater element from right to get any greater permutation.\\n\\t\\t\\t\\t\\t-  To get the NEXT GREATER PERMUTATION we can reverse the array from next index to end as they were in descending order and by reversing, they will be in ascending order and that would be our next greater permutation.\\n                - Else, Complete array is in descending order so just make it into ascending by reversing it.\\n        \"\"\"\\n        # Check for the index from right from where the array doesn\\'t follows the descending order.\\n        i = len(nums)-2\\n        while i >= 0 and nums[i+1] <= nums[i]:\\n            i -= 1\\n        \\n        # If any such index is found then swap its value with the first greater element from right.\\n        if i >= 0:\\n            j = len(nums)-1\\n            while j >= 0 and nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        \\n        # Reverse the further array items\\n        i += 1\\n        j = len(nums)-1\\n        while i < j:\\n            nums[i], nums[j] = nums[j], nums[i]\\n            i += 1\\n            j -= 1\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \"\"\"\\n            Since we have to find the next greater permutation of array, we can think greedly by modifying only that part of array which will contribute in detemining the next greater permutation.\\n            Now, to determine the contributing sub-array, consider the below examples:\\n                - [1,2,3,4,5] -(next greater permutation)> [1,2,3,5,4]\\n                - [1,2,5,3,4] -(next greater permutation)> [1,2,5,4,3]\\n                - [1,2,4,3,5] -(next greater permutation)> [1,2,4,5,3]\\n                - [1,2,4,5,3] -(next greater permutation)> [1,2,5,4,3]->[1,2,5,3,4]\\n                - [1,3,5,4,2] -(next greater permutation)> [1,4,5,3,2]->[1,4,2,3,5]\\n                - [5,4,3,2,1] -(next greater permutation)> [1,2,3,4,5]\\n            From the above examples, we can see that if we traverse from end and check for the index(from right) from where the elements are not in descending order-\\n                - If found, it means that this index needs to be updated with the firs greater element from right to get any greater permutation.\\n\\t\\t\\t\\t\\t-  To get the NEXT GREATER PERMUTATION we can reverse the array from next index to end as they were in descending order and by reversing, they will be in ascending order and that would be our next greater permutation.\\n                - Else, Complete array is in descending order so just make it into ascending by reversing it.\\n        \"\"\"\\n        # Check for the index from right from where the array doesn\\'t follows the descending order.\\n        i = len(nums)-2\\n        while i >= 0 and nums[i+1] <= nums[i]:\\n            i -= 1\\n        \\n        # If any such index is found then swap its value with the first greater element from right.\\n        if i >= 0:\\n            j = len(nums)-1\\n            while j >= 0 and nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        \\n        # Reverse the further array items\\n        i += 1\\n        j = len(nums)-1\\n        while i < j:\\n            nums[i], nums[j] = nums[j], nums[i]\\n            i += 1\\n            j -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836471,
                "title": "2-solutions-with-stl-beats-100-non-stl-solution",
                "content": "# STL Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int idx = -1;\\n        int n = nums.size();\\n\\n        for(int i = n-2;i >= 0;i--){\\n            if(nums[i] < nums[i+1]){\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        if(idx == -1){\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        for(int i = n-1;i >= 0;i--){\\n            if(nums[i] > nums[idx]){\\n                swap(nums[i], nums[idx]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + idx + 1, nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int idx = -1;\\n        int n = nums.size();\\n\\n        for(int i = n-2;i >= 0;i--){\\n            if(nums[i] < nums[i+1]){\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        if(idx == -1){\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        for(int i = n-1;i >= 0;i--){\\n            if(nums[i] > nums[idx]){\\n                swap(nums[i], nums[idx]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + idx + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597823,
                "title": "o-n-solution-intuitive-and-easy-explaination",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTreating the array as real number for example [1,2,3] read as 123, the next permutation or the next greater  number that can be formed using these digits is 132 [1,3,2] is thus the next permutation.One thing to observe is that when we move from right to left as soon as we encounter a smaller number we think of swapping it with its just greater number because  we need a number just greater than the given number so using this observation we can loop in reverse order and find a number that is less than the current digit .On the contrary if we get a number greater than the current number then using the digits we cannot form a greater number so we are in search of a smaller number.As soon as it is found we break out from the loop. We then find a just greater number in the right half(already traversed part of the array just now) and swap the dip element with it. As we know if we swap a number greater than the dip element we need the other numbers to be in sorted order in th right half so that the number formed is just greater as the array was already sorted in descending order we just reverse it to get the increasing order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j,n=nums.size();\\n       for(i=n-2;i>=0;i--)\\n       {\\n           if(nums[i]<nums[i+1])\\n                break;\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n       }\\n       else\\n       {\\n            for(j=n-1;j>=i;j--)\\n            {\\n                if(nums[j]>nums[i])\\n                    break;\\n            }\\n           swap(nums[i],nums[j]);\\n           reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j,n=nums.size();\\n       for(i=n-2;i>=0;i--)\\n       {\\n           if(nums[i]<nums[i+1])\\n                break;\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n       }\\n       else\\n       {\\n            for(j=n-1;j>=i;j--)\\n            {\\n                if(nums[j]>nums[i])\\n                    break;\\n            }\\n           swap(nums[i],nums[j]);\\n           reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084401,
                "title": "priority-queue-c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n**First Approach**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), element;\\n        if(n==1){\\n            return;\\n        }\\n        int index=-1;\\n        priority_queue<int> pq;\\n        for(int i=n-1; i>=0; i--){\\n            pq.push(nums[i]);\\n            if(pq.top()!= nums[i]){\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        int check, k = n-1;\\n        bool flag = true;\\n        element = nums[index];\\n        while (!pq.empty()) {\\n            if(pq.top() == element && flag){\\n                check = k+1;\\n                flag = false;\\n            }\\n            nums[k] = pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n\\n    }\\n};\\n```\\n**Second Approach**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1){\\n            return;\\n        }\\n\\n        int index=-1,element,check;\\n        for(int i=n-1; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                index = i-1;\\n                element = nums[i-1];\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        sort(nums.begin() + index, nums.end());\\n        \\n        for(int i=n-1; i>=index; i--){\\n            if(nums[i] == element){\\n                check = i+1;\\n                break;\\n            }\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), element;\\n        if(n==1){\\n            return;\\n        }\\n        int index=-1;\\n        priority_queue<int> pq;\\n        for(int i=n-1; i>=0; i--){\\n            pq.push(nums[i]);\\n            if(pq.top()!= nums[i]){\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        int check, k = n-1;\\n        bool flag = true;\\n        element = nums[index];\\n        while (!pq.empty()) {\\n            if(pq.top() == element && flag){\\n                check = k+1;\\n                flag = false;\\n            }\\n            nums[k] = pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1){\\n            return;\\n        }\\n\\n        int index=-1,element,check;\\n        for(int i=n-1; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                index = i-1;\\n                element = nums[i-1];\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        sort(nums.begin() + index, nums.end());\\n        \\n        for(int i=n-1; i>=index; i--){\\n            if(nums[i] == element){\\n                check = i+1;\\n                break;\\n            }\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075088,
                "title": "javascript-very-very-easy-to-understand-solution",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/Lhsz3BSJEKY\\n\\n# Code\\n```\\nvar nextPermutation = function(nums) {\\n    let swap = (l,r) =>{\\n        [nums[l],nums[r]] = [nums[r],nums[l]]\\n    }\\n    let reverse = (left) =>{\\n        let right = nums.length-1;\\n        while(left<right){\\n            swap(left,right)\\n            left++\\n            right--\\n        }\\n    }\\n\\n    for(let i = nums.length-2; i>=0; i--){\\n        for(let j = nums.length-1; j>i; j--){\\n            if(nums[j] >nums[i]){\\n                swap(i,j);\\n                reverse(i+1)\\n                return;\\n            }\\n        }\\n    }\\n    reverse(0)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nextPermutation = function(nums) {\\n    let swap = (l,r) =>{\\n        [nums[l],nums[r]] = [nums[r],nums[l]]\\n    }\\n    let reverse = (left) =>{\\n        let right = nums.length-1;\\n        while(left<right){\\n            swap(left,right)\\n            left++\\n            right--\\n        }\\n    }\\n\\n    for(let i = nums.length-2; i>=0; i--){\\n        for(let j = nums.length-1; j>i; j--){\\n            if(nums[j] >nums[i]){\\n                swap(i,j);\\n                reverse(i+1)\\n                return;\\n            }\\n        }\\n    }\\n    reverse(0)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910550,
                "title": "concise-in-place-solution-with-no-backtracking",
                "content": "```csharp\\npublic void NextPermutation(int[] arr)\\n{\\n    int i = arr.Length - 2;\\n    while (i >= 0 && arr[i] >= arr[i + 1]) i--;\\n\\n    if (i >= 0)\\n    {\\n        int j = arr.Length - 1;\\n        while (arr[i] >= arr[j]) j--;\\n        (arr[i], arr[j]) = (arr[j], arr[i]);\\n    }\\n    \\n\\tarr.AsSpan(i + 1, arr.Length - i - 1).Reverse();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic void NextPermutation(int[] arr)\\n{\\n    int i = arr.Length - 2;\\n    while (i >= 0 && arr[i] >= arr[i + 1]) i--;\\n\\n    if (i >= 0)\\n    {\\n        int j = arr.Length - 1;\\n        while (arr[i] >= arr[j]) j--;\\n        (arr[i], arr[j]) = (arr[j], arr[i]);\\n    }\\n    \\n\\tarr.AsSpan(i + 1, arr.Length - i - 1).Reverse();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909231,
                "title": "c-1ms-algorithm-explaination",
                "content": "```\\n// Algorithm\\n//  1. find index i that arr[i] < arr[i+1] from end-1 to start of array.\\n//  2. Search for index j that arr[j] > arr[i] from back to start.\\n//  3. Swap (arr[i] > arr[j]).\\n//  4. Reverse Array from index i+1 to End of Array.\\n//  5. In Case we can not find i that means it is a Sorted Array(decreasing) , We have simply reverse Array.\\nclass Solution\\n{\\npublic:\\n    void nextPermutation(vector<int> &arr)\\n    {\\n        int firstIndex = INT_MAX;\\n        for (int i = arr.size() - 2; i >= 0; i--)\\n        {\\n            if (arr[i] < arr[i + 1])\\n            {\\n                firstIndex = i;\\n                break;\\n            }\\n        }\\n        if (firstIndex == INT_MAX)\\n        {\\n            reverse(arr.begin(), arr.end());\\n        }\\n        else\\n        {\\n            int highIndex = INT_MAX;\\n            for (int i = arr.size() - 1; i >= 0; i--)\\n            {\\n                if (arr[i] > arr[firstIndex])\\n                {\\n                    highIndex = i;\\n                    break;\\n                }\\n            }\\n            swap(arr[highIndex], arr[firstIndex]);\\n            reverse(arr.begin() + firstIndex + 1, arr.end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Algorithm\\n//  1. find index i that arr[i] < arr[i+1] from end-1 to start of array.\\n//  2. Search for index j that arr[j] > arr[i] from back to start.\\n//  3. Swap (arr[i] > arr[j]).\\n//  4. Reverse Array from index i+1 to End of Array.\\n//  5. In Case we can not find i that means it is a Sorted Array(decreasing) , We have simply reverse Array.\\nclass Solution\\n{\\npublic:\\n    void nextPermutation(vector<int> &arr)\\n    {\\n        int firstIndex = INT_MAX;\\n        for (int i = arr.size() - 2; i >= 0; i--)\\n        {\\n            if (arr[i] < arr[i + 1])\\n            {\\n                firstIndex = i;\\n                break;\\n            }\\n        }\\n        if (firstIndex == INT_MAX)\\n        {\\n            reverse(arr.begin(), arr.end());\\n        }\\n        else\\n        {\\n            int highIndex = INT_MAX;\\n            for (int i = arr.size() - 1; i >= 0; i--)\\n            {\\n                if (arr[i] > arr[firstIndex])\\n                {\\n                    highIndex = i;\\n                    break;\\n                }\\n            }\\n            swap(arr[highIndex], arr[firstIndex]);\\n            reverse(arr.begin() + firstIndex + 1, arr.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723652,
                "title": "easiest-explanatation-guarantee-with-intuition-c",
                "content": "***Easiest Explanatation Guarantee***\\n\\nSo I will give the algorithm first, then what the algorithm does, and then the intuition\\n\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index1=-1,index2=-1;\\n        for(int i=nums.size()-1;i>0;i--) {\\n            if(nums[i]>nums[i-1]) {\\n                index1=i-1;\\n                break;\\n            }\\n            \\n        }\\n        if(index1!=-1) {\\n            for(int i=nums.size()-1;i>0;i--) {\\n                if(nums[i]>nums[index1]) {\\n                    index2=i;\\n                    break;\\n                }\\n            }\\n            //swap\\n            swap(nums[index1],nums[index2]);\\n            \\n            \\n        }\\n        reverse(nums.begin()+index1 + 1,nums.end());\\nreturn ;\\n    }\\n};\\n```\\n\\n\\nYou can find this algorithm in the all over the discussion section, but here you will find the intuition\\n\\nSee, We convert a permutation into greater lexicographical order by converting the last part into largest lexicographical order\\nFor eg 1 2 4 3 5\\nWe will not change 1 2 till we convert 4 3 5 into the largest order ie 5 4 3 , then only we can change 1 2\\n\\nSo the first step is to find the string from the back which is already in the largest lexicographical order \\nWe do this by finding index1 from the back as all elements after index1 will be in largest lexicographical order.\\neg 1 2 5 4 3 , we will find index1 to be 1 (nums[index1]=2),\\n\\nIn second step we will find element greater than nums[index] to replace it with.\\nIn example we now need to change 2, that is why we start from end because we know the string 5 4 3 will be in descending order\\nWe will find index2 to be 4(nums[index2]=3)\\n\\nAfter that we swap nums[index1] with nums[index2] \\nSo order becomes 1 3 5 4 2 , \\nThen we reverse the 5 4 2 string so as to convert it into smallest order\\n\\nSo order becomes 1 3 2 4 5 \\n\\nPlease do upvote if you find it helpful\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index1=-1,index2=-1;\\n        for(int i=nums.size()-1;i>0;i--) {\\n            if(nums[i]>nums[i-1]) {\\n                index1=i-1;\\n                break;\\n            }\\n            \\n        }\\n        if(index1!=-1) {\\n            for(int i=nums.size()-1;i>0;i--) {\\n                if(nums[i]>nums[index1]) {\\n                    index2=i;\\n                    break;\\n                }\\n            }\\n            //swap\\n            swap(nums[index1],nums[index2]);\\n            \\n            \\n        }\\n        reverse(nums.begin()+index1 + 1,nums.end());\\nreturn ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864025,
                "title": "simple-c-solution-with-explanation-beats-94",
                "content": "```\\n/* The simple intution to solve this problem is to find the index which will get swaped.\\nNow if we dont find any index, that means that the vector is in descending order and \\nhence we must sort it in ascending order and return. Now the simple logic to find the \\nswap index is that it is the number which breaks the ascending order sequence from the right (nums[i-1] < nums[i]) .\\nEx:- 2543, so here 543 is in ascending order from right and 2 breaks the sequence. So 0 will be the swap index. \\nNow to get the next permutation and not any permutation, we must swap the index found previously\\nwith the first element which is greater than the nums[index]. Now we swap the \\ntwo elements. So our swap index now contains an element which is greater than what\\nit had earlier. So now to have the next permutation, we must sort all the elements to its\\nright in ascending order as it will become the minimum possible value that could have\\nbeen formed by replacing the swap index with some value greater than it. \\n\\t\\t\\t\\n\\t\\t\\t\\tPlease upvote, if you find the solution helpful. \\n*/\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        for(int i = nums.size()-1; i>=1; i--)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                index = i-1;\\n                break;\\n            }\\n        }\\n        \\n        if(index == -1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        for(int i = nums.size()-1; i>index; i--)\\n        {\\n            if(nums[i] > nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                sort(nums.begin()+index+1, nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/* The simple intution to solve this problem is to find the index which will get swaped.\\nNow if we dont find any index, that means that the vector is in descending order and \\nhence we must sort it in ascending order and return. Now the simple logic to find the \\nswap index is that it is the number which breaks the ascending order sequence from the right (nums[i-1] < nums[i]) .\\nEx:- 2543, so here 543 is in ascending order from right and 2 breaks the sequence. So 0 will be the swap index. \\nNow to get the next permutation and not any permutation, we must swap the index found previously\\nwith the first element which is greater than the nums[index]. Now we swap the \\ntwo elements. So our swap index now contains an element which is greater than what\\nit had earlier. So now to have the next permutation, we must sort all the elements to its\\nright in ascending order as it will become the minimum possible value that could have\\nbeen formed by replacing the swap index with some value greater than it. \\n\\t\\t\\t\\n\\t\\t\\t\\tPlease upvote, if you find the solution helpful. \\n*/\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        for(int i = nums.size()-1; i>=1; i--)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                index = i-1;\\n                break;\\n            }\\n        }\\n        \\n        if(index == -1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        for(int i = nums.size()-1; i>index; i--)\\n        {\\n            if(nums[i] > nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                sort(nums.begin()+index+1, nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615545,
                "title": "easy-python-solution-o-n-time-w-comments",
                "content": "**notes/assumptions:**\\n- modify in place, no outputs\\n- inputs: list of integers \\n- space: O(1)\\n- no negative integers\\n\\n**approach:**\\n- iterate through nums in reverse order until I find my first decreasing element\\n\\t- if the num @ current index > the num @ previous index \\n\\t\\t- break out of the loop\\n\\n- if index == 0 --> return the reverse of the loop \\n\\n- iterate through nums to find the index of the next element greater than my first decreasing element\\n\\t- swap the elements\\n\\t- reverse the rest of the nums from index of my decreasing element onwards\\n\\n\\n**complexity:**\\n- time: O(n) - we iterate through at most len of nums elements\\n- space: O(1) - modify in place and only use variables to store index\\n\\n\\n``` python\\nclass Solution(object):\\n\\tdef nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n\\t\\t# helper function to reverse the array from particular index\\n        def reverse_from_index(arr, start_idx, end_idx):\\n            while start_idx < end_idx:\\n                arr[start_idx], arr[end_idx] = arr[end_idx], arr[start_idx]\\n                start_idx += 1\\n                end_idx -= 1\\n            \\n        # find the first decreasing element\\n        first_decreasing_index = len(nums) - 1\\n        while first_decreasing_index > 0 and nums[first_decreasing_index] <= nums[first_decreasing_index - 1]:\\n            first_decreasing_index -= 1\\n\\n        # reverse nums because nums is in descending order and return \\n        if first_decreasing_index == 0:\\n            reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n            return\\n\\n        # find the next element greater than the first decreasing element\\n        next_num_index = len(nums) - 1\\n        while next_num_index > 0 and nums[next_num_index] <= nums[first_decreasing_index - 1]: \\n            next_num_index -= 1\\n\\n        # swap the two elements\\n        nums[first_decreasing_index - 1], nums[next_num_index] = nums[next_num_index], nums[first_decreasing_index - 1]\\n\\n        # reverse the rest of the list\\n        reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` python\\nclass Solution(object):\\n\\tdef nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n\\t\\t# helper function to reverse the array from particular index\\n        def reverse_from_index(arr, start_idx, end_idx):\\n            while start_idx < end_idx:\\n                arr[start_idx], arr[end_idx] = arr[end_idx], arr[start_idx]\\n                start_idx += 1\\n                end_idx -= 1\\n            \\n        # find the first decreasing element\\n        first_decreasing_index = len(nums) - 1\\n        while first_decreasing_index > 0 and nums[first_decreasing_index] <= nums[first_decreasing_index - 1]:\\n            first_decreasing_index -= 1\\n\\n        # reverse nums because nums is in descending order and return \\n        if first_decreasing_index == 0:\\n            reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n            return\\n\\n        # find the next element greater than the first decreasing element\\n        next_num_index = len(nums) - 1\\n        while next_num_index > 0 and nums[next_num_index] <= nums[first_decreasing_index - 1]: \\n            next_num_index -= 1\\n\\n        # swap the two elements\\n        nums[first_decreasing_index - 1], nums[next_num_index] = nums[next_num_index], nums[first_decreasing_index - 1]\\n\\n        # reverse the rest of the list\\n        reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561996,
                "title": "java-clean-code-time-o-n-space-o-1",
                "content": "```java\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        if (n == 0) return;\\n        int i = n - 2;\\n        while (i >= 0 && arr[i] >= arr[i+1]) i--; // Find first min point from the right\\n        if (i == -1) {\\n            reverse(arr, 0, n - 1);\\n        } else {\\n            int nextGreaterIndex = i;\\n            for (int j = i + 1; j < n; j++) {\\n                if (arr[j] > arr[i])\\n                    nextGreaterIndex = j;\\n            }\\n            swap(arr, i, nextGreaterIndex);\\n            reverse(arr, i + 1, n - 1);\\n        }\\n    }\\n    void swap(int[] arr, int i, int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    void reverse(int[] arr, int l, int r) {\\n        while (l < r) swap(arr, l++, r--);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        if (n == 0) return;\\n        int i = n - 2;\\n        while (i >= 0 && arr[i] >= arr[i+1]) i--; // Find first min point from the right\\n        if (i == -1) {\\n            reverse(arr, 0, n - 1);\\n        } else {\\n            int nextGreaterIndex = i;\\n            for (int j = i + 1; j < n; j++) {\\n                if (arr[j] > arr[i])\\n                    nextGreaterIndex = j;\\n            }\\n            swap(arr, i, nextGreaterIndex);\\n            reverse(arr, i + 1, n - 1);\\n        }\\n    }\\n    void swap(int[] arr, int i, int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    void reverse(int[] arr, int l, int r) {\\n        while (l < r) swap(arr, l++, r--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248070,
                "title": "java-solution",
                "content": "**Solution 1:**\\n\\n**Intuition:**\\n- A permutation is a rearrangement of the members of the sequence into a new sequence. For example, there are `24` permutations of `[a, b, c, d]`; some of these are \\n`[b, a, d, c]`, `[d, a, b, c]`, and `[a, d, b, c]`.\\n- There exists `n!` permutations of `n` elements. These can totally ordered using the dictionary ordering. We define permutation `p` to appear before `q` if in the first place where `p` and `q` differ in their array representations, the corresponding entry for `p` is less than that for `q`.\\nFor example, `[2, 0, 1] < [2, 1, 0]`. Note that permutation `[0, 1, 2]` is the smallest permutation under dictionary ordering, and `[2, 1, 0]` is the largest permutation under dictionary ordering.\\n- Here the algorithm takes a permutation as an input and returns the next permutation under dictionary ordering. \\nFor example, if the input is `[1, 0, 3 ,2]`, then we return `[1, 2, 0, 3]`.\\n- If the input permutation is the last permutation, then we return the first permutation. \\nFor example, if the input is `[4, 3, 2 ,1]`, then we return `[1, 2, 3, 4]`.\\n---------------------\\n- The key insight is that we want to increase the permutation by as little as possible. Here we can not change the values, only reorder them. We will use input permutation \\n`[6, 2, 1, 5, 4, 3, 0]`.\\n- Specifically, we start from the right, and look at the longest decreasing `suffix`, which is `[5, 4, 3, 0]` for our example. We can not get the next permutation just by modifying this `suffix`, since it is already the maximum it can be.\\n- Instead we look at the entry `e` that appears just before the longest decreasing `suffix`, which is `1` in this case. \\n- If there is no such element, i.e., the longest decreasing `suffix` is the entire input permutation, for which the next permutation is the first permutation. In this case we return reverse of input permutation.\\n- Observe that `e` must be less than some entries in `suffix`, since the entry immediately after `e` is greater than `e`. Intuitively, we should swap `e` with the smallest entry `s` in the `suffix` which is larger than `e` so as to minimize the change to the `prefix`, which is defined to the part of the sequence that appears before the `suffix`.\\nFor example, here `e = 1` and `s = 3` Swapping `s` and `e` results in `[6, 2, 3, 5, 4, 1, 0]`.\\n- We are not done yet, since the new `prefix` is the smallest possible for all permutations greater than the initial permutation, but the new `suffix` may not be the smallest. We can get the smallest `suffix` by sorting the entries in the `suffix` from the smallest to largest. For our working example, this yields the `suffix` `[0, 1, 4, 5]`.\\n- As an optimization, it is not necessary to call the full blown sorting algorithm on `suffix`. Since the `suffix` was initially decreasing, and after replacing `s` by `e` it still remains decreasing, reversing the `suffix` has the effect of sorting it from smallest to largest.\\n---------------------\\n\\n**Algorithm:**\\n1. Find the largest index `i` such that `A[i] < A[i + 1]`. If no such index exists, just reverse `A` and done.\\n2. Find the largest index `j` such that `j > i` and `A[i] < A[j]`.\\n3. Swap `A[i]` and `A[j]`.\\n4. Reverse the sequence after position `i`. i.e. the sub-array `A[i + 1, n]`.\\n\\n- For example, given the sequence `[1, 2, 3, 4]`, which is in increasing order, and given that the index is zero-based, the steps are as follows:\\n  1. Index `i = 2`, because `3` is placed at an index that satisfies condition of being the largest index that is still less than `A[i + 1]` which is `4`.\\n  2. Index `j = 3`, because `4` is the only value in the sequence that is greater than `3` in order to satisfy the condition `A[i] < A[j]`.\\n  3. The values of `A[2]` and `A[3]` are swapped to form the new sequence `[1, 2, 4, 3]`.\\n  4. The sequence after `i` index, i.e. `A[2]` to the final element is reversed. Because only one value lies after this index (the `3`), the sequence remains unchanged in this instance. Thus the lexicographic successor of the initial state is permuted as: `[1, 2, 4, 3]`.\\n\\n- Following this algorithm, the next lexicographic permutation will be `[1, 3, 2, 4]`, and the `24`<sup>th</sup> permutation will be `[4, 3, 2, 1]` at which point `A[i] < A[i + 1]` does not exist, indicating that this is the last permutation.\\n\\n**Time complexity:** `O(N)`\\n**Space complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        int N = A.length;\\n        int i;\\n        int j;\\n\\n        for (i = N - 2; i >= 0; i--) {\\n            if (A[i] < A[i + 1])\\n                break;\\n        }\\n\\n        if (i >= 0) {\\n            for (j = N - 1; j > i; j--) {\\n                if (A[i] < A[j])\\n                    break;\\n            }\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, N - 1);\\n    }\\n\\n    private void reverse(int[] A, int start, int end) {\\n        while (start < end) {\\n            swap(A, start++, end--);\\n        }\\n    }\\n\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        int N = A.length;\\n        int i;\\n        int j;\\n\\n        for (i = N - 2; i >= 0; i--) {\\n            if (A[i] < A[i + 1])\\n                break;\\n        }\\n\\n        if (i >= 0) {\\n            for (j = N - 1; j > i; j--) {\\n                if (A[i] < A[j])\\n                    break;\\n            }\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, N - 1);\\n    }\\n\\n    private void reverse(int[] A, int start, int end) {\\n        while (start < end) {\\n            swap(A, start++, end--);\\n        }\\n    }\\n\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795248,
                "title": "really-simple-solution-everyone-can-understand-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlgorithm / Intuition\\nThe steps are the following:\\n\\nFind the break-point, i: Break-point means the first index i from the back of the given array where arr[i] becomes smaller than arr[i+1].\\nFor example, if the given array is {2,1,5,4,3,0,0}, the break-point will be index 1(0-based indexing). Here from the back of the array, index 1 is the first index where arr[1] i.e. 1 is smaller than arr[i+1] i.e. 5.\\nTo find the break-point, using a loop we will traverse the array backward and store the index i where arr[i] is less than the value at index (i+1) i.e. arr[i+1].\\nIf such a break-point does not exist i.e. if the array is sorted in decreasing order, the given permutation is the last one in the sorted order of all possible permutations. So, the next permutation must be the first i.e. the permutation in increasing order.\\nSo, in this case, we will reverse the whole array and will return it as our answer.\\nIf a break-point exists:\\nFind the smallest number i.e. > arr[i] and in the right half of index i(i.e. from index i+1 to n-1) and swap it with arr[i].\\nReverse the entire right half(i.e. from index i+1 to n-1) of index i. And finally, return the array.\\nNote: For a better understanding of intuition, please watch the video at the bottom of the page.\\n\\n# Dry run\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/a7afeec0-e1c6-4065-a964-f204b2c3cd31_1689915729.846143.png)\\n![image.png](https://assets.leetcode.com/users/images/6ec6a3e9-da9b-42f5-ab15-8e8fac596a35_1689915741.7086728.png)\\n![image.png](https://assets.leetcode.com/users/images/dbbca798-e59f-45c5-86d9-d683129646ac_1689915753.1975505.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity: O(3N), where N = size of the given array\\nFinding the break-point, finding the next greater element, and reversal at the end takes O(N) for each, where N is the number of elements in the input array. This sums up to 3*O(N) which is approximately O(3N).\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity: Since no extra storage is required. Thus, its space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        int ind = -1;\\n        // for finding the break point\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (arr[i] < arr[i + 1]) {\\n                ind = i;\\n                break;\\n            }\\n        }\\n        // if the break point does not exist\\n        if (ind == -1) {\\n            reverse(arr, 0, n - 1);\\n            return;\\n        }\\n        // if the break point exists\\n        int j = n - 1;\\n        for (int i = n - 1; i >= ind + 1; i--) {\\n            if (arr[i] > arr[ind]) {\\n                swap(arr, i, ind);\\n                break;\\n            }\\n        }\\n        // Reverse the entire right half array\\n        reverse(arr, ind + 1, n - 1);\\n    }\\n\\n    // Function for reverse the array\\n    public void reverse(int[] arr, int l, int r) {\\n        int start = l;\\n        int end = r;\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    // Function for swap the elements\\n    public void swap(int[] arr, int i, int j) {\\n        int tem = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tem;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        int ind = -1;\\n        // for finding the break point\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (arr[i] < arr[i + 1]) {\\n                ind = i;\\n                break;\\n            }\\n        }\\n        // if the break point does not exist\\n        if (ind == -1) {\\n            reverse(arr, 0, n - 1);\\n            return;\\n        }\\n        // if the break point exists\\n        int j = n - 1;\\n        for (int i = n - 1; i >= ind + 1; i--) {\\n            if (arr[i] > arr[ind]) {\\n                swap(arr, i, ind);\\n                break;\\n            }\\n        }\\n        // Reverse the entire right half array\\n        reverse(arr, ind + 1, n - 1);\\n    }\\n\\n    // Function for reverse the array\\n    public void reverse(int[] arr, int l, int r) {\\n        int start = l;\\n        int end = r;\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    // Function for swap the elements\\n    public void swap(int[] arr, int i, int j) {\\n        int tem = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tem;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716085,
                "title": "easy-c-solution-o-n-time-complexity-beats-100-in-both",
                "content": "# Code\\n```\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145361,
                "title": "c-easy-explanation-0ms",
                "content": "**Approach to the Problem**\\n\\nLet\\'s understand the problem with an example.\\n```\\n1 2 3 4 \\n```\\nFirstly, we traverse from the end element i.e, 4. \\nFind the pnt where the element is less than the next element. here it is-> 2 as 2<3\\nCode for above two lines:\\n```\\nfor(pnt=n-2;pnt>=0;pnt--){\\nif(nums[pnt]<nums[pnt+1]\\n  break;\\n}\\n```\\nNow if pnt<0 it means the number is in decreasing order and hence, the next permutation will be the reverse of it.\\ncode for it:\\n```\\nif(pnt<0)\\n reverse(nums.begin(),nums.end());\\n```\\nElse check by traversing from the last element the number greater than the number at (pnt) if found then swap them.\\nCode for it:\\n```\\nelse{\\n  for(l=n-1;l>k;l--){\\n\\t if(nums[l]>nums[k])\\n\\t  break;\\n\\t}\\n\\tswap(nums[l],nums[k]);\\n```\\nNow at the end, reverse the sequence starting after pnt and ending at nums end.\\n```\\nreverse(nums.begin()+pnt+1,nums.end());\\n```\\nfor eg. \\n```\\n**1 2 3 4** \\nnext permutation=> **1 2 4 3** => swapped(3,4)\\nnext permutation=> 1 2 4 3 => 1 3 4 2(swapped 2 with 3)=>**1 3 2 4**(reversed the number after 4)\\nnext permutation=>1 3 2 4=> 1 3 4 2(swapped 2 wih 4)\\nnext permutation=>1 3 4 2=>1 4 3 2(swapped 3 with 4)=>**1 4 2 3**(reversed the number after 4)\\n```\\nHere\\'s the whole code \\uD83D\\uDC47\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     int n=nums.size(),pnt,l;\\n     for(pnt=n-2;pnt>=0;pnt--){\\n         if(nums[pnt]<nums[pnt+1]){\\n             break;\\n         }\\n     }\\n     if(pnt<0){\\n         reverse(nums.begin(),nums.end());\\n     }else{\\n         for(l=n-1;l>pnt;l--){\\n             if(nums[l]>nums[pnt]){\\n                 break;\\n             }\\n         }\\n         swap(nums[l],nums[pnt]);\\n         reverse(nums.begin()+pnt+1,nums.end());\\n     }\\n    }\\n};\\n```\\n**IF You Liked the explanation please Upvote it:)**",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\n1 2 3 4 \\n```\n```\\nfor(pnt=n-2;pnt>=0;pnt--){\\nif(nums[pnt]<nums[pnt+1]\\n  break;\\n}\\n```\n```\\nif(pnt<0)\\n reverse(nums.begin(),nums.end());\\n```\n```\\nelse{\\n  for(l=n-1;l>k;l--){\\n\\t if(nums[l]>nums[k])\\n\\t  break;\\n\\t}\\n\\tswap(nums[l],nums[k]);\\n```\n```\\nreverse(nums.begin()+pnt+1,nums.end());\\n```\n```\\n**1 2 3 4** \\nnext permutation=> **1 2 4 3** => swapped(3,4)\\nnext permutation=> 1 2 4 3 => 1 3 4 2(swapped 2 with 3)=>**1 3 2 4**(reversed the number after 4)\\nnext permutation=>1 3 2 4=> 1 3 4 2(swapped 2 wih 4)\\nnext permutation=>1 3 4 2=>1 4 3 2(swapped 3 with 4)=>**1 4 2 3**(reversed the number after 4)\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     int n=nums.size(),pnt,l;\\n     for(pnt=n-2;pnt>=0;pnt--){\\n         if(nums[pnt]<nums[pnt+1]){\\n             break;\\n         }\\n     }\\n     if(pnt<0){\\n         reverse(nums.begin(),nums.end());\\n     }else{\\n         for(l=n-1;l>pnt;l--){\\n             if(nums[l]>nums[pnt]){\\n                 break;\\n             }\\n         }\\n         swap(nums[l],nums[pnt]);\\n         reverse(nums.begin()+pnt+1,nums.end());\\n     }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117786,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       next_permutation(nums.begin() ,nums.end());\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       next_permutation(nums.begin() ,nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716217,
                "title": "python-easy-solution-comments",
                "content": "\\tclass Solution:\\n\\t\\tdef nextPermutation(self, nums: List[int]) -> None:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# 1st Step...\\n\\t\\t\\ti = n-2\\n\\t\\t\\twhile i >= 0 and nums[i] >= nums[i+1]:\\n\\t\\t\\t\\ti -= 1\\n\\t\\t\\t# ...\\n\\n\\t\\t\\tif i < 0:\\n\\t\\t\\t\\t# It shows that all the elements are in descending order.\\n\\t\\t\\t\\tnums[:] = nums[::-1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# 2nd Step...\\n\\t\\t\\t\\tj = n-1\\n\\t\\t\\t\\twhile nums[j] <= nums[i]:\\n\\t\\t\\t\\t\\tj -= 1\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 3rd Step...\\n\\t\\t\\t\\tnums[i], nums[j] = nums[j], nums[i]\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 4th Step...\\n\\t\\t\\t\\tnums[i+1:] = sorted(nums[i+1:])\\n\\t\\t\\t\\t# ...\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef nextPermutation(self, nums: List[int]) -> None:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# 1st Step...\\n\\t\\t\\ti = n-2\\n\\t\\t\\twhile i >= 0 and nums[i] >= nums[i+1]:\\n\\t\\t\\t\\ti -= 1\\n\\t\\t\\t# ...\\n\\n\\t\\t\\tif i < 0:\\n\\t\\t\\t\\t# It shows that all the elements are in descending order.\\n\\t\\t\\t\\tnums[:] = nums[::-1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# 2nd Step...\\n\\t\\t\\t\\tj = n-1\\n\\t\\t\\t\\twhile nums[j] <= nums[i]:\\n\\t\\t\\t\\t\\tj -= 1\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 3rd Step...\\n\\t\\t\\t\\tnums[i], nums[j] = nums[j], nums[i]\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 4th Step...\\n\\t\\t\\t\\tnums[i+1:] = sorted(nums[i+1:])\\n\\t\\t\\t\\t# ...\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1577491,
                "title": "java-detailed-explanation-with-diagram-o-n",
                "content": "The key observation in this algorithm is that when we want to compute the next permutation, we must \\u201Cincrease\\u201D the sequence as little as possible. Just like when we count up using numbers, we try to modify the rightmost elements and leave the left side unchanged.\\n\\nTo find next lexicographically greater permutation of numbers, follow following steps\\n1. Find the index (starting from right ending to left) which breaks the increasing order (nums[index - 1] < nums[index])\\n2. Find the FIRST number starting from right which is GREATER than the number we found at \\'index - 1\\' in step 1\\n3. After the swap, reverse the sequence which is RIGHT of \\'index - 1\\'\\n\\n![image](https://assets.leetcode.com/users/images/74a765af-58c3-4c4d-b284-39190c084e96_1636878412.2445583.png)\\n\\n\\nSource of diagram (good read) : https://www.nayuki.io/page/next-lexicographical-permutation-algorithm\\n\\nTC: O(N) -> all increasing order (worst case)\\nSC: O(1)\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int index = nums.length - 1;\\n        \\n        while(index > 0) {\\n            if(nums[index - 1] < nums[index]) { // find first index from right where the num breaks the increasing order (from right to left)\\n                break;\\n            }\\n            index--;\\n        }\\n        \\n        if(index == 0) { // if we have reached the index 0, this means the given array is in decreasing order so reverse it\\n            reverse(nums, index);\\n            return;\\n        } else {\\n            int val = nums[index - 1];\\n            int idxToSwap = nums.length - 1;\\n            while(idxToSwap > index - 1) {\\n                if(nums[idxToSwap] > val) { // find the first num which is grater than the num at \\'index - 1\\'\\n                    break;\\n                }\\n                idxToSwap--;\\n            }\\n            swap(nums, index - 1, idxToSwap); // swap the num, this will basically ATTEMPT to increase the original number \\'just a little\\'\\n            reverse(nums, index); // this step along with above step will basically increase the original number \\'just a little\\' (basically next lexicographically greater permutation of numbers)\\n            return;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int firstIdx, int secondIdx) {\\n        int temp = nums[firstIdx];\\n        nums[firstIdx] = nums[secondIdx];\\n        nums[secondIdx] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start) {\\n        int end = nums.length - 1;\\n        while(start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int index = nums.length - 1;\\n        \\n        while(index > 0) {\\n            if(nums[index - 1] < nums[index]) { // find first index from right where the num breaks the increasing order (from right to left)\\n                break;\\n            }\\n            index--;\\n        }\\n        \\n        if(index == 0) { // if we have reached the index 0, this means the given array is in decreasing order so reverse it\\n            reverse(nums, index);\\n            return;\\n        } else {\\n            int val = nums[index - 1];\\n            int idxToSwap = nums.length - 1;\\n            while(idxToSwap > index - 1) {\\n                if(nums[idxToSwap] > val) { // find the first num which is grater than the num at \\'index - 1\\'\\n                    break;\\n                }\\n                idxToSwap--;\\n            }\\n            swap(nums, index - 1, idxToSwap); // swap the num, this will basically ATTEMPT to increase the original number \\'just a little\\'\\n            reverse(nums, index); // this step along with above step will basically increase the original number \\'just a little\\' (basically next lexicographically greater permutation of numbers)\\n            return;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int firstIdx, int secondIdx) {\\n        int temp = nums[firstIdx];\\n        nums[firstIdx] = nums[secondIdx];\\n        nums[secondIdx] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start) {\\n        int end = nums.length - 1;\\n        while(start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400124,
                "title": "python-easy-sorting-binary-search-nlogn-time",
                "content": "***PLEASE DO UPVOTE***\\n```\\nfrom heapq import heappush, heappop, heapify\\nclass Solution:\\n    \\n    def find_ceil(self, a,i,j, key):\\n        ans = None\\n        while i<=j:\\n            mid = (i+j)//2\\n            if a[mid] > key: #strictly greater than key\\n                ans = mid\\n                i = mid+1\\n            else:\\n                j = mid-1\\n        return ans\\n    \\n    def sort(self,a, i, j):\\n        heap = []\\n        heapify(heap)\\n        for k in range(i, j+1):\\n            heappush(heap, a[k])\\n        for k in range(i, j+1):\\n            a[k] = heappop(heap)\\n            \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx,n = None, len(nums)\\n        for i in range(n-2,-1,-1):\\n            if nums[i] < nums[i+1]:\\n                idx = i \\n                break\\n        if idx!=None:\\n            idx2 = self.find_ceil(nums, idx+1, n-1, nums[idx])\\n            nums[idx], nums[idx2] = nums[idx2], nums[idx]\\n            self.sort(nums, idx+1, n-1)\\n        else:\\n            nums.sort()\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop, heapify\\nclass Solution:\\n    \\n    def find_ceil(self, a,i,j, key):\\n        ans = None\\n        while i<=j:\\n            mid = (i+j)//2\\n            if a[mid] > key: #strictly greater than key\\n                ans = mid\\n                i = mid+1\\n            else:\\n                j = mid-1\\n        return ans\\n    \\n    def sort(self,a, i, j):\\n        heap = []\\n        heapify(heap)\\n        for k in range(i, j+1):\\n            heappush(heap, a[k])\\n        for k in range(i, j+1):\\n            a[k] = heappop(heap)\\n            \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx,n = None, len(nums)\\n        for i in range(n-2,-1,-1):\\n            if nums[i] < nums[i+1]:\\n                idx = i \\n                break\\n        if idx!=None:\\n            idx2 = self.find_ceil(nums, idx+1, n-1, nums[idx])\\n            nums[idx], nums[idx2] = nums[idx2], nums[idx]\\n            self.sort(nums, idx+1, n-1)\\n        else:\\n            nums.sort()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358174,
                "title": "java-solution-0ms-faster-than-100-submissions",
                "content": "**Please Upvote the Solution if you find it useful!!**\\n\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null||nums.length<=1) return;\\n        \\n        int i = nums.length-2;\\n        while(i>=0 && nums[i]>=nums[i+1]) i--;\\n        \\n        if(i>=0)\\n        {\\n            int j = nums.length-1;\\n            while(nums[j]<=nums[i]) j--;            \\n            swap(nums,i,j);                \\n        }\\n        reverse(nums,i+1,nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;        \\n    }\\n    \\n    public void reverse(int[] nums, int i,int j)\\n    {\\n        while(i<j)\\n        swap(nums,i++,j--);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null||nums.length<=1) return;\\n        \\n        int i = nums.length-2;\\n        while(i>=0 && nums[i]>=nums[i+1]) i--;\\n        \\n        if(i>=0)\\n        {\\n            int j = nums.length-1;\\n            while(nums[j]<=nums[i]) j--;            \\n            swap(nums,i,j);                \\n        }\\n        reverse(nums,i+1,nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;        \\n    }\\n    \\n    public void reverse(int[] nums, int i,int j)\\n    {\\n        while(i<j)\\n        swap(nums,i++,j--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313889,
                "title": "c-100-faster-easy-2-approaches",
                "content": "**1. OPTIMAL APPROACH**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n        for(k=n-2; k>=0; k--){\\n            if(nums[k]<nums[k+1]){\\n                break;\\n            }\\n        }\\n        if(k<0){\\n            reverse(nums.begin(), nums.end());\\n        }\\n        else{\\n            for(l=n-1; l>k; l--){\\n                if(nums[l]>nums[k]){\\n                    break;\\n                }\\n            }\\n            swap(nums[l], nums[k]);\\n            reverse(nums.begin()+k+1, nums.end());\\n        }\\n    }\\n};\\n```\\n\\n**2. STL function**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n        for(k=n-2; k>=0; k--){\\n            if(nums[k]<nums[k+1]){\\n                break;\\n            }\\n        }\\n        if(k<0){\\n            reverse(nums.begin(), nums.end());\\n        }\\n        else{\\n            for(l=n-1; l>k; l--){\\n                if(nums[l]>nums[k]){\\n                    break;\\n                }\\n            }\\n            swap(nums[l], nums[k]);\\n            reverse(nums.begin()+k+1, nums.end());\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968963,
                "title": "faster-easy-understanding-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i,n=nums.size();\\n        for(i=n-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        int j=i-1;\\n        int index=j;\\n        for(int i=n-1;j!=-1 && i>j;i--){\\n            if(nums[i]>nums[j]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(j!=-1)\\n        swap(nums[j],nums[index]);\\n        reverse(nums.begin()+j+1,nums.end());\\n        \\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i,n=nums.size();\\n        for(i=n-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        int j=i-1;\\n        int index=j;\\n        for(int i=n-1;j!=-1 && i>j;i--){\\n            if(nums[i]>nums[j]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(j!=-1)\\n        swap(nums[j],nums[index]);\\n        reverse(nums.begin()+j+1,nums.end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806532,
                "title": "rust-usual-solutoin",
                "content": "```\\nimpl Solution {\\n    pub fn next_permutation(nums: &mut Vec<i32>) {\\n        let l = nums.len();\\n        let (mut i, mut j) = (l-1, l-1);\\n\\t\\t\\n\\t\\t// get the index of last increasing subseq elem from right\\n        while i > 0 && nums[i-1] >= nums[i] { i -= 1; }\\n\\t\\t\\n\\t\\t// nums[i-1] is the smallest in range (i-1..len-1)\\n\\t\\t// elems from (i..len - 1) are in descending\\n        if i > 0 {\\n\\t\\t\\t// get index of the first element >= nums[i-1]\\n\\t\\t\\t// equivalent to sorting the element in ascending and get the index of element right after nums[i-1]\\n             while j >= i && nums[j] <= nums[i-1] { j -= 1; }\\n\\t\\t\\t // swap the smallest and next greater element\\n             nums.swap(i-1, j);\\n        }\\n\\n\\t\\t// reverse the elements from (i to len - 1) to convert to ascending\\n        nums[i..l].reverse();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn next_permutation(nums: &mut Vec<i32>) {\\n        let l = nums.len();\\n        let (mut i, mut j) = (l-1, l-1);\\n\\t\\t\\n\\t\\t// get the index of last increasing subseq elem from right\\n        while i > 0 && nums[i-1] >= nums[i] { i -= 1; }\\n\\t\\t\\n\\t\\t// nums[i-1] is the smallest in range (i-1..len-1)\\n\\t\\t// elems from (i..len - 1) are in descending\\n        if i > 0 {\\n\\t\\t\\t// get index of the first element >= nums[i-1]\\n\\t\\t\\t// equivalent to sorting the element in ascending and get the index of element right after nums[i-1]\\n             while j >= i && nums[j] <= nums[i-1] { j -= 1; }\\n\\t\\t\\t // swap the smallest and next greater element\\n             nums.swap(i-1, j);\\n        }\\n\\n\\t\\t// reverse the elements from (i to len - 1) to convert to ascending\\n        nums[i..l].reverse();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545263,
                "title": "python-3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx = len(nums)-2\\n        while idx>=0:\\n            if nums[idx]<nums[idx+1]:\\n                break\\n            idx-=1\\n        if idx < 0:\\n            nums.sort()\\n            return\\n        \\n        nextIdx = idx+1\\n        while nextIdx<len(nums) and nums[nextIdx]>nums[idx]:\\n            nextIdx+=1\\n        \\n        #swap idx and nextIdx\\n        nums[idx], nums[nextIdx-1] = nums[nextIdx-1], nums[idx]\\n        nums[idx+1:] = nums[idx+1:][::-1]\\n\\t\\t\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 2 -> first element which is smaller that next element \\n\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 3 -> smallest emlement which is larget that 2\\n\\n# 1\\u3000\\u30003\\u3000\\u30007\\u3000\\u30004\\u3000\\u30002\\u3000\\u30001   swap 2 and 3\\n\\n# 1\\u3000\\u30003\\u3000\\u3000[1\\u3000\\u30002\\u3000\\u30004\\u3000\\u30007]   sort nums after 3\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx = len(nums)-2\\n        while idx>=0:\\n            if nums[idx]<nums[idx+1]:\\n                break\\n            idx-=1\\n        if idx < 0:\\n            nums.sort()\\n            return\\n        \\n        nextIdx = idx+1\\n        while nextIdx<len(nums) and nums[nextIdx]>nums[idx]:\\n            nextIdx+=1\\n        \\n        #swap idx and nextIdx\\n        nums[idx], nums[nextIdx-1] = nums[nextIdx-1], nums[idx]\\n        nums[idx+1:] = nums[idx+1:][::-1]\\n\\t\\t\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 2 -> first element which is smaller that next element \\n\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 3 -> smallest emlement which is larget that 2\\n\\n# 1\\u3000\\u30003\\u3000\\u30007\\u3000\\u30004\\u3000\\u30002\\u3000\\u30001   swap 2 and 3\\n\\n# 1\\u3000\\u30003\\u3000\\u3000[1\\u3000\\u30002\\u3000\\u30004\\u3000\\u30007]   sort nums after 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412808,
                "title": "c-beats-100-on-memory-with-explanation",
                "content": "```\\n    void nextPermutation(vector<int>& nums) { // Example <1,0,3,2>\\n\\t// We need the next permutation to be <1,2,0,3>\\n\\t// Start from the right side and find the first element that is less than the one immediately after it. \\n\\t// That is 0.\\n\\t\\n        auto inversionPoint = is_sorted_until(rbegin(nums),rend(nums));\\n        if (inversionPoint == rend(nums)) { // Note that if no element is found that smaller than the one\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// immediately after it we have reached the end of the vector, meaning we are at the last valid permutation\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// In that case, we want to return the first permutation (simply sort the vector).\\n            reverse(rbegin(nums),rend(nums)); // Using reverse on a vector sorted in ascending order \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//(from right to left) will yield a vector that is sorted from left to right.\\n            return; \\n        }\\n        auto lowestUpper = upper_bound(rbegin(nums),inversionPoint, *inversionPoint); // Now we need to find the first number\\n\\t    // that is higher than our inversion point of 0. That is 2.\\n        \\n\\t\\titer_swap(lowestUpper, inversionPoint); // We swap 0 and 2. We now have <1, 2, 3, 0>\\n        reverse(rbegin(nums), inversionPoint); // We reverse from 0 to 2 non inclusive of 2 \\n        return; // We now arrive at  <1,2, 0, 3>\\n    }\\n\\t\\n\\t// If this was helpful please give me reputation. Thanks!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    void nextPermutation(vector<int>& nums) { // Example <1,0,3,2>\\n\\t// We need the next permutation to be <1,2,0,3>\\n\\t// Start from the right side and find the first element that is less than the one immediately after it. \\n\\t// That is 0.\\n\\t\\n        auto inversionPoint = is_sorted_until(rbegin(nums),rend(nums));\\n        if (inversionPoint == rend(nums)) { // Note that if no element is found that smaller than the one\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// immediately after it we have reached the end of the vector, meaning we are at the last valid permutation\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// In that case, we want to return the first permutation (simply sort the vector).\\n            reverse(rbegin(nums),rend(nums)); // Using reverse on a vector sorted in ascending order \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//(from right to left) will yield a vector that is sorted from left to right.\\n            return; \\n        }\\n        auto lowestUpper = upper_bound(rbegin(nums),inversionPoint, *inversionPoint); // Now we need to find the first number\\n\\t    // that is higher than our inversion point of 0. That is 2.\\n        \\n\\t\\titer_swap(lowestUpper, inversionPoint); // We swap 0 and 2. We now have <1, 2, 3, 0>\\n        reverse(rbegin(nums), inversionPoint); // We reverse from 0 to 2 non inclusive of 2 \\n        return; // We now arrive at  <1,2, 0, 3>\\n    }\\n\\t\\n\\t// If this was helpful please give me reputation. Thanks!",
                "codeTag": "Unknown"
            },
            {
                "id": 13902,
                "title": "simple-javascript-o-n-same-as-556-next-greater-element-iii",
                "content": "```\\nvar nextPermutation = function(nums) {\\n    let j = nums.length - 1, i = j - 1;\\n    while (nums[i + 1] <= nums[i]) i--;\\n    if (~i) {\\n        while (nums[j] <= nums[i]) j--;\\n        swap(nums, i, j);\\n    }\\n    for (let k = i + 1, stop = (i + nums.length) / 2; k < stop; k++) {\\n        swap(nums, k, nums.length - k + i);\\n    }\\n};\\n\\nfunction swap(nums, i, j) {\\n    let temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n```\\nSee [#556](https://discuss.leetcode.com/topic/86405/javascript-o-log-n-time-and-o-1-space-using-buckets) for the strategy.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nextPermutation = function(nums) {\\n    let j = nums.length - 1, i = j - 1;\\n    while (nums[i + 1] <= nums[i]) i--;\\n    if (~i) {\\n        while (nums[j] <= nums[i]) j--;\\n        swap(nums, i, j);\\n    }\\n    for (let k = i + 1, stop = (i + nums.length) / 2; k < stop; k++) {\\n        swap(nums, k, nums.length - k + i);\\n    }\\n};\\n\\nfunction swap(nums, i, j) {\\n    let temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13981,
                "title": "o-n-1ms-java-solution-with-comments",
                "content": "        public void nextPermutation(int[] nums) {\\n            // Degenerate case.\\n            if (nums.length < 2) {\\n                return;\\n            }\\n    \\n            // Step 0: Working from right to left, find the index i of the first decreased value.\\n            int indexOfFirstDecrease;\\n            indexOfFirstDecrease = nums.length - 2;\\n            while (indexOfFirstDecrease >= 0 && nums[indexOfFirstDecrease] >= nums[indexOfFirstDecrease + 1]) {\\n                indexOfFirstDecrease--;\\n            }\\n    \\n            // Step 1: If it's a strictly decreasing array, there is no greater permutation, so we need to find the least\\n            // according to the problem statement. We can do this by reversing the array so it is strictly increasing.\\n            // Then we're finished.\\n            if (indexOfFirstDecrease == -1) {\\n                for (int j = 0; j < nums.length / 2; j++) {\\n                    int temp = nums[j];\\n                    nums[j] = nums[nums.length - 1 - j];\\n                    nums[nums.length - 1 - j] = temp;\\n                }\\n                return;\\n            }\\n    \\n            // Step 2: Find next-greatest number in the subpermutation after nums[indexOfFirstDecrease];\\n            // This works because we know that nums[i + 1], ..., nums[nums.length - 1] are in strictly non-increasing order\\n            int indexOfNextGreatestNumber = indexOfFirstDecrease + 1;\\n            while (indexOfNextGreatestNumber < nums.length - 1 && nums[indexOfNextGreatestNumber + 1] > nums[indexOfFirstDecrease]) {\\n                indexOfNextGreatestNumber++;\\n            }\\n    \\n            // Step 3: Interchange the values at indexOfFirstDecrease and indexOfNextGreatestNumber.\\n            int interchangeTemp = nums[indexOfFirstDecrease];\\n            nums[indexOfFirstDecrease] = nums[indexOfNextGreatestNumber];\\n            nums[indexOfNextGreatestNumber] = interchangeTemp;\\n    \\n            // Step 4: Reverse the values between indices (indexOfFirstDecrease + 1) and (nums.length - 1)\\n            int init = indexOfFirstDecrease + 1;\\n            for (int k = 0; k < (nums.length - init) / 2; k++) {\\n                int temp = nums[init + k];\\n                nums[init + k] = nums[nums.length - 1 - k];\\n                nums[nums.length - 1 - k] = temp;\\n            }\\n        }",
                "solutionTags": [],
                "code": "        public void nextPermutation(int[] nums) {\\n            // Degenerate case.\\n            if (nums.length < 2) {\\n                return;\\n            }\\n    \\n            // Step 0: Working from right to left, find the index i of the first decreased value.\\n            int indexOfFirstDecrease;\\n            indexOfFirstDecrease = nums.length - 2;\\n            while (indexOfFirstDecrease >= 0 && nums[indexOfFirstDecrease] >= nums[indexOfFirstDecrease + 1]) {\\n                indexOfFirstDecrease--;\\n            }\\n    \\n            // Step 1: If it's a strictly decreasing array, there is no greater permutation, so we need to find the least\\n            // according to the problem statement. We can do this by reversing the array so it is strictly increasing.\\n            // Then we're finished.\\n            if (indexOfFirstDecrease == -1) {\\n                for (int j = 0; j < nums.length / 2; j++) {\\n                    int temp = nums[j];\\n                    nums[j] = nums[nums.length - 1 - j];\\n                    nums[nums.length - 1 - j] = temp;\\n                }\\n                return;\\n            }\\n    \\n            // Step 2: Find next-greatest number in the subpermutation after nums[indexOfFirstDecrease];\\n            // This works because we know that nums[i + 1], ..., nums[nums.length - 1] are in strictly non-increasing order\\n            int indexOfNextGreatestNumber = indexOfFirstDecrease + 1;\\n            while (indexOfNextGreatestNumber < nums.length - 1 && nums[indexOfNextGreatestNumber + 1] > nums[indexOfFirstDecrease]) {\\n                indexOfNextGreatestNumber++;\\n            }\\n    \\n            // Step 3: Interchange the values at indexOfFirstDecrease and indexOfNextGreatestNumber.\\n            int interchangeTemp = nums[indexOfFirstDecrease];\\n            nums[indexOfFirstDecrease] = nums[indexOfNextGreatestNumber];\\n            nums[indexOfNextGreatestNumber] = interchangeTemp;\\n    \\n            // Step 4: Reverse the values between indices (indexOfFirstDecrease + 1) and (nums.length - 1)\\n            int init = indexOfFirstDecrease + 1;\\n            for (int k = 0; k < (nums.length - init) / 2; k++) {\\n                int temp = nums[init + k];\\n                nums[init + k] = nums[nums.length - 1 - k];\\n                nums[nums.length - 1 - k] = temp;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 14106,
                "title": "share-my-short-solution",
                "content": "    public void nextPermutation(int[] num) {\\n           int start = num.length - 1;\\n           while (start > 0 && num[start-1] >= num[start]) start--;\\n           if (start > 0) {\\n               int end = num.length - 1;\\n               while (num[end] <= num[start-1]) end--;\\n               swap(num, start-1, end);\\n           }\\n           //we don't need to sort, we can just reverse it\\n           for (int i=start; i<(start+num.length)/2; i++) {\\n               swap(num, i, num.length-1+start-i);\\n           }\\n        }\\n        \\n        void swap(int[] A, int i, int j) {\\n            int temp = A[i];\\n            A[i] = A[j];\\n            A[j] = temp;\\n        }",
                "solutionTags": [],
                "code": "    public void nextPermutation(int[] num) {\\n           int start = num.length - 1;\\n           while (start > 0 && num[start-1] >= num[start]) start--;\\n           if (start > 0) {\\n               int end = num.length - 1;\\n               while (num[end] <= num[start-1]) end--;\\n               swap(num, start-1, end);\\n           }\\n           //we don't need to sort, we can just reverse it\\n           for (int i=start; i<(start+num.length)/2; i++) {\\n               swap(num, i, num.length-1+start-i);\\n           }\\n        }\\n        \\n        void swap(int[] A, int i, int j) {\\n            int temp = A[i];\\n            A[i] = A[j];\\n            A[j] = temp;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 4079304,
                "title": "3-approaches-well-explained-bruteforce-better-optimized",
                "content": "# Approach 1: Brute Force \\uD83E\\uDDD0\\n\\n### Intuition \\uD83E\\uDD14\\nWe want to find the next lexicographically greater permutation of an array of integers, `nums`.\\n\\n### Approach \\uD83D\\uDEE0\\uFE0F\\nThe brute force solution has three steps:\\n1. Find all possible permutations of given array `nums`.\\n2. Linearly search for the given permutation.\\n3. Return the very next permutation of the given found permutation.\\n\\n### Time Complexity \\u23F3\\n- **Generating All Permutations:** Generating all permutations of an array with N elements has a time complexity of O(N!). This is because there are N! (N factorial) possible permutations of an array of size N.\\n\\n- **Finding a Particular Arrangement Linearly:** After generating all permutations, you would need to linearly search for a particular arrangement. This search would also take O(N!) time in the worst case because you might need to go through all permutations to find the desired one.\\n\\n- **Returning the Next Permutation of the Found Permutation:** Once you\\'ve found the desired permutation, finding the next permutation of it would also take O(N) time because you need to follow the steps for finding the next permutation on that specific permutation.\\n\\nThus, the time complexity of this approach would be O(N!) due to the generation of all permutations. It\\'s an inefficient approach, especially for large values of N, and is likely to give a **TLE**.\\n\\n### Space Complexity \\uD83D\\uDE80\\nThe space complexity for generating all permutations of an array with N elements is O(N!) because you\\'re storing N! different permutations.\\n\\n# Approach 2: Better Solution (only for cpp users) - Using `next_permutation()` fun\\uD83E\\uDDD0\\n\\n### Approach \\uD83D\\uDEE0\\uFE0F\\nWe can use the `next_permutation()` function. The next_permutation function is a part of the C++ Standard Library\\'s `<algorithm>` header. It\\'s used to generate the next lexicographically greater permutation of a vector.\\n\\n### Time Complexity \\u23F3\\nThe time complexity of the `next_permutation()` function is O(N), where N is the size of the input vector (nums in this case).\\nThe function traverses the vector from right to left to find the first pair of two consecutive elements such that the left element is less than the right element. This operation takes O(N) time in the worst case.\\nThe subsequent operations, such as finding the smallest greater element and reversing the subarray, also take O(N) time in total.\\nSo, the overall time complexity is O(N).\\n\\n### Space Complexity \\uD83D\\uDE80\\nThe next_permutation function operates in-place and does not use any additional memory that scales with the input size. Therefore, the space complexity of the nextPermutation function is O(1), which means it uses constant extra memory.\\n\\n### Code \\uD83D\\uDCBB\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```\\n\\n# Approach 3: Optimized Solution \\uD83E\\uDDD0\\n\\n### Approach \\uD83D\\uDEE0\\uFE0F\\n- Like in a dictionary the very next word to a given word is almost the same except for a very few alphabets, e.g. in a dictionary Fire would come after fira. Notice how the first three alphabets are the same?\\n- Observing this lexicographical order in an English dictionary, we apply a similar approach in the array as well.\\n- Given array `nums` we find a **break point**. What is a breakpoint exactly and why are we finding it?\\n- Notice that the next permutation of [1,2,5,4,3,0] -> [1,3,5,4,2,0] -> [1,3,0,2,4,5]. Observe how two numbers have been swapped( 2 and 3) first, and then the rest of the array is reversed.\\n- This is because 2 is a breakpoint. A breakpoint here refers to a point that is lesser than the next element in the array.\\n- We traverse `nums` starting from i=n-2th index. We compare each `nums[i]` with `nums[i+1]`. If at any index `i`, `nums[i]`<`nums[i+1]`, we set `i` as out `breakindex` variable.\\n- Now after we\\'ve found the `breakindex`, we traverse the right half of the `nums` array after `breakindex`, so from `i=n-1` till `i=breakpint+1`, and look for the least greater after the `breakpoint`.\\n- In the array example taken above, index 1 was the `breakindex` and we traverse from element 5 to 0 and find that 3 is the least element greater than 1 in that portion of the array.\\n- Now, we swap the `breakindex` element with this `leastgreat` index element.\\n- Now we reverse the array from `breakindex+1` to `n-1`.\\n-**Edge case:** It may happen that the array in the input is the last possible maximum permutation possible for the elements like: [5,4,3,3,2,0], so the next permutation will be the reverse of it which is the first smallest possible permutation of the elements. So in case we do not find a `breakpoint` like in this case, we simply reverse the given `nums` array.\\n\\n### Time Complexity \\u23F3\\nThe time complexity of this approach is linear. We traverse the array twice: first to find the `breakpoint` and then to find the least greater element. Each traversal takes O(N) time.tore indices and values.\\n\\n### Space Complexity \\uD83D\\uDE80\\nThe space complexity is constant O(1) because the algorithm operates in-place without using any additional data structures that scale with the input size. \\n\\n### Code \\uD83D\\uDCBB\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        //find the breakpoint\\n        int breakpoint=-1;\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--){\\n          if(nums[i]<nums[i+1]){\\n            breakpoint=i;\\n            break;\\n          }  \\n        } \\n        if(breakpoint==-1){reverse(nums.begin(),nums.end());return;}\\n        \\n        //find least greater of element at the breakpoint\\n        int leastgreater=-1; \\n        int leastGvalue=101;\\n        for(int i=n-1;i>breakpoint;i--){\\n            if(nums[i]>nums[breakpoint]){\\n                if(nums[i]<leastGvalue){\\n                    leastgreater=i;\\n                    leastGvalue=nums[i];\\n                }\\n            }\\n        }\\n\\n        //now swap breakpoint with leastgreater\\n        swap(nums[breakpoint],nums[leastgreater]);\\n        \\n        //reverse everything after the breakpoint\\n        reverse(nums.begin()+breakpoint+1,nums.end());\\nreturn;\\n}\\n};\\n```\\n\\n![CAN YOU PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/fc2c0af7-4f47-44cf-b680-292fe4f08da0_1695449550.2816818.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        //find the breakpoint\\n        int breakpoint=-1;\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--){\\n          if(nums[i]<nums[i+1]){\\n            breakpoint=i;\\n            break;\\n          }  \\n        } \\n        if(breakpoint==-1){reverse(nums.begin(),nums.end());return;}\\n        \\n        //find least greater of element at the breakpoint\\n        int leastgreater=-1; \\n        int leastGvalue=101;\\n        for(int i=n-1;i>breakpoint;i--){\\n            if(nums[i]>nums[breakpoint]){\\n                if(nums[i]<leastGvalue){\\n                    leastgreater=i;\\n                    leastGvalue=nums[i];\\n                }\\n            }\\n        }\\n\\n        //now swap breakpoint with leastgreater\\n        swap(nums[breakpoint],nums[leastgreater]);\\n        \\n        //reverse everything after the breakpoint\\n        reverse(nums.begin()+breakpoint+1,nums.end());\\nreturn;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009650,
                "title": "explained-every-step-0ms-100-beats-java",
                "content": "# Approach\\n- First we have to find where i < i+1 while we are traversing the array from second last element , second last beacause we are comapring it with i+1.If we start from last then it will give index out of bound.When we find that point where i < i+1 we store that i index in variable name ind which is firstly intialised as -1.\\nlet understand why we are doing this,\\n```\\n->In question asked of next permutation of given arr elements . \\nLet suppose the given arr = [1 2 3]\\nwe can rearrange it in 6 different ways or we say there is 3! permutations , which are\\n 1 2 3\\n 1 3 2<- This is our answer \\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we can see 1 3 2  > 1 2 3,\\n->so we have to check and take that prefix,if we make change on that then our modified array is greater then previous array . \\nunderstand this with different example \\n;-                  i    i+1\\n                    ^    ^\\ngiven arr = [1 , 2 , 0 , 5 , 1]\\n             this is where our condition stops \\nNow we store this i in ind variable and break the loop.\\n```\\n- We can\\'t directly swap i with i+1 or any other number which can make array greater then previous beacuse output is according to the sorted permutation so we have to update it in sorted order before that think of edge case \\n```\\nEDGE CASE \\ngiven arr = [3 2 1]\\nAll permutation : -\\n 1 2 3\\n 1 3 2\\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we there is no next permutaion of  3 2 1  then we return the first permutation means\\n1 2 3 is our output in this case and we can get it by just reversing the array .\\n```\\n- Now lets decide with which element we can swap our ind index in order to make **Greater then previous** and **Next Permutation**\\n```\\ngiven arr = [1 2 0 5 1]\\n            0 1 2 3 4<-Index\\nind  = 2 \\nnow we have 5 and 1 to swap with ind index in order to make it greater then previous array , \\ni can\\'t write all possible permutaion of  1 2 0 5 1 but i just write the next permutation of it which is \\n  1 2 1 0 5 is our next permutaion\\n->Now if we swap i with 5 then our array is greater but not our next permutation \\n-> If we swap ind index value with 1 then our array is \\n1 2 1 5 0\\n->So by this we understanded we have to pick smallest from all larger elements\\n->0(ind index value)<1<5,just greater then ind index value and smaller then all choices we have.\\n->We can find this by traversing the array from last to ind or 0.\\nif(a[i]>a[ind]){\\nswap(a[i],a[ind]);\\nbreak;\\n}\\nNow after this we have 1 2 1 5 0\\n```\\n- After this we have to sort the remainig array in order to make next permutation we can do it simply by reversing the array from ind+1 to a.legnth-1.\\n```\\n1 2 1 5 0<-a.length-1\\n      ^ \\n    ind+1\\nif we just reverse this portion then\\n 1  2 1 0 5 is array and this is also next permutation of our given array.\\n```\\n\\n---\\n\\n*If there is some doubt or any mistake i have done in explaining please let me know in comments \\uD83D\\uDE4F*\\n# Complexity\\nin place and use only constant extra memory.\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int ind = -1;\\n        for(int i = a.length-2;i>=0;i--){\\n            if(a[i]<a[i+1]){\\n                ind = i;\\n                break;\\n            }\\n        }\\n        if(ind==-1){\\n            arev(a,0,a.length-1);\\n            return;\\n        }\\n        for(int i = a.length-1;i>=0;i--){\\n            if(a[i]>a[ind]){\\n                int temp = a[i];\\n                a[i]=a[ind];\\n                a[ind]=temp;\\n                break;\\n            }\\n        }\\n        arev(a,ind+1,a.length-1);\\n\\n    }\\n        static void arev(int[] a,int low,int high){\\n        while(low<high){\\n            int temp = a[low];\\n            a[low]=a[high];\\n            a[high]=temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n->In question asked of next permutation of given arr elements . \\nLet suppose the given arr = [1 2 3]\\nwe can rearrange it in 6 different ways or we say there is 3! permutations , which are\\n 1 2 3\\n 1 3 2<- This is our answer \\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we can see 1 3 2  > 1 2 3,\\n->so we have to check and take that prefix,if we make change on that then our modified array is greater then previous array . \\nunderstand this with different example \\n;-                  i    i+1\\n                    ^    ^\\ngiven arr = [1 , 2 , 0 , 5 , 1]\\n             this is where our condition stops \\nNow we store this i in ind variable and break the loop.\\n```\n```\\nEDGE CASE \\ngiven arr = [3 2 1]\\nAll permutation : -\\n 1 2 3\\n 1 3 2\\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we there is no next permutaion of  3 2 1  then we return the first permutation means\\n1 2 3 is our output in this case and we can get it by just reversing the array .\\n```\n```\\ngiven arr = [1 2 0 5 1]\\n            0 1 2 3 4<-Index\\nind  = 2 \\nnow we have 5 and 1 to swap with ind index in order to make it greater then previous array , \\ni can\\'t write all possible permutaion of  1 2 0 5 1 but i just write the next permutation of it which is \\n  1 2 1 0 5 is our next permutaion\\n->Now if we swap i with 5 then our array is greater but not our next permutation \\n-> If we swap ind index value with 1 then our array is \\n1 2 1 5 0\\n->So by this we understanded we have to pick smallest from all larger elements\\n->0(ind index value)<1<5,just greater then ind index value and smaller then all choices we have.\\n->We can find this by traversing the array from last to ind or 0.\\nif(a[i]>a[ind]){\\nswap(a[i],a[ind]);\\nbreak;\\n}\\nNow after this we have 1 2 1 5 0\\n```\n```\\n1 2 1 5 0<-a.length-1\\n      ^ \\n    ind+1\\nif we just reverse this portion then\\n 1  2 1 0 5 is array and this is also next permutation of our given array.\\n```\n```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int ind = -1;\\n        for(int i = a.length-2;i>=0;i--){\\n            if(a[i]<a[i+1]){\\n                ind = i;\\n                break;\\n            }\\n        }\\n        if(ind==-1){\\n            arev(a,0,a.length-1);\\n            return;\\n        }\\n        for(int i = a.length-1;i>=0;i--){\\n            if(a[i]>a[ind]){\\n                int temp = a[i];\\n                a[i]=a[ind];\\n                a[ind]=temp;\\n                break;\\n            }\\n        }\\n        arev(a,ind+1,a.length-1);\\n\\n    }\\n        static void arev(int[] a,int low,int high){\\n        while(low<high){\\n            int temp = a[low];\\n            a[low]=a[high];\\n            a[high]=temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404423,
                "title": "c-beat-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for(int i = 0; i < n-1; i++) {\\n          if(nums[i]<nums[i+1]) idx = i;\\n        }\\n        if(idx == -1) {\\n          reverse(nums.begin(), nums.end());\\n          return;\\n        }\\n        int l = idx + 1;\\n        for(int i = idx + 1; i < n; i++) {\\n            if(nums[i] > nums[idx]) l = i;\\n        }\\n        swap(nums[idx], nums[l]);\\n        reverse(nums.begin() + 1 + idx, nums.end());\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for(int i = 0; i < n-1; i++) {\\n          if(nums[i]<nums[i+1]) idx = i;\\n        }\\n        if(idx == -1) {\\n          reverse(nums.begin(), nums.end());\\n          return;\\n        }\\n        int l = idx + 1;\\n        for(int i = idx + 1; i < n; i++) {\\n            if(nums[i] > nums[idx]) l = i;\\n        }\\n        swap(nums[idx], nums[l]);\\n        reverse(nums.begin() + 1 + idx, nums.end());\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332720,
                "title": "simple-solution-in-python",
                "content": "\\nimport itertools\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        \"\"\"\\n        1. From right to left find the one with misorer match that is the one that not in ascending            order\\n        2.Swap the element with next greatest element from its rigth sub array\\n        3.the reverse the right sub arrray (but here it is already reversed)\\n        \"\"\"\\n        right_subarr,n=[],len(nums)\\n        right_subarr.append(nums[-1]) \\n        for i in range(n-2,-1,-1):\\n            if nums[i]>=right_subarr[-1]:right_subarr.append(nums[i])\\n            else:\\n                temp=right_subarr[:]\\n                temp.sort()\\n                for next_greatest in temp:\\n                    if next_greatest>nums[i]:\\n                        m=next_greatest\\n                        break\\n                ind=right_subarr.index(m)\\n                \\n                nums[i],right_subarr[ind]=right_subarr[ind],nums[i]\\n                break\\n        if len(right_subarr)==n: nums[:]=right_subarr[:]\\n        else: nums[i+1:n]=right_subarr[:]\\n        print(right_subarr,nums)\\n        \\n        \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\nimport itertools\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        \"\"\"\\n        1. From right to left find the one with misorer match that is the one that not in ascending            order\\n        2.Swap the element with next greatest element from its rigth sub array\\n        3.the reverse the right sub arrray (but here it is already reversed)\\n        \"\"\"\\n        right_subarr,n=[],len(nums)\\n        right_subarr.append(nums[-1]) \\n        for i in range(n-2,-1,-1):\\n            if nums[i]>=right_subarr[-1]:right_subarr.append(nums[i])\\n            else:\\n                temp=right_subarr[:]\\n                temp.sort()\\n                for next_greatest in temp:\\n                    if next_greatest>nums[i]:\\n                        m=next_greatest\\n                        break\\n                ind=right_subarr.index(m)\\n                \\n                nums[i],right_subarr[ind]=right_subarr[ind],nums[i]\\n                break\\n        if len(right_subarr)==n: nums[:]=right_subarr[:]\\n        else: nums[i+1:n]=right_subarr[:]\\n        print(right_subarr,nums)\\n        \\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224452,
                "title": "next-permutation-o-n-solution-in-python",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nChange the array from the last and not from the start as it will change it drastically and we have to increase the sequence as little as possible\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- example: [2,3,8,5,4,1,0]\\n- First identify the longest non increasing subarray  from the last i.e [8,5,4,1,0]\\n- If whole array is in descending order, its already the largest permutation so just reverse it \\n- Now will swap the element to the left of the longest subarray(3) with the smallest element from the subarray i.e larger than that element. To find the element we will traverse from end untill you find element just greater than (3) i.e (4).\\n- Now swap them to get [2,4,8,5,3,1,0]\\n- Now just reverse the longest non increasing subarray(since its already in descending order) to get the smallest permutation i.e [2,4,0,1,3,5,8]\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        i=len(nums)-1\\n        while i>0 and nums[i-1]>=nums[i]:\\n            i=i-1\\n        if i<1:\\n            nums[:]=nums[::-1]\\n        else:\\n            j=len(nums)-1 #last element \\n            #we have to find element from last that is greater than nums[i-1]\\n            while nums[j]<=nums[i-1]:\\n                j=j-1\\n            nums[i-1], nums[j]= nums[j], nums[i-1]\\n            nums[i:]=reversed(nums[i:])\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        i=len(nums)-1\\n        while i>0 and nums[i-1]>=nums[i]:\\n            i=i-1\\n        if i<1:\\n            nums[:]=nums[::-1]\\n        else:\\n            j=len(nums)-1 #last element \\n            #we have to find element from last that is greater than nums[i-1]\\n            while nums[j]<=nums[i-1]:\\n                j=j-1\\n            nums[i-1], nums[j]= nums[j], nums[i-1]\\n            nums[i:]=reversed(nums[i:])\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113745,
                "title": "easiest-o-n-solution-in-c-with-approach",
                "content": "# Approach\\nstep 1: find the element with a[i]>a[i-1];\\nstep 2: if non found then return a sort array.\\nstep 3: find the just greater element than step 1 element.\\nstep 4: swap step 3 and step 1 elements and reverse/sort the element before the step 1 index.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        // 1 3 5 4 2\\n        //find a[i]>a[i+1]\\n        int toswap=INT_MIN,withswap=INT_MIN;\\n        for(int i=a.size()-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                toswap=i-1;\\n                break;\\n            }\\n        }\\n        //edge case\\n        if(toswap==INT_MIN) return reverse(a.begin(),a.end());\\n        //just greater element than toswap.\\n        else{\\n            for(int i=a.size()-1;i>toswap;i--){\\n                if(a[i]>a[toswap]){\\n                    withswap=i;\\n                    break;\\n                }\\n            }\\n            swap(a[toswap],a[withswap]);\\n            return reverse(a.begin()+toswap+1,a.end()); \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        // 1 3 5 4 2\\n        //find a[i]>a[i+1]\\n        int toswap=INT_MIN,withswap=INT_MIN;\\n        for(int i=a.size()-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                toswap=i-1;\\n                break;\\n            }\\n        }\\n        //edge case\\n        if(toswap==INT_MIN) return reverse(a.begin(),a.end());\\n        //just greater element than toswap.\\n        else{\\n            for(int i=a.size()-1;i>toswap;i--){\\n                if(a[i]>a[toswap]){\\n                    withswap=i;\\n                    break;\\n                }\\n            }\\n            swap(a[toswap],a[withswap]);\\n            return reverse(a.begin()+toswap+1,a.end()); \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936089,
                "title": "time-o-n-easy-to-understanding",
                "content": "# Code\\n```\\nclass Solution(object):\\n    # To Reverse the Part of a List/Array\\n    def reverseLst(self,lst,left,right):\\n        while left < right:\\n            lst[left],lst[right] = lst[right],lst[left]\\n            left += 1\\n            right -= 1\\n        return lst\\n\\n    def nextPermutation(self, nums):\\n        numsLen = len(nums)\\n\\n        # Reaching the element which is Greater than the next and near to the right, and the element\\'s idx is  eleIdx\\n        eleIdx = numsLen - 1\\n        while 0 < eleIdx and nums[eleIdx-1] >= nums[eleIdx]:\\n            eleIdx -= 1\\n\\n        # if the eleIdx is 0 that mean the Whole lst is reversely sorted in this case just return the sorted array but don\\'t sort Just reverse it to get the sorted lst\\n        if eleIdx == 0:\\n            return self.reverseLst(nums,0,numsLen -1)\\n\\n        # Reversing the right sub array from the eleIdx to end -> indirectly Sorting\\n        nums = self.reverseLst(nums,eleIdx,numsLen -1)\\n\\n        # mainEle is the element that is neaded to swap with the next minum element after the mainEle\\'s idx\\n        mainEleIdx = eleIdx -1\\n\\n        # finding the right position for the mainElement and swapping it to the right position\\n        while eleIdx < numsLen and nums[mainEleIdx] >= nums[eleIdx]:\\n            eleIdx += 1\\n\\n        nums[mainEleIdx],nums[eleIdx] = nums[eleIdx],nums[mainEleIdx]\\n        return nums\\n```\\nYou Can also Look At My SDE Prep Repo [*`\\uD83E\\uDDE2 GitHub`*](https://github.com/Ayon-SSP/The-SDE-Prep)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    # To Reverse the Part of a List/Array\\n    def reverseLst(self,lst,left,right):\\n        while left < right:\\n            lst[left],lst[right] = lst[right],lst[left]\\n            left += 1\\n            right -= 1\\n        return lst\\n\\n    def nextPermutation(self, nums):\\n        numsLen = len(nums)\\n\\n        # Reaching the element which is Greater than the next and near to the right, and the element\\'s idx is  eleIdx\\n        eleIdx = numsLen - 1\\n        while 0 < eleIdx and nums[eleIdx-1] >= nums[eleIdx]:\\n            eleIdx -= 1\\n\\n        # if the eleIdx is 0 that mean the Whole lst is reversely sorted in this case just return the sorted array but don\\'t sort Just reverse it to get the sorted lst\\n        if eleIdx == 0:\\n            return self.reverseLst(nums,0,numsLen -1)\\n\\n        # Reversing the right sub array from the eleIdx to end -> indirectly Sorting\\n        nums = self.reverseLst(nums,eleIdx,numsLen -1)\\n\\n        # mainEle is the element that is neaded to swap with the next minum element after the mainEle\\'s idx\\n        mainEleIdx = eleIdx -1\\n\\n        # finding the right position for the mainElement and swapping it to the right position\\n        while eleIdx < numsLen and nums[mainEleIdx] >= nums[eleIdx]:\\n            eleIdx += 1\\n\\n        nums[mainEleIdx],nums[eleIdx] = nums[eleIdx],nums[mainEleIdx]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854196,
                "title": "pen-n-paper-solution-easy-with-comments-2-solved-examples",
                "content": "![tempImageMwxUvV.jpg](https://assets.leetcode.com/users/images/b7877058-c4d1-40f1-8361-5248a2ba97a6_1669566589.0427344.jpeg)\\n![tempImageFumuEH.jpg](https://assets.leetcode.com/users/images/c9fd7d51-3776-4056-b5ef-a612ff46817f_1669566608.6524541.jpeg)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        # To find next permutations, we\\'ll start from the end\\n        \"\"\"\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number greater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now our pointer is pointing at two different positions\\n        # i. first non-ascending number from end\\n        # j. first number greater than nums[i-1]\\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        # To find next permutations, we\\'ll start from the end\\n        \"\"\"\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number greater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now our pointer is pointing at two different positions\\n        # i. first non-ascending number from end\\n        # j. first number greater than nums[i-1]\\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734334,
                "title": "clean-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        int ind1,ind2,i;\\n        for(i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(i<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]>nums[ind1]){\\n                ind2=i;\\n                break;\\n            }\\n        }\\n        int temp=nums[ind1];\\n                nums[ind1]=nums[ind2];\\n                nums[ind2]=temp;\\n        \\n        reverse(nums.begin()+ind1+1,nums.end());  \\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        int ind1,ind2,i;\\n        for(i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(i<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]>nums[ind1]){\\n                ind2=i;\\n                break;\\n            }\\n        }\\n        int temp=nums[ind1];\\n                nums[ind1]=nums[ind2];\\n                nums[ind2]=temp;\\n        \\n        reverse(nums.begin()+ind1+1,nums.end());  \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570943,
                "title": "clean-code-with-comments-1ms",
                "content": "```\\nclass Solution {\\n    private void reverse(int[] arr, int start){\\n        int end = arr.length-1;\\n        while(start < end){\\n            swap(arr, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length-2;\\n        // decreasing order find kro \\n        while(i>=0 && nums[i] >= nums[i+1]){\\n            i--;\\n        }\\n        // jese hi mila swap krdo\\n        if(i>=0){\\n            // required element dhundo swap krne ke liye \\n            int j = nums.length-1;\\n            while(j>=0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n            // jese hi element miljaye swap krdo \\n            swap(nums, i, j);\\n        }\\n        // reverse krdo baki ka \\n        reverse(nums, i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private void reverse(int[] arr, int start){\\n        int end = arr.length-1;\\n        while(start < end){\\n            swap(arr, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length-2;\\n        // decreasing order find kro \\n        while(i>=0 && nums[i] >= nums[i+1]){\\n            i--;\\n        }\\n        // jese hi mila swap krdo\\n        if(i>=0){\\n            // required element dhundo swap krne ke liye \\n            int j = nums.length-1;\\n            while(j>=0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n            // jese hi element miljaye swap krdo \\n            swap(nums, i, j);\\n        }\\n        // reverse krdo baki ka \\n        reverse(nums, i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316586,
                "title": "c-approach-and-intuition",
                "content": "**Basic Intution:**\\n* If we look carefully to the sample inputs we will always find an increasing order for a certain breakpoint.\\n* For e.g. in [1 2 3], the next permutation will be [1 3 2] ---> 1<3>2. Similarily in [2 1 3], the next permutation will be    [2 3 1]--->2<3>1.\\n* The only time this won\\'t apply is when the given input is in decreasing order.\\n\\n1. So, we can traverse from back and check for the index position whose value is lesser than its prior index position\\'s value. Let\\'s store it in a variable--idx1.\\n2. Next, we have to again traverse from back and check which value is greater than the idx1 position value. Swap the places to get the possible next greater element.\\n3. However, this swap will only ensure the correctness of breakpoint. We need to then, reverse the rest array elements to the right side of the breakpoint in order to find the next permutation.\\n\\n**Edge case**\\nWhen the given array is in decreasing order, the next permutation will be the same array in reverse order. So in that case we can simply just reverse the entire array. For e.g. [3 2 1] --> [1 2 3].\\n\\n**Happy Hunting**",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2126330,
                "title": "python-solution",
                "content": "i=len(nums)-2\\n        while i>=0:\\n            if(nums[i]>=nums[i+1]):\\n                i-=1\\n            else:\\n                break\\n        j=len(nums)-1\\n        if i>=0:\\n            while j>=0:\\n                if(nums[j]<=nums[i]):\\n                    j-=1\\n                else:\\n                    break\\n            nums[j],nums[i]=nums[i],nums[j]\\n        def reverse(nums,a,b):\\n            while(a<b):\\n                nums[a],nums[b]=nums[b],nums[a]\\n                a+=1\\n                b-=1\\n        reverse(nums,i+1,len(nums)-1)\\n![image](https://assets.leetcode.com/users/images/47a26b6b-9549-48f3-8f40-3fc38ecce0a1_1654963496.6587029.jpeg)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "i=len(nums)-2\\n        while i>=0:\\n            if(nums[i]>=nums[i+1]):\\n                i-=1\\n            else:\\n                break\\n        j=len(nums)-1\\n        if i>=0:\\n            while j>=0:\\n                if(nums[j]<=nums[i]):\\n                    j-=1\\n                else:\\n                    break\\n            nums[j],nums[i]=nums[i],nums[j]\\n        def reverse(nums,a,b):\\n            while(a<b):\\n                nums[a],nums[b]=nums[b],nums[a]\\n                a+=1\\n                b-=1\\n        reverse(nums,i+1,len(nums)-1)\\n![image](https://assets.leetcode.com/users/images/47a26b6b-9549-48f3-8f40-3fc38ecce0a1_1654963496.6587029.jpeg)\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1927066,
                "title": "4-step-explanation-linear-time-two-pointers",
                "content": "Hello Leetcoders, Hope you are doing well.\\n\\nLet\\'s continue with **next permutation**\\n\\n**Problem statement**\\nWe have an array of Integers, we need to find next permutation of that number in lexographic (Dictionary) order.\\ne.g\\n1 3 2\\n\\nso all permutations for the give number in dictionary order will be,\\nIndex 0 -> 1 2 3\\nIndex 1 -> 1 3 2\\nIndex 2 -> 2 1 3\\nIndex 3 -> 2 3 1\\nIndex 4 -> 3 1 2\\nIndex 5 -> 3 2 1\\n\\nour answer for input 1 3 2 (at index 1) will be 2 1 3 (at index 2)\\n\\n**How can we solve this problem**\\nFirst approcah comes in our mind will be **Brute-force approach**\\n\\nwhat we can do in brute-force method is\\n\\n* Store given array into temp array\\n* Sort given input array into increasing order\\n* Create a 2D arraylist\\n* Call recusrive function and calculate all permutations and store those permutations into 2D arrayList\\n* now find index of temp array in 2D arrayList\\n* print index + 1 from 2D arrayList\\n\\nTime complexity : too bad\\nSpace complexity : not O(1) as problem says\\n\\nNow how can we optimize the solution\\n\\n**Optimal Approach**\\nAccording to problem they want next permutation of the given array which comes in **lexographic order**\\nwe use lexographic order in dictionary (normal oxford one, not python ;->)\\nIf we dive into the dictionary can think about how they organised we will find our apprach.\\n\\nwe will understand dictionary work using example i.e **1 3 5 4 2**\\n\\n**Step 1 :**\\nIf you see the array carefully you will find that first numbers is in increasing order than after certain point it is decreasing. We will call this certain point **Break-point.**\\n\\n\\nwe have to find this break-point, A simple way we can do this\\n```\\ntraverse from 2nd last index and compare nums[i] >= nums[i+1] \\nwhen this fails we will find our break-point\\n\\nin our example \\ni = 3 (2nd last index)\\n\\nfirst iteration : 4 >= 2\\ni = 2\\n\\nsecond iteration : 5 >= 4\\ni=1\\n\\nthird iteration 3 >= 5\\nbreak\\n\\nour break-point i = 1\\n```\\n\\n**Step 2**\\nwe have prefix which is arr[0, i] i.e 1 3 this need to be change in lexographic order, for that we have to replace 3 with some integer which is present in another subarray[i+1, last] i.e 5 4 2\\n\\nWhat options we have\\nReplace 3 by 5 -> 1 5\\nReplace 3 by 4 -> 1 4\\nReplace 3 by 2 -> 1 2\\n\\nbut we want our next permutaion so we have to find greater than 3 which means 2 is rejected\\nwe want in lexographic order means 1 4 comes before 1 5.\\nif you sum-up both above point it is basically saying that find smallest number which is greater than break-point integer\\n\\n```\\ntraverse from last \\nnums[j] <= nums[i]\\n\\n\\narray 1 3 5 4 2\\ni = 1\\n\\nj = 4 (last index)\\nnums[j] <= nums[i]\\n\\nfirst Iteration : 2 <= 3\\nj = 3\\n\\nsecond iteration : 4 <= 3\\nbreak\\n\\nj = 3\\n```\\n\\n**Step 3**\\nSwap both ith and jth index element to get smallest lexographic prefix\\n```\\nswap(arr, i, j)\\n\\n\\ninput = 1 3 5 4 2\\noutput = 1 4 5 3 2\\n```\\n\\n**Step 4**\\n\\nI will say again we want lexographically next permutation so we find our prifix i.e 1 4\\nnow try to find remaining combination\\n\\nso you will see after swaping, our array is 1 4 5 3 2\\ntake arr(i+1, last)\\n5 3 2\\n\\nwe want it in dictionary order so\\nreverse it 2 3 5\\n\\n**final output : 1 4 2 3 5**\\n\\n**Edge case**\\nWhat happen if we can\\'t find any break-point\\ne.g 3 2 1\\n\\nin this case step 1, 2, 3 will be skipped and we perform step 4 directly\\nreverse the arr\\n1 2 3 is our output\\n\\n**Code**\\n```\\nclass Solution {\\n   public void nextPermutation(int[] nums) {\\n       if(nums == null || nums.length <= 1) return; // base case\\n       \\n       int i = nums.length - 2; // second last index\\n       while(i >= 0 && nums[i] >= nums[i+1]) i--; // find break point\\n       \\n       if(i >= 0) { // iff we found break point\\n           int j = nums.length - 1;\\n           while(nums[j] <= nums[i]) j--; // find smallest integer greater than break-point integer\\n           \\n           swap(nums, i, j); // swap the integers\\n       }\\n       reverse(nums, i+1, nums.length - 1); // reverse array apart from prefix\\n       \\n   }\\n   \\n   private void swap(int[] arr, int i, int j) {\\n       int temp = arr[i];\\n       arr[i] = arr[j];\\n       arr[j] = temp;\\n   }\\n   \\n   private void reverse(int arr[], int left, int right) {\\n       while(left < right) {\\n           swap(arr, left++, right--);\\n       }\\n   }\\n}\\n```\\n\\n**For break-point : O(n)\\nFor Smallest integer : O(n)\\nFor Swap : O(1)\\nFor Reverse : O(n)**\\n\\nT(n) : O(n)\\nSpace complexity : O(1)\\n\\nIn case of any doubt, feel free to comment down below, Thank you",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\ntraverse from 2nd last index and compare nums[i] >= nums[i+1] \\nwhen this fails we will find our break-point\\n\\nin our example \\ni = 3 (2nd last index)\\n\\nfirst iteration : 4 >= 2\\ni = 2\\n\\nsecond iteration : 5 >= 4\\ni=1\\n\\nthird iteration 3 >= 5\\nbreak\\n\\nour break-point i = 1\\n```\n```\\ntraverse from last \\nnums[j] <= nums[i]\\n\\n\\narray 1 3 5 4 2\\ni = 1\\n\\nj = 4 (last index)\\nnums[j] <= nums[i]\\n\\nfirst Iteration : 2 <= 3\\nj = 3\\n\\nsecond iteration : 4 <= 3\\nbreak\\n\\nj = 3\\n```\n```\\nswap(arr, i, j)\\n\\n\\ninput = 1 3 5 4 2\\noutput = 1 4 5 3 2\\n```\n```\\nclass Solution {\\n   public void nextPermutation(int[] nums) {\\n       if(nums == null || nums.length <= 1) return; // base case\\n       \\n       int i = nums.length - 2; // second last index\\n       while(i >= 0 && nums[i] >= nums[i+1]) i--; // find break point\\n       \\n       if(i >= 0) { // iff we found break point\\n           int j = nums.length - 1;\\n           while(nums[j] <= nums[i]) j--; // find smallest integer greater than break-point integer\\n           \\n           swap(nums, i, j); // swap the integers\\n       }\\n       reverse(nums, i+1, nums.length - 1); // reverse array apart from prefix\\n       \\n   }\\n   \\n   private void swap(int[] arr, int i, int j) {\\n       int temp = arr[i];\\n       arr[i] = arr[j];\\n       arr[j] = temp;\\n   }\\n   \\n   private void reverse(int arr[], int left, int right) {\\n       while(left < right) {\\n           swap(arr, left++, right--);\\n       }\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910927,
                "title": "c-1-lines-std-library",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n\\nhttps://en.cppreference.com/w/cpp/algorithm/next_permutation",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910469,
                "title": "java-highly-commented-with-example-proof-o-n-0ms-runtime",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1st step --> Find the pivot\\n        \\n        /*iska matlab aisa number jisko tumhe actually swap karna hai basically \\n\\t\\tleft lesser value to right larger value. So yaha par pehle hum wo left lesser\\n\\t\\tvalue dhund rahe hai next step mein right larger value.Ex: 9 1 5 3 toh \\n\\t\\tisme check karo ki kab tumhe arr[idx+1]>arr[idx] mil jaaye is case mein 1st idx is pivot hoga.\\n\\t\\t*/\\n        \\n        int i = arr.length-2;\\n        while(i>=0 && arr[i]>=arr[i+1])\\n            i--;\\n        \\n  /*why if because in case of the largest number i will be -ve itself like 3 2 1\\n  have to return the smallest arrangement i.e. 1 2 3 so simply reverse no need of \\n  2nd step */\\n\\n        \\n        /*2nd step: Find the just larger value than your arr[i] so we can swap \\n\\t\\tboth the numbers. Ex: 9 1 5 3 mein 1 and 3 will be swapped because 3 is \\n\\t\\tjust immediate larger than our arr[i] */\\n        \\n        if(i>=0){  \\n            int j = arr.length-1;\\n            while(arr[i]>=arr[j])\\n            j--;\\n            \\n            /*Step 3: Swap both the indexes i.e. i and j in our example the resultant\\n\\t\\t\\twould look like 9 3 5 1 */\\n            \\n            swap(arr,i,j);\\n        }\\n        \\n        //Step-4 : Reverse the array after the pivot point\\n        \\n         /*Why see if you look carefully our number after swap becomes 9 3 5 1 \\n\\t\\t but according to question we want the next permutation which is just \\n\\t\\t immediate greater than the given number right so our resultant final answer \\n\\t\\t should be 9 3 1 5, for that we have to reverse the array after the pivot \\n\\t\\t point i.e. reverse from (i+1,arr.length-1) also if you remember our if check \\n\\t\\t is due to what if we provided with the highest number itself so we have to \\n\\t\\t return the smallest permutation i.e. reverse the whole array so our that \\n\\t\\t purpose is also serving because what we are passing is in our \\n\\t\\t reverse array (i+1,arr.length-1) and for highest number i = -1 \\n\\t\\t so automatically due to the function it will become(0,arr.length-1) .\\n */\\n        \\n        reverse(arr,i+1,arr.length-1);\\n        \\n    }\\n    \\n    public void reverse(int[] arr,int i,int j){\\n        while(i<j){\\n            swap(arr,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    public void swap(int[] arr,int i,int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1st step --> Find the pivot\\n        \\n        /*iska matlab aisa number jisko tumhe actually swap karna hai basically \\n\\t\\tleft lesser value to right larger value. So yaha par pehle hum wo left lesser\\n\\t\\tvalue dhund rahe hai next step mein right larger value.Ex: 9 1 5 3 toh \\n\\t\\tisme check karo ki kab tumhe arr[idx+1]>arr[idx] mil jaaye is case mein 1st idx is pivot hoga.\\n\\t\\t*/\\n        \\n        int i = arr.length-2;\\n        while(i>=0 && arr[i]>=arr[i+1])\\n            i--;\\n        \\n  /*why if because in case of the largest number i will be -ve itself like 3 2 1\\n  have to return the smallest arrangement i.e. 1 2 3 so simply reverse no need of \\n  2nd step */\\n\\n        \\n        /*2nd step: Find the just larger value than your arr[i] so we can swap \\n\\t\\tboth the numbers. Ex: 9 1 5 3 mein 1 and 3 will be swapped because 3 is \\n\\t\\tjust immediate larger than our arr[i] */\\n        \\n        if(i>=0){  \\n            int j = arr.length-1;\\n            while(arr[i]>=arr[j])\\n            j--;\\n            \\n            /*Step 3: Swap both the indexes i.e. i and j in our example the resultant\\n\\t\\t\\twould look like 9 3 5 1 */\\n            \\n            swap(arr,i,j);\\n        }\\n        \\n        //Step-4 : Reverse the array after the pivot point\\n        \\n         /*Why see if you look carefully our number after swap becomes 9 3 5 1 \\n\\t\\t but according to question we want the next permutation which is just \\n\\t\\t immediate greater than the given number right so our resultant final answer \\n\\t\\t should be 9 3 1 5, for that we have to reverse the array after the pivot \\n\\t\\t point i.e. reverse from (i+1,arr.length-1) also if you remember our if check \\n\\t\\t is due to what if we provided with the highest number itself so we have to \\n\\t\\t return the smallest permutation i.e. reverse the whole array so our that \\n\\t\\t purpose is also serving because what we are passing is in our \\n\\t\\t reverse array (i+1,arr.length-1) and for highest number i = -1 \\n\\t\\t so automatically due to the function it will become(0,arr.length-1) .\\n */\\n        \\n        reverse(arr,i+1,arr.length-1);\\n        \\n    }\\n    \\n    public void reverse(int[] arr,int i,int j){\\n        while(i<j){\\n            swap(arr,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    public void swap(int[] arr,int i,int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909160,
                "title": "o-n-solution-easy-solution-with-comments",
                "content": "**step1:** find the first decending number from the end. Store number in index.\\n**step2:** If we don\\'t find the index then there is no permutation possible for the current number. So we return the first permutation. To do that we need to return reversed array.\\n**Step 3:** If we got the index, Then we need to find the second index. Second index is basically the index which has value greater then the first index value from back. Store the second index value.\\n**Step 4:** Swap index and second index value.\\n**Step 5:** reverse all the array items after the index value. We are doing this bacause we need to find the minimum permutation value after the array index.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    const len=nums.length-1;\\n    //stores the first index and second index for swapping.\\n    let index;\\n    let secIndex;\\n    \\n    //get the first index\\n    for(index=len-1;index>=0;index--){\\n        if(nums[index]<nums[index+1]){\\n            break;\\n        }\\n    }\\n    //if we don\\'t find first index we don\\'t find second index. we just reverse nums arr.\\n    //that means if we get [3,2,1] as input then our next permutation is [1,2,3].\\n    if(index<0){\\n        nums.reverse();\\n    }else{\\n        //find the second index from last.\\n        //if we find a value from back which is greater than value of index optained.\\n        for(secIndex=len;secIndex>index;secIndex--){\\n            if(nums[secIndex]>nums[index]){\\n                break;\\n            }\\n        }\\n        //swap values of index and secondindex.\\n        [nums[index],nums[secIndex]]=[nums[secIndex],nums[index]];\\n        \\n        //reverse values after the index value till last.\\n        let low=index+1;\\n        let high=len;\\n        while(low<high){\\n           [ nums[low],nums[high]]=[ nums[high],nums[low]];\\n            low++;\\n            high--\\n        }\\n    }\\n    \\n    \\n    return nums;\\n};\\n```\\n**TC: O(n)\\nSC: O(1)**",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    const len=nums.length-1;\\n    //stores the first index and second index for swapping.\\n    let index;\\n    let secIndex;\\n    \\n    //get the first index\\n    for(index=len-1;index>=0;index--){\\n        if(nums[index]<nums[index+1]){\\n            break;\\n        }\\n    }\\n    //if we don\\'t find first index we don\\'t find second index. we just reverse nums arr.\\n    //that means if we get [3,2,1] as input then our next permutation is [1,2,3].\\n    if(index<0){\\n        nums.reverse();\\n    }else{\\n        //find the second index from last.\\n        //if we find a value from back which is greater than value of index optained.\\n        for(secIndex=len;secIndex>index;secIndex--){\\n            if(nums[secIndex]>nums[index]){\\n                break;\\n            }\\n        }\\n        //swap values of index and secondindex.\\n        [nums[index],nums[secIndex]]=[nums[secIndex],nums[index]];\\n        \\n        //reverse values after the index value till last.\\n        let low=index+1;\\n        let high=len;\\n        while(low<high){\\n           [ nums[low],nums[high]]=[ nums[high],nums[low]];\\n            low++;\\n            high--\\n        }\\n    }\\n    \\n    \\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908457,
                "title": "only-for-beginner-100-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        // if(next_permutation(nums.begin(), nums.end())){\\n        //     return;\\n        // }\\n        // sort(nums.begin(), nums.end());\\n        // return;\\n        \\n\\t\\t\\n\\t\\t// Dry run for better understanding , very easy logic\\n\\t\\t\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                sort(nums.begin()+i+1, nums.end());\\n                auto it = upper_bound(nums.begin()+i+1, nums.end(), nums[i]);\\n                swap(*it, nums[i]);\\n                sort(nums.begin()+i+1, nums.end());\\n                return ;\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        return;\\n    }\\n};\\n//  If you understand this then please upvote this.\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        // if(next_permutation(nums.begin(), nums.end())){\\n        //     return;\\n        // }\\n        // sort(nums.begin(), nums.end());\\n        // return;\\n        \\n\\t\\t\\n\\t\\t// Dry run for better understanding , very easy logic\\n\\t\\t\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                sort(nums.begin()+i+1, nums.end());\\n                auto it = upper_bound(nums.begin()+i+1, nums.end(), nums[i]);\\n                swap(*it, nums[i]);\\n                sort(nums.begin()+i+1, nums.end());\\n                return ;\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        return;\\n    }\\n};\\n//  If you understand this then please upvote this.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922289,
                "title": "easy-c-well-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // we move from the left of array and find the first\\n        // element which is lesser than the previous one.\\n        int n = nums.size(), i;\\n        for(i = n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1])\\n                break;\\n        }\\n        \\n        // if sorted in non-increasing order, we can not find\\n        // next permutation\\n        if(i == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // sort the array in non-decreasing order after ith \\n        // position, because we want the very next permutation\\n        sort(nums.begin()+(i+1), nums.end());\\n\\n        // find the very next greater number from nums[i] &\\n        // swap it with that\\n        int j = i+1;\\n        while(j<n && nums[j]<=nums[i]){\\n            j++;\\n        }\\n            \\n        swap(nums[i], nums[j]);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // we move from the left of array and find the first\\n        // element which is lesser than the previous one.\\n        int n = nums.size(), i;\\n        for(i = n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1])\\n                break;\\n        }\\n        \\n        // if sorted in non-increasing order, we can not find\\n        // next permutation\\n        if(i == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // sort the array in non-decreasing order after ith \\n        // position, because we want the very next permutation\\n        sort(nums.begin()+(i+1), nums.end());\\n\\n        // find the very next greater number from nums[i] &\\n        // swap it with that\\n        int j = i+1;\\n        while(j<n && nums[j]<=nums[i]){\\n            j++;\\n        }\\n            \\n        swap(nums[i], nums[j]);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559892,
                "title": "c-solution",
                "content": "## Intuition\\n1. Backward traverse the array until we find the two consecutive numbers such that ```nums[i] < nums[i + 1]```. Because the numbers to the right of ```nums[i]``` are in descending order, so we can\\'t make that part bigger.\\n2. Now we need to backward traverse the array again to find first number ```nums[j]``` such that ```nums[j] > nums[i]```, and then swap them to generate a bigger number.  \\n\\t* Why do we need to find the **first** ```nums[j]```? Because we need to generate the **smallest** permutation that is greater than the original number.\\n3.  After swapping ```nums[i]``` and ```nums[j]```, we need to reverse the numbers to the right of ```nums[i]``` to force this part to be the smallest. \\n\\t* Why do we use reverse rather than sort? Sorting will work as well. However, swapping ```nums[i]``` and ```nums[j]``` doesn\\'t change the fact that the numbers to the right of ```nums[i]``` are still in descending order. So reversing this part can make its value smallest and meanwhile achieve O(N) time complexity. If we use sorting, then the complexity of this part will be O(NlogN).\\n\\n\\n## Implementation\\n```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        \\n        int swap = -1;\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            if(nums[i] < nums[i + 1])\\n            {\\n                swap = i;\\n                break;\\n            }\\n        }\\n\\n        if(swap == -1)\\n        {\\n            Reverse(nums, 0, nums.Length - 1);\\n            return;\\n        }  \\n        \\n        for(int j = nums.Length - 1; j >= 0; j--)\\n        {\\n            if(nums[j] > nums[swap])\\n            {\\n                Swap(nums, j, swap);\\n                break;\\n            }\\n        }\\n        \\n        Reverse(nums, swap + 1, nums.Length - 1);\\n    }\\n    \\n    public void Swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void Reverse(int[] nums, int start, int end)\\n    {\\n        while(start < end)\\n        {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n\\n## Complexity\\n* Time compleixty: O(N)\\n* Space complexity: O(1)",
                "solutionTags": [],
                "code": "```nums[i] < nums[i + 1]```\n```nums[i]```\n```nums[j]```\n```nums[j] > nums[i]```\n```nums[j]```\n```nums[i]```\n```nums[j]```\n```nums[i]```\n```nums[i]```\n```nums[j]```\n```nums[i]```\n```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        \\n        int swap = -1;\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            if(nums[i] < nums[i + 1])\\n            {\\n                swap = i;\\n                break;\\n            }\\n        }\\n\\n        if(swap == -1)\\n        {\\n            Reverse(nums, 0, nums.Length - 1);\\n            return;\\n        }  \\n        \\n        for(int j = nums.Length - 1; j >= 0; j--)\\n        {\\n            if(nums[j] > nums[swap])\\n            {\\n                Swap(nums, j, swap);\\n                break;\\n            }\\n        }\\n        \\n        Reverse(nums, swap + 1, nums.Length - 1);\\n    }\\n    \\n    public void Swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void Reverse(int[] nums, int start, int end)\\n    {\\n        while(start < end)\\n        {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398787,
                "title": "python-solution-with-inline-explanation",
                "content": "```python\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Two key observations in the problem:\\n            1. A decreasing array is the last permutation of the array, and the \\n               next one is the reverse of it. For example, `3,2,1` is the last \\n               permutation of this array and `1,2,3` will be next.\\n            2. For a decreasing subarray, there is a number right before the \\n               subarray that \"leads\" the subarray, e.g., `2,4,3,1` in which `2` \\n               \"leads\" the subarray `4,3,1`. Similarly, the decreasing subarray \\n               is the last permutation of itself, and the next one should be \\n               mostly the reverse of the subarray, except that the \"leading\" \\n               number is going to change. Looking at the previous example, the \\n               next permutation is `3,1,2,4` wherein the \"leading\" number is \\n               `3`, which is the next greater number than `2` in the sequence. \\n               Herein, the rule for generating the next permutation for a \\n               subarray is - 1) swap the \"leading\" number and the next greater \\n               one in the decreasing subarray; 2) reverse the decreasing \\n               subarray.\\n        In summary, the whole process should be the following:\\n            1. Find the decreasing subarray if not the entire array\\n            2. If it is not the entire array, swap the \"leading\" number and its \\n               next greater number in the decreasing subarray\\n            3. Reverse the decreasing part\\n        \"\"\"\\n        # if there is only a single number in the array, the next permutation is\\n        # itself\\n        if len(nums) == 1:\\n            return \\n\\n        # find the decreasing subarray from right to left and the pointer stops \\n        # at the \"leading\" number, if not the head of the array\\n        start = len(nums) - 2\\n        while start >= 0:\\n            if nums[start] < nums[start + 1]:\\n                break\\n            start -= 1\\n\\n        # find the two ends of the subarray to be reversed\\n        if start < 0:\\n            # if the entire array is decreasing, the entire array needs to be \\n            # reversed end-to-end\\n            start = 0\\n        else:\\n            # otherwise, we have a decreasing subarray and a \"leading\" number, \\n            # so we find and swap the \"leading\" number and its next greater \\n            # first \\n            i = start\\n            while i < len(nums) - 1 and nums[cur] < nums[i + 1]:\\n                i += 1\\n            nums[start], nums[i] = nums[i], nums[start]\\n            \\n            # the decreasing subarray will be reversed\\n            start += 1\\n\\n        # reverse the decreasing subarray in-place\\n        end = len(nums) - 1\\n        while start < end:\\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Two key observations in the problem:\\n            1. A decreasing array is the last permutation of the array, and the \\n               next one is the reverse of it. For example, `3,2,1` is the last \\n               permutation of this array and `1,2,3` will be next.\\n            2. For a decreasing subarray, there is a number right before the \\n               subarray that \"leads\" the subarray, e.g., `2,4,3,1` in which `2` \\n               \"leads\" the subarray `4,3,1`. Similarly, the decreasing subarray \\n               is the last permutation of itself, and the next one should be \\n               mostly the reverse of the subarray, except that the \"leading\" \\n               number is going to change. Looking at the previous example, the \\n               next permutation is `3,1,2,4` wherein the \"leading\" number is \\n               `3`, which is the next greater number than `2` in the sequence. \\n               Herein, the rule for generating the next permutation for a \\n               subarray is - 1) swap the \"leading\" number and the next greater \\n               one in the decreasing subarray; 2) reverse the decreasing \\n               subarray.\\n        In summary, the whole process should be the following:\\n            1. Find the decreasing subarray if not the entire array\\n            2. If it is not the entire array, swap the \"leading\" number and its \\n               next greater number in the decreasing subarray\\n            3. Reverse the decreasing part\\n        \"\"\"\\n        # if there is only a single number in the array, the next permutation is\\n        # itself\\n        if len(nums) == 1:\\n            return \\n\\n        # find the decreasing subarray from right to left and the pointer stops \\n        # at the \"leading\" number, if not the head of the array\\n        start = len(nums) - 2\\n        while start >= 0:\\n            if nums[start] < nums[start + 1]:\\n                break\\n            start -= 1\\n\\n        # find the two ends of the subarray to be reversed\\n        if start < 0:\\n            # if the entire array is decreasing, the entire array needs to be \\n            # reversed end-to-end\\n            start = 0\\n        else:\\n            # otherwise, we have a decreasing subarray and a \"leading\" number, \\n            # so we find and swap the \"leading\" number and its next greater \\n            # first \\n            i = start\\n            while i < len(nums) - 1 and nums[cur] < nums[i + 1]:\\n                i += 1\\n            nums[start], nums[i] = nums[i], nums[start]\\n            \\n            # the decreasing subarray will be reversed\\n            start += 1\\n\\n        # reverse the decreasing subarray in-place\\n        end = len(nums) - 1\\n        while start < end:\\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279370,
                "title": "c-with-comments",
                "content": "```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        var n = nums.Length;\\n        // 1. find the last element of the increasing sequence from the back to the front\\n        var lastElementIndex = n - 1;\\n        while (lastElementIndex > 0 && nums[lastElementIndex - 1] >= nums[lastElementIndex]) {\\n            lastElementIndex--;\\n        }\\n\\n        var preLastElementIndex = lastElementIndex - 1;\\n\\n        if (preLastElementIndex < 0) {\\n            // Corner case: 4,3,2,1 => 1,2,3,4\\n            reverse(0, n - 1, nums);\\n        } else {\\n            // 2. find the fist element larger than the pre and replace from the back to the front\\n            var firstElementLargerIndex = n - 1;\\n            while (firstElementLargerIndex > 0 && nums[preLastElementIndex] >= nums[firstElementLargerIndex]) {\\n                firstElementLargerIndex--;\\n            }\\n\\n            // 3. swap\\n            var temp = nums[firstElementLargerIndex];\\n            nums[firstElementLargerIndex] = nums[preLastElementIndex];\\n            nums[preLastElementIndex] = temp;\\n\\n            // 4. reverse [lastElementIndex ... n - 1] in place\\n            reverse(lastElementIndex, n - 1, nums);\\n        }\\n    }\\n\\n    private void reverse(int left, int right, int[] nums) {\\n        while (left < right) {\\n            var temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        var n = nums.Length;\\n        // 1. find the last element of the increasing sequence from the back to the front\\n        var lastElementIndex = n - 1;\\n        while (lastElementIndex > 0 && nums[lastElementIndex - 1] >= nums[lastElementIndex]) {\\n            lastElementIndex--;\\n        }\\n\\n        var preLastElementIndex = lastElementIndex - 1;\\n\\n        if (preLastElementIndex < 0) {\\n            // Corner case: 4,3,2,1 => 1,2,3,4\\n            reverse(0, n - 1, nums);\\n        } else {\\n            // 2. find the fist element larger than the pre and replace from the back to the front\\n            var firstElementLargerIndex = n - 1;\\n            while (firstElementLargerIndex > 0 && nums[preLastElementIndex] >= nums[firstElementLargerIndex]) {\\n                firstElementLargerIndex--;\\n            }\\n\\n            // 3. swap\\n            var temp = nums[firstElementLargerIndex];\\n            nums[firstElementLargerIndex] = nums[preLastElementIndex];\\n            nums[preLastElementIndex] = temp;\\n\\n            // 4. reverse [lastElementIndex ... n - 1] in place\\n            reverse(lastElementIndex, n - 1, nums);\\n        }\\n    }\\n\\n    private void reverse(int left, int right, int[] nums) {\\n        while (left < right) {\\n            var temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061592,
                "title": "o-n-0ms-simple-java-solution-most-optimized-solution-easily-explained-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWrite down all the permuatation of that array in the copy and try to decode how the next permutation comes by fixing the prefixes by following lexicographical order \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the break-point, i: Break-point means the first index i from the back of the given array where arr[i] becomes smaller than arr[i+1].\\nFor example, if the given array is {2,1,5,4,3,0,0}, the break-point will be index 1(0-based indexing). Here from the back of the array, index 1 is the first index where arr[1] i.e. 1 is smaller than arr[i+1] i.e. 5.\\n\\nTo find the break-point, using a loop we will traverse the array backward and store the index i where arr[i] is less than the value at index (i+1) i.e. arr[i+1].\\n\\nIf such a break-point does not exist i.e. if the array is sorted in decreasing order, the given permutation is the last one in the sorted order of all possible permutations. So, the next permutation must be the first i.e. the permutation in increasing order.\\nSo, in this case, we will reverse the whole array and will return it as our answer.\\n\\nIf a break-point exists:\\nFind the smallest number i.e. > arr[i] and in the right half of index i(i.e. from index i+1 to n-1) and swap it with arr[i].\\n\\nReverse the entire right half(i.e. from index i+1 to n-1) of index i. And finally, return the array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n      public void swap(int[] nums, int i, int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public void reverse(int[] nums, int i ,int j){\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n\\n    }\\n    public void nextPermutation(int[] nums) {\\n        int index=-1;\\n        int n = nums.length;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                index= i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            reverse(nums,0,n-1);\\n        }\\n        else{\\n            for(int i=n-1;i>index;i--){\\n                if(nums[i] > nums[index]){\\n                    swap(nums,i,index);\\n                    break;\\n                }\\n            }\\n            reverse(nums,index+1, n-1 );\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public void swap(int[] nums, int i, int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public void reverse(int[] nums, int i ,int j){\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n\\n    }\\n    public void nextPermutation(int[] nums) {\\n        int index=-1;\\n        int n = nums.length;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                index= i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            reverse(nums,0,n-1);\\n        }\\n        else{\\n            for(int i=n-1;i>index;i--){\\n                if(nums[i] > nums[index]){\\n                    swap(nums,i,index);\\n                    break;\\n                }\\n            }\\n            reverse(nums,index+1, n-1 );\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714796,
                "title": "superb-logic-with-unlimited-concept",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        index=-1\\n        n=len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i]<arr[i+1]:\\n                index=i\\n                break\\n        if index==-1:\\n            arr[:]=arr[::-1]\\n            return arr\\n        for i in range(n-1,index-1,-1):\\n            if arr[index]<arr[i]:\\n                arr[index],arr[i]=arr[i],arr[index]\\n                break\\n        arr[::]=arr[:index+1]+sorted(arr[index+1:])\\n        return arr \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        index=-1\\n        n=len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i]<arr[i+1]:\\n                index=i\\n                break\\n        if index==-1:\\n            arr[:]=arr[::-1]\\n            return arr\\n        for i in range(n-1,index-1,-1):\\n            if arr[index]<arr[i]:\\n                arr[index],arr[i]=arr[i],arr[index]\\n                break\\n        arr[::]=arr[:index+1]+sorted(arr[index+1:])\\n        return arr \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565329,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for (int i = n-2; i >= 0; i--) {\\n            if (nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        if (idx != -1) {\\n            for (int i = n-1; i > idx; i--) {\\n                if (nums[i] > nums[idx]) {\\n                    swap(nums[i], nums[idx]);\\n                    break;\\n                }\\n            }\\n        }\\n        reverse(nums.begin()+idx+1, nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for (int i = n-2; i >= 0; i--) {\\n            if (nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        if (idx != -1) {\\n            for (int i = n-1; i > idx; i--) {\\n                if (nums[i] > nums[idx]) {\\n                    swap(nums[i], nums[idx]);\\n                    break;\\n                }\\n            }\\n        }\\n        reverse(nums.begin()+idx+1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537825,
                "title": "c-analytics-solution-runtime-beats-63-memory-beats-71",
                "content": "# Introduction\\nThis is a dumb solution where you ***understand how to create the next permutation manually***. Thus if you are looking for a solution that requires ***less algorithm skills but more thinking***, here is your place.\\n\\n# Code (!the explanation etc. is below this section!)\\n```\\nclass Solution {\\npublic:\\n    void swapAB(int &a, int &b){\\n        int tmp = a;\\n        a = b;\\n        b = tmp;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // if it\\'s the last permutation\\n        bool flag = true;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] > nums[i-1]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag == true){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        // if it\\'s not the last permutation\\n        int lastIndex = nums.size()-1;\\n        while(nums[lastIndex-1] >= nums[lastIndex])\\n            lastIndex --;\\n        lastIndex --;\\n\\n        int mid = 101, midIdx = lastIndex;\\n        for(int i=lastIndex+1; i<nums.size(); i++){\\n            if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n                mid = nums[i];\\n                midIdx = i;\\n            }\\n        }\\n        swap(nums[lastIndex], nums[midIdx]);\\n\\n        for(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n            if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n    }\\n};\\n```\\n\\n# Approach\\nLet us use a couple of examples to help us understand how to get the next permutation.\\nThis is how you find the next permutation:\\n\\n1. 5 4 3 2 1 -> [5 4 3 2 1] ---------------> 1 2 3 4 5 (special case)\\n2. 1 2 3 4 5 -> 1 2 3 4 [5] -> 1 2 **4** [5 3] -> 1 2 4 **3 5**\\n3. 1 3 5 4 2 -> 1 3 [5 4 2] -> 1 **4** [5 3 2] -> 1 4 **2 3 5**\\n4. 1 5 4 3 2 -> 1 [5 4 3 2] -> **2** [5 4 3 1] -> 2 **1 3 4 5**\\n\\nEx1 is **special**, so let us tryna solve case 2-4 first.\\n\\n- The first \"arrow\" represents **finding the longest decending array at the end of the nums**. We temporarily call this decending array as \"The ***queue***\".\\n- The second \"arrow\" represents **replace the num before the queue with the smallest number in the queue that is greater than this number**.\\n- The third \"arrow\" means **sorting the queue**. As the original queue is decending and the replaced number is still in place, we only need to **reverse the whole queue**.\\n\\nNow you know how my solution works. Why it works is just generally how to find the next permutation, you can notice how it works if you print out all the permutations and observe the pattern in it.\\n\\nThe code for this part is\\n```\\n// step one / first \"->\"\\nint lastIndex = nums.size()-1;\\nwhile(nums[lastIndex-1] >= nums[lastIndex])\\n    lastIndex --;\\nlastIndex --;\\n// step two / second \"->\"\\nint mid = 101, midIdx = lastIndex;\\nfor(int i=lastIndex+1; i<nums.size(); i++){\\n    if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n        mid = nums[i];\\n        midIdx = i;\\n    }\\n}\\nswap(nums[lastIndex], nums[midIdx]);\\n// step three / third \"->\"\\nfor(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n    if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n```\\n\\nNow for the special case. Our Ex1 is special is **Thoroughly Decending**, the next permutation is the sorted permutation. Hence, we need an \"if\" statement to watch out for this case, the code is below:\\n```\\nbool flag = true; // keep track of whether it\\'s decending overall\\nfor(int i=1; i<nums.size(); i++){\\n    if(nums[i] > nums[i-1]){\\n        flag = false;\\n        break;\\n    }\\n}\\nif(flag == true){\\n    sort(nums.begin(), nums.end());\\n    return; // remember to return here to keep the nums sorted!\\n}\\n```\\n\\nThere you have it. This is my answer to this problem!\\n\\n# Complexity\\n- Time complexity: O(N) when it\\'s detecting the special case\\n\\n- Space complexity: O(1) only some parameters to keep track of info\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void swapAB(int &a, int &b){\\n        int tmp = a;\\n        a = b;\\n        b = tmp;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // if it\\'s the last permutation\\n        bool flag = true;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] > nums[i-1]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag == true){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        // if it\\'s not the last permutation\\n        int lastIndex = nums.size()-1;\\n        while(nums[lastIndex-1] >= nums[lastIndex])\\n            lastIndex --;\\n        lastIndex --;\\n\\n        int mid = 101, midIdx = lastIndex;\\n        for(int i=lastIndex+1; i<nums.size(); i++){\\n            if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n                mid = nums[i];\\n                midIdx = i;\\n            }\\n        }\\n        swap(nums[lastIndex], nums[midIdx]);\\n\\n        for(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n            if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n    }\\n};\\n```\n```\\n// step one / first \"->\"\\nint lastIndex = nums.size()-1;\\nwhile(nums[lastIndex-1] >= nums[lastIndex])\\n    lastIndex --;\\nlastIndex --;\\n// step two / second \"->\"\\nint mid = 101, midIdx = lastIndex;\\nfor(int i=lastIndex+1; i<nums.size(); i++){\\n    if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n        mid = nums[i];\\n        midIdx = i;\\n    }\\n}\\nswap(nums[lastIndex], nums[midIdx]);\\n// step three / third \"->\"\\nfor(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n    if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n```\n```\\nbool flag = true; // keep track of whether it\\'s decending overall\\nfor(int i=1; i<nums.size(); i++){\\n    if(nums[i] > nums[i-1]){\\n        flag = false;\\n        break;\\n    }\\n}\\nif(flag == true){\\n    sort(nums.begin(), nums.end());\\n    return; // remember to return here to keep the nums sorted!\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347668,
                "title": "java-solution-runtime-0-ms-beats-100-accepted",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        if (A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while (i >= 0 && A[i] >= A[i + 1]) i--;\\n        if (i >= 0) {\\n            int j = A.length - 1;\\n            while (A[j] <= A[i]) j--;\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, A.length - 1);\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while (i < j) swap(A, i++, j--);\\n    }\\n}\\n```\\n# \\u2B06\\uFE0FUpvote if you like the solution",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        if (A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while (i >= 0 && A[i] >= A[i + 1]) i--;\\n        if (i >= 0) {\\n            int j = A.length - 1;\\n            while (A[j] <= A[i]) j--;\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, A.length - 1);\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while (i < j) swap(A, i++, j--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133449,
                "title": "simple-o-n-java-solution-with-explanation-and-example",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        //Example\\n        //   3\\n        //  / \\\\\\n        // 1   2\\n\\n        //find the index of the first number that is lesser than it\\'s next\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(nums[i-1]<nums[i]){\\n                ind1=i-1;       //nums[ind1]=1\\n                break;\\n            }\\n        }\\n        int ind2=-1;\\n        //if such a number exists, for a lexicographical order, find the number immediately bigger than it\\n        if(ind1!=-1){\\n            for(int i=nums.length-1;i>=ind1;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;     //nums[ind2]=2\\n                    break;\\n                }\\n            }\\n            //perform a swap of the two numbers\\n            int temp=nums[ind1];\\n            nums[ind1]=nums[ind2];\\n            nums[ind2]=temp;\\n\\n        //      3\\n        //     / \\\\\\n        //    2   1\\n        }\\n        //reverse the order after the break point(ind1) to ensure the lexicographical order\\n        for(int i=ind1+1,j=nums.length-1;i<j;i++,j--){\\n            int t=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=t;\\n        }\\n        // 2   3\\n        //  \\\\ /\\n        //   1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        //Example\\n        //   3\\n        //  / \\\\\\n        // 1   2\\n\\n        //find the index of the first number that is lesser than it\\'s next\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(nums[i-1]<nums[i]){\\n                ind1=i-1;       //nums[ind1]=1\\n                break;\\n            }\\n        }\\n        int ind2=-1;\\n        //if such a number exists, for a lexicographical order, find the number immediately bigger than it\\n        if(ind1!=-1){\\n            for(int i=nums.length-1;i>=ind1;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;     //nums[ind2]=2\\n                    break;\\n                }\\n            }\\n            //perform a swap of the two numbers\\n            int temp=nums[ind1];\\n            nums[ind1]=nums[ind2];\\n            nums[ind2]=temp;\\n\\n        //      3\\n        //     / \\\\\\n        //    2   1\\n        }\\n        //reverse the order after the break point(ind1) to ensure the lexicographical order\\n        for(int i=ind1+1,j=nums.length-1;i<j;i++,j--){\\n            int t=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=t;\\n        }\\n        // 2   3\\n        //  \\\\ /\\n        //   1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125459,
                "title": "python-easy-to-understand-beats-75-time-complexity",
                "content": "# Code\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        def reverse(nums, start):\\n            end = len(nums) - 1\\n            while start < end:\\n                nums[start], nums[end] = nums[end], nums[start]\\n                start += 1\\n                end -= 1\\n        i = len(nums) - 2\\n        while i >= 0 and nums[i + 1] <= nums[i]:\\n            i -= 1\\n        if i >= 0:\\n            j = len(nums) - 1\\n            while nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        reverse(nums, i + 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        def reverse(nums, start):\\n            end = len(nums) - 1\\n            while start < end:\\n                nums[start], nums[end] = nums[end], nums[start]\\n                start += 1\\n                end -= 1\\n        i = len(nums) - 2\\n        while i >= 0 and nums[i + 1] <= nums[i]:\\n            i -= 1\\n        if i >= 0:\\n            j = len(nums) - 1\\n            while nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        reverse(nums, i + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397776,
                "title": "next-permutation-simple-c-solution",
                "content": "void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }",
                "solutionTags": [],
                "code": "void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2256856,
                "title": "c-simple-fast-solution-next-permutation",
                "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size()-1;\\n        int inflectionPoint=0;\\n        for(int i=n; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                inflectionPoint=i;\\n                break;\\n            }\\n        }\\n        if(inflectionPoint==0){\\n            sort(nums.begin(),nums.end());\\n        }\\n        else{               //if we get an inflection point\\n            int toSwap= nums[inflectionPoint-1];\\n            int min= INT_MAX;\\n            for(int j=inflectionPoint; j<=n; j++){\\n                if(nums[j]-toSwap>0 && nums[j]-toSwap<min){\\n                    int temp=nums[j];\\n                    nums[j]=nums[inflectionPoint-1];\\n                    nums[inflectionPoint-1]=temp;\\n                }\\n            }\\n            sort(nums.begin()+inflectionPoint, nums.end());\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size()-1;\\n        int inflectionPoint=0;\\n        for(int i=n; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                inflectionPoint=i;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2238691,
                "title": "functional-declarative-javascript-typescript-solution",
                "content": "```\\n// mutative!\\nfunction swapValuesByIndex(array, index1, index2){\\n    let value1 = array[index1];\\n    array[index1] = array[index2];\\n    array[index2] = value1;\\n}\\n\\n// mutative! \\nfunction reversePartOfArray(array, startIndex, endIndex){\\n    while(startIndex < endIndex){\\n        swapValuesByIndex(array, startIndex, endIndex);\\n        startIndex += 1;\\n        endIndex -= 1;\\n    }\\n}\\n\\nfunction findLastIndexWhere(array, callbackFn){\\n    for(let i = array.length - 1; i >= 0; i--){\\n        if(callbackFn(array[i], i)) return i;\\n    }\\n}\\n\\n// mutative!\\nfunction nextPermutation(nums: number[]): void {\\n    // step 1: find the last digit that decreases from the one after it\\n    const firstIndex = findLastIndexWhere(nums, (num, i) => nums[i+1] !== undefined && num < nums[i+1]);\\n\\n    // step 1a: if the whole array is monotonically increasing from end to beginning, reverse the entire array\\n    if(firstIndex === undefined){\\n        reversePartOfArray(nums, 0, nums.length - 1);\\n        return;\\n    }\\n\\n    // step 2: find the last digit that is larger than our \"pivot\" digit\\n    const secondIndex = findLastIndexWhere(nums, (num, i) => num > nums[firstIndex]);\\n    \\n    // step 3: swap those digits\\n    swapValuesByIndex(nums, firstIndex, secondIndex);\\n    \\n    // step 4: reverse the part of the number after the swapped one\\n    reversePartOfArray(nums, firstIndex + 1, nums.length - 1);\\n};\\n\\n// time complexity: O(n + n + n) = O(n)\\n// space complexity: O(1)\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// mutative!\\nfunction swapValuesByIndex(array, index1, index2){\\n    let value1 = array[index1];\\n    array[index1] = array[index2];\\n    array[index2] = value1;\\n}\\n\\n// mutative! \\nfunction reversePartOfArray(array, startIndex, endIndex){\\n    while(startIndex < endIndex){\\n        swapValuesByIndex(array, startIndex, endIndex);\\n        startIndex += 1;\\n        endIndex -= 1;\\n    }\\n}\\n\\nfunction findLastIndexWhere(array, callbackFn){\\n    for(let i = array.length - 1; i >= 0; i--){\\n        if(callbackFn(array[i], i)) return i;\\n    }\\n}\\n\\n// mutative!\\nfunction nextPermutation(nums: number[]): void {\\n    // step 1: find the last digit that decreases from the one after it\\n    const firstIndex = findLastIndexWhere(nums, (num, i) => nums[i+1] !== undefined && num < nums[i+1]);\\n\\n    // step 1a: if the whole array is monotonically increasing from end to beginning, reverse the entire array\\n    if(firstIndex === undefined){\\n        reversePartOfArray(nums, 0, nums.length - 1);\\n        return;\\n    }\\n\\n    // step 2: find the last digit that is larger than our \"pivot\" digit\\n    const secondIndex = findLastIndexWhere(nums, (num, i) => num > nums[firstIndex]);\\n    \\n    // step 3: swap those digits\\n    swapValuesByIndex(nums, firstIndex, secondIndex);\\n    \\n    // step 4: reverse the part of the number after the swapped one\\n    reversePartOfArray(nums, firstIndex + 1, nums.length - 1);\\n};\\n\\n// time complexity: O(n + n + n) = O(n)\\n// space complexity: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230218,
                "title": "easy-c-sol-naive-efficient-approach-linear-time",
                "content": "```\\n// Naive Solution Use the Inbuilt C++ function i.e, next_permutation : Time : O(N*N!) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }\\n};\\n\\n// Efficient Solution : Time : O(N) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\n        int n = nums.size();\\n\\n        int ind1,ind2;\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                ind1 = i;\\n                break;\\n            }\\n        }\\n\\n        if(ind1 < 0){\\n            reverse(nums.begin(),nums.end());\\n        }else{\\n\\n            for(int i=n-1;i>ind1;i--){\\n                if(nums[i] > nums[ind1]){\\n                    ind2 = i;\\n                    break;\\n                }\\n            }\\n\\n            swap(nums[ind1],nums[ind2]);\\n\\n            reverse(nums.begin()+ind1+1,nums.end());\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2007932,
                "title": "very-clearly-explained-using-examples-easy-to-understand-python-solution",
                "content": "A very **famous question**!\\nLet me explain using this example.\\n\\n**For example:**\\n2 5 4 3 1 -> 3 5 4 2 1 -> 3 1 2 4 5\\n\\n1. First loop from the end, find the first index that is not increasing,\\nin the example, it is the index of number 2.\\n2. Then we will again loop from the end, find the first index that is bigger than 2,\\nin the example, it is the index of number 3.\\n3. Swap these two.\\n4. At last reverse from 5 to end.\\n\\nTake care of the **duplicates**!\\nFor example:\\n2 5 5 3 1 -> 3 5 5 2 1 -> 3 1 2 5 5 \\n\\n**Time:** O(n)\\n**Space:** O(1)\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if len(nums) == 0 or len(nums) == 1:\\n            return\\n        \\n        i = len(nums) - 1\\n        while i > 0 and nums[i] <= nums[i - 1]: # here must be <= to take care of the duplicates!\\n            i -= 1\\n        \\n        if i == 0:\\n            self.swap(nums, 0, len(nums) - 1)\\n            return\\n        left_index = i - 1\\n        \\n        i = len(nums) - 1\\n        while nums[i] <= nums[left_index]:\\n            i -= 1\\n        nums[i], nums[left_index] = nums[left_index], nums[i]\\n        self.swap(nums, left_index + 1, len(nums) - 1)\\n    \\n    def swap(self, nums, left, right):\\n        while left < right:\\n            nums[left], nums[right] = nums[right], nums[left]\\n            left += 1\\n            right -= 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if len(nums) == 0 or len(nums) == 1:\\n            return\\n        \\n        i = len(nums) - 1\\n        while i > 0 and nums[i] <= nums[i - 1]: # here must be <= to take care of the duplicates!\\n            i -= 1\\n        \\n        if i == 0:\\n            self.swap(nums, 0, len(nums) - 1)\\n            return\\n        left_index = i - 1\\n        \\n        i = len(nums) - 1\\n        while nums[i] <= nums[left_index]:\\n            i -= 1\\n        nums[i], nums[left_index] = nums[left_index], nums[i]\\n        self.swap(nums, left_index + 1, len(nums) - 1)\\n    \\n    def swap(self, nums, left, right):\\n        while left < right:\\n            nums[left], nums[right] = nums[right], nums[left]\\n            left += 1\\n            right -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910219,
                "title": "daily-leet",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int r=-1;\\n        int s=-1;\\n        for(int i=nums.length-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                r=i-1;\\n                break;\\n            }\\n        }\\n        if(r==-1){\\n            reverse(nums,0,nums.length-1);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=r;i--){\\n                if(nums[i]>nums[r]){\\n                    s=i;\\n                    break;\\n                }\\n            }    \\n            swap(nums,r,s);\\n            reverse(nums,r+1,nums.length-1);\\n        }\\n        return;    \\n    }\\n    public void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public void swap(int[] nums, int i, int index) {\\n        int temp = nums[index];\\n        nums[index] = nums[i];\\n        nums[i] = temp;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int r=-1;\\n        int s=-1;\\n        for(int i=nums.length-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                r=i-1;\\n                break;\\n            }\\n        }\\n        if(r==-1){\\n            reverse(nums,0,nums.length-1);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=r;i--){\\n                if(nums[i]>nums[r]){\\n                    s=i;\\n                    break;\\n                }\\n            }    \\n            swap(nums,r,s);\\n            reverse(nums,r+1,nums.length-1);\\n        }\\n        return;    \\n    }\\n    public void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public void swap(int[] nums, int i, int index) {\\n        int temp = nums[index];\\n        nums[index] = nums[i];\\n        nums[i] = temp;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908548,
                "title": "next-permutation-c-solution-commented-explained-easily",
                "content": "```\\n//Check from right to left for any position for while nums[i-1]<nums[i]\\n    void nextPermutation(vector<int>& nums) {\\n        // declaring i so as to store position where the condition is true;\\n        int i =0, n = nums.size()-1;\\n        for(i=n;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        // This case comes when the array is sorted in reverse order in that cause we directly sort it in \\n        // increasing order.\\n        if(i <=0){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        // Do the opertion move from right to left and find any number greater that nums[i] and then \\n        // swap it and sort from that position.\\n        for(int j = n;j>=0;j--){\\n            if(nums[j]>nums[i-1]){\\n                swap(nums[j], nums[i-1]);\\n                sort(nums.begin()+i, nums.end());\\n                break;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Check from right to left for any position for while nums[i-1]<nums[i]\\n    void nextPermutation(vector<int>& nums) {\\n        // declaring i so as to store position where the condition is true;\\n        int i =0, n = nums.size()-1;\\n        for(i=n;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        // This case comes when the array is sorted in reverse order in that cause we directly sort it in \\n        // increasing order.\\n        if(i <=0){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        // Do the opertion move from right to left and find any number greater that nums[i] and then \\n        // swap it and sort from that position.\\n        for(int j = n;j>=0;j--){\\n            if(nums[j]>nums[i-1]){\\n                swap(nums[j], nums[i-1]);\\n                sort(nums.begin()+i, nums.end());\\n                break;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1871342,
                "title": "c-simple-code-easy-to-understand-tc-o-n-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvoid nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                for (l = n - 1; l > k; l--) {\\n                    if (nums[l] > nums[k]) {\\n                        break;\\n                    }\\n                } \\n                swap(nums[k], nums[l]);\\n                reverse(nums.begin() + k + 1, nums.end());\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t}\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvoid nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                for (l = n - 1; l > k; l--) {\\n                    if (nums[l] > nums[k]) {\\n                        break;\\n                    }\\n                } \\n                swap(nums[k], nums[l]);\\n                reverse(nums.begin() + k + 1, nums.end());\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1846325,
                "title": "c-detailed-explanation-with-comments-with-example",
                "content": "Steps involved;\\nExample: find next permutation of {1,2,5,4,3}\\nfirstly select the no. which is lesser then its next element,while checking from backward  ans store its index j\\nfor this example .no is  2 of index 1,stored in j;\\nNow search for the least no which is greater then it starting last index;\\nHere its 3 of index  4;\\n\\nThen swap these,and reverse  from the index j+1;\\nswapping: {1,3,5,4,2};\\nreversing from j+1=1+1=2\\n{1,3,2,4,5} ans\\n\\nThe expection is that,if the no is in desending order,it means our loop will reach to i=-1 before breaking,so the next pemutation will be the no in ascending order or say reverse of current no.for ex:{4,3,2,1} its next permut: {1,2,3,4}\\n\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int i,j=0;\\n        for(i=n-2;i>=0;i--){\\n            \\n            if(nums[i]<nums[i+1]){\\n                j=i;\\n                break;\\n            }\\n        }\\n          if(i==-1){\\n\\t\\t  reverse(nums.begin(),nums.end());   //for cases like {3,2,1}\\n\\t\\t  return;\\n\\t\\t  }\\n        \\n        for(i=n-1;i>j;i--){\\n            if(nums[i]>nums[j]){\\n                swap(nums[i],nums[j]);\\n                \\n                break;\\n            }\\n        }\\n      \\n       reverse(nums.begin()+j+1,nums.end());\\n        \\n        \\n    }\\n};\\n```\\n**Please do upvote if u find useful,It motivates me to post more such**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int i,j=0;\\n        for(i=n-2;i>=0;i--){\\n            \\n            if(nums[i]<nums[i+1]){\\n                j=i;\\n                break;\\n            }\\n        }\\n          if(i==-1){\\n\\t\\t  reverse(nums.begin(),nums.end());   //for cases like {3,2,1}\\n\\t\\t  return;\\n\\t\\t  }\\n        \\n        for(i=n-1;i>j;i--){\\n            if(nums[i]>nums[j]){\\n                swap(nums[i],nums[j]);\\n                \\n                break;\\n            }\\n        }\\n      \\n       reverse(nums.begin()+j+1,nums.end());\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775228,
                "title": "c-easy-and-original-solution-with-comments",
                "content": "```\\nvoid nextPermutation(vector<int>& nums) {\\n\\t// start from end\\n\\tfor (int i=nums.size()-1; i>=1; i--){ \\n\\t\\t\\t// if there is an number that is smaller than the next number, that means we can start swapping\\n\\t\\t\\tif (nums[i]>nums[i-1]){\\n\\t\\t\\t\\t// we search for the smallest number(but larger than current number) in the remaining vector and swap\\n\\t\\t\\t\\tfor (int j=nums.size()-1; j>=i; j--){\\n\\t\\t\\t\\t\\tif (nums[j]>nums[i-1]){\\n\\t\\t\\t\\t\\t\\tswap(nums[i-1],nums[j]);\\n\\t\\t\\t\\t\\t\\t// sort the remaining vector so its smallest possible with index i being the new number\\n\\t\\t\\t\\t\\t\\tsort(nums.begin()+i,nums.end());\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\tsort(nums.begin(),nums.end());\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid nextPermutation(vector<int>& nums) {\\n\\t// start from end\\n\\tfor (int i=nums.size()-1; i>=1; i--){ \\n\\t\\t\\t// if there is an number that is smaller than the next number, that means we can start swapping\\n\\t\\t\\tif (nums[i]>nums[i-1]){\\n\\t\\t\\t\\t// we search for the smallest number(but larger than current number) in the remaining vector and swap\\n\\t\\t\\t\\tfor (int j=nums.size()-1; j>=i; j--){\\n\\t\\t\\t\\t\\tif (nums[j]>nums[i-1]){\\n\\t\\t\\t\\t\\t\\tswap(nums[i-1],nums[j]);\\n\\t\\t\\t\\t\\t\\t// sort the remaining vector so its smallest possible with index i being the new number\\n\\t\\t\\t\\t\\t\\tsort(nums.begin()+i,nums.end());\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\tsort(nums.begin(),nums.end());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392551,
                "title": "c-easy-to-understand-fast-intuitive",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n      int n=nums.size();\\n        int i,k;\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                break;\\n            }    \\n        }    \\n        if(i<0)\\n        reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(k=n-1;k>=0;k--)\\n            {\\n                if(nums[k]>nums[i])\\n                break;\\n            }\\n            swap(nums[i],nums[k]);\\n            reverse(nums.begin()+i+1,nums.end());\\n        }    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n      int n=nums.size();\\n        int i,k;\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                break;\\n            }    \\n        }    \\n        if(i<0)\\n        reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(k=n-1;k>=0;k--)\\n            {\\n                if(nums[k]>nums[i])\\n                break;\\n            }\\n            swap(nums[i],nums[k]);\\n            reverse(nums.begin()+i+1,nums.end());\\n        }    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373821,
                "title": "optimized-solution-with-explanation-in-java-along-with-video",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums.length <=1){\\n            return;\\n        }\\n        \\n        int i=nums.length-2;\\n        for(;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                break;\\n            }\\n        }\\n        \\n        if(i==-1){\\n            reverse(nums, 0, nums.length-1);\\n            return;\\n        }\\n        \\n        int j=nums.length-1;\\n        for(;j>=0;j--){\\n            if(nums[j]>nums[i]){\\n                break;\\n            }\\n        }\\n        \\n        swap(nums, i, j);\\n        reverse(nums, i+1, nums.length-1);\\n        \\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end){\\n        while(start < end){\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n}\\n```\\nBackward traverse the array until we find the two consecutive numbers such that nums[i] < nums[i + 1]. Because the numbers to the right of nums[i] are in descending order, so we can\\'t make that part bigger.\\n\\nNow we need to backward traverse the array again to find the first number nums[j] such that nums[j] > nums[i], and then swap them to generate a bigger number, as we need to generate the smallest permutation that is greater than the original number.\\n\\nAfter swapping nums[i] and nums[j], we need to reverse the numbers to the right of nums[i] to force this part to be the smallest. As swapping nums[i] and nums[j] doesn\\'t change the fact that the numbers to the right of nums[i] are still in descending order. So reversing this part can make its value smallest and meanwhile achieve O(N) time complexity. If we use sorting, then the complexity of this part will be O(NlogN).\\n\\n\\nTime compleixty: O(N)\\nSpace complexity: O(1)\\n\\n\\n![image](https://assets.leetcode.com/users/images/f758bcfa-a02b-4887-9045-c00cc140499d_1627716482.0443752.png)\\n\\nDetailed Explanation with Video:\\nyoutu[dot]be/un9_wSaxn7w\\n(Replace [dot] with .)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums.length <=1){\\n            return;\\n        }\\n        \\n        int i=nums.length-2;\\n        for(;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                break;\\n            }\\n        }\\n        \\n        if(i==-1){\\n            reverse(nums, 0, nums.length-1);\\n            return;\\n        }\\n        \\n        int j=nums.length-1;\\n        for(;j>=0;j--){\\n            if(nums[j]>nums[i]){\\n                break;\\n            }\\n        }\\n        \\n        swap(nums, i, j);\\n        reverse(nums, i+1, nums.length-1);\\n        \\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end){\\n        while(start < end){\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179173,
                "title": "c-fully-detailed-solution",
                "content": "So what do we mean my next permutation of the array\\n\\n# lets learn by basic concept of the permutation - \\n\\nso one of the test case be nums = {1,2,3} and the next permutaion be {1,3,2}\\n\\nso we have\\n\\n![image](https://assets.leetcode.com/users/images/566ca29b-45c5-4eaf-b33a-72ca1af46338_1619532968.2147515.png)\\n\\nSo with the help of the given recursion tree \\n\\nfor the first branch\\n\\n[1, , ,]  ->  we have two choices and than next child have only one possibility and that\\'s our answer but now how do we know that\\'s our answer \\nIf we see clearly that by recursion tree first change will we can made is in level 2 (from level 0) \\nSo if we have 1 as root than we have two choices so criteria for selecting the 2 and 3 is base on the last element as we always going to have one choice\\n\\nSo by the basics of the permutation algorithm - \\nWe can have following intutuion for the question given to us\\n\\n# Step1 - Find the first position in the array which follow the nums[i] > nums[i-1] for the ith element \\n# Step2 - After selecting the ith position we search for the next greater element than the ith element\\n# Step3 - Swap the both the current element at index i and next greater element\\n# Step4 - Reverse the numbers next to the ith position\\nFollow following step we will able to solve the question in **O(n) - time complexity and O(1) - time complexity**\\n\\n# Code -   \\n![image](https://assets.leetcode.com/users/images/6663e1a1-368a-4c0f-9a6b-636a35ee72f6_1619533848.548016.png)\\n\\nTo strengthen the grip on this algorithm try to solve following question\\n**1830. Minimum Number of Operations to Make String Sorted**\\n\\nI hope my explanation is enough for you guys to proceed.",
                "solutionTags": [],
                "code": "So what do we mean my next permutation of the array\\n\\n# lets learn by basic concept of the permutation - \\n\\nso one of the test case be nums = {1,2,3} and the next permutaion be {1,3,2}\\n\\nso we have\\n\\n![image](https://assets.leetcode.com/users/images/566ca29b-45c5-4eaf-b33a-72ca1af46338_1619532968.2147515.png)\\n\\nSo with the help of the given recursion tree \\n\\nfor the first branch\\n\\n[1, , ,]  ->  we have two choices and than next child have only one possibility and that\\'s our answer but now how do we know that\\'s our answer \\nIf we see clearly that by recursion tree first change will we can made is in level 2 (from level 0) \\nSo if we have 1 as root than we have two choices so criteria for selecting the 2 and 3 is base on the last element as we always going to have one choice\\n\\nSo by the basics of the permutation algorithm - \\nWe can have following intutuion for the question given to us\\n\\n# Step1 - Find the first position in the array which follow the nums[i] > nums[i-1] for the ith element \\n# Step2 - After selecting the ith position we search for the next greater element than the ith element\\n# Step3 - Swap the both the current element at index i and next greater element\\n# Step4 - Reverse the numbers next to the ith position\\nFollow following step we will able to solve the question in **O(n) - time complexity and O(1) - time complexity**\\n\\n# Code -   \\n![image](https://assets.leetcode.com/users/images/6663e1a1-368a-4c0f-9a6b-636a35ee72f6_1619533848.548016.png)\\n\\nTo strengthen the grip on this algorithm try to solve following question\\n**1830. Minimum Number of Operations to Make String Sorted**\\n\\nI hope my explanation is enough for you guys to proceed.",
                "codeTag": "Unknown"
            },
            {
                "id": 1151884,
                "title": "100-faster-c-next-permutation",
                "content": "***Do upvote if you found it helpful as it motivates me to post more content***\\n***Make sure to make a dry run for better understanding***\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) {\\n        int idx=-1;\\n        int n=v.size();\\n        int i,prev;\\n        for(i=n-1;i>0;i--)\\n        {\\n            if(v[i]>v[i-1]) \\n            {\\n                idx=i;\\n                break;\\n            }\\n        }\\n        \\n        if(idx==-1) // if given in descending order then reverse it\\n            reverse(v.begin(),v.end());\\n        \\n        else\\n        {\\n              prev=idx;\\n            for(i=idx+1;i<n;i++)\\n            {\\n                if((v[i]>v[idx-1]) && (v[i]<=v[prev]))\\n                    prev=i;\\n            }\\n             swap(v[idx-1],v[prev]);\\n             reverse(v.begin()+idx,v.end());\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) {\\n        int idx=-1;\\n        int n=v.size();\\n        int i,prev;\\n        for(i=n-1;i>0;i--)\\n        {\\n            if(v[i]>v[i-1]) \\n            {\\n                idx=i;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1029262,
                "title": "c-10-lines-0ms-beats-100",
                "content": "```\\nvoid nextPermutation(vector<int>& nums) {\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            for(int j = nums.size()-1; j >= i; j--){\\n                if(nums.at(j) > nums.at(i)){\\n                    swap(nums.at(j),nums.at(i));\\n                    reverse(nums.begin()+i+1, nums.end());\\n                    return;\\n                }\\n            }\\n        }\\n        reverse(nums.begin(), nums.end());             \\n    }\\n```\\ni wrote this solution 2 weeks ago. \\nthe reason i came back to this solution is because I was doing [https://leetcode.com/problems/permutation-sequence/](http://) and thought i could resue codes in this problem. \\n",
                "solutionTags": [],
                "code": "```\\nvoid nextPermutation(vector<int>& nums) {\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            for(int j = nums.size()-1; j >= i; j--){\\n                if(nums.at(j) > nums.at(i)){\\n                    swap(nums.at(j),nums.at(i));\\n                    reverse(nums.begin()+i+1, nums.end());\\n                    return;\\n                }\\n            }\\n        }\\n        reverse(nums.begin(), nums.end());             \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 724118,
                "title": "python3-solution",
                "content": "```\\nimport bisect\\nclass Solution:\\n    \\n    def reverse(self,nums,low,high):\\n        while low<=high:\\n            nums[low],nums[high] = nums[high],nums[low]\\n            low+=1\\n            high-=1\\n    \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        i = length-2\\n        index = None\\n        while i>=0:\\n            if nums[i]<nums[i+1]:\\n                index = i\\n                break\\n            i = i-1\\n        if index==None:\\n            self.reverse(nums,0,length-1)\\n        else:\\n            self.reverse(nums,index+1,length-1)\\n            swap_index = bisect.bisect_right(nums,nums[index],index+1,length-1)\\n            nums[index],nums[swap_index] = nums[swap_index],nums[index]\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\nclass Solution:\\n    \\n    def reverse(self,nums,low,high):\\n        while low<=high:\\n            nums[low],nums[high] = nums[high],nums[low]\\n            low+=1\\n            high-=1\\n    \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        i = length-2\\n        index = None\\n        while i>=0:\\n            if nums[i]<nums[i+1]:\\n                index = i\\n                break\\n            i = i-1\\n        if index==None:\\n            self.reverse(nums,0,length-1)\\n        else:\\n            self.reverse(nums,index+1,length-1)\\n            swap_index = bisect.bisect_right(nums,nums[index],index+1,length-1)\\n            nums[index],nums[swap_index] = nums[swap_index],nums[index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375358,
                "title": "c-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        if(nums.size()<=1) return;\\n        int n= nums.size(), pos, i;\\n        \\n        for(i=n-1; i>=1; i--){\\n            if(nums[i-1]<nums[i])\\n               break;\\n        }\\n        if(i==0) return reverse(nums.begin(), nums.end());\\n        pos=i-1;\\n        \\n        for(i=n-1; i>pos && i>=0; i--){\\n            if(nums[i]>nums[pos]){\\n                swap(nums[i], nums[pos]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + pos+1, nums.end());\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        if(nums.size()<=1) return;\\n        int n= nums.size(), pos, i;\\n        \\n        for(i=n-1; i>=1; i--){\\n            if(nums[i-1]<nums[i])\\n               break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 327076,
                "title": "python-24ms-beats-94-with-step-by-step-explanation",
                "content": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        card = len(nums)\\n        \\n        for k in range(card-1):             # check if a greater arrangement is not possible\\n            if nums[k] < nums[k+1]:\\n                break\\n        else:\\n            nums.reverse()                  # if it\\'s not possible - reverse sequence and stop\\n            return\\n\\n        for i in range(card - 1, 0, -1):    # card-1, card-2, card-3, ..., 2, 1\\n            if nums[i] > nums[i - 1]:       # from the end of sequence find the first decreasing element (\\'nums[i-1]\\')\\n                low = nums[i]\\n                \\n                # among afterward digits (nums[i]...nums[card-1]) we find the smallest digit (\\'low\\') that is bigger then \\'nums[i-1]\\'\\n                for n in range(i+1, card):  \\n                    if nums[i-1] < nums[n] < low:\\n                        low = nums[n]\\n\\n                low_index = nums.index(low, i) \\n                nums[i - 1], nums[low_index] = nums[low_index], nums[i - 1]  # swap \\'nums[i-1]\\' and \\'low\\' in a sequence\\n            \\n                for iter_num in range(card-1, i, -1):  # sort afterward digits (nums[i]...nums[card-1])\\n                    for idx in range(i, iter_num):     # PS: this is Bubble Sort algorithm, but you can choose smth faster\\n                        if nums[idx] > nums[idx + 1]:\\n                            nums[idx + 1], nums[idx] = nums[idx], nums[idx + 1]\\n                break                                  # STOP\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        card = len(nums)\\n        \\n        for k in range(card-1):             # check if a greater arrangement is not possible\\n            if nums[k] < nums[k+1]:\\n                break\\n        else:\\n            nums.reverse()                  # if it\\'s not possible - reverse sequence and stop\\n            return\\n\\n        for i in range(card - 1, 0, -1):    # card-1, card-2, card-3, ..., 2, 1\\n            if nums[i] > nums[i - 1]:       # from the end of sequence find the first decreasing element (\\'nums[i-1]\\')\\n                low = nums[i]\\n                \\n                # among afterward digits (nums[i]...nums[card-1]) we find the smallest digit (\\'low\\') that is bigger then \\'nums[i-1]\\'\\n                for n in range(i+1, card):  \\n                    if nums[i-1] < nums[n] < low:\\n                        low = nums[n]\\n\\n                low_index = nums.index(low, i) \\n                nums[i - 1], nums[low_index] = nums[low_index], nums[i - 1]  # swap \\'nums[i-1]\\' and \\'low\\' in a sequence\\n            \\n                for iter_num in range(card-1, i, -1):  # sort afterward digits (nums[i]...nums[card-1])\\n                    for idx in range(i, iter_num):     # PS: this is Bubble Sort algorithm, but you can choose smth faster\\n                        if nums[idx] > nums[idx + 1]:\\n                            nums[idx + 1], nums[idx] = nums[idx], nums[idx + 1]\\n                break                                  # STOP\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301074,
                "title": "swift-16ms-100-beat-using-internet-logix",
                "content": "Check it out on the web. It\\'s good.\\n\\n```\\nclass Solution {\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        \\n        if nums.count <= 0 { return }\\n        \\n        var switchIndex: Int?\\n        var prev = nums.last!\\n        var i: Int = nums.count - 2\\n        \\n        while i >= 0 {    \\n            if nums[i] < prev {\\n                switchIndex = i\\n                break\\n            }\\n            prev = nums[i]\\n            i -= 1\\n        }\\n        \\n        guard let index = switchIndex else {\\n            nums.reverse()\\n            return\\n        }\\n        \\n        var successorValue: Int?\\n        var successorIndex: Int = index + 1\\n        \\n        for i in index+1..<nums.count {\\n            if nums[i] > nums[index] {\\n                if let value = successorValue {\\n                    if nums[i] <= value {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                } else {\\n                    successorValue = nums[i]\\n                    successorIndex = i\\n                }\\n            }\\n        }\\n        \\n        nums.swapAt(successorIndex, index)\\n        nums[(index+1)...].reverse()\\n    }\\n}\\n```\\n\\nDig?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        \\n        if nums.count <= 0 { return }\\n        \\n        var switchIndex: Int?\\n        var prev = nums.last!\\n        var i: Int = nums.count - 2\\n        \\n        while i >= 0 {    \\n            if nums[i] < prev {\\n                switchIndex = i\\n                break\\n            }\\n            prev = nums[i]\\n            i -= 1\\n        }\\n        \\n        guard let index = switchIndex else {\\n            nums.reverse()\\n            return\\n        }\\n        \\n        var successorValue: Int?\\n        var successorIndex: Int = index + 1\\n        \\n        for i in index+1..<nums.count {\\n            if nums[i] > nums[index] {\\n                if let value = successorValue {\\n                    if nums[i] <= value {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                } else {\\n                    successorValue = nums[i]\\n                    successorIndex = i\\n                }\\n            }\\n        }\\n        \\n        nums.swapAt(successorIndex, index)\\n        nums[(index+1)...].reverse()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291800,
                "title": "simple-c-solution-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i = 0;\\n        for(i = nums.size() - 2 ; i >= 0 ; i--){\\n            if(nums[i] < nums[i+1])break;\\n        }\\n        sort(nums.begin() + i + 1,nums.end());\\n        for(int j = i; j < nums.size();j++ ){\\n            if(nums[j] > nums[i]){\\n                swap(nums[i] , nums[j]);\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i = 0;\\n        for(i = nums.size() - 2 ; i >= 0 ; i--){\\n            if(nums[i] < nums[i+1])break;\\n        }\\n        sort(nums.begin() + i + 1,nums.end());\\n        for(int j = i; j < nums.size();j++ ){\\n            if(nums[j] > nums[i]){\\n                swap(nums[i] , nums[j]);\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213308,
                "title": "simple-javascript-solution-beats-100",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    function swap(a, b) {\\n        const temp = nums[a]\\n        nums[a] = nums[b]\\n        nums[b] = temp\\n    }\\n    \\n    function reverse(start) {\\n        let end = nums.length - 1\\n        while (start < end) {\\n            swap(start, end)\\n            start++\\n            end--\\n        }\\n    }\\n    \\n    \\n    let i = nums.length - 2;\\n    while (i >= 0 && nums[i + 1] <= nums[i]) {\\n        i--;\\n    }\\n    if (i < 0) {\\n        reverse(0);\\n        return;\\n    }\\n    let j = nums.length - 1;\\n    while (j >= 0 && nums[j] <= nums[i]) {\\n        j--;\\n    }\\n    swap(i, j);\\n    reverse(i + 1);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    function swap(a, b) {\\n        const temp = nums[a]\\n        nums[a] = nums[b]\\n        nums[b] = temp\\n    }\\n    \\n    function reverse(start) {\\n        let end = nums.length - 1\\n        while (start < end) {\\n            swap(start, end)\\n            start++\\n            end--\\n        }\\n    }\\n    \\n    \\n    let i = nums.length - 2;\\n    while (i >= 0 && nums[i + 1] <= nums[i]) {\\n        i--;\\n    }\\n    if (i < 0) {\\n        reverse(0);\\n        return;\\n    }\\n    let j = nums.length - 1;\\n    while (j >= 0 && nums[j] <= nums[i]) {\\n        j--;\\n    }\\n    swap(i, j);\\n    reverse(i + 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 119205,
                "title": "simple-python-code",
                "content": "```python\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # 1. get the start index of non-increasing sequence from tail\\n        # 2. swap\\n        # 3. sort the non-increasing\\n        if not nums: return nums\\n        l = len(nums)\\n        i, j = l - 2, l - 1\\n        while i >= 0 and nums[i] >= nums[i+1]:\\n            i -= 1\\n        while j > i and nums[j] <= nums[i]:\\n            j -= 1\\n        nums[i], nums[j] = nums[j], nums[i]\\n        nums[i+1:] = sorted(nums[i+1:])\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # 1. get the start index of non-increasing sequence from tail\\n        # 2. swap\\n        # 3. sort the non-increasing\\n        if not nums: return nums\\n        l = len(nums)\\n        i, j = l - 2, l - 1\\n        while i >= 0 and nums[i] >= nums[i+1]:\\n            i -= 1\\n        while j > i and nums[j] <= nums[i]:\\n            j -= 1\\n        nums[i], nums[j] = nums[j], nums[i]\\n        nums[i+1:] = sorted(nums[i+1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14000,
                "title": "a-mathematical-solution-accepted-as-best-in-c-well-explained",
                "content": "The following algorithm from [wiki][1] generates the next permutation lexicographically after a given permutation. It changes the given permutation in-place.\\n\\n - Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\\n - Find the largest index l greater than k such that a[k] < a[l].\\n - Swap the value of a[k] with that of a[l].\\n - Reverse the sequence from a[k + 1] up to and including the final element a[n].\\n\\nAs for the demonstration, it will be presented in the comments of the solution as follows for your better understanding.\\n\\n----------\\n\\n    void swap(int* p, int* q)\\n    {\\n        int t = *p; *p = *q; *q = t;\\n    }\\n    void reverse(int* nums, int begin, int end)\\n    {\\n        for(int i = begin; i < (begin+end+1)/2; i++)\\n            swap(nums+i, nums+end+begin-i);\\n    }\\n    void nextPermutation(int* nums, int size)\\n    {\\n        int i=size-1, j=size-1;\\n        while(i>0 && nums[i]<=nums[i-1]) i--; //make sure the [i..size-1] is in descending order;\\n        if(i==0) //the whole array is descending now, reverse it to the smallest as problem requires;\\n        {\\n            reverse(nums, 0, size-1);\\n            return ;\\n        }\\n        while(nums[j] <= nums[i-1]) j--; //find the first bigger one backwards;\\n        swap(nums+j, nums+i-1); //ensure the next is bigger;\\n        reverse(nums, i, size-1); //since [i..size-1] is descending, after reverse it will be ascending and as a result - [i..size-1] will be the smallest - the smallest in the bigger results - the next permutation;\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "The following algorithm from [wiki][1] generates the next permutation lexicographically after a given permutation. It changes the given permutation in-place.\\n\\n - Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\\n - Find the largest index l greater than k such that a[k] < a[l].\\n - Swap the value of a[k] with that of a[l].\\n - Reverse the sequence from a[k + 1] up to and including the final element a[n].\\n\\nAs for the demonstration, it will be presented in the comments of the solution as follows for your better understanding.\\n\\n----------\\n\\n    void swap(int* p, int* q)\\n    {\\n        int t = *p; *p = *q; *q = t;\\n    }\\n    void reverse(int* nums, int begin, int end)\\n    {\\n        for(int i = begin; i < (begin+end+1)/2; i++)\\n            swap(nums+i, nums+end+begin-i);\\n    }\\n    void nextPermutation(int* nums, int size)\\n    {\\n        int i=size-1, j=size-1;\\n        while(i>0 && nums[i]<=nums[i-1]) i--; //make sure the [i..size-1] is in descending order;\\n        if(i==0) //the whole array is descending now, reverse it to the smallest as problem requires;\\n        {\\n            reverse(nums, 0, size-1);\\n            return ;\\n        }\\n        while(nums[j] <= nums[i-1]) j--; //find the first bigger one backwards;\\n        swap(nums+j, nums+i-1); //ensure the next is bigger;\\n        reverse(nums, i, size-1); //since [i..size-1] is descending, after reverse it will be ascending and as a result - [i..size-1] will be the smallest - the smallest in the bigger results - the next permutation;\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order",
                "codeTag": "Unknown"
            },
            {
                "id": 14008,
                "title": "20-line-1ms-in-place-java-code-with-expalantion",
                "content": "> 1. scan from right to left, find first pair where a[i] > a[i-1]. note that a[i:] is non-ascending.\\n> 2. scan from right to left again, find first element a[j] where a[j] > a[i-1]. since a[i:] is non-ascending, a[j] is the smallest number that > a[i-1].\\n> 3. swap a[i-1] with a[j]. note that after swap, a[i:] remains non-ascending.\\n> 4. reverse a[i:] so that a[i:] becomes non-descending.\\n\\n    public class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int p = nums.length-1;\\n            while (p>0 && nums[p]<=nums[p-1]) { --p; }\\n            if (p == 0) {  // case like [3,2,1]\\n                reverse(nums, 0, nums.length-1);\\n                return;\\n            }\\n            int q = nums.length-1;\\n            while (nums[q]<=nums[p-1]) { --q; }\\n            int temp = nums[p-1]; nums[p-1] = nums[q]; nums[q] = temp;\\n            reverse(nums, p, nums.length-1);\\n        }\\n        \\n        private void reverse(int[] a, int from, int to) {\\n            for (; from < to; ++from, --to) {\\n                int temp = a[from];\\n                a[from] = a[to];\\n                a[to] = temp;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int p = nums.length-1;\\n            while (p>0 && nums[p]<=nums[p-1]) { --p; }",
                "codeTag": "Java"
            },
            {
                "id": 14055,
                "title": "one-loop-simple-java-solution-with-comments",
                "content": "    public class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int len = nums.length;\\n            int index = -1;\\n            //find out the index that is not ascending from right most\\n            for(int i=len-2; i>=0; i--) {\\n                if(nums[i] < nums[i+1]) {\\n                    index = i; break;\\n                }\\n            }\\n            if(index == -1) Arrays.sort(nums);\\n            else {\\n                //sort the right part of index and swap the index with the min of nums bigger than nums[index] in the right part\\n                Arrays.sort(nums, index+1, len);\\n                for(int i=index+1; i<len; i++) {\\n                    if(nums[i] > nums[index]) {\\n                        swap(nums, i, index);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        public void swap(int[]nums, int i, int j) {\\n            int tmp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = tmp;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int len = nums.length;\\n            int index = -1;\\n            //find out the index that is not ascending from right most\\n            for(int i=len-2; i>=0; i--) {\\n                if(nums[i] < nums[i+1]) {\\n                    index = i; break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14073,
                "title": "4-line-12ms-c-code",
                "content": "    class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int i;\\n            for(i = nums.size() - 1;i > 0 && nums[i-1] >= nums[i];i--);\\n            std::reverse(nums.begin() + i, nums.end());\\n            if (i>0) swap(nums[i-1],*upper_bound(nums.begin() + i, nums.end(),nums[i-1]));\\n        }\\n    };\\n\\nThanks for the upper_bound idea from:\\nhttps://leetcode.com/discuss/41925/solution-lines-imitate-next_permutation-bring-binary-search\\n\\notherwise I search it myself:\\n\\n    class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int i,j;\\n            \\n            for(i = nums.size() - 1;i > 0 && nums[i-1] >= nums[i];i--);\\n            if (i)\\n            {\\n                for(j = nums.size() - 1; nums[j] <= nums[i-1];j--);\\n                swap(nums[i-1],nums[j]);\\n            }\\n            std::reverse(nums.begin() + i, nums.end());\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int i;\\n            for(i = nums.size() - 1;i > 0 && nums[i-1] >= nums[i];i--);\\n            std::reverse(nums.begin() + i, nums.end());\\n            if (i>0) swap(nums[i-1],*upper_bound(nums.begin() + i, nums.end(),nums[i-1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 14079,
                "title": "my-12ms-c-solution-use-reverse-iterator-very-easy-to-understand",
                "content": "the next permutaion could be like this.\\n\\n 1. find the first element which is great than the previous one from the\\n    last.\\n 2. then judge whether it is the first element of the vector or not .if\\n    it is the first element ,it means the vector is descent ,like this\\n    [5,4,3,2,1]\\n 3. then just sort it ascend.if it is not ,then swap the iter+1 to the\\n    minimum element which is great than iter+1.then sort the remaining\\n    vector.\\n\\n    class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return ;\\n        \\n        //use reverse iterator,because we want to iterate from the last to the first element\\n        auto iter=nums.rbegin();\\n        \\n        //find first element that is greater than the previous one.this time *(iter+1) is greater than *iter\\n        while(iter!=(nums.rend()-1)&&*iter<=*(iter+1))\\n            iter++;\\n            \\n        //if iter point to the first element .which means the origin vecotr is descand,just sort the vector\\n        if(iter==nums.rend()-1)\\n            sort(nums.begin(),nums.end());\\n        else\\n        {\\n            //or swap iter+1 to the element which is the mixest one but great than itself\\n            auto upper=iter;\\n            auto tmp=nums.rbegin();\\n            for(;tmp!=iter;tmp++)\\n            {\\n                if(*tmp>*(iter+1))\\n                {\\n                    if(*tmp<*upper)\\n                    {\\n                        upper=tmp;\\n                    }\\n                }\\n            }\\n            swap(*(iter+1),*upper);\\n            \\n            //sort the element\\n            sort(nums.rbegin(),iter+1,greater<int>());\\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return ;\\n        \\n        //use reverse iterator,because we want to iterate from the last to the first element\\n        auto iter=nums.rbegin();\\n        \\n        //find first element that is greater than the previous one.this time *(iter+1) is greater than *iter\\n        while(iter!=(nums.rend()-1)&&*iter<=*(iter+1))\\n            iter++;\\n            \\n        //if iter point to the first element .which means the origin vecotr is descand,just sort the vector\\n        if(iter==nums.rend()-1)\\n            sort(nums.begin(),nums.end());\\n        else\\n        {\\n            //or swap iter+1 to the element which is the mixest one but great than itself\\n            auto upper=iter;\\n            auto tmp=nums.rbegin();\\n            for(;tmp!=iter;tmp++)\\n            {\\n                if(*tmp>*(iter+1))\\n                {\\n                    if(*tmp<*upper)\\n                    {\\n                        upper=tmp;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 4056343,
                "title": "c-one-line-code-2-approaches",
                "content": "# *PLEASE UPVOTE GUYS \\uD83E\\uDD79*\\n\\n\\n# Approach**\\n1. **With inbuilt STL function** \\n\\n2. **pointers**\\n- The nextPermutation function takes a vector nums as input and is used to find the next lexicographically greater permutation of the elements in nums.\\n\\n- It first calculates the size of the nums vector and initializes the index variable to -1.\\n\\n- It searches for the first element index from the right (starting from the second-to-last element) such that nums[i] is less than nums[i+1]. This step helps identify the rightmost element that can be modified to create a greater permutation.\\n\\n- If an index is found (i.e., there\\'s a possible next permutation), it proceeds to find the smallest element greater than nums[index] from the right. This element is found by iterating from the right end of the vector. Once found, it swaps this element with nums[index].\\n\\n- Finally, it reverses the elements to the right of index. This step ensures that the remaining elements to the right are in ascending order, making the permutation as small as possible while still being greater than the original.\\n\\n# Complexity\\n- Time complexity:\\n**O(N)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\n                  ----------Approach 1----------\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n\\n                  ----------Approach 2----------\\n\\nclass Solution {\\npublic:\\n    // Function to find the next lexicographically greater permutation of \\'nums\\'\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(); // Get the size of the \\'nums\\' vector\\n        int index = -1; // Initialize \\'index\\' to -1\\n\\n        // 1. Find the first element \\'index\\' from the right such that nums[i] < nums[i+1]\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        // 2. If \\'index\\' is found, find the smallest element greater than nums[index] from the right\\n        if (index != -1) {\\n            for (int i = n - 1; i >= index; i--) {\\n                if (nums[i] > nums[index]) {\\n                    swap(nums[i], nums[index]); // Swap nums[i] and nums[index]\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // 3. Reverse the elements to the right of \\'index\\'\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n                  ----------Approach 1----------\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n\\n                  ----------Approach 2----------\\n\\nclass Solution {\\npublic:\\n    // Function to find the next lexicographically greater permutation of \\'nums\\'\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(); // Get the size of the \\'nums\\' vector\\n        int index = -1; // Initialize \\'index\\' to -1\\n\\n        // 1. Find the first element \\'index\\' from the right such that nums[i] < nums[i+1]\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        // 2. If \\'index\\' is found, find the smallest element greater than nums[index] from the right\\n        if (index != -1) {\\n            for (int i = n - 1; i >= index; i--) {\\n                if (nums[i] > nums[index]) {\\n                    swap(nums[i], nums[index]); // Swap nums[i] and nums[index]\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // 3. Reverse the elements to the right of \\'index\\'\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002581,
                "title": "leetcode-31-next-permutation-c-solution-explanation-and-complexity-analysis",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start by traversing the list of numbers from right to left until you find the first element (let\\'s call it nums[i]) that is smaller than its right neighbor (nums[i+1]). This element is the first candidate for swapping.\\n\\n- It simply means that if we have a number that is greater that number nums[i] on the right we can get an array that is greater (lexicographically ordering of elements) than the current number and as the permutation are in lexicographical order we can get our next permutation just by manipulating the elements on the right side.\\n\\n- If no such element is found (i.e., if i becomes -1), it means that the list is in descending order, and there is no greater permutation possible. In this case, reverse the entire list to obtain the smallest permutation and return it.\\n\\n- If you found an element to swap (i.e., i is not -1), proceed to find the smallest element to the right of nums[i] that is just greater than nums[i]. This is done by traversing the list again from right to left and stopping when you find an element greater than nums[i]. Let\\'s call this element nums[j].\\n\\n- Swap nums[i] and nums[j] to get the array that will have greater value.Like in [1,2,3,2,1] doing above steps will get us to [1,3,2,2,1].Since we got our array greater by just with index (i), the value of array on the right side of (i) must be lowest to get the next permutation.\\n\\n- Finally, sort the elements to the right of nums[i] in ascending order to ensure you have the next greater permutation.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  void nextPermutation(vector<int>& nums) {\\n    int n = nums.size(), i = n - 2;\\n    while(i >= 0 && nums[i] >= nums[i + 1])i--;\\n    if(i < 0){\\n      reverse(nums.begin() + i + 1, nums.end());\\n      return;\\n    }\\n    int j = n - 1;\\n    while(j > i && nums[j] <= nums[i])j--;\\n    swap(nums[i], nums[j]);\\n    sort(nums.begin() + i + 1, nums.end());\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void nextPermutation(vector<int>& nums) {\\n    int n = nums.size(), i = n - 2;\\n    while(i >= 0 && nums[i] >= nums[i + 1])i--;\\n    if(i < 0){\\n      reverse(nums.begin() + i + 1, nums.end());\\n      return;\\n    }\\n    int j = n - 1;\\n    while(j > i && nums[j] <= nums[i])j--;\\n    swap(nums[i], nums[j]);\\n    sort(nums.begin() + i + 1, nums.end());\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910626,
                "title": "better-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int imp=n-1;\\n        while(imp>=0)\\n        {\\n               if(imp==0)\\n            break;\\n            if(nums[imp]<=nums[imp-1])\\n            {\\n                imp--;\\n            }\\n            else\\n            break;\\n         \\n        }\\n        if(imp!=0)\\n        {\\n            int greater=-1;\\n            for(int i=imp;i<n;i++)\\n            {\\n                if(greater==-1 || nums[greater]>nums[i])\\n                {\\n                   if(nums[imp-1]<nums[i])\\n                   {\\n                       greater=i;\\n                   }\\n                }\\n            }\\n            swap(nums[greater], nums[imp-1]);\\n        }\\n        sort(nums.begin()+imp, nums.end());\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int imp=n-1;\\n        while(imp>=0)\\n        {\\n               if(imp==0)\\n            break;\\n            if(nums[imp]<=nums[imp-1])\\n            {\\n                imp--;\\n            }\\n            else\\n            break;\\n         \\n        }\\n        if(imp!=0)\\n        {\\n            int greater=-1;\\n            for(int i=imp;i<n;i++)\\n            {\\n                if(greater==-1 || nums[greater]>nums[i])\\n                {\\n                   if(nums[imp-1]<nums[i])\\n                   {\\n                       greater=i;\\n                   }\\n                }\\n            }\\n            swap(nums[greater], nums[imp-1]);\\n        }\\n        sort(nums.begin()+imp, nums.end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781549,
                "title": "c-optimized-approach-with-step-by-step-solution",
                "content": "# Intuition\\nI referred to a youtube video for Lexicographical ordering | Order of permutation | Discrete Mathematics\\n# Approach\\nThis can be divided into four Steps:\\n\\n**Step 1:** Find the largest value of i such that nums[i-1] < nums[i]\\n\\nA short note (If i is 0, it means the array is in descending order, so we reverse it to get the smallest permutation as in lexicographic orderring leading zeros are significant)\\n\\n**Step 2:** Find the largest value of j such that nums[i-1] < nums[j]\\n**Step 3:** Interchange nums[i-1] and nums[j]\\n**Step 4:** Reverse the numbers from index i to the end\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void nextPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n    \\n    // Step 1: Find the largest value of i such that nums[i-1] < nums[i]\\n    int i = n - 1;\\n    while (i > 0 && nums[i-1] >= nums[i])\\n        i--;\\n    \\n    // If i is 0, it means the array is in descending order, so we reverse it to get the smallest permutation\\n    if (i == 0) {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n    \\n    // Step 2: Find the largest value of j such that nums[i-1] < nums[j]\\n    int j = n - 1;\\n    while (nums[j] <= nums[i-1])\\n        j--;\\n    \\n    // Step 3: Interchange nums[i-1] and nums[j]\\n    swap(nums[i-1], nums[j]);\\n    \\n    // Step 4: Reverse the numbers from index i to the end\\n    reverse(nums.begin() + i, nums.end());\\n}\\n\\n};\\n```\\nA pro tip I just discovered that you can directly use next_permutation(nums.begin(),nums.end());",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void nextPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n    \\n    // Step 1: Find the largest value of i such that nums[i-1] < nums[i]\\n    int i = n - 1;\\n    while (i > 0 && nums[i-1] >= nums[i])\\n        i--;\\n    \\n    // If i is 0, it means the array is in descending order, so we reverse it to get the smallest permutation\\n    if (i == 0) {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n    \\n    // Step 2: Find the largest value of j such that nums[i-1] < nums[j]\\n    int j = n - 1;\\n    while (nums[j] <= nums[i-1])\\n        j--;\\n    \\n    // Step 3: Interchange nums[i-1] and nums[j]\\n    swap(nums[i-1], nums[j]);\\n    \\n    // Step 4: Reverse the numbers from index i to the end\\n    reverse(nums.begin() + i, nums.end());\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765713,
                "title": "c-fully-optimised-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index=-1;\\n        for(int i=nums.size()-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                index=i-1;\\n                break;\\n            }\\n        }\\n        //finding the break point \\n        // now stored in index\\n\\n        if(index==-1){\\n            sort(nums.begin(),nums.end());\\n            return ;\\n        }\\n        // if no break point we sort the array and return\\n        // else\\n        for(int i=nums.size()-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                swap(nums[i],nums[index]);\\n                break;\\n            }\\n        }\\n        //swaping the min element which is greater than break point \\n        // and now sorting the remaining elements to get the next permutation\\n        sort(nums.begin()+index+1,nums.end());\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index=-1;\\n        for(int i=nums.size()-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                index=i-1;\\n                break;\\n            }\\n        }\\n        //finding the break point \\n        // now stored in index\\n\\n        if(index==-1){\\n            sort(nums.begin(),nums.end());\\n            return ;\\n        }\\n        // if no break point we sort the array and return\\n        // else\\n        for(int i=nums.size()-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                swap(nums[i],nums[index]);\\n                break;\\n            }\\n        }\\n        //swaping the min element which is greater than break point \\n        // and now sorting the remaining elements to get the next permutation\\n        sort(nums.begin()+index+1,nums.end());\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758581,
                "title": "easiest-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        \\n        int i = nums.length-2;\\n        \\n        while(i>=0 && nums[i+1] <= nums[i]){\\n            i--;\\n        }\\n        if(i >= 0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i]){\\n                j--;\\n            }\\n            swap(nums,i,j);\\n        }\\n        reverse(nums, i+1);\\n        \\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i){\\n        int j= nums.length-1;\\n        \\n        while(i<j){\\n            swap(nums, j, i);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        \\n        int i = nums.length-2;\\n        \\n        while(i>=0 && nums[i+1] <= nums[i]){\\n            i--;\\n        }\\n        if(i >= 0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i]){\\n                j--;\\n            }\\n            swap(nums,i,j);\\n        }\\n        reverse(nums, i+1);\\n        \\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i){\\n        int j= nums.length-1;\\n        \\n        while(i<j){\\n            swap(nums, j, i);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691414,
                "title": "java-clean-code-beats-100-with-explanation",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1286931-->1289631-->1289136(ans)\\n        // find 1st decreasing element from the right\\n        int temp=0,i,min=Integer.MAX_VALUE,pivot=0,pos=0;\\n        for ( i=arr.length-1;i>=1;i--)\\n            if (arr[i]>arr[i-1])\\n            {\\n                pivot=i;break;\\n            }\\n        // find no. just larger than arr[pivot-1]\\n        if (pivot>0)//to check if there is a decreasing element to the left of pivot(i.e.pivot!=0)\\n        {\\n            for (i=pivot;i<arr.length;i++)\\n            {\\n                if (arr[i]>arr[pivot-1])\\n                    min=Math.min(min,arr[i]);\\n                if (min==arr[i])\\n                    pos=i;\\n            }\\n            //swap min and arr[pivot-1]\\n            swap(arr,pos,pivot-1);\\n        }\\n\\n        //reverse from pivot to end\\n        int high=arr.length-1;\\n        while(pivot<=high){\\n            swap(arr,pivot,high);\\n            high--;pivot++;\\n        }\\n    }\\n    private void swap(int[] arr,int low,int high){\\n            int temp=arr[low];\\n            arr[low]=arr[high];\\n            arr[high]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1286931-->1289631-->1289136(ans)\\n        // find 1st decreasing element from the right\\n        int temp=0,i,min=Integer.MAX_VALUE,pivot=0,pos=0;\\n        for ( i=arr.length-1;i>=1;i--)\\n            if (arr[i]>arr[i-1])\\n            {\\n                pivot=i;break;\\n            }\\n        // find no. just larger than arr[pivot-1]\\n        if (pivot>0)//to check if there is a decreasing element to the left of pivot(i.e.pivot!=0)\\n        {\\n            for (i=pivot;i<arr.length;i++)\\n            {\\n                if (arr[i]>arr[pivot-1])\\n                    min=Math.min(min,arr[i]);\\n                if (min==arr[i])\\n                    pos=i;\\n            }\\n            //swap min and arr[pivot-1]\\n            swap(arr,pos,pivot-1);\\n        }\\n\\n        //reverse from pivot to end\\n        int high=arr.length-1;\\n        while(pivot<=high){\\n            swap(arr,pivot,high);\\n            high--;pivot++;\\n        }\\n    }\\n    private void swap(int[] arr,int low,int high){\\n            int temp=arr[low];\\n            arr[low]=arr[high];\\n            arr[high]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565400,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565269,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565562,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570786,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565167,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567466,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568712,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569214,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570729,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566711,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565400,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565269,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565562,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570786,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565167,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567466,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568712,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569214,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570729,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566711,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575010,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1568651,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1568433,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1567030,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1566322,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1804406,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1685039,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1575896,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1570227,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1572944,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1569407,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1967407,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1928220,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1673006,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1670882,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1636952,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1576827,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1576497,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1574308,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1574113,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1573290,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1573223,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1573078,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1571870,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1570596,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1575467,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2074673,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2074405,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2073000,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2068405,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2061766,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2057195,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2053460,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2048586,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2044833,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2036705,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2035692,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2029696,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2029289,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2025716,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2022674,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2022489,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2009841,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2009524,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2005917,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2004595,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1999023,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1997557,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1997551,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1987560,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1987074,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1982735,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1967012,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1966109,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1964653,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1940853,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1925601,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1920437,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1916945,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1901514,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1892281,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1891452,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1889718,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1889684,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1889680,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1880139,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1858142,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1844600,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1831749,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1829892,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1808656,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1807808,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1794691,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1789383,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1777049,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1761635,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759819,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1754439,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1752918,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1752597,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1737199,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1729224,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1728678,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1728478,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1725436,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1710694,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1710323,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1709660,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1708744,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1693918,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            }
        ]
    },
    {
        "title": "Palindrome Partitioning",
        "question_content": "<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\"><strong>palindrome</strong></span>. Return <em>all possible palindrome partitioning of </em><code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aab\"\n<strong>Output:</strong> [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"a\"\n<strong>Output:</strong> [[\"a\"]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 16</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 182307,
                "title": "java-backtracking-template-general-approach",
                "content": "All backtracking problems are composed by these three steps: ```choose```, ```explore```, ```unchoose```.\\nSo for each problem, you need to know:\\n1. \\t```choose what?``` For this problem, we choose each substring.\\n2. \\t```how to explore?``` For this problem, we do the same thing to the remained string.\\n3. \\t```unchoose``` Do the opposite operation of choose.\\n\\nLet\\'s take this problem as an example:\\n```1.Define helper()```: Usually we need a helper funcition in backtracking problem, to accept more parameters.\\n```2.Parameters```:  Usually we need the following parameters\\n```\\n    1. The object you are working on:  For this problem is String s.\\n    2. A start index or an end index which indicate which part you are working on: For this problem, we use substring to indicate the start index.\\n    3. A step result, to remember current choose and then do unchoose : For this problem, we use List<String> step.\\n    4. A final result, to remember the final result. Usually when we add, we use \\'result.add(new ArrayList<>(step))\\' instead of \\'result.add(step)\\', since step is reference passed. We will modify step later, so we need to copy it and add the copy to the result;\\n```\\n```3.Base case```:  The base case defines when to add step into result, and when to return.\\n```4.Use for-loop ```:  Usually we need a for loop to iterate though the input String s, so that we can choose all the options.\\n```5.Choose ```: In this problem, if the substring of s is palindrome, we add it into the step, which means we choose this substring.\\n```6.Explore ```: In this problem, we want to do the same thing to the remaining substring. So we recursively call our function.\\n```7.Un-Choose ```: We draw back, remove the chosen substring, in order to try other options. \\n\\n<hr/>\\n\\n```The above is mainly the template, the code is shown below:```\\n\\n```java\\npublic List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n```\\nOther related backtracking problems discuss:\\n[A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning)\\n](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))",
                "solutionTags": [],
                "code": "```choose```\n```explore```\n```unchoose```\n```choose what?```\n```how to explore?```\n```unchoose```\n```1.Define helper()```\n```2.Parameters```\n```\\n    1. The object you are working on:  For this problem is String s.\\n    2. A start index or an end index which indicate which part you are working on: For this problem, we use substring to indicate the start index.\\n    3. A step result, to remember current choose and then do unchoose : For this problem, we use List<String> step.\\n    4. A final result, to remember the final result. Usually when we add, we use \\'result.add(new ArrayList<>(step))\\' instead of \\'result.add(step)\\', since step is reference passed. We will modify step later, so we need to copy it and add the copy to the result;\\n```\n```3.Base case```\n```4.Use for-loop ```\n```5.Choose ```\n```6.Explore ```\n```7.Un-Choose ```\n```The above is mainly the template, the code is shown below:```\n```java\\npublic List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41963,
                "title": "java-backtracking-solution",
                "content": "if the input is \"aab\", check if [0,0] \"a\" is palindrome. then check [0,1] \"aa\", then [0,2] \"aab\".\\nWhile checking [0,0], the rest of string is \"ab\",  use ab as input to make a recursive call.\\n![enter image description here][1]\\n\\nin this example, in the loop of i=l+1, a recursive call will be made with input = \"ab\".\\nEvery time a recursive call is made, the position of l move right. \\n\\nHow to define a correct answer?\\nThink about DFS, if the current string to be checked (Palindrome) contains the last position, in this case \"c\", this path is a correct answer, otherwise, it's a false answer.\\n\\n![enter image description here][2]\\n\\nline 13:  is the boundary to check if the current string contains the last element. \\n l>=s.length()  \\n\\n    public class Solution {\\n            List<List<String>> resultLst;\\n    \\t    ArrayList<String> currLst;\\n    \\t    public List<List<String>> partition(String s) {\\n    \\t        resultLst = new ArrayList<List<String>>();\\n    \\t        currLst = new ArrayList<String>();\\n    \\t        backTrack(s,0);\\n    \\t        return resultLst;\\n    \\t    }\\n    \\t    public void backTrack(String s, int l){\\n    \\t        if(currLst.size()>0 //the initial str could be palindrome\\n    \\t            && l>=s.length()){\\n    \\t                List<String> r = (ArrayList<String>) currLst.clone();\\n    \\t                resultLst.add(r);\\n    \\t        }\\n    \\t        for(int i=l;i<s.length();i++){\\n    \\t            if(isPalindrome(s,l,i)){\\n    \\t                if(l==i)\\n    \\t                    currLst.add(Character.toString(s.charAt(i)));\\n    \\t                else\\n    \\t                    currLst.add(s.substring(l,i+1));\\n    \\t                backTrack(s,i+1);\\n    \\t                currLst.remove(currLst.size()-1);\\n    \\t            }\\n    \\t        }\\n    \\t    }\\n    \\t    public boolean isPalindrome(String str, int l, int r){\\n    \\t        if(l==r) return true;\\n    \\t        while(l<r){\\n    \\t            if(str.charAt(l)!=str.charAt(r)) return false;\\n    \\t            l++;r--;\\n    \\t        }\\n    \\t        return true;\\n    \\t    }\\n    }\\n\\n\\n  [1]: http://1.bp.blogspot.com/-3g_qWEIsyUI/VJR0Co__PcI/AAAAAAAAAfg/okeb7u1mZnI/s1600/test.png\\n  [2]: http://i58.tinypic.com/2la69p2.png",
                "solutionTags": [],
                "code": "class Solution {\\n            List<List<String>> resultLst;\\n    \\t    ArrayList<String> currLst;\\n    \\t    public List<List<String>> partition(String s) {\\n    \\t        resultLst = new ArrayList<List<String>>();\\n    \\t        currLst = new ArrayList<String>();\\n    \\t        backTrack(s,0);\\n    \\t        return resultLst;\\n    \\t    }",
                "codeTag": "Java"
            },
            {
                "id": 41982,
                "title": "java-dp-dfs-solution",
                "content": "The normal dfs backtracking will need to check each substring for palindrome, but a dp array can be used to record the possible break for palindrome before we start recursion.\\n\\nEdit:\\nSharing my thought process:\\nfirst, I ask myself that how to check if a string is palindrome or not, usually a two point solution scanning from front and back.  Here if you want to get all the possible palindrome partition, first a nested for loop to get every possible partitions for a string, then a scanning for all the partitions.  That's a O(n^2) for partition and O(n^2) for the scanning of string, totaling at O(n^4) just for the partition.  However, if we use a 2d array to keep track of any string we have scanned so far, with an addition pair, we can determine whether it's palindrome or not by justing looking at that pair, which is this line `if(s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j+1][i-1]))`.  This way, the 2d array `dp` contains the possible palindrome partition among all.  \\n\\nsecond, based on the prescanned palindrome partitions saved in dp array, a simple backtrack does the job.\\n\\n    public class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res = new ArrayList<>();\\n            boolean[][] dp = new boolean[s.length()][s.length()];\\n            for(int i = 0; i < s.length(); i++) {\\n                for(int j = 0; j <= i; j++) {\\n                    if(s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j+1][i-1])) {\\n                        dp[j][i] = true;\\n                    }\\n                }\\n            }\\n            helper(res, new ArrayList<>(), dp, s, 0);\\n            return res;\\n        }\\n        \\n        private void helper(List<List<String>> res, List<String> path, boolean[][] dp, String s, int pos) {\\n            if(pos == s.length()) {\\n                res.add(new ArrayList<>(path));\\n                return;\\n            }\\n            \\n            for(int i = pos; i < s.length(); i++) {\\n                if(dp[pos][i]) {\\n                    path.add(s.substring(pos,i+1));\\n                    helper(res, path, dp, s, i+1);\\n                    path.remove(path.size()-1);\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res = new ArrayList<>();\\n            boolean[][] dp = new boolean[s.length()][s.length()];\\n            for(int i = 0; i < s.length(); i++) {\\n                for(int j = 0; j <= i; j++) {\\n                    if(s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j+1][i-1])) {\\n                        dp[j][i] = true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 41973,
                "title": "python-recursive-iterative-backtracking-solution",
                "content": "Inspired by caikehe's solution:\\n\\n    def partition(self, s):\\n        res = []\\n        self.dfs(s, [], res)\\n        return res\\n    \\n    def dfs(self, s, path, res):\\n        if not s:\\n            res.append(path)\\n            return\\n        for i in range(1, len(s)+1):\\n            if self.isPal(s[:i]):\\n                self.dfs(s[i:], path+[s[:i]], res)\\n        \\n    def isPal(self, s):\\n        return s == s[::-1]",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "Inspired by caikehe's solution:\\n\\n    def partition(self, s):\\n        res = []\\n        self.dfs(s, [], res)\\n        return res\\n    \\n    def dfs(self, s, path, res):\\n        if not s:\\n            res.append(path)\\n            return\\n        for i in range(1, len(s)+1):\\n            if self.isPal(s[:i]):\\n                self.dfs(s[i:], path+[s[:i]], res)\\n        \\n    def isPal(self, s):\\n        return s == s[::-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1667786,
                "title": "python-simple-recursion-detailed-explanation-easy-to-understand",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* Find answer recursively and memory trick can save some time\\n* traverse and check every prefix `s[:i]` of `s`\\n\\t* if prefix `s[:i]` is a palindrome, then process the left suffix `s[i:]` recursively\\n\\t* since the suffix `s[i:]` may repeat, **the memory trick can save some time**\\n\\n![image](https://assets.leetcode.com/users/images/e6650768-c996-457d-94c9-c5508860df35_1641356753.0113478.png)\\n\\n\\n```\\nTime  Complexity: O(N * (2 ^ N))\\nSpace Complexity: O(N * (2 ^ N))\\n```\\n\\n**Python3**\\n```\\nclass Solution(object):\\n    @cache  # the memory trick can save some time\\n    def partition(self, s):\\n        if not s: return [[]]\\n        ans = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  # prefix is a palindrome\\n                for suf in self.partition(s[i:]):  # process suffix recursively\\n                    ans.append([s[:i]] + suf)\\n        return ans\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.memory = collections.defaultdict(list)\\n        \\n    def partition(self, s):\\n        if not s: return [[]]\\n        if s in self.memory: return self.memory[s]  # the memory trick can save some time\\n        ans = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  # prefix is a palindrome\\n                for suf in self.partition(s[i:]):  # process suffix recursively\\n                    ans.append([s[:i]] + suf)\\n        self.memory[s] = ans\\n        return ans\\n```\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nTime  Complexity: O(N * (2 ^ N))\\nSpace Complexity: O(N * (2 ^ N))\\n```\n```\\nclass Solution(object):\\n    @cache  # the memory trick can save some time\\n    def partition(self, s):\\n        if not s: return [[]]\\n        ans = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  # prefix is a palindrome\\n                for suf in self.partition(s[i:]):  # process suffix recursively\\n                    ans.append([s[:i]] + suf)\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.memory = collections.defaultdict(list)\\n        \\n    def partition(self, s):\\n        if not s: return [[]]\\n        if s in self.memory: return self.memory[s]  # the memory trick can save some time\\n        ans = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  # prefix is a palindrome\\n                for suf in self.partition(s[i:]):  # process suffix recursively\\n                    ans.append([s[:i]] + suf)\\n        self.memory[s] = ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41964,
                "title": "clean-c-backtracking-solution",
                "content": "The Idea is simple: loop through the string, check if substr(0, i) is palindrome. If it is, recursively call dfs() on the rest of sub string: substr(i+1, length). keep the current palindrome partition so far in the 'path' argument of dfs(). When reaching the end of string, add current partition in the result.\\n\\n    class Solution {\\n    public:\\n        vector<vector<string>> partition(string s) {\\n            vector<vector<string> > ret;\\n            if(s.empty()) return ret;\\n            \\n            vector<string> path;\\n            dfs(0, s, path, ret);\\n            \\n            return ret;\\n        }\\n        \\n        void dfs(int index, string& s, vector<string>& path, vector<vector<string> >& ret) {\\n            if(index == s.size()) {\\n                ret.push_back(path);\\n                return;\\n            }\\n            for(int i = index; i < s.size(); ++i) {\\n                if(isPalindrome(s, index, i)) {\\n                    path.push_back(s.substr(index, i - index + 1));\\n                    dfs(i+1, s, path, ret);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n        \\n        bool isPalindrome(const string& s, int start, int end) {\\n            while(start <= end) {\\n                if(s[start++] != s[end--])\\n                    return false;\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<string>> partition(string s) {\\n            vector<vector<string> > ret;\\n            if(s.empty()) return ret;\\n            \\n            vector<string> path;\\n            dfs(0, s, path, ret);\\n            \\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3171259,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\nprivate: \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if(start==n){\\n            pars.push_back(par);\\n        }else{\\n            for(int i = start ; i < n ;i ++){\\n               if(isPalindrome(s,start,i)){\\n                   par.push_back(s.substr(start,i-start+1));\\n                   partition(s,i+1,par,pars);\\n                   par.pop_back();\\n               }\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[n] = [[]]\\n        for begin in range(n - 1, -1, -1):\\n            for end in range(begin + 1, n + 1):\\n                candidate = s[begin:end]\\n                if candidate == candidate[::-1]:\\n                     for each in dp[end]:\\n                         new_each = [candidate]\\n                         new_each.extend(each)\\n                         dp[begin].append(new_each)\\n        return dp[0]  \\n```\\n\\n```Java []\\nclass Solution {\\n    int n;\\n    boolean[][] is_palindrome;\\n    String[][] substrings;\\n\\n    List<List<String>> ans;\\n\\n    void FindSubstrings(int ind, ArrayList<String> list) {\\n        if (ind == n) {\\n            ans.add(new ArrayList<String>(list));\\n            return;\\n        }\\n\\n        for (int i = ind + 1; i <= n; i++) {\\n            if (!is_palindrome[ind][i]) continue;\\n            list.add(substrings[ind][i]);\\n            FindSubstrings(i, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n\\n    public List<List<String>> partition(String s) {\\n        n = s.length();\\n        is_palindrome = new boolean[n + 1][n + 1];\\n        substrings = new String[n + 1][n + 1];\\n        for (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) {\\n            substrings[i][j] = s.substring(i, j);\\n            is_palindrome[i][j] = IsPalindrome(substrings[i][j]);\\n        }\\n\\n        ans = new ArrayList<List<String>>();\\n        FindSubstrings(0, new ArrayList<String>());\\n        return ans;\\n    }\\n\\n    boolean IsPalindrome(String s) {\\n        int lower = 0;\\n        int higher = s.length() - 1;\\n        while (lower < higher) {\\n            if (s.charAt(lower) != s.charAt(higher)) return false;\\n            lower++;\\n            higher--;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\nprivate: \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if(start==n){\\n            pars.push_back(par);\\n        }else{\\n            for(int i = start ; i < n ;i ++){\\n               if(isPalindrome(s,start,i)){\\n                   par.push_back(s.substr(start,i-start+1));\\n                   partition(s,i+1,par,pars);\\n                   par.pop_back();\\n               }\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[n] = [[]]\\n        for begin in range(n - 1, -1, -1):\\n            for end in range(begin + 1, n + 1):\\n                candidate = s[begin:end]\\n                if candidate == candidate[::-1]:\\n                     for each in dp[end]:\\n                         new_each = [candidate]\\n                         new_each.extend(each)\\n                         dp[begin].append(new_each)\\n        return dp[0]  \\n```\n```Java []\\nclass Solution {\\n    int n;\\n    boolean[][] is_palindrome;\\n    String[][] substrings;\\n\\n    List<List<String>> ans;\\n\\n    void FindSubstrings(int ind, ArrayList<String> list) {\\n        if (ind == n) {\\n            ans.add(new ArrayList<String>(list));\\n            return;\\n        }\\n\\n        for (int i = ind + 1; i <= n; i++) {\\n            if (!is_palindrome[ind][i]) continue;\\n            list.add(substrings[ind][i]);\\n            FindSubstrings(i, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n\\n    public List<List<String>> partition(String s) {\\n        n = s.length();\\n        is_palindrome = new boolean[n + 1][n + 1];\\n        substrings = new String[n + 1][n + 1];\\n        for (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) {\\n            substrings[i][j] = s.substring(i, j);\\n            is_palindrome[i][j] = IsPalindrome(substrings[i][j]);\\n        }\\n\\n        ans = new ArrayList<List<String>>();\\n        FindSubstrings(0, new ArrayList<String>());\\n        return ans;\\n    }\\n\\n    boolean IsPalindrome(String s) {\\n        int lower = 0;\\n        int higher = s.length() - 1;\\n        while (lower < higher) {\\n            if (s.charAt(lower) != s.charAt(higher)) return false;\\n            lower++;\\n            higher--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667647,
                "title": "well-explained-java-c-python-javascript-easy-for-mind-to-accept-it",
                "content": "**Intitution :**\\n```\\nLet\\'s Understood with an example:\\n\\n\"xxyy\" -> [\"x\", \"x\", \"y\", \"y\"] // 1st List of all the substring\\n          [\"x\", \"x\", \"yy\"] // 2nd List of all the substring\\n          [\"xx\", \"y\", \"y\"] // 3rd List of all the substring\\n          [\"xx\", \"yy\"] // 4th List of all the substring\\n\\nIn the above example we can only have 4 possible list\\'s\\n\\nOur task is to return a list of all of these list\\'s, that are possible\\n```\\n# **`JUST UNDERSTAND IT LIKE THIS :-`**\\n![image](https://assets.leetcode.com/users/images/510ea72a-009d-43ef-8afc-7c79b0596948_1641351439.2749941.png)\\n\\n**Approach Explaination :-** \\n`A basic summary of diagram, how we are doing it`\\nTake an example, \"xxyy\". \\nIf we partition over x|xyy so the substring \"x\" is a palindrome. Where i can have the first partition.\\n\\nBut, if they don\\'t allow to partition over there, then our second partition will be xx|yy. Because this \"xx\" is a palindrome substring. Thus we still left out with yy, so if i do the partion over here xxy|y the answer will be no, because if i do the partition over here the substring \"xxy\" is not a palindrome.\\n\\nCan i do a partition over here xxyy|. No. Because xxyy is not a palindromic substring. So, we can see when we started we can do a partition over here x|xyy OR xx|yy so that is what we do. We try to do partition where ever it is possible\\n\\nSo, in the first case we did a partition over x|xyy where we left out with xyy. So, if i do a partiton like x|x|yy where x it\\'self a palindrome. And we left out with a substring yy\\nNow can you do a partition over here x|xy|y. No, because this substring xy is not a palindrome\\nAgain can we do a partition over here x|xyy|. No, because this substring xyy is not a palindrome\\n\\nSo, the only partition possible is x|x|yy. And after that we tend to call the recursion for remaining substring\\n\\nIf i try to do a partition over here x|x|y|y so, the substring y in itself is a palindromic substring. After that we left out with remaining y substring.\\nNow you ask can we do a partition over here x|x|yy|, Yes \\n\\nLike this way, we do the partition in complete STRING using recursion. And with the help of Backtracking we store our answer.\\n![image](https://assets.leetcode.com/users/images/104d7464-a56c-45c3-87cc-4caea3a05103_1641347225.9497328.png)\\n\\n![image](https://assets.leetcode.com/users/images/f091240a-0866-4fcb-b774-416cdc7dc560_1641347244.659475.png)\\n\\n*h means, helper function* \\n**JAVA**\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>(); // which will be our answer\\n        List<String> path = new ArrayList<>(); // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    public void helper(int index, String s, List<String> path, List<List<String>> res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.length()){\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.length(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.add(s.substring(index, i + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.remove(path.size() - 1); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    } \\n    \\n    public boolean isPalindrome(String s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s.charAt(start++) != s.charAt(end--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // which will be our answer\\n        vector<string> path; // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = [] # which will be our answer\\n        self.helper(res, [], s) # calling to recursion function \\n        return res\\n    \\n    # Entire recursive function, that generates all the partition substring\\n    def helper(self, res, curr, s):\\n        if s == \"\":\\n            res.append(curr)\\n        \\n        for i in range(len(s)):\\n            if self.isPalindrome(s[:i + 1]): # what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                self.helper(res, curr + [s[:i + 1]], s[i + 1:]) # take the substring and store it in our list & call the next substring from index + 1\\n    \\n    # A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n    def isPalindrome(self, s):\\n        for i in range(len(s) // 2):\\n            if s[i] != s[len(s) - 1 - i]:\\n                return False\\n        return True\\n```\\n\\n*`EDIT : JavaScript code added`*\\n\\n**JavaScript**\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    const res = [];\\n    const path = [];\\n    \\n    const helper = (s, i, j) =>{\\n        if(i === s.length){\\n            res.push([...path]);\\n            return;\\n        }\\n        \\n        for(let index = j; index <= s.length; ++index){\\n            if(isPalindrome(s, i, index)){\\n                path.push(s.slice(i, index));\\n                helper(s, index, index+1);\\n                path.pop();\\n            }\\n        }\\n    }\\n    \\n    const isPalindrome = (s, i, j) =>{\\n        while(i < j - 1){\\n            if(s[i] !== s[j-1]){\\n                return false;\\n            }\\n            ++i;\\n            --j;\\n        }\\n        return true;\\n    };\\n    \\n    helper(s, 0, 1);\\n    return res;\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N*2^N) where N is the length of string s. This is the worst-case time complexity when all the possible substrings are palindrome.\\n\\n* **Space Complexity :-** BigO(N) as space will be used to store the recursion stack",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nLet\\'s Understood with an example:\\n\\n\"xxyy\" -> [\"x\", \"x\", \"y\", \"y\"] // 1st List of all the substring\\n          [\"x\", \"x\", \"yy\"] // 2nd List of all the substring\\n          [\"xx\", \"y\", \"y\"] // 3rd List of all the substring\\n          [\"xx\", \"yy\"] // 4th List of all the substring\\n\\nIn the above example we can only have 4 possible list\\'s\\n\\nOur task is to return a list of all of these list\\'s, that are possible\\n```\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>(); // which will be our answer\\n        List<String> path = new ArrayList<>(); // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    public void helper(int index, String s, List<String> path, List<List<String>> res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.length()){\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.length(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.add(s.substring(index, i + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.remove(path.size() - 1); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    } \\n    \\n    public boolean isPalindrome(String s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s.charAt(start++) != s.charAt(end--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // which will be our answer\\n        vector<string> path; // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = [] # which will be our answer\\n        self.helper(res, [], s) # calling to recursion function \\n        return res\\n    \\n    # Entire recursive function, that generates all the partition substring\\n    def helper(self, res, curr, s):\\n        if s == \"\":\\n            res.append(curr)\\n        \\n        for i in range(len(s)):\\n            if self.isPalindrome(s[:i + 1]): # what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                self.helper(res, curr + [s[:i + 1]], s[i + 1:]) # take the substring and store it in our list & call the next substring from index + 1\\n    \\n    # A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n    def isPalindrome(self, s):\\n        for i in range(len(s) // 2):\\n            if s[i] != s[len(s) - 1 - i]:\\n                return False\\n        return True\\n```\n```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    const res = [];\\n    const path = [];\\n    \\n    const helper = (s, i, j) =>{\\n        if(i === s.length){\\n            res.push([...path]);\\n            return;\\n        }\\n        \\n        for(let index = j; index <= s.length; ++index){\\n            if(isPalindrome(s, i, index)){\\n                path.push(s.slice(i, index));\\n                helper(s, index, index+1);\\n                path.pop();\\n            }\\n        }\\n    }\\n    \\n    const isPalindrome = (s, i, j) =>{\\n        while(i < j - 1){\\n            if(s[i] !== s[j-1]){\\n                return false;\\n            }\\n            ++i;\\n            --j;\\n        }\\n        return true;\\n    };\\n    \\n    helper(s, 0, 1);\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42101,
                "title": "c-backtracking",
                "content": "The problem has a nice structure that backtracking naturally fits in. The structure is, given a starting position `start`, we search from `start` till the end of the string. Once we reach a position `i` such that the sub-string from `start` to `i` (`s.substr(start, i  - start + 1)`) is a palindrome, we add it to a temporary `par`. Then we recursively call the same function to process the remaining sub-string. Once we reach the end of the string, we add `par` into the result `pars` of all the possible partitioning.\\n \\nThen, backtracking happens. Remember that at position `i`, we find `s.substr(start, i - start + 1)` to be a palindrome and we immediately add it to `par`. It is obvious that there may be some other position `j` such that `j > i` and `s.substr(start, j - start + 1)` is also a palindrome. So we need to recover to the state before adding `s.substr(start, i - start + 1)` to `par` and continue to find the next palindrome position after `i`. And we simply need to pop `s.substr(start, i - start + 1)` out of `par` to make things work.  \\n \\nPutting these together, the code is as follows, which should be self-explanatory.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\nprivate: \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if (start == n) {\\n            pars.push_back(par);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    par.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, par, pars);\\n                    par.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\nprivate: \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if (start == n) {\\n            pars.push_back(par);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    par.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, par, pars);\\n                    par.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083493,
                "title": "day-22-beginner-friendly-solution-with-diagram-backtracking",
                "content": "# Intuition\\nGenerate all the substrings using recursion and check if they are palindrome or not.If not Backtrack form there. Recursively traverse over the string.\\n![0d06f29b-d12b-4b0b-8568-32ef95c6c849_1674351396.3135014.png](https://assets.leetcode.com/users/images/21f16e09-d0af-463c-9c78-266e5f7efbf0_1674351816.1919978.png)\\n\\n![Screenshot_20230122_055612.png](https://assets.leetcode.com/users/images/51c8fea9-fefa-45ab-99ff-9260d093bdb2_1674348126.053113.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a function called \"checkPalindrome\" that takes in a string, start index and end index as parameters. This function checks if the substring of the string from start index to end index is a palindrome or not.\\n2. Create a function called \"palindromePartition\" that takes in an index, a vector of strings, a 2D vector of strings, and a string as parameters. This function partitions the given string into all possible palindrome partitions.\\n3. In the \"palindromePartition\" function, check if the current index is equal to the length of the string. If it is, add the current partition to the output vector and return.\\n4. Iterate from the current index to the end of the string.\\n5. For each iteration, check if the substring from current index to the current iterator is a palindrome using the \"checkPalindrome\" function.\\n6. If it is a palindrome, add it to the partition vector and recursively call the \"palindromePartition\" function with the updated partition and the next index.\\n7. After the recursive call, remove the last element from the partition vector.\\n8. Return the output vector after all partitions have been found.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkPalindrome(string str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str[startIndex] != str[lastIndex])\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    void palindromePartition(int index, vector<string>& ds, vector<vector<string>>& output, string str){\\n        if(index == str.length()){\\n            output.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.push_back(str.substr(index, i - index + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> ds;\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean checkPalindrome(String str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str.charAt(startIndex) != str.charAt(lastIndex))\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    public void palindromePartition(int index, List<String> ds, List<List<String>> output, String str){\\n        if(index == str.length()){\\n            output.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.add(str.substring(index, i + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> output = new ArrayList<>();\\n        List<String> ds = new ArrayList<>();\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def checkPalindrome(self, str, startIndex, lastIndex):\\n        while startIndex <= lastIndex:\\n            if str[startIndex] != str[lastIndex]:\\n                return False\\n            startIndex += 1\\n            lastIndex -= 1\\n        return True\\n\\n    def palindromePartition(self, index, ds, output, str):\\n        if index == len(str):\\n            output.append(ds[:])\\n            return\\n        for i in range(index, len(str)):\\n            if self.checkPalindrome(str, index, i):\\n                ds.append(str[index:i+1])\\n                self.palindromePartition(i+1, ds, output, str)\\n                ds.pop()\\n\\n    def partition(self, s: str) -> List[List[str]]:\\n        output = []\\n        ds = []\\n        self.palindromePartition(0, ds, output, s)\\n        return output\\n\\n```\\n\\n\\n# Complexity\\n- Time complexity: **O(2^n*n)**\\nThe time complexity is O(2^n) because for each character in the input string, the algorithm generates two recursive calls, one for including the character in the current partition and one for not including it. Since the input string can have up to n characters, this results in 2^n possible partitions. The algorithm must check each partition to see if it is a palindrome, and therefore the time complexity is O(2^n)and O(N) time to generate the substring and determine if it is a palindrome or not. So overall time complexity is O(2^n*n).\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\nThe space complexity is O(n) because the algorithm uses a single vector to store the current partition. The size of the vector is directly proportional to the number of characters in the input string and therefore the space complexity is O(n). Additionally, the algorithm uses a 2D vector to store all the partitions, the size of this vector also increase linearly as the size of the input string increase, so the space complexity is O(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkPalindrome(string str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str[startIndex] != str[lastIndex])\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    void palindromePartition(int index, vector<string>& ds, vector<vector<string>>& output, string str){\\n        if(index == str.length()){\\n            output.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.push_back(str.substr(index, i - index + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> ds;\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean checkPalindrome(String str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str.charAt(startIndex) != str.charAt(lastIndex))\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    public void palindromePartition(int index, List<String> ds, List<List<String>> output, String str){\\n        if(index == str.length()){\\n            output.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.add(str.substring(index, i + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> output = new ArrayList<>();\\n        List<String> ds = new ArrayList<>();\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def checkPalindrome(self, str, startIndex, lastIndex):\\n        while startIndex <= lastIndex:\\n            if str[startIndex] != str[lastIndex]:\\n                return False\\n            startIndex += 1\\n            lastIndex -= 1\\n        return True\\n\\n    def palindromePartition(self, index, ds, output, str):\\n        if index == len(str):\\n            output.append(ds[:])\\n            return\\n        for i in range(index, len(str)):\\n            if self.checkPalindrome(str, index, i):\\n                ds.append(str[index:i+1])\\n                self.palindromePartition(i+1, ds, output, str)\\n                ds.pop()\\n\\n    def partition(self, s: str) -> List[List[str]]:\\n        output = []\\n        ds = []\\n        self.palindromePartition(0, ds, output, s)\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41974,
                "title": "my-java-dp-only-solution-without-recursion-o-n-2",
                "content": "  \\n\\n           \\n    public class Solution {\\n     \\tpublic static List<List<String>> partition(String s) {\\n    \\t\\tint len = s.length();\\n    \\t\\tList<List<String>>[] result = new List[len + 1];\\n    \\t\\tresult[0] = new ArrayList<List<String>>();\\n    \\t\\tresult[0].add(new ArrayList<String>());\\n    \\n    \\t\\tboolean[][] pair = new boolean[len][len];\\n    \\t\\tfor (int i = 0; i < s.length(); i++) {\\n    \\t\\t\\tresult[i + 1] = new ArrayList<List<String>>();\\n    \\t\\t\\tfor (int left = 0; left <= i; left++) {\\n    \\t\\t\\t\\tif (s.charAt(left) == s.charAt(i) && (i-left <= 1 || pair[left + 1][i - 1])) {\\n    \\t\\t\\t\\t\\tpair[left][i] = true;\\n    \\t\\t\\t\\t\\tString str = s.substring(left, i + 1);\\n    \\t\\t\\t\\t\\tfor (List<String> r : result[left]) {\\n    \\t\\t\\t\\t\\t\\tList<String> ri = new ArrayList<String>(r);\\n    \\t\\t\\t\\t\\t\\tri.add(str);\\n    \\t\\t\\t\\t\\t\\tresult[i + 1].add(ri);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn result[len];\\n    \\t}\\n    }\\n\\nHere the **pair** is to mark a range for the substring is a Pal. if pair[i][j] is true, that means sub string from i to j is pal.\\n\\nThe **result[i]**, is to store from beginng until current index i (Non inclusive), all possible partitions. From the past result we can determine current result.",
                "solutionTags": [],
                "code": "class Solution {\\n     \\tpublic static List<List<String>> partition(String s) {\\n    \\t\\tint len = s.length();\\n    \\t\\tList<List<String>>[] result = new List[len + 1];\\n    \\t\\tresult[0] = new ArrayList<List<String>>();\\n    \\t\\tresult[0].add(new ArrayList<String>());\\n    \\n    \\t\\tboolean[][] pair = new boolean[len][len];\\n    \\t\\tfor (int i = 0; i < s.length(); i++) {\\n    \\t\\t\\tresult[i + 1] = new ArrayList<List<String>>();\\n    \\t\\t\\tfor (int left = 0; left <= i; left++) {\\n    \\t\\t\\t\\tif (s.charAt(left) == s.charAt(i) && (i-left <= 1 || pair[left + 1][i - 1])) {\\n    \\t\\t\\t\\t\\tpair[left][i] = true;\\n    \\t\\t\\t\\t\\tString str = s.substring(left, i + 1);\\n    \\t\\t\\t\\t\\tfor (List<String> r : result[left]) {\\n    \\t\\t\\t\\t\\t\\tList<String> ri = new ArrayList<String>(r);\\n    \\t\\t\\t\\t\\t\\tri.add(str);\\n    \\t\\t\\t\\t\\t\\tresult[i + 1].add(ri);\\n    \\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 42025,
                "title": "1-liner-python-ruby",
                "content": "Python:\\n\\nBroken into several physical lines for readability, but still one logical line and just one simple statement.\\n\\n    def partition(self, s):\\n        return [[s[:i]] + rest\\n                for i in xrange(1, len(s)+1)\\n                if s[:i] == s[i-1::-1]\\n                for rest in self.partition(s[i:])] or [[]]\\n\\nRuby:\\n\\n    def partition(s)\\n      s == '' ? [[]] : s.size.times.flat_map { |i| s[0..i] != s[0..i].reverse ? [] :\\n        partition(s[i+1..-1]).map { |rest| [s[0..i]] + rest }\\n      }\\n    end",
                "solutionTags": [
                    "Python"
                ],
                "code": "Python:\\n\\nBroken into several physical lines for readability, but still one logical line and just one simple statement.\\n\\n    def partition(self, s):\\n        return [[s[:i]] + rest\\n                for i in xrange(1, len(s)+1)\\n                if s[:i] == s[i-1::-1]\\n                for rest in self.partition(s[i:])] or [[]]\\n\\nRuby:\\n\\n    def partition(s)\\n      s == '' ? [[]] : s.size.times.flat_map { |i| s[0..i] != s[0..i].reverse ? [] :\\n        partition(s[i+1..-1]).map { |rest| [s[0..i]] + rest }\\n      }\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 42100,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution(object):\\n    def partition(self, s):\\n        res = []\\n        self.dfs(s, [], res)\\n        return res\\n    \\n    def dfs(self, s, path, res):\\n        if not s:\\n            res.append(path)\\n        for i in range(1, len(s)+1):\\n            if self.isPalindrome(s[:i]):\\n                self.dfs(s[i:], path+[s[:i]], res)\\n                 \\n    def isPalindrome(self, s):\\n        l, r = 0, len(s)-1\\n        while l < r:\\n            if s[l] != s[r]:\\n                return False\\n            l += 1; r -= 1\\n        return True\\n\\t\\t\\n\\tdef isPalindrome1(self, s):\\n\\t\\treturn s == s[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def partition(self, s):\\n        res = []\\n        self.dfs(s, [], res)\\n        return res\\n    \\n    def dfs(self, s, path, res):\\n        if not s:\\n            res.append(path)\\n        for i in range(1, len(s)+1):\\n            if self.isPalindrome(s[:i]):\\n                self.dfs(s[i:], path+[s[:i]], res)\\n                 \\n    def isPalindrome(self, s):\\n        l, r = 0, len(s)-1\\n        while l < r:\\n            if s[l] != s[r]:\\n                return False\\n            l += 1; r -= 1\\n        return True\\n\\t\\t\\n\\tdef isPalindrome1(self, s):\\n\\t\\treturn s == s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667714,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanation",
                "content": "**Reframing the question:-**\\nFind all the substrings which satisfies the palindrome condition of given string s.\\n\\n***\\n\\n**Intuition:-**\\n* The structure of the question is quite clear that it **promotes the use of recursion** . The recursion approach of this question can be like:  we start iteration from beginning and step by step we increase the size of substr that we are checking for palindromes . Once the palindrome substr is found ,the substr needs to go to a vector/list storing those palindromes substr . This is how the brute recursion will work .\\n* The **optimization** of the above recursion is **backtracking**. \\nA **backtracking algorithm uses the depth-first search method**. When it starts exploring the solutions, a bounding or a helper function is applied so that the **algorithm can check if the so-far built solution satisfies the constraints**. If it does, it continues searching. If it doesn\\u2019t, the branch would be eliminated, and the algorithm goes back to the level before. In simple words backtracking starts from some intermediate position where there is still a hope to get a new palindrome .\\n* In backtracking algo there is **always a helper metod** or a safe checker merhod which checks whether the built soution satisifes the conditions or not . This one thing has **certainity of 100%**.\\n\\n***\\n\\n**Algorithm :-** \\n1. As i told you in **backtracking,** one thing is sure i.e a **helper method**. In our problem we will need a bool helper method which will check the palindrome conditions, let\\'s name it as `bool isPalindrome()` .\\n2. Now let\\'s **create some variables** : `result` vector for storing all the substring which satisfies the palindrome condition , `path` vector for storing the ongoing substr which has the potential of satisfying the conditions of palindrome , `start` variable for storing the start position of the current substr , `index i` for traversing inside the substring and `n` fro storing the size of given string `s`.\\n3. **Now we search** from `start` till the end of the string. Once we reach a position `i` such that the sub-string from `start to i (s.substr(start, i - start + 1)) is a palindrome`, we add it to our `path` variable. Then we recursively call the same method to execute the remaining substring . Once we reach the end of the string, we add palindromes `path` into the `result`  of all the *possible partitioning* . \\n4. Remember that at position `i` , we find `s.substr(start, i - start + 1)` to be a palindrome and we immediately add it to `path` . Now think that there may be a  position `j` such that `j > i` and `s.substr(start, j - start + 1)` is also a palindrome. Thus now we need to go back to our `start`  before adding `s.substr(start, i - start + 1)` to `path` and continue to find the next palindrome position after `i` . And after this evertime we simply need to remove or pop `s.substr(start, i - start + 1)` out of `path` to execute the backtracking algo . \\n5. The steps we executed in the above step is none other than the **famous dfs** . \\n\\n***\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**Time Complexity :-** *`O(n*(2^n)) [n=length of the string] `*\\n**Space Complexity :-** *`O(n) [beacause of recursion stack]`*\\n***\\n\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n\\n***\\n**If you have some doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote ;)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42021,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 315175,
                "title": "python-dp-bottom-up-beats-99-55",
                "content": "```python\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[-1] = [[]]\\n        for i in range(len(s) - 1, -1, -1):\\n            for j in range(i + 1, len(s) + 1):\\n                if s[i:j] == s[i:j][::-1]:\\n                    for each in dp[j]:\\n                        dp[i].append([s[i:j]] + each)\\n        return dp[0]\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[-1] = [[]]\\n        for i in range(len(s) - 1, -1, -1):\\n            for j in range(i + 1, len(s) + 1):\\n                if s[i:j] == s[i:j][::-1]:\\n                    for each in dp[j]:\\n                        dp[i].append([s[i:j]] + each)\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084823,
                "title": "c-beats-93-easy-image-explanation-backtracking",
                "content": "# Intuition\\n![Screenshot (707).png](https://assets.leetcode.com/users/images/f81f345a-003e-4d43-9e47-a916b58ebd50_1674370162.0126262.png)\\n\\nsteps:-\\n1) lets us consider string **aab** here we take first string that is **a** and check whether it is palindrome or not ;\\n2) if it is palindrome  then we add it to temp vector and recursively call dfs function for substring(i+1) i.e **ab**\\n3) now here also we check first substring i.e **a** is palindrome or not as we did earlier and add it to temp if it is palindrome, recursively call function for **b** alone by now our temp contains [\"a\",\"a\"];\\n4) now when we are left with **b** only then on recursive call fun, our temp becomes [\"a\",\"a\",\"b\"].  we call fn after b then there is empty string and we consider it base condition. storing temp in ans vector.\\n5)  whatever changes we made need to backtrack for next possible solution so we backtrack by poping out from temp . after one pop up we get temp as [\"a\",\"a\"]. we backtrack and check for **ab** only as **ab** is not palindrome so we increase i and check for next. repeat the same .\\n\\n**watch picture for better understanding**\\nLets Connect On Linkedin https://www.linkedin.com/in/sonal-prasad-sahu-78973a229/\\n\\n![Screenshot (709).png](https://assets.leetcode.com/users/images/98696b6d-1e78-4ef3-bd53-2efbaadcc4ed_1674371319.542758.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    bool ispalindrome(string s){\\n        for(int i=0;i<s.size()/2;++i){\\n            if(s[i]==s[s.size()-1-i]){\\n                continue;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\npublic: void dfs(vector<vector<string>>&ans,vector<string>&temp,string s){\\n   if(s.size()==0){  //base condistion when there is no string left\\n       ans.push_back(temp);\\n       return;\\n   }\\n    for(int i=0;i<s.size();++i){\\n        string check=s.substr(0,i+1);\\n        if(ispalindrome(check)){\\n            temp.push_back(check);\\n            dfs(ans,temp,s.substr(i+1));\\n            temp.pop_back();\\n\\n        }\\n    }\\n}\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>temp;\\n        dfs(ans,temp,s);\\n        return ans;\\n    }\\n};\\n```\\n![begging.jpg](https://assets.leetcode.com/users/images/8501d672-af23-4012-9d2f-0bca258c3c6f_1674388006.9311438.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n\\n    bool ispalindrome(string s){\\n        for(int i=0;i<s.size()/2;++i){\\n            if(s[i]==s[s.size()-1-i]){\\n                continue;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\npublic: void dfs(vector<vector<string>>&ans,vector<string>&temp,string s){\\n   if(s.size()==0){  //base condistion when there is no string left\\n       ans.push_back(temp);\\n       return;\\n   }\\n    for(int i=0;i<s.size();++i){\\n        string check=s.substr(0,i+1);\\n        if(ispalindrome(check)){\\n            temp.push_back(check);\\n            dfs(ans,temp,s.substr(i+1));\\n            temp.pop_back();\\n\\n        }\\n    }\\n}\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>temp;\\n        dfs(ans,temp,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083543,
                "title": "easy-explanation-with-video-and-pics-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic idea is whenever the problem requires doing something repeatedly and we also have to store this result --> Back Tracking is the answer.\\n![Screenshot 2023-01-22 at 6.58.38 AM.png](https://assets.leetcode.com/users/images/f60ae877-3305-4205-b8c6-9c99bff8c2e4_1674350931.9986715.png)\\n\\nThe idea of recursion is we will make someone do things repeatedly after they have produced the result. Say in the above example we give a log of size 4 to the wood cutter he gives 1, 3 back but we again pass him 3 and he gives 1 and 2, 2 is passed again until cut is no longer possible. The return statement.\\n\\n\\n# BackTracking\\nHere comes a concept people feel difficult but let me explain with respect to above example. \\n![Screenshot 2023-01-22 at 7.02.22 AM.png](https://assets.leetcode.com/users/images/0de593ca-2f90-4df9-91f6-fc82666829c8_1674351166.8143.png)\\n\\nThe idea is simple, We have to store the result. ex you give the wood cutter log of 4 units, he gives 1 and 3, but look we have 3 more possibilities with 3. So we store the left part 1 and pass the right part again and again. (1,3) (1, 2, 1) (1,1,2) are the possible result and are stored.\\n\\n![Screenshot 2023-01-22 at 7.06.20 AM.png](https://assets.leetcode.com/users/images/0d06f29b-d12b-4b0b-8568-32ef95c6c849_1674351396.3135014.png)\\n\\nThe same goes with the string, we cut the string, check if the left part is palindrome, if not we stop it here, since that is not what is required.\\nPass the result down and so on until its no longer possible.\\n\\n\\nVideo Explanation: https://youtu.be/fhXo6BDTIJc\\n\\n\\n![sfw-please-upvote-me-v0-u5cacra0rnca1.webp](https://assets.leetcode.com/users/images/9a71e63c-438f-42f5-9476-77ece82e3a25_1674351598.3380027.webp)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        \\n        woodcutter(s, new ArrayList<>());\\n        return result;\\n    }\\n\\n    public void woodcutter(String s, List<String> subResult) {\\n        // Base case\\n        if( s.length() == 0 || s == null) {\\n            result.add(new ArrayList<>(subResult));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String cut = s.substring(0, i);\\n            if(!isPalindrome(cut)) continue;\\n            \\n            subResult.add(cut); \\n            woodcutter(s.substring(i, s.length()), subResult);\\n            subResult.remove(subResult.size() - 1); \\n        }\\n        return;\\n    }\\n\\n    public boolean isPalindrome(String s){\\n        int i = 0; int j = s.length()-1;\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        \\n        woodcutter(s, new ArrayList<>());\\n        return result;\\n    }\\n\\n    public void woodcutter(String s, List<String> subResult) {\\n        // Base case\\n        if( s.length() == 0 || s == null) {\\n            result.add(new ArrayList<>(subResult));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String cut = s.substring(0, i);\\n            if(!isPalindrome(cut)) continue;\\n            \\n            subResult.add(cut); \\n            woodcutter(s.substring(i, s.length()), subResult);\\n            subResult.remove(subResult.size() - 1); \\n        }\\n        return;\\n    }\\n\\n    public boolean isPalindrome(String s){\\n        int i = 0; int j = s.length()-1;\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42023,
                "title": "concise-java-solution",
                "content": "    public class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res=new ArrayList<List<String>>();\\n            if(s.length()==0)return res;\\n            recur(res,new ArrayList<String>(),s);\\n            return res;\\n        }\\n        \\n        public void recur(List<List<String>> res,List<String> temp, String s){\\n            if(s.length()==0){\\n                res.add(new ArrayList<String>(temp));\\n                return;\\n            }\\n            for(int i=0;i<s.length();i++){\\n                if(isPalin(s.substring(0,i+1))){\\n                    temp.add(s.substring(0,i+1));\\n                    recur(res,temp,s.substring(i+1));\\n                    temp.remove(temp.size()-1);\\n                }\\n            }\\n        }\\n        \\n        public boolean isPalin(String s){\\n            for(int i=0;i<s.length()/2;i++){\\n                if(s.charAt(i)!=s.charAt(s.length()-1-i))return false;\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res=new ArrayList<List<String>>();\\n            if(s.length()==0)return res;\\n            recur(res,new ArrayList<String>(),s);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 486544,
                "title": "python-straightforward-recursion-easy-above-average-performance-well-explained",
                "content": "First, we create a globar list `res` - this is the result we are going return.\\n\\nSecond, we define a recursive function.  It takes two arguments:\\n\\n`arr` - a list of palindromes we have found up to this point\\n`str` - the string left to analyze\\n\\nSince it\\'s a recursive function, let\\'s define the exit criteria. If `str` is empty and `arr` is not - that means we\\'ve been able to break up the whole intial string `s` into palindromes. So we just add `arr` to `res` and return. If `str` is empty but `arr` is also empty - that means we got an empty `s`. So we just return without adding `arr` to `res`.\\n\\nOk, now we define the recursion step. We look at every substring of `str` `(str[:1],...,str[:-1]` and check if it is a palindrome. The check is simply `if str[:i] == str[:i][::-1]:` . If this substring is a palindrome, we continue recursion by calling helper again with `arr+[str[:i]]` (the extended palindrome sequence) and what is left from `str: str[i:]`.\\n\\nThat\\'s it!\\n\\n\\n```\\nclass Solution(object):\\n    def partition(self, s):\\n        res=[]\\n        \\n        def helper(arr, str):\\n            if str:\\n                for i in range(1, len(str)+1):\\n                    if str[:i] == str[:i][::-1]:\\n                        helper(arr+[str[:i]], str[i:])\\n            elif arr: \\n                    res.append(arr)\\n        \\n        helper([], s)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def partition(self, s):\\n        res=[]\\n        \\n        def helper(arr, str):\\n            if str:\\n                for i in range(1, len(str)+1):\\n                    if str[:i] == str[:i][::-1]:\\n                        helper(arr+[str[:i]], str[i:])\\n            elif arr: \\n                    res.append(arr)\\n        \\n        helper([], s)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971898,
                "title": "python-dp-dfs-solution-explained",
                "content": "First thing we need to see when we look at problem description, that `n` is pretty small, no more than `15`, and it is done for reason: we will see in our complexity analysis why. Let us use function `find_all_palindromes`, where:\\n\\n1. `s` is input string, imagine `abacc`.\\n2. Output is lengths of biggest palindromes for each of the `2n-1` possible middles. Why there is `2n-1`? Because it can be either letter or in between letters.\\n3. Here I use very simple way to find all palindromes: just consider every possible substring, there will be `O(n^2)` of them and check in `O(n)` if it is palindrome. Total complexity of this step is `O(n^3)`, but we do not care here: complexity of the next step will be much bigger.\\n\\nNow, let us `dp[i+1]` be solution for `s[:i]`. How we can find `dp[i+1]`? We need to iterate over all `k in range (0, N)`: possible starts of last palindrome and check `if B[2*i-k+1] >= k`: this condition means that `s[i-k: i+1]` is palindrome: so now we just iterate over all solutions for `dp[i-k]` and add this string to the end of solutions. Why I prefer here `dp` solution, not backtracking, because it is more universal and you can solve **132. Palindrome Partitioning II** just changing code a bit.\\n\\n**Comlexity**: as we discussed, complexity of finding all palindromes is `O(n^3)`. Now, imagine we have string `aaa...aa` with length `n`. Then there will be exactly `2^(n-1)` ways to split this string in palindromes: we can cut it in any of `n-1` places. So, there will be `O(2^n* n)` time and space to keep solution for `s`. Also we keep solution for all prefixes of `s`, but we have `O(2^n * n + 2^(n-1)*(n-1) + ...)` which is still `O(2^n * n)`. Space complexity is the same: we need this amount of memory just to keep answer.\\n\\n**Remark** I ran this code 6 months ago and it was around 60-70ms, now it is 600-700ms, this means, that leetcode added new tests and histogram is not relevant at the moment. Do not be discouraged whey you see something like  faster than 10%, it is not true.\\n\\n**Remark2** Note again, that `find_all_palindromes(s)` has complexity `O(n^3)` here, and there is `O(n^2)` and even `O(n)` algorithms for this. But if you change this part, difference will be negligible: you can try and will see.\\n\\n```\\nclass Solution:\\n    def partition(self, s):\\n        def find_all_palindromes(s):\\n            B = [0] * (2*n)\\n            for i, j in combinations_with_replacement(range(n), 2):\\n                if s[i:j+1] == s[i:j+1][::-1]:\\n                    B[i+j+1] = max(B[i+j+1], j-i+1)\\n            return B\\n        \\n        n = len(s)\\n        B = find_all_palindromes(s)\\n        \\n        dp = [[] for _ in range(n+1)]\\n        dp[0] = [[]]\\n        for i in range(0, n):\\n            for k in range(0, i+1):\\n                if B[2*i-k+1] >= k:\\n                    for elem in dp[i-k]:\\n                        dp[i + 1].append(elem  + [s[i-k:i+1]])\\n\\n        return dp[-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s):\\n        def find_all_palindromes(s):\\n            B = [0] * (2*n)\\n            for i, j in combinations_with_replacement(range(n), 2):\\n                if s[i:j+1] == s[i:j+1][::-1]:\\n                    B[i+j+1] = max(B[i+j+1], j-i+1)\\n            return B\\n        \\n        n = len(s)\\n        B = find_all_palindromes(s)\\n        \\n        dp = [[] for _ in range(n+1)]\\n        dp[0] = [[]]\\n        for i in range(0, n):\\n            for k in range(0, i+1):\\n                if B[2*i-k+1] >= k:\\n                    for elem in dp[i-k]:\\n                        dp[i + 1].append(elem  + [s[i-k:i+1]])\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084642,
                "title": "python3-simple-backtracking-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem DP can be considered but as we are not calculating number of solutions but to return all the possible solutions.So it is better to backtrack. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Consider a function palindrome to check whether a string is palindrome or not.\\n- an other function dfs to backtrack with parameters \\'i\\' -> current position and curr -> current solution\\n- first condition if postion \\'i\\' is the last position of the string we got our complete traversal and append to the solution\\n- else traverse the string from  \\'i\\' to len(s) and if current partition \\'sol\\' is palindrome backtrack again for all possible solutions.\\n- In a nutshell we get all the possible solutions just by backtracking.\\n\\n# Complexity\\n- Time complexity: O(2^n)*O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> For Each character in the input string the algorithm generates 2 recursive calls, one for including the character and one for not including it.For this O(2^n).To check whether the string is palindrome or not we have O(n) time complexity.\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The list stores single list for a current partition.So in the worst case if each character is considered a palindrome then the time complexity will be O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        lst = []\\n        def palindrome(a):\\n            return a == a[::-1]\\n        def dfs(i,curr):\\n            if i == len(s):\\n                lst.append(curr)\\n                return \\n            for j in range(i,len(s)):\\n                sol = s[i:j+1]\\n                if palindrome(sol):\\n                    dfs(j+1, curr + [sol] )\\n            return \\n        dfs(0,[])\\n        return lst\\n            \\n\\n```\\nps: s[::-1] easy way to reverse a string",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        lst = []\\n        def palindrome(a):\\n            return a == a[::-1]\\n        def dfs(i,curr):\\n            if i == len(s):\\n                lst.append(curr)\\n                return \\n            for j in range(i,len(s)):\\n                sol = s[i:j+1]\\n                if palindrome(sol):\\n                    dfs(j+1, curr + [sol] )\\n            return \\n        dfs(0,[])\\n        return lst\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154417,
                "title": "easy-backtracking-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool palindrome(string prefix)\\n    {\\n        int l=0;\\n        int r=prefix.size()-1;\\n        while(l<r)\\n        {\\n            if(prefix[l]!=prefix[r])\\n                return false;\\n            l++;r--;\\n        }\\n        return true;\\n    }\\n    void solve(string s,vector<vector<string>>&ans,vector<string>&v)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string prefix=s.substr(0,i+1);\\n            string left=s.substr(i+1);\\n            if(palindrome(prefix))\\n            {\\n                v.push_back(prefix);\\n                solve(left,ans,v);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>v;\\n        solve(s,ans,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool palindrome(string prefix)\\n    {\\n        int l=0;\\n        int r=prefix.size()-1;\\n        while(l<r)\\n        {\\n            if(prefix[l]!=prefix[r])\\n                return false;\\n            l++;r--;\\n        }\\n        return true;\\n    }\\n    void solve(string s,vector<vector<string>>&ans,vector<string>&v)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string prefix=s.substr(0,i+1);\\n            string left=s.substr(i+1);\\n            if(palindrome(prefix))\\n            {\\n                v.push_back(prefix);\\n                solve(left,ans,v);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>v;\\n        solve(s,ans,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971863,
                "title": "python-js-c-go-by-dfs-backtracking-w-comment",
                "content": "Python by DFS backtracking\\n\\n---\\n\\n**Implementation**:\\n\\nin **Python**:\\n\\n```\\nclass Solution:\\n    \\n    # -----------------------------------------------------\\n    def dfs(self, s, partition, result):\\n        \\n        if not s:\\n            \\n            ## base case aka stop condition\\n            # add into result when we meet a empty string\\n            result.append( partition[::] )\\n            return\\n        \\n        \\n        ## general cases:\\n        # scan each possible split index\\n        \\n        for i in range(1, len(s)+1):\\n            \\n            prefix, postfix = s[:i], s[i:]\\n            \\n            if self.is_palindrome( prefix ):\\n                \\n                # current prefix is palindrome, keep trying to make more partition in DFS\\n                partition.append( prefix )\\n                self.dfs(postfix, partition, result)\\n                partition.pop()\\n\\n    # -----------------------------------------------------\\n    \\n    def is_palindrome(self, s):\\n        \\n        # helper function to chceck palindrome\\n        return s == s[::-1]\\n    \\n    # -----------------------------------------------------\\n    \\n    def partition(self, s):\\n\\n        # record for solution\\n        result = []\\n\\n        # make palindrome partition in DFS\\n        self.dfs(s, [], result)\\n        return result\\n```\\n\\n---\\n\\nIn **Javascript**:\\n\\n<details>\\n\\t<summary>Expand to see source code</summary>\\n\\t\\n```\\nconst isPalindrome = str => ( str === str.split(\\'\\').reverse().join(\\'\\') );\\n\\n\\nvar dfs = function(s, partition, result){\\n    \\n    // Base case:\\n    // Empty string must be palindrome\\n    if( 0 == s.length ){\\n        \\n        result.push( [...partition] );\\n        return;\\n    }\\n    \\n    \\n    // General cases:\\n    \\n    for( let i = 1; i <= s.length ; i++ ){\\n        \\n        let prefix = s.substring(0, i);\\n        let postfix = s.substring(i);\\n        \\n        // Current prefix is palindrome, keep trying to make more partition in postfix by DFS\\n        if( isPalindrome(prefix) ){\\n            \\n            partition.push( prefix );\\n            \\n            dfs( postfix, partition, result);\\n            \\n            partition.pop();\\n        }\\n        \\n    }\\n    return\\n};\\n\\nvar partition = function(s) {\\n    \\n    // buffer for partition in DFS\\n    let partition = [];\\n    \\n    // final output of palindrome substrings\\n    let result = [];\\n    \\n    dfs(s, partition, result);\\n    \\n    return result;\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nIn **C++**:\\n\\n<details>\\n\\t<summary>Expand to see source code</summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        \\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        \\n        // Make palindrome partition in DFS\\n        dfs( s, partition, result);\\n        \\n        return result;\\n        \\n    }\\nprivate:\\n    bool isPalindrome(const string &s){\\n        \\n        string revStr = s;\\n        reverse( revStr.begin(), revStr.end() );\\n        \\n        return s == revStr;\\n    }\\n        \\n        \\n    void dfs(string &s, vector<string> &partition, vector< vector<string> > &result ){\\n        \\n        // Base case:\\n        // Empty string must be palindrome\\n        \\n        if( 0 == s.size() ){\\n            \\n            result.push_back( partition );\\n            return;\\n        } \\n        \\n        \\n        // General cases:\\n        for( int i = 1 ; i <= s.size() ; i++ ){\\n            \\n            string prefix = s.substr(0, i);\\n            string postfix = s.substr(i);\\n            \\n            // Current prefix is palindrome, leep trying to make more partition in postfix by DFS\\n            if( isPalindrome(prefix) ){\\n\\n                partition.push_back( prefix );\\n\\n                dfs( postfix, partition, result);\\n                \\n                partition.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\n```\\n\\n</details>\\n\\n---\\n\\nIn **Go**:\\n\\n<details>\\n\\t<summary>Expand to see source code</summary>\\n\\n```\\nfunc isPalindrome(s string)bool{\\n    \\n    left, right := 0, len(s)-1\\n    \\n    for left < right{\\n    \\n        if s[left] != s[right]{\\n            return false;\\n        }\\n        \\n        left, right = left+1, right-1\\n    }\\n    \\n    return true;\\n}\\n\\n\\nfunc dfs(s string, partition *[]string, result *[][]string){\\n    \\n    // Base case:\\n    // Empty string must be palindrome\\n    if 0 == len(s){\\n        \\n        // Make a copy of current partition, and save into result\\n        goodPartition := make([]string, len(*partition))\\n        copy(goodPartition, *partition)\\n\\n        *result = append(*result, goodPartition)\\n        return\\n    }\\n    \\n    \\n    // General case:\\n    for i := 1 ; i <= len(s) ; i++{\\n        \\n        prefix := s[0:i]\\n        postfix := s[i:]\\n        \\n        if isPalindrome( prefix ){\\n            \\n            *partition = append(*partition, prefix)\\n            \\n            dfs( postfix, partition, result)\\n            \\n            // golang doesn\\'t have built-in pop function for slice\\n            *partition = (*partition)[:len(*partition)-1]\\n        }\\n    }\\n    return\\n}\\n\\n\\nfunc partition(s string) [][]string {\\n    \\n    // buffer for partition in DFS\\n    part := make([]string,0)\\n    \\n    // final output of palindrome substrins\\n    result := make([][]string,0)\\n    \\n    dfs(s, &part, &result)\\n    return result\\n}\\n```\\n\\n</details>\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki : Palindrome](https://en.wikipedia.org/wiki/Palindrome)\\n\\n[2] [Python official docs about string and sting slicing](https://docs.python.org/3/tutorial/introduction.html#strings)\\n\\n[3] [MDN: Javascript docs about substring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring)\\n\\n[4] [Cpp reference about C++ substring](https://www.cplusplus.com/reference/string/string/substr/)\\n\\n[5] [Golang Docs about substring](https://golangdocs.com/substring-in-golang)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "String",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # -----------------------------------------------------\\n    def dfs(self, s, partition, result):\\n        \\n        if not s:\\n            \\n            ## base case aka stop condition\\n            # add into result when we meet a empty string\\n            result.append( partition[::] )\\n            return\\n        \\n        \\n        ## general cases:\\n        # scan each possible split index\\n        \\n        for i in range(1, len(s)+1):\\n            \\n            prefix, postfix = s[:i], s[i:]\\n            \\n            if self.is_palindrome( prefix ):\\n                \\n                # current prefix is palindrome, keep trying to make more partition in DFS\\n                partition.append( prefix )\\n                self.dfs(postfix, partition, result)\\n                partition.pop()\\n\\n    # -----------------------------------------------------\\n    \\n    def is_palindrome(self, s):\\n        \\n        # helper function to chceck palindrome\\n        return s == s[::-1]\\n    \\n    # -----------------------------------------------------\\n    \\n    def partition(self, s):\\n\\n        # record for solution\\n        result = []\\n\\n        # make palindrome partition in DFS\\n        self.dfs(s, [], result)\\n        return result\\n```\n```\\nconst isPalindrome = str => ( str === str.split(\\'\\').reverse().join(\\'\\') );\\n\\n\\nvar dfs = function(s, partition, result){\\n    \\n    // Base case:\\n    // Empty string must be palindrome\\n    if( 0 == s.length ){\\n        \\n        result.push( [...partition] );\\n        return;\\n    }\\n    \\n    \\n    // General cases:\\n    \\n    for( let i = 1; i <= s.length ; i++ ){\\n        \\n        let prefix = s.substring(0, i);\\n        let postfix = s.substring(i);\\n        \\n        // Current prefix is palindrome, keep trying to make more partition in postfix by DFS\\n        if( isPalindrome(prefix) ){\\n            \\n            partition.push( prefix );\\n            \\n            dfs( postfix, partition, result);\\n            \\n            partition.pop();\\n        }\\n        \\n    }\\n    return\\n};\\n\\nvar partition = function(s) {\\n    \\n    // buffer for partition in DFS\\n    let partition = [];\\n    \\n    // final output of palindrome substrings\\n    let result = [];\\n    \\n    dfs(s, partition, result);\\n    \\n    return result;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        \\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        \\n        // Make palindrome partition in DFS\\n        dfs( s, partition, result);\\n        \\n        return result;\\n        \\n    }\\nprivate:\\n    bool isPalindrome(const string &s){\\n        \\n        string revStr = s;\\n        reverse( revStr.begin(), revStr.end() );\\n        \\n        return s == revStr;\\n    }\\n        \\n        \\n    void dfs(string &s, vector<string> &partition, vector< vector<string> > &result ){\\n        \\n        // Base case:\\n        // Empty string must be palindrome\\n        \\n        if( 0 == s.size() ){\\n            \\n            result.push_back( partition );\\n            return;\\n        } \\n        \\n        \\n        // General cases:\\n        for( int i = 1 ; i <= s.size() ; i++ ){\\n            \\n            string prefix = s.substr(0, i);\\n            string postfix = s.substr(i);\\n            \\n            // Current prefix is palindrome, leep trying to make more partition in postfix by DFS\\n            if( isPalindrome(prefix) ){\\n\\n                partition.push_back( prefix );\\n\\n                dfs( postfix, partition, result);\\n                \\n                partition.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\n```\n```\\nfunc isPalindrome(s string)bool{\\n    \\n    left, right := 0, len(s)-1\\n    \\n    for left < right{\\n    \\n        if s[left] != s[right]{\\n            return false;\\n        }\\n        \\n        left, right = left+1, right-1\\n    }\\n    \\n    return true;\\n}\\n\\n\\nfunc dfs(s string, partition *[]string, result *[][]string){\\n    \\n    // Base case:\\n    // Empty string must be palindrome\\n    if 0 == len(s){\\n        \\n        // Make a copy of current partition, and save into result\\n        goodPartition := make([]string, len(*partition))\\n        copy(goodPartition, *partition)\\n\\n        *result = append(*result, goodPartition)\\n        return\\n    }\\n    \\n    \\n    // General case:\\n    for i := 1 ; i <= len(s) ; i++{\\n        \\n        prefix := s[0:i]\\n        postfix := s[i:]\\n        \\n        if isPalindrome( prefix ){\\n            \\n            *partition = append(*partition, prefix)\\n            \\n            dfs( postfix, partition, result)\\n            \\n            // golang doesn\\'t have built-in pop function for slice\\n            *partition = (*partition)[:len(*partition)-1]\\n        }\\n    }\\n    return\\n}\\n\\n\\nfunc partition(s string) [][]string {\\n    \\n    // buffer for partition in DFS\\n    part := make([]string,0)\\n    \\n    // final output of palindrome substrins\\n    result := make([][]string,0)\\n    \\n    dfs(s, &part, &result)\\n    return result\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083724,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=x_cz9YqULlk&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=22) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/bWBHaVW2/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Rust"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=x_cz9YqULlk&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=22) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/bWBHaVW2/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3084168,
                "title": "3-solutions-deep-explaination-backtracking-c-java-python3",
                "content": "# Approach : Backtracking\\n```\\nExample - xxyy\\n```\\n![104d7464-a56c-45c3-87cc-4caea3a05103_1641347225.9497328.png](https://assets.leetcode.com/users/images/23e40e5d-a8dd-4ea5-b19f-5c369ea62d6f_1674362772.6449003.png)\\n\\n# Complexity :\\n- Time Complexity :- BigO(N*2^N)\\n- Space Complexity :- BigO(N)\\n\\n# Request \\uD83D\\uDE0A :\\n- If you find this solution easy to understand and helpful, then Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/1049379a-7a98-48f2-beea-227de8d2370b_1674361539.0190594.gif)\\n\\n# Code [C++]: \\uD83D\\uDD25\\uD83D\\uDD25\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // which will be our answer\\n        vector<string> path; // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n# Code [Java]:\\uD83D\\uDD25\\uD83D\\uDD25\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>(); // which will be our answer\\n        List<String> path = new ArrayList<>(); // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    public void helper(int index, String s, List<String> path, List<List<String>> res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.length()){\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.length(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.add(s.substring(index, i + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.remove(path.size() - 1); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    } \\n    \\n    public boolean isPalindrome(String s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s.charAt(start++) != s.charAt(end--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n# Code [Python3]:\\uD83D\\uDD25\\uD83D\\uDD25\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        palindro = []\\n        path = []\\n        self.helper(0, s, path, palindro)\\n        return palindro\\n\\n    def helper(self, index, s, path, palindro):\\n        if index == len(s):\\n            palindro.append(path[:])\\n            return\\n        for i in range(index, len(s)):\\n            if self.is_palindro(s, index, i):\\n                path.append(s[index:i+1])\\n                self.helper(i+1, s, path, palindro)\\n                path.pop()\\n\\n    def is_palindro(self, s, start, end):\\n        while start <= end:\\n            if s[start] != s[end]:\\n                return False\\n            start += 1\\n            end -= 1\\n        return True\\n\\n```\\ncredits to [@hi-malik](https://leetcode.com/hi-malik/) for helping me out",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nExample - xxyy\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // which will be our answer\\n        vector<string> path; // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>(); // which will be our answer\\n        List<String> path = new ArrayList<>(); // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    public void helper(int index, String s, List<String> path, List<List<String>> res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.length()){\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.length(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.add(s.substring(index, i + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.remove(path.size() - 1); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    } \\n    \\n    public boolean isPalindrome(String s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s.charAt(start++) != s.charAt(end--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        palindro = []\\n        path = []\\n        self.helper(0, s, path, palindro)\\n        return palindro\\n\\n    def helper(self, index, s, path, palindro):\\n        if index == len(s):\\n            palindro.append(path[:])\\n            return\\n        for i in range(index, len(s)):\\n            if self.is_palindro(s, index, i):\\n                path.append(s[index:i+1])\\n                self.helper(i+1, s, path, palindro)\\n                path.pop()\\n\\n    def is_palindro(self, s, start, end):\\n        while start <= end:\\n            if s[start] != s[end]:\\n                return False\\n            start += 1\\n            end -= 1\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42113,
                "title": "share-my-dynamic-programming-solution-with-explaination",
                "content": "Use a DP vecor DP[i] to record all solutions using string s[:i+1]\\n\\n    class Solution:\\n        # @param {string} s\\n        # @return {string[][]}\\n        def partition(self, s):\\n            if not s:\\n                return [[]]\\n            dp = {0:[[]], 1:[[s[0]]]}\\n            for ii in xrange(1, len(s)):\\n                dp[ii+1] = []\\n                for jj in xrange(0, ii+1):\\n                    if self.isPalindrome(s[jj:ii+1]):\\n                        for sol in dp[jj]:\\n                            dp[ii+1].append(sol+[s[jj:ii+1]])\\n            return dp[len(s)]\\n\\n        \\n        def isPalindrome(self, string):\\n            return string == string[::-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n        # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 557573,
                "title": "intuitive-javascript-solution-with-dfs",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    const output = [];\\n    const partitions = [];\\n    const isPalindrome = str => str === str.split(\\'\\').reverse().join(\\'\\');\\n    const findPalindrome = (str, start, parts, result) => {\\n        if (start === str.length) {\\n            result.push([...parts])\\n            return;\\n        }\\n        \\n        for (let i = start + 1; i <= str.length; i++) {\\n            const target = str.substring(start, i);\\n            if (isPalindrome(target)) {\\n                parts.push(target);\\n                findPalindrome(str, i, parts, result);        \\n                parts.pop();\\n            }\\n        }\\n    }\\n    /*\\n        string: \\'aab\\'\\n        start = 0 will find palindrome in \\'a\\', \\'aa\\', \\'aab\\'\\n        start = 1 will find palindrome in      \\'a\\',  \\'ab\\'\\n        start = 2 will find palindrome in            \\'b\\'\\n     */\\n    findPalindrome(s, 0, partitions, output);   \\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    const output = [];\\n    const partitions = [];\\n    const isPalindrome = str => str === str.split(\\'\\').reverse().join(\\'\\');\\n    const findPalindrome = (str, start, parts, result) => {\\n        if (start === str.length) {\\n            result.push([...parts])\\n            return;\\n        }\\n        \\n        for (let i = start + 1; i <= str.length; i++) {\\n            const target = str.substring(start, i);\\n            if (isPalindrome(target)) {\\n                parts.push(target);\\n                findPalindrome(str, i, parts, result);        \\n                parts.pop();\\n            }\\n        }\\n    }\\n    /*\\n        string: \\'aab\\'\\n        start = 0 will find palindrome in \\'a\\', \\'aa\\', \\'aab\\'\\n        start = 1 will find palindrome in      \\'a\\',  \\'ab\\'\\n        start = 2 will find palindrome in            \\'b\\'\\n     */\\n    findPalindrome(s, 0, partitions, output);   \\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3323894,
                "title": "short-c-java-python-js-explained-solution",
                "content": "\\n# **Read Article COde with Explaination:\\n# **\\nhttps://www.nileshblog.tech/2023/01/palindrome-partitioning-of-a-string-leetcode-problem-solution/\\n\\n\\n![WhatsApp Image 2023-01-22 at 11.27.47 AM.jpeg](https://assets.leetcode.com/users/images/0f629558-6de6-4518-840a-9d79536debdd_1674368333.426988.jpeg)\\n\\n\\n\\nRead Article COde with Explaination:\\n\\nhttps://www.nileshblog.tech/2023/01/palindrome-partitioning-of-a-string-leetcode-problem-solution/\\n\\n\\n\\n![0c02f9a6-2084-4ebb-b8f3-600c8b5f62a4_1674006448.3568876.jpeg](https://assets.leetcode.com/users/images/7671beaf-d6ab-412a-8d70-58fb792be7a6_1674368322.430683.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "\\n# **Read Article COde with Explaination:\\n# **\\nhttps://www.nileshblog.tech/2023/01/palindrome-partitioning-of-a-string-leetcode-problem-solution/\\n\\n\\n![WhatsApp Image 2023-01-22 at 11.27.47 AM.jpeg](https://assets.leetcode.com/users/images/0f629558-6de6-4518-840a-9d79536debdd_1674368333.426988.jpeg)\\n\\n\\n\\nRead Article COde with Explaination:\\n\\nhttps://www.nileshblog.tech/2023/01/palindrome-partitioning-of-a-string-leetcode-problem-solution/\\n\\n\\n\\n![0c02f9a6-2084-4ebb-b8f3-600c8b5f62a4_1674006448.3568876.jpeg](https://assets.leetcode.com/users/images/7671beaf-d6ab-412a-8d70-58fb792be7a6_1674368322.430683.jpeg)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2779787,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string> > ret;\\n        if(s.empty()) return ret;\\n        \\n        vector<string> path;\\n        dfs(0, s, path, ret);\\n        \\n        return ret;\\n    }\\n    \\n    void dfs(int index, string& s, vector<string>& path, vector<vector<string> >& ret) {\\n        if(index == s.size()) {\\n            ret.push_back(path);\\n            return;\\n        }\\n        for(int i = index; i < s.size(); ++i) {\\n            if(isPalindrome(s, index, i)) {\\n                path.push_back(s.substr(index, i - index + 1));\\n                dfs(i+1, s, path, ret);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(const string& s, int start, int end) {\\n        while(start <= end) {\\n            if(s[start++] != s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string> > ret;\\n        if(s.empty()) return ret;\\n        \\n        vector<string> path;\\n        dfs(0, s, path, ret);\\n        \\n        return ret;\\n    }\\n    \\n    void dfs(int index, string& s, vector<string>& path, vector<vector<string> >& ret) {\\n        if(index == s.size()) {\\n            ret.push_back(path);\\n            return;\\n        }\\n        for(int i = index; i < s.size(); ++i) {\\n            if(isPalindrome(s, index, i)) {\\n                path.push_back(s.substr(index, i - index + 1));\\n                dfs(i+1, s, path, ret);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(const string& s, int start, int end) {\\n        while(start <= end) {\\n            if(s[start++] != s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435290,
                "title": "c-recursion-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<string>> partition(string s) {\\n\\t\\tvector<vector<string>> ans;\\n\\t\\tvector<string>path;\\n\\t\\tint n = s.size();\\n\\t\\tsolve(0, n, s, path, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tvoid solve(int index, int n, string s, vector<string>&path, vector<vector<string>>&ans)\\n\\t{\\n\\t\\tif (index == n)\\n\\t\\t{\\n\\t\\t\\tans.push_back(path);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = index; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] == s[index] && ispalindrome(index, i, s))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpath.push_back(s.substr(index, i - index + 1));\\n\\t\\t\\t\\tsolve(i + 1, n, s, path, ans);\\n\\t\\t\\t\\tpath.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbool ispalindrome(int start, int end, string &s)\\n\\t{\\n\\t\\twhile (start < end)\\n\\t\\t{\\n\\t\\t\\tif (s[start++] != s[end--])\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<string>> partition(string s) {\\n\\t\\tvector<vector<string>> ans;\\n\\t\\tvector<string>path;\\n\\t\\tint n = s.size();\\n\\t\\tsolve(0, n, s, path, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tvoid solve(int index, int n, string s, vector<string>&path, vector<vector<string>>&ans)\\n\\t{\\n\\t\\tif (index == n)\\n\\t\\t{\\n\\t\\t\\tans.push_back(path);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = index; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] == s[index] && ispalindrome(index, i, s))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpath.push_back(s.substr(index, i - index + 1));\\n\\t\\t\\t\\tsolve(i + 1, n, s, path, ans);\\n\\t\\t\\t\\tpath.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbool ispalindrome(int start, int end, string &s)\\n\\t{\\n\\t\\twhile (start < end)\\n\\t\\t{\\n\\t\\t\\tif (s[start++] != s[end--])\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083432,
                "title": "well-explained-beginner-friendly-java-c-py-with-algorithm-short-simple",
                "content": "\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/5ab61190-e3d5-486b-bd64-33b691de34f7_1674345818.8312604.png)\\n\\n```\\nLet\\'s Understood with an example:\\n\\n\"xxyy\" -> [\"x\", \"x\", \"y\", \"y\"] // 1st List of all the substring\\n          [\"x\", \"x\", \"yy\"] // 2nd List of all the substring\\n          [\"xx\", \"y\", \"y\"] // 3rd List of all the substring\\n          [\"xx\", \"yy\"] // 4th List of all the substring\\n\\nIn the above example we can only have 4 possible list\\'s\\n\\nOur task is to return a list of all of these list\\'s, that are possible\\n```\\n\\nTake an example, \"xxyy\".\\nIf we partition over x|xyy so the substring \"x\" is a palindrome. Where i can have the first partition.\\n\\nBut, if they don\\'t allow to partition over there, then our second partition will be xx|yy. Because this \"xx\" is a palindrome substring. Thus we still left out with yy, so if i do the partion over here xxy|y the answer will be no, because if i do the partition over here the substring \"xxy\" is not a palindrome.\\n\\nCan i do a partition over here xxyy|. No. Because xxyy is not a palindromic substring. So, we can see when we started we can do a partition over here x|xyy OR xx|yy so that is what we do. We try to do partition where ever it is possible\\n\\nSo, in the first case we did a partition over x|xyy where we left out with xyy. So, if i do a partiton like x|x|yy where x it\\'self a palindrome. And we left out with a substring yy\\nNow can you do a partition over here x|xy|y. No, because this substring xy is not a palindrome\\nAgain can we do a partition over here x|xyy|. No, because this substring xyy is not a palindrome\\n\\nSo, the only partition possible is x|x|yy. And after that we tend to call the recursion for remaining substring\\n\\nIf i try to do a partition over here x|x|y|y so, the substring y in itself is a palindromic substring. After that we left out with remaining y substring.\\nNow you ask can we do a partition over here x|x|yy|, Yes\\n\\nLike this way, we do the partition in complete STRING using recursion. And with the help of Backtracking we store our answer.\\n\\n![image.png](https://assets.leetcode.com/users/images/1b01b518-620e-4e35-b0a3-49f034611e67_1674347528.772972.png)\\n![image.png](https://assets.leetcode.com/users/images/ba149c7d-b4d5-4c1d-abb8-8b76f8342241_1674347548.816257.png)\\n\\n\\nAll backtracking problems are composed by these three steps: choose, explore, unchoose.\\nSo for each problem, you need to know:\\n\\nchoose what? For this problem, we choose each substring.\\nhow to explore? For this problem, we do the same thing to the remained string. unchoose Do the opposite operation of choose.\\nLet\\'s take this problem as an example:\\n1. Define helper(): Usually we need a helper funcition in backtracking problem, to accept more parameters.\\n2. Parameters: Usually we need the following parameters\\n\\n    1. The object you are working on:  For this problem is String s.\\n    2. A start index or an end index which indicate which part you are working on: For this problem, we use substring to indicate the start index.\\n    3. A step result, to remember current choose and then do unchoose : For this problem, we use List<String> step.\\n    4. A final result, to remember the final result. Usually when we add, we use \\'result.add(new ArrayList<>(step))\\' instead of \\'result.add(step)\\', since step is reference passed. We will modify step later, so we need to copy it and add the copy to the result;\\n\\n3 .Base case: The base case defines when to add step into result, and when to return.\\n4 .Use for-loop : Usually we need a for loop to iterate though the input String s, so that we can choose all the options.\\n5 .Choose : In this problem, if the substring of s is palindrome, we add it into the step, which means we choose this substring.\\n6 .Explore : In this problem, we want to do the same thing to the remaining substring. So we recursively call our function.\\n7 .Un-Choose : We draw back, remove the chosen substring, in order to try other options.\\n\\n# Code\\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```\\n```java []\\nclass Solution {\\n   public List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> path; // here we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res; //returning\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;//returning\\n        }\\n        // then partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false; //returning if false\\n        }\\n        return true;//returning if true\\n    }\\n};\\n```\\n\\n\\n# Algorithm :-\\n\\n1. As i told you in backtracking, one thing is sure i.e a helper method. In our problem we will need a bool helper method which will check the palindrome conditions, let\\'s name it as bool isPalindrome().\\n2. Now let\\'s create some variables : result vector for storing all the substring which satisfies the palindrome condition , path vector for storing the ongoing substr which has the potential of satisfying the conditions of palindrome , start variable for storing the start position of the current substr , index i for traversing inside the substring and n fro storing the size of given string s.\\n3. Now we search from start till the end of the string. Once we reach a position i such that the sub-string from start to i (s.substr(start, i - start + 1)) is a palindrome, we add it to our path variable. Then we recursively call the same method to execute the remaining substring . Once we reach the end of the string, we add palindromes path into the result of all the possible partitioning .\\n4. Remember that at position i , we find s.substr(start, i - start + 1) to be a palindrome and we immediately add it to path . Now think that there may be a position j such that j > i and s.substr(start, j - start + 1) is also a palindrome. Thus now we need to go back to our start before adding s.substr(start, i - start + 1) to path and continue to find the next palindrome position after i . And after this evertime we simply need to remove or pop s.substr(start, i - start + 1) out of path to execute the backtracking algo .\\n5. The steps we executed in the above step is none other than the famous dfs .\\n\\n# Code\\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```\\n```java []\\nclass Solution {\\n   public List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> path; // here we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res; //returning\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;//returning\\n        }\\n        // then partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false; //returning if false\\n        }\\n        return true;//returning if true\\n    }\\n};\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on [Linkedin](https://www.linkedin.com/in/kailas-rathod/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nLet\\'s Understood with an example:\\n\\n\"xxyy\" -> [\"x\", \"x\", \"y\", \"y\"] // 1st List of all the substring\\n          [\"x\", \"x\", \"yy\"] // 2nd List of all the substring\\n          [\"xx\", \"y\", \"y\"] // 3rd List of all the substring\\n          [\"xx\", \"yy\"] // 4th List of all the substring\\n\\nIn the above example we can only have 4 possible list\\'s\\n\\nOur task is to return a list of all of these list\\'s, that are possible\\n```\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```\n```java []\\nclass Solution {\\n   public List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> path; // here we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res; //returning\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;//returning\\n        }\\n        // then partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false; //returning if false\\n        }\\n        return true;//returning if true\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```\n```java []\\nclass Solution {\\n   public List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> path; // here we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res; //returning\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;//returning\\n        }\\n        // then partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false; //returning if false\\n        }\\n        return true;//returning if true\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935375,
                "title": "100-fastest-swift-solution-time-o-n-2-n-space-o-n-2",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * 2^n), where n is the length of s.\\n    //   - space: O(n^2), where n is the length of s.\\n\\n    func partition(_ s: String) -> [[String]] {\\n        let n = s.count\\n        var dp = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\\n        var ans = [[String]]()\\n        var currentList = [String]()\\n\\n        dfs(&ans, str: Array(s), n: n, start: 0, &currentList, &dp)\\n        return ans\\n    }\\n\\n    \\n    private func dfs(_ ans: inout [[String]], str: [Character], n: Int, start: Int, _ currentList: inout [String], _ dp: inout [[Bool]]) {\\n        guard start < n else { ans.append(currentList); return }\\n            \\n        for end in start..<n {\\n            guard str[start] == str[end], (end - start <= 2 || dp[start + 1][end - 1]) else { continue }\\n            dp[start][end] = true\\n            currentList.append(String(str[start...end]))\\n            dfs(&ans, str: str, n: n, start: end + 1, &currentList, &dp)\\n            currentList.removeLast()\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * 2^n), where n is the length of s.\\n    //   - space: O(n^2), where n is the length of s.\\n\\n    func partition(_ s: String) -> [[String]] {\\n        let n = s.count\\n        var dp = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\\n        var ans = [[String]]()\\n        var currentList = [String]()\\n\\n        dfs(&ans, str: Array(s), n: n, start: 0, &currentList, &dp)\\n        return ans\\n    }\\n\\n    \\n    private func dfs(_ ans: inout [[String]], str: [Character], n: Int, start: Int, _ currentList: inout [String], _ dp: inout [[Bool]]) {\\n        guard start < n else { ans.append(currentList); return }\\n            \\n        for end in start..<n {\\n            guard str[start] == str[end], (end - start <= 2 || dp[start + 1][end - 1]) else { continue }\\n            dp[start][end] = true\\n            currentList.append(String(str[start...end]))\\n            dfs(&ans, str: str, n: n, start: end + 1, &currentList, &dp)\\n            currentList.removeLast()\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668362,
                "title": "solution-swift-palindrome-partitioning-test-cases",
                "content": "```swift\\nclass Solution {\\n    func partition(_ s: String) -> [[String]] {\\n        guard s.count > 1 else { return [[s]] }\\n        var path: [String] = [], paths: [[String]] = []\\n        dfs(&paths, &path, Array(s), 0)\\n        return paths\\n    }\\n    \\n    private func dfs(_ paths: inout [[String]], _ path: inout [String], _ s: [Character], _ idx: Int) {\\n        guard idx != s.count else { paths.append(Array(path)); return }\\n        \\n        for i in idx..<s.count {\\n            let curr = String(s[idx...i])\\n            if isPalindrome(curr) {\\n                path.append(curr)\\n                dfs(&paths, &path, s, i + 1)\\n                path.removeLast()\\n            }\\n        }\\n    }\\n    private func isPalindrome(_ s: String) -> Bool {\\n        guard s.count > 1 else { return true }\\n        let len = s.count, chars = [Character](s)\\n        for i in 0..<len >> 1 where chars[i] != chars[len - 1 - i] {\\n            return false\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.032 (0.035) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.partition(\"aab\")\\n        XCTAssertEqual(value, [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.partition(\"a\")\\n        XCTAssertEqual(value, [[\"a\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func partition(_ s: String) -> [[String]] {\\n        guard s.count > 1 else { return [[s]] }\\n        var path: [String] = [], paths: [[String]] = []\\n        dfs(&paths, &path, Array(s), 0)\\n        return paths\\n    }\\n    \\n    private func dfs(_ paths: inout [[String]], _ path: inout [String], _ s: [Character], _ idx: Int) {\\n        guard idx != s.count else { paths.append(Array(path)); return }\\n        \\n        for i in idx..<s.count {\\n            let curr = String(s[idx...i])\\n            if isPalindrome(curr) {\\n                path.append(curr)\\n                dfs(&paths, &path, s, i + 1)\\n                path.removeLast()\\n            }\\n        }\\n    }\\n    private func isPalindrome(_ s: String) -> Bool {\\n        guard s.count > 1 else { return true }\\n        let len = s.count, chars = [Character](s)\\n        for i in 0..<len >> 1 where chars[i] != chars[len - 1 - i] {\\n            return false\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.partition(\"aab\")\\n        XCTAssertEqual(value, [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.partition(\"a\")\\n        XCTAssertEqual(value, [[\"a\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324347,
                "title": "c-99-beat-o-2-n-time-complexity-using-dynamic-rememberance",
                "content": "Rather than thunderbolting our many extra useless substrings and having to perform a potentially O(N) IS_PALINDROME computation, we can use dynamic programming to arrive at a SHORTER RUNNING solution. We take advantage of the fact that \"a\" is a pally, \"aa\" is a pally, and \"a\"{PALLY}\"a\" is a pally. No need to re-compute over and over.\\n\\nWe use a triangular dynamic grid to represent our palindrome points.\\n\\nTake the word \"BOOBOO\"\\n\\nRow[B] = {1, 0, 0, 1, 0, 0}\\nRow[O] = {0, 1, 1, 0, 0, 1}\\nRow[O] = {0, 0, 1, 0, 1, 0}\\nRow[B] = {0, 0, 0, 1, 0, 0}\\nRow[O] = {0, 0, 0, 0, 1, 1}\\nRow[O] = {0, 0, 0, 0, 0, 1}\\n\\nIgnore the bottom-left triangle.\\n\\nSlot[1][1] Represents the 1st O\\nSlot[2][1] Represents the 1st O and the 2nd O \"OO\" => Which is pally.\\n\\n\\n\\n\\nThe recursive step is still O(2 ^ N) because there can potentially be that many solutions...\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> partition(string s) {\\n        \\n        int **aPally = new int*[s.size() + 1];\\n        for (int i=0;i<=s.size();i++) {\\n            aPally[i] = new int[s.size() + 1];\\n            for (int k=0;k<=s.size();k++) {\\n                aPally[i][k] = 0;\\n            }\\n        }\\n        \\n        //All single characters are pallys.\\n        for (int i=0;i<s.size();i++) {\\n            aPally[i][i] = 1;\\n        }\\n        \\n        //\"aa\" is a pally, \"bb\" is a pally, etc.\\n        for (int i=1;i<s.size();i++) {\\n            aPally[i][i-1] = (s[i-1] == s[i]);\\n        }\\n        \\n        //\"a\"{Pally}\"a\" is a pally, dynamic shortcut.\\n        int aGap, i, j;\\n        for (aGap=2;aGap<s.size();aGap++) {\\n            for (i=aGap;i<s.size();i++) {\\n                j = i - aGap; \\n                if (aPally[i-1][j+1] && s[i] == s[j]) {\\n                    aPally[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<string>> aResult;\\n        vector<string> aTemp;\\n        helper(aResult, s, aPally, aTemp, 0);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<string>> &pResult, string &pString, int **pPally, vector<string> &pTemp, int pIndex) {\\n        \\n        if (pIndex >= pString.size()) {\\n            pResult.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int aLen=1;pIndex+aLen<=pString.size();aLen++) {\\n            //Look up the chunk in our table. If it\\'s a pally, add the substring\\n            //to our temp solution and continue to probe deeper and deeper.\\n            if (pPally[pIndex + aLen - 1][pIndex]) {\\n                pTemp.push_back(pString.substr(pIndex, aLen));\\n                helper(pResult, pString, pPally, pTemp, pIndex + aLen);\\n                pTemp.pop_back();\\n            }   \\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> partition(string s) {\\n        \\n        int **aPally = new int*[s.size() + 1];\\n        for (int i=0;i<=s.size();i++) {\\n            aPally[i] = new int[s.size() + 1];\\n            for (int k=0;k<=s.size();k++) {\\n                aPally[i][k] = 0;\\n            }\\n        }\\n        \\n        //All single characters are pallys.\\n        for (int i=0;i<s.size();i++) {\\n            aPally[i][i] = 1;\\n        }\\n        \\n        //\"aa\" is a pally, \"bb\" is a pally, etc.\\n        for (int i=1;i<s.size();i++) {\\n            aPally[i][i-1] = (s[i-1] == s[i]);\\n        }\\n        \\n        //\"a\"{Pally}\"a\" is a pally, dynamic shortcut.\\n        int aGap, i, j;\\n        for (aGap=2;aGap<s.size();aGap++) {\\n            for (i=aGap;i<s.size();i++) {\\n                j = i - aGap; \\n                if (aPally[i-1][j+1] && s[i] == s[j]) {\\n                    aPally[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<string>> aResult;\\n        vector<string> aTemp;\\n        helper(aResult, s, aPally, aTemp, 0);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<string>> &pResult, string &pString, int **pPally, vector<string> &pTemp, int pIndex) {\\n        \\n        if (pIndex >= pString.size()) {\\n            pResult.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int aLen=1;pIndex+aLen<=pString.size();aLen++) {\\n            //Look up the chunk in our table. If it\\'s a pally, add the substring\\n            //to our temp solution and continue to probe deeper and deeper.\\n            if (pPally[pIndex + aLen - 1][pIndex]) {\\n                pTemp.push_back(pString.substr(pIndex, aLen));\\n                helper(pResult, pString, pPally, pTemp, pIndex + aLen);\\n                pTemp.pop_back();\\n            }   \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085951,
                "title": "easy-solution-fully-explained-c-python3-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful.\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe iterate through each substring of the string and perform the following operations:\\n1. First, we check current substring is palindrome or not and next substring is palindrome or not and so on.\\n2. If the substring is palindrome then add this to the output otherwise ignore it.\\n3. If index == n then, add this output vector to the answer vector.\\nExample: Given string S = \"aab\"\\n\\n                            aab\\n                           / |  \\\\\\n                          /  |   \\\\\\n                         a   aa   aab(x)\\n                        / \\\\   \\\\   \\n                       /   \\\\   \\\\\\n                      a    ab   b\\n                     /     (x)\\n                    /\\n                   b\\n        \\n        ans = {{\\'a\\',\\'a\\',\\'b\\'}, {\\'aa\\', \\'b\\'}}\\n\\n# Approach : Backtracking\\n<!-- Describe your approach to solving the problem. -->\\n\\nTime Complexity : O(N*2^N)\\nSpace Complexity : O(N)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    // main function that takes in a string and returns all possible partitions of the string\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // vector to store all possible partitions\\n        vector<string> path; // vector to store current partition\\n        func(0, s, res, path); // call helper function to start recursion\\n        return res;\\n     }\\n\\n    // helper function that uses recursion to find all possible partitions\\n    void func(int ind, string s, vector<vector<string>>& res, vector<string>& path){\\n        if(ind == s.size()){ // base case: if we have reached the end of the string\\n            res.push_back(path); // add current partition to the result vector\\n            return ;\\n        }\\n        for(int i=ind;i<s.size();++i){ // iterate through all substrings starting from the current index\\n            if(isPalindrome(s, ind, i)){ // check if the current substring is a palindrome\\n                path.push_back(s.substr(ind, i-ind+1)); // if it is, add it to the current partition\\n                func(i+1, s, res, path); // call function recursively with the next index as the starting point\\n                path.pop_back(); // backtrack to check for other partitions\\n            }\\n        }\\n    }\\n\\n    // helper function that checks if a substring is a palindrome\\n    bool isPalindrome(string s, int start, int end){\\n        while(start<=end){ // iterate through the substring\\n            if(s[start++]!=s[end--]) // check if current characters are not equal\\n                return false; // if they are not, return false\\n        }\\n        return true; // if we reach this point, the substring is a palindrome\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = [] # vector to store all possible partitions\\n        path = [] # vector to store current partition\\n        self.func(0, s, res, path) # call helper function to start recursion\\n        return res\\n\\n    # helper function that uses recursion to find all possible partitions\\n    def func(self, ind, s, res, path):\\n        if ind == len(s): # base case: if we have reached the end of the string\\n            res.append(path[:]) # add current partition to the result vector\\n            return \\n        for i in range(ind, len(s)): # iterate through all substrings starting from the current index\\n            if self.isPalindrome(s, ind, i): # check if the current substring is a palindrome\\n                path.append(s[ind:i+1]) # if it is, add it to the current partition\\n                self.func(i+1, s, res, path) # call function recursively with the next index as the starting point\\n                path.pop() # backtrack to check for other partitions\\n\\n    # helper function that checks if a substring is a palindrome\\n    def isPalindrome(self, s, start, end):\\n        while start <= end: # iterate through the substring\\n            if s[start] != s[end]: # check if current characters are not equal\\n                return False # if they are not, return false\\n            start += 1\\n            end -= 1\\n        return True # if we reach this point, the substring is a palindrome\\n\\n```\\n```\\n                          Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful.\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // main function that takes in a string and returns all possible partitions of the string\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // vector to store all possible partitions\\n        vector<string> path; // vector to store current partition\\n        func(0, s, res, path); // call helper function to start recursion\\n        return res;\\n     }\\n\\n    // helper function that uses recursion to find all possible partitions\\n    void func(int ind, string s, vector<vector<string>>& res, vector<string>& path){\\n        if(ind == s.size()){ // base case: if we have reached the end of the string\\n            res.push_back(path); // add current partition to the result vector\\n            return ;\\n        }\\n        for(int i=ind;i<s.size();++i){ // iterate through all substrings starting from the current index\\n            if(isPalindrome(s, ind, i)){ // check if the current substring is a palindrome\\n                path.push_back(s.substr(ind, i-ind+1)); // if it is, add it to the current partition\\n                func(i+1, s, res, path); // call function recursively with the next index as the starting point\\n                path.pop_back(); // backtrack to check for other partitions\\n            }\\n        }\\n    }\\n\\n    // helper function that checks if a substring is a palindrome\\n    bool isPalindrome(string s, int start, int end){\\n        while(start<=end){ // iterate through the substring\\n            if(s[start++]!=s[end--]) // check if current characters are not equal\\n                return false; // if they are not, return false\\n        }\\n        return true; // if we reach this point, the substring is a palindrome\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = [] # vector to store all possible partitions\\n        path = [] # vector to store current partition\\n        self.func(0, s, res, path) # call helper function to start recursion\\n        return res\\n\\n    # helper function that uses recursion to find all possible partitions\\n    def func(self, ind, s, res, path):\\n        if ind == len(s): # base case: if we have reached the end of the string\\n            res.append(path[:]) # add current partition to the result vector\\n            return \\n        for i in range(ind, len(s)): # iterate through all substrings starting from the current index\\n            if self.isPalindrome(s, ind, i): # check if the current substring is a palindrome\\n                path.append(s[ind:i+1]) # if it is, add it to the current partition\\n                self.func(i+1, s, res, path) # call function recursively with the next index as the starting point\\n                path.pop() # backtrack to check for other partitions\\n\\n    # helper function that checks if a substring is a palindrome\\n    def isPalindrome(self, s, start, end):\\n        while start <= end: # iterate through the substring\\n            if s[start] != s[end]: # check if current characters are not equal\\n                return False # if they are not, return false\\n            start += 1\\n            end -= 1\\n        return True # if we reach this point, the substring is a palindrome\\n\\n```\n```\\n                          Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084227,
                "title": "c-simple-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply generate all the substrings using recursion and check if they are palindrome or not.If not Backtrack form there.Recursively traverse over the string like in dfs.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to keep track of the last partition index  and to iterate from that index to the end of the array to check whether we can form a palindrome substring or not. If we are able to find such a substring we use recursion to continue exploring . If we reach the end whole string it means we were able to partition the string into x number of palindromes. Save the result and backtrack to continue exploring.\\n# Complexity\\n- Time complexity:($$O(n*2^n)$$)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>>ans;\\n    bool isPalindrome(string& s,int i,int j){\\n    \\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n     \\n\\n    void generate(string& s,int start, vector<string>&temp){\\n          if(s.size()==start){\\n             ans.push_back(temp); \\n             return;\\n          }\\n\\n          for(int i=start;i<s.length();i++){\\n              if(isPalindrome(s,start,i)){\\n                  temp.push_back(s.substr(start,i-start+1));\\n                  generate(s,i+1,temp);\\n                  temp.pop_back();\\n              }\\n          }\\n          \\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string>temp;\\n        generate(s,0,temp);\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>>ans;\\n    bool isPalindrome(string& s,int i,int j){\\n    \\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n     \\n\\n    void generate(string& s,int start, vector<string>&temp){\\n          if(s.size()==start){\\n             ans.push_back(temp); \\n             return;\\n          }\\n\\n          for(int i=start;i<s.length();i++){\\n              if(isPalindrome(s,start,i)){\\n                  temp.push_back(s.substr(start,i-start+1));\\n                  generate(s,i+1,temp);\\n                  temp.pop_back();\\n              }\\n          }\\n          \\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string>temp;\\n        generate(s,0,temp);\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913154,
                "title": "recursive-solution-using-c-with-time-complexity-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019re dividing the string into substrings and checking if it\\u2019s palindrome or not.\\n- We\\u2019re storing all the palindromic substrings into a temp vector, using the help function to divide them into substrings.\\n- In our help function our base condition if the checking index is equal to string size, that means we are at last index, so simply push back temp to our ans vector.\\n- Else we\\u2019ll check palindrome for the rest of the string & take a loop, divide index by index and check for palindrome.\\n- If it\\u2019s a palindrome substring then we\\u2019ll push it to ans & then we\\u2019ll call again the help function for the rest.\\n- After the function returns we\\u2019ll pop back the element from temp, which means there is another substring that is not a palindrome.\\n- **Time complexity:** O(n*2^n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> temp;\\n        help(0, s, temp, ans);\\n        return ans;\\n    }\\n    \\n    void help(int index, string s, vector<string> &temp, vector<vector<string>> &ans){\\n        if(index == s.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(isPalindrome(s, index, i)){\\n                temp.push_back(s.substr(index, i-index+1));\\n                help(i+1, s, temp, ans);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end){\\n        while(start<=end){\\n            if(s[start++] != s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> temp;\\n        help(0, s, temp, ans);\\n        return ans;\\n    }\\n    \\n    void help(int index, string s, vector<string> &temp, vector<vector<string>> &ans){\\n        if(index == s.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(isPalindrome(s, index, i)){\\n                temp.push_back(s.substr(index, i-index+1));\\n                help(i+1, s, temp, ans);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end){\\n        while(start<=end){\\n            if(s[start++] != s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744058,
                "title": "must-see-simple-c-solution-detailed-explanation-how-to-link-problems",
                "content": "**Approach:  **\\nFirst thing that comes to everyone\\'s mind to:\\ngiven a string like: \\n\\ns=\"aba\"\\nIf I can print something this: \\n \\n(a)(b)(a)\\n(a)(ba)\\n(ab)(a)\\n(aba).\\n\\nThen, I will just check each bracket and if its a palidrome, I will add else not. \\n\\nI Approached the same Way: \\nFirst I wrote the code for this: \\n\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nvoid bt(string s, int pos, vector<string> comb){\\n        if(pos >= s.size()){\\n            for(auto x:comb) cout<<x;\\n            cout<<endl;\\n            return;\\n        }\\n        // Palindrome length == 1\\n        comb.push_back(\"(\");\\n        comb.push_back(s.substr(pos,1));\\n        comb.push_back(\")\");\\n        bt(s, pos + 1, comb);\\n        comb.pop_back();\\n        comb.pop_back();\\n        comb.pop_back();\\n        // Palindrome length > 1\\n        for(int step = 2; pos + step <= s.size(); step++){\\n                comb.push_back(\"(\");\\n                comb.push_back(s.substr(pos, step));\\n                comb.push_back(\")\");\\n                bt(s, pos + step, comb);\\n                comb.pop_back();\\n                comb.pop_back();\\n                comb.pop_back();\\n        }\\n    }\\nint main()\\n{\\n    string temp;\\n    vector<string>t;\\n    string s(\"aba\");\\n    bt(s,0,t);\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/ce898062-b969-477c-8871-2e9551a122f7_1595161362.6001675.png)\\n\\n\\nThen, I just a Line to this to check Palindrome or not and removed that brackets pushes and popes and we are done.\\n\\n\\n```\\n vector<vector<string>> partition(string s) {\\n        vector<vector<string>>res;\\n        backtrack(res,s,0,vector<string>());\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<string>>& res, string s, int pos, vector<string> comb){\\n        if(pos >= s.size()){\\n            res.push_back(comb);\\n            return;\\n        }\\n        // Palindrome length == 1\\n        comb.push_back(s.substr(pos,1));\\n        backtrack(res, s, pos + 1, comb);\\n        comb.pop_back();\\n        // Palindrome length > 1\\n        for(int step = 2; pos + step <= s.size(); step++){\\n          **  if(isPalindrome(s.substr(pos, step))){**     -------->>>>>>>>>>>ONLY CHANGE\\n                comb.push_back(s.substr(pos, step));\\n                backtrack(res, s, pos + step, comb);\\n                comb.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s){\\n        int i(0), j(s.size()-1);\\n        while(i < j) \\n            if(s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n```\\n\\n\\nPS: Implement from what you know. \\uD83D\\uDE0E\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nvoid bt(string s, int pos, vector<string> comb){\\n        if(pos >= s.size()){\\n            for(auto x:comb) cout<<x;\\n            cout<<endl;\\n            return;\\n        }\\n        // Palindrome length == 1\\n        comb.push_back(\"(\");\\n        comb.push_back(s.substr(pos,1));\\n        comb.push_back(\")\");\\n        bt(s, pos + 1, comb);\\n        comb.pop_back();\\n        comb.pop_back();\\n        comb.pop_back();\\n        // Palindrome length > 1\\n        for(int step = 2; pos + step <= s.size(); step++){\\n                comb.push_back(\"(\");\\n                comb.push_back(s.substr(pos, step));\\n                comb.push_back(\")\");\\n                bt(s, pos + step, comb);\\n                comb.pop_back();\\n                comb.pop_back();\\n                comb.pop_back();\\n        }\\n    }\\nint main()\\n{\\n    string temp;\\n    vector<string>t;\\n    string s(\"aba\");\\n    bt(s,0,t);\\n}\\n```\n```\\n vector<vector<string>> partition(string s) {\\n        vector<vector<string>>res;\\n        backtrack(res,s,0,vector<string>());\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<string>>& res, string s, int pos, vector<string> comb){\\n        if(pos >= s.size()){\\n            res.push_back(comb);\\n            return;\\n        }\\n        // Palindrome length == 1\\n        comb.push_back(s.substr(pos,1));\\n        backtrack(res, s, pos + 1, comb);\\n        comb.pop_back();\\n        // Palindrome length > 1\\n        for(int step = 2; pos + step <= s.size(); step++){\\n          **  if(isPalindrome(s.substr(pos, step))){**     -------->>>>>>>>>>>ONLY CHANGE\\n                comb.push_back(s.substr(pos, step));\\n                backtrack(res, s, pos + step, comb);\\n                comb.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s){\\n        int i(0), j(s.size()-1);\\n        while(i < j) \\n            if(s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 670391,
                "title": "javascript-clean-backtracking-beats-95",
                "content": "Time Complexity : O(N * 2^(N-1))\\nSpace Complexity: O(2^(N-1))\\n```javascript\\nvar partition = function(s) {\\n    \\n    function isPalindrome(str) {\\n        let left = 0, right = str.length-1;\\n        \\n        while(left < right) {\\n            if(str[left] !== str[right]) return false\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    \\n    const result = [];\\n    \\n    function permute(arr, str) {\\n        if(!str.length) result.push(arr);\\n        \\n        for(let i = 1; i <= str.length; i++) {\\n            const subStr = str.slice(0, i);\\n            if(isPalindrome(subStr)) {\\n                permute([...arr, subStr], str.slice(i));\\n            }\\n        }\\n    }\\n    permute([], s);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar partition = function(s) {\\n    \\n    function isPalindrome(str) {\\n        let left = 0, right = str.length-1;\\n        \\n        while(left < right) {\\n            if(str[left] !== str[right]) return false\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    \\n    const result = [];\\n    \\n    function permute(arr, str) {\\n        if(!str.length) result.push(arr);\\n        \\n        for(let i = 1; i <= str.length; i++) {\\n            const subStr = str.slice(0, i);\\n            if(isPalindrome(subStr)) {\\n                permute([...arr, subStr], str.slice(i));\\n            }\\n        }\\n    }\\n    permute([], s);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289392,
                "title": "js-beating-100-with-explanation",
                "content": "``` javascript\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nlet partition = function(s) {\\n  let res = []\\n  let plds = []\\n  helper(s, 0, plds, res)\\n  return res\\n}\\n\\nlet helper = (s, start, plds, res) => {\\n//goal\\n  if (start === s.length) {\\n    res.push(plds.concat())\\n  }\\n  for (let i = start; i < s.length; i++) {\\n  //constraint\\n    if (isPalindrome(s.substring(start, i + 1))) {\\n      plds.push(s.substring(start, i + 1))\\n\\t  //choices\\n      helper(s, i + 1, plds, res)\\n      plds.pop()\\n    }\\n  }\\n}\\n\\nlet isPalindrome = (s) => {\\n  let l = 0\\n  let r = s.length - 1\\n  while (r > l) {\\n    if (s[l] !== s[r]) {\\n      return false\\n    }\\n    l++\\n    r--\\n  }\\n  return true\\n}\\n```\\n\\nFor backtracking problems, there are always three elements\\n1. choice (decision)\\n2. goal\\n3. constraint\\n\\nIn this problem, we need return all possible palindrome partitioning of s.\\nSo, we  need to check all the combinations of substrings of s.\\n\\nThe `choice` can be assumed as how to partition s, so we can get the substring by\\n`s.substring(start, i + 1)` where `start` is the start index of the substring, `i` is the end index of the substring. Each level of the choice can be expanded to the length of s, so we got the `for` loop.\\nThe start index of next substring (choice) can be assumed as `i + 1`.\\n\\nIf the substring is not palindrome, we should stop exploring the choices. This is `constraint`.\\n\\nIf the `start` index equals to the length of s, we meet our `goal`. which means all the choices(substrings) we expolres so far is palindrome.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "``` javascript\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nlet partition = function(s) {\\n  let res = []\\n  let plds = []\\n  helper(s, 0, plds, res)\\n  return res\\n}\\n\\nlet helper = (s, start, plds, res) => {\\n//goal\\n  if (start === s.length) {\\n    res.push(plds.concat())\\n  }\\n  for (let i = start; i < s.length; i++) {\\n  //constraint\\n    if (isPalindrome(s.substring(start, i + 1))) {\\n      plds.push(s.substring(start, i + 1))\\n\\t  //choices\\n      helper(s, i + 1, plds, res)\\n      plds.pop()\\n    }\\n  }\\n}\\n\\nlet isPalindrome = (s) => {\\n  let l = 0\\n  let r = s.length - 1\\n  while (r > l) {\\n    if (s[l] !== s[r]) {\\n      return false\\n    }\\n    l++\\n    r--\\n  }\\n  return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42134,
                "title": "my-c-solution-13ms-backtracking",
                "content": "    class Solution {\\n    public:\\n        void palPart (vector<vector<string>> &ans,vector<string> &temp,string s,int j){\\n            if(s.size()==0)\\n                return;\\n            //\\u7279\\u6b8a\\u8f93\\u5165\\n            if(j>s.size()-1){\\n            ans.push_back(temp);\\n            return;\\n            }\\n            //\\u8fb9\\u754c\\u6761\\u4ef6\\uff0c\\u5f88\\u91cd\\u8981\\n            int m,n,l;\\n            \\n            for(m=s.size()-1;m>=j;m--){\\n                l=j;\\n                n=m;\\n                \\n                while(l<n&&s[l]==s[n]){\\n                    \\n                    l++;\\n                    n--;\\n                    \\n                }//\\u5224\\u65ads(j,m)\\u662f\\u4e0d\\u662f\\u56de\\u6587\\n                if(l>=n){\\n                    \\n                    temp.push_back(s.substr(j,m-j+1));//\\u5b50\\u4e32\\u5165\\u6808\\n                    \\n                    palPart(ans,temp,s,m+1);//\\u904d\\u5386\\n                    \\n                    temp.pop_back();//\\u904d\\u5386\\u5b8c\\u6bd5\\uff0c\\u5b50\\u4e32\\u51fa\\u6808\\n                }\\n            }\\n        }\\n    \\n        vector<vector<string>> partition(string s) {\\n        vector<vector<string> >  ans;\\n        vector<string> temp;\\n        palPart (ans,temp,s,0);\\n        return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void palPart (vector<vector<string>> &ans,vector<string> &temp,string s,int j){\\n            if(s.size()==0)\\n                return;\\n            //\\u7279\\u6b8a\\u8f93\\u5165\\n            if(j>s.size()-1){\\n            ans.push_back(temp);\\n            return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 42136,
                "title": "concise-java-solution",
                "content": "DFS to find every combinations of the string, if the substring is not Palindrome, ignore it then go to the next.\\n\\n    public class Solution {\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        public List<List<String>> partition(String s) {\\n            helper(s, new ArrayList<String>());\\n            return result;\\n        }        \\n        \\n        public void helper(String s, List<String> cur){                 //DFS every combinations\\n            if(s.length() == 0){result.add(cur); return;}        \\n            for(int i = 1; i <= s.length(); i++){\\n                String sub = s.substring(0,i);\\n                if(isPal(sub)){\\n                    List<String> newList = new ArrayList<String>(cur);\\n                    newList.add(sub);\\n                    helper(s.substring(i,s.length()), newList);\\n                }\\n                else continue;                                    //not palindrome, ignore it\\n            }        \\n        }                \\n        \\n        public boolean isPal(String str){\\n            int l = 0;\\n            int r = str.length()-1;\\n            while(l <= r){\\n                if(str.charAt(l) != str.charAt(r))  return false;\\n                l++;r--;\\n            }\\n            return true;\\n        }\\n    } \\n\\n\\nnote: I found some people using the same method of mine, but they like to call their methods \"backtracking\", it is actually DFS, note backtracking.",
                "solutionTags": [],
                "code": "class Solution {\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        public List<List<String>> partition(String s) {\\n            helper(s, new ArrayList<String>());\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2213062,
                "title": "c-palindrome-partitioning-all-variations",
                "content": "**Do Upvote if it helps :-)**\\n\\n**MUST CHECK->**\\n**Best Time to Buy and Sell Stock All Variations\\uD83D\\uDC49**[Click Me](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/2237933/C%2B%2B-Best-Time-to-Buy-and-Sell-Stock-All-Variations-Recursion%2BMemoization)\\n\\n[131. Palindrome Partitioning I](https://leetcode.com/problems/palindrome-partitioning/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<string>>ans;\\n\\t\\tbool isPali(string s,int l,int r){\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tif(s[l]!=s[r]){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tl++;\\n\\t\\t\\t\\tr--;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid check(int ind,string &s,vector<string> &cur){\\n\\t\\t\\tif(ind==s.size()){\\n\\t\\t\\t\\tans.push_back(cur);\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=ind;i<s.size();i++){\\n\\t\\t\\t\\tif(isPali(s,ind,i)){\\n\\t\\t\\t\\t\\tcur.push_back(s.substr(ind,i-ind+1));\\n\\t\\t\\t\\t\\tcheck(i+1,s,cur);\\n\\t\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<string>> partition(string s) {\\n\\t\\t\\tvector<string>cur;\\n\\t\\t\\tcheck(0,s,cur);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n[132. Palindrome Partitioning II](https://leetcode.com/problems/palindrome-partitioning-ii/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> dp;\\n\\t\\tint isPali(string &s,int l,int r){\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tif(s[l++]!=s[r--]) return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tint solve(string &s,int pos,int n){\\n\\t\\t\\tif(pos>=n  || isPali(s,pos,n)) return 0;\\n\\t\\t\\tif(dp[pos]!=-1) return dp[pos];\\n\\t\\t\\tint ans=0,tmp=INT_MAX;\\n\\t\\t\\tfor(int i=pos;i<n;i++){\\n\\t\\t\\t\\tif(isPali(s,pos,i)){\\n\\t\\t\\t\\t\\tans=1+solve(s,i+1,n);\\n\\t\\t\\t\\t\\ttmp=min(tmp,ans);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[pos] = tmp;\\n\\t\\t}\\n\\t\\tint minCut(string s) {\\n\\t\\t\\tdp.assign(s.size(),-1);\\n\\t\\t\\treturn solve(s,0,s.size())-1;\\n\\t\\t}\\n\\t};\\n\\t\\n[1278. Palindrome Partitioning III](https://leetcode.com/problems/palindrome-partitioning-iii/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> cost;\\n\\t\\tint costFun(string &s,int l,int r){\\n\\t\\t\\tif(l>=r) return 0;\\n\\t\\t\\tif(cost[l][r]!=-1) return cost[l][r];\\n\\t\\t\\treturn cost[l][r] = (s[l]!=s[r]) + costFun(s,l+1,r-1);\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>>dp;\\n\\t\\tint solve(string &s,int k,int pos,int n){\\n\\t\\t\\tif(k==0) return costFun(s,pos,n-1);\\n\\t\\t\\tif(pos>=n) return INT_MAX;\\n\\t\\t\\tif(dp[pos][k]!=-1) return dp[pos][k];\\n\\t\\t\\tint ans=1e6;\\n\\t\\t\\tfor(int i=pos;i<n-1;i++){\\n\\t\\t\\t\\tans=min(ans,costFun(s,pos,i)+solve(s,k-1,i+1,n));\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[pos][k] = ans;\\n\\t\\t}\\n\\t\\tint palindromePartition(string s, int k) {\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tcost.assign(n,vector<int>(n,-1));\\n\\t\\t\\tdp.assign(n,vector<int>(k+1,-1));\\n\\t\\t\\treturn solve(s,k-1,0,n);\\n\\t\\t}\\n\\t};\\n\\t\\n[1745. Palindrome Partitioning IV](https://leetcode.com/problems/palindrome-partitioning-iv/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> dp;\\n\\t\\tvector<vector<int>> pali;\\n\\t\\tint isPali(string &s,int l,int r){\\n\\t\\t\\tif(l>=r) return 1;\\n\\t\\t\\tif(pali[l][r]!=-1) return pali[l][r];\\n\\t\\t\\tif(s[l]==s[r]) return pali[l][r] = isPali(s,l+1,r-1);\\n\\t\\t\\treturn pali[l][r] = 0;\\n\\t\\t}\\n\\n\\t\\tbool checkPartitioning(string s) {\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tpali.assign(n,vector<int>(n,-1));\\n\\t\\t\\tfor(int i=1;i<n-1;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=i;j++){\\n\\t\\t\\t\\t\\tif(isPali(s,0,j-1) && isPali(s,j,i) && isPali(s,i+1,n-1)) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<string>>ans;\\n\\t\\tbool isPali(string s,int l,int r){\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tif(s[l]!=s[r]){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 805513,
                "title": "c-solution-using-backtracking-and-mcm-concepts-12ms-93-faster",
                "content": "```\\nvector<vector<string>> ans;\\nint n;\\nstring s;\\nbool isPalin(int i,int j)// check for palindrome\\n{\\n    while(i<j)\\n    {\\n        if(s[i]!=s[j])return 0;\\n        i++;j--;\\n    }\\n    return 1;\\n}\\nvoid palinParti(vector<string>& cur,int start)\\n{\\n    if(start==n){ans.push_back(cur);return;} // base case\\n    \\n        for(int i=start;i<n;i++)\\n        {\\n            if(isPalin(start,i))\\n            {\\n                cur.push_back(s.substr(start,i-start+1));// push the current substring on to the vector.\\n                \\n                palinParti(cur,i+1); // typical MCM(Matrix-Chain-Multiplication) based approach\\n                \\n                cur.pop_back(); // back-track for next substring from (start to i)\\n            }\\n        }\\n}\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string S)\\n    {s=S;\\n      n=s.length();\\n      ans.clear();\\n      vector<string> cur;\\n     \\n     palinParti(cur,0);\\n     \\n     return ans;\\n    }\\n};\\n//For better explannation refer this video. [https://www.youtube.com/watch?v=szKVpQtBHh8](http://)",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<string>> partition(string S)\\n    {s=S;\\n      n=s.length();\\n      ans.clear();\\n      vector<string> cur;\\n     \\n     palinParti(cur,0);\\n     \\n     return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 777877,
                "title": "python-easy-simple-dfs-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        ans = []\\n\\n        def dfs(currList, k):\\n            if k == len(s):\\n                ans.append(currList)\\n                return\\n\\n            for i in range(k, len(s)):\\n                tmpStr = s[k:i + 1]\\n                if tmpStr == tmpStr[::-1]:\\n                    dfs(currList + [tmpStr], i + 1)\\n\\n        dfs([], 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        ans = []\\n\\n        def dfs(currList, k):\\n            if k == len(s):\\n                ans.append(currList)\\n                return\\n\\n            for i in range(k, len(s)):\\n                tmpStr = s[k:i + 1]\\n                if tmpStr == tmpStr[::-1]:\\n                    dfs(currList + [tmpStr], i + 1)\\n\\n        dfs([], 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42103,
                "title": "simple-backtracking-java-solution-with-95-performance",
                "content": "    public class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            if (s.equals(\"\")) {\\n                res.add(new ArrayList<String>());\\n                return res;\\n            }\\n            for (int i = 0; i < s.length(); i++) {\\n                if (isPalindrome(s, i + 1)) {\\n                    for (List<String> list : partition(s.substring(i+1))) {\\n                        list.add(0, s.substring(0, i + 1));\\n                        res.add(list);\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n        \\n        public boolean isPalindrome(String s, int n) {\\n            for (int i = 0; i < n / 2; i++) {\\n                if (s.charAt(i) != s.charAt(n - i - 1))\\n                    return false;\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            if (s.equals(\"\")) {\\n                res.add(new ArrayList<String>());\\n                return res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3084574,
                "title": "c-java-recursion-deep-dive-explanation",
                "content": "# Approach\\nFor every position of string we have two choices, either to put a partion over there or not, if we put the partition we are supposed to caheck if all our partitions are **palindromes** or not.\\nRecursion is an obivous choice to find all the partitions possible.\\n\\n*Palindome : a word that is the same when read forwards or backwards.*\\n\\n# Code Explanation\\n\\n***Helper function palind(string s)*** : \\nthat checks whether a given string s is a palindrome. It does this by creating a copy of the string s, reversing it and comparing it with the original string. If they are the same, it returns true, otherwise it returns false.\\n\\n***Helper function call(int ind,vector<vector<string>>& ans,vector<string>& vec,string s)*** :\\nrecursive function to find all possible partitions of the string s into palindromes.\\n\\nThis function takes four parameters:\\n\\n1. **Integer ind** representing the current index in the string s being processed.\\n2. A reference to a **vector of vectors of strings ans** to store all the partitions.\\n3. A reference to a **vector of strings vec** to store the current partition being processed.\\n4. A **string s** representing the original string to be partitioned.\\n\\n**BASE CASE:**\\n1. The function checks current index ind is equal to the size of the string s. If it is, it pushes the current partition stored in the vec to the ans and return.\\n\\nIt starts a for loop from the current index ind to the end of the string s, and for each substring from ind to i, it checks if the substring is a palindrome using the helper function palind(string s).\\n\\nIf the substring is a palindrome, it pushes the substring to the vec and calls the helper function recursively with updated index i+1 and vec. After the recursive call, it pops the last element from the vec to restore the vec to its previous state and try next substring.\\n\\nIt continues this process until all possible partitions have been found and stored in the ans vector. Finally, it returns the ans vector.\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\n    bool palind(string s)\\n    {\\n        string a=s;\\n        reverse(a.begin(),a.end());\\n        if (a==s) return true;\\n        else return false;\\n    }\\n    \\n    void call(int ind,vector<vector<string>>& ans,vector<string>& vec,string s)\\n    {\\n        if (ind==s.size())\\n        {\\n            ans.push_back(vec);\\n        }\\n        \\n        for (int i=ind;i<s.size();i++)\\n        {\\n            if (palind(s.substr(ind,i-ind+1)))\\n            {\\n                vec.push_back(s.substr(ind,i-ind+1));\\n                call(i+1,ans,vec,s);\\n                vec.pop_back();\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> vec;\\n        call(0,ans,vec,s);\\n        return ans;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    boolean palind(String s) {\\n        String a = new StringBuilder(s).reverse().toString();\\n        if (a.equals(s)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    void call(int ind, List<List<String>> ans, List<String> vec, String s) {\\n        if (ind == s.length()) {\\n            ans.add(new ArrayList<String>(vec));\\n        }\\n        \\n        for (int i = ind; i < s.length(); i++) {\\n            if (palind(s.substring(ind, i + 1))) {\\n                vec.add(s.substring(ind, i + 1));\\n                call(i + 1, ans, vec, s);\\n                vec.remove(vec.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        List<String> vec = new ArrayList<String>();\\n        call(0, ans, vec, s);\\n        return ans;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\nO((2^n*n) : The reason for this is that the function \\'call\\' is called recursively for each possible substring of \\'s\\' and the function \\'palind\\' is called for each substring to check if it is a palindrome. \\n\\n- Space complexity:\\nO(n^2) : the function \\'call\\' is using a recursive call stack and the function \\'palind\\' is creating a copy of the input string for each call. Additionally, the \\'ans\\' and \\'vec\\' vectors are also using O(n^2) space in the worst case.\\n.\\n.\\n.\\n*DO UPVOTE IF THIS HELPED :)*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    bool palind(string s)\\n    {\\n        string a=s;\\n        reverse(a.begin(),a.end());\\n        if (a==s) return true;\\n        else return false;\\n    }\\n    \\n    void call(int ind,vector<vector<string>>& ans,vector<string>& vec,string s)\\n    {\\n        if (ind==s.size())\\n        {\\n            ans.push_back(vec);\\n        }\\n        \\n        for (int i=ind;i<s.size();i++)\\n        {\\n            if (palind(s.substr(ind,i-ind+1)))\\n            {\\n                vec.push_back(s.substr(ind,i-ind+1));\\n                call(i+1,ans,vec,s);\\n                vec.pop_back();\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> vec;\\n        call(0,ans,vec,s);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    boolean palind(String s) {\\n        String a = new StringBuilder(s).reverse().toString();\\n        if (a.equals(s)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    void call(int ind, List<List<String>> ans, List<String> vec, String s) {\\n        if (ind == s.length()) {\\n            ans.add(new ArrayList<String>(vec));\\n        }\\n        \\n        for (int i = ind; i < s.length(); i++) {\\n            if (palind(s.substring(ind, i + 1))) {\\n                vec.add(s.substring(ind, i + 1));\\n                call(i + 1, ans, vec, s);\\n                vec.remove(vec.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        List<String> vec = new ArrayList<String>();\\n        call(0, ans, vec, s);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668997,
                "title": "beats-100-in-time-and-99-97-in-memory-4ms-solution",
                "content": "![image](https://assets.leetcode.com/users/images/a6671596-c281-458c-a1f5-64cb89039273_1641400322.9022577.png)\\n```class Solution {\\n        boolean dp[][];//global array for finding whether the String is palindromic or not\\n        String str_arr[][];\\n        List < List < String >> rv;//return value\\n        int len;\\n        ArrayList<String> helper;\\n\\n        public void fill_palindromic_arr(String str) {\\n            len = str.length();\\n            dp = new boolean[len][len];\\n            str_arr = new String[len][len];\\n\\t\\t\\t\\n            for (int i = 0; i < len; i++) {\\n                dp[i][i] = true;\\n            }\\n            for (int i = 0; i < len - 1; i++) {\\n                dp[i][i + 1] = str.charAt(i) == str.charAt(i + 1);\\n            }\\n            for (int g = 2; g < len; g++) {\\n                for (int si = 0; si < len; si++) {\\n                    int ei = si + g;\\n                    if (ei < len && str.charAt(si) == str.charAt(ei)) {\\n                        dp[si][ei] |= dp[si + 1][ei - 1];\\n                    }\\n                }\\n            }\\n\\t\\t\\t//creating and storing only the palindromic substring\\n\\t\\t\\t// do not create each and every substring otherwise exactly O(N*N*N) time will be taken even for the best case\\n\\t\\t\\t//for example when length is 16 and all characters are unique in case only 16 palindromic strings need to be created\\n\\t\\t\\t//whereas if we create all the strings steps taken would be N*N for number of substrings and N for creation of each substring\\n\\t\\t\\t//i.e 16*16*16 along with that it will also strain java internpool for maintaining so many strings\\n\\t\\t\\t//also there would be lot of garbage for the garbage collector to collect\\n\\t\\t\\t// check https://en.wikipedia.org/wiki/String_interning\\n\\t\\t\\t\\n            for (int si = 0; si < len; si++) {\\n                for (int ei = si; ei < len; ei++) {\\n                    if(dp[si][ei])\\n                    str_arr[si][ei] = str.substring(si, ei + 1);\\n                }\\n            }\\n        }\\n\\n        public List<List<String>> partition(String s) {\\n            rv = new ArrayList<>();\\n            fill_palindromic_arr(s);\\n            helper = new ArrayList<String>(len);\\n            fill(0);\\n            return rv;\\n        }\\n\\n        public void fill(int si) {\\n            // this function is supposed to fill the complete List for string defined from si\\n            if (si >= len) {\\n\\t\\t\\t\\t//base case\\n                rv.add(new ArrayList<String>(helper));\\n                return;\\n            }\\n            for (int ei = si; ei < len; ei++) {\\n                if (dp[si][ei]) {\\n                    // the string was a palindrome\\n\\t\\t\\t\\t\\t//consume the palindrome equivalent to doing work for own\\n                    helper.add(str_arr[si][ei]);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//having faith on recursion that it will work for the subquery\\n                    fill(ei + 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//clearing the arraylist for another call\\n\\t\\t\\t\\t\\t//this string has been explored and used, now it can not be used\\n\\t\\t\\t\\t\\t//because when we return from stack trace at that time our helper\\n\\t\\t\\t\\t\\t//arraylist should not have plaindromes from index beyond its call\\n                    helper.remove(helper.size()-1);\\n                }\\n            }\\n        }\\n    }\\n```\\nPoints to be focused\\n1 ) Instead of creating string each and every time we can simply pass a refrence of it, in the above code see the usage of String str_arr[][]\\nAlso notice that only palindromic substrings were filled\\n2 ) Initialized the size of the arraylist of string to the s.length() in order to avoid its resizing\\n3 ) used bottom up dp(tabulation) for checking whether the string is a palindrome or not\\n\\nMotivation Point :  See your solution in an unclickable area",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```class Solution {\\n        boolean dp[][];//global array for finding whether the String is palindromic or not\\n        String str_arr[][];\\n        List < List < String >> rv;//return value\\n        int len;\\n        ArrayList<String> helper;\\n\\n        public void fill_palindromic_arr(String str) {\\n            len = str.length();\\n            dp = new boolean[len][len];\\n            str_arr = new String[len][len];\\n\\t\\t\\t\\n            for (int i = 0; i < len; i++) {\\n                dp[i][i] = true;\\n            }\\n            for (int i = 0; i < len - 1; i++) {\\n                dp[i][i + 1] = str.charAt(i) == str.charAt(i + 1);\\n            }\\n            for (int g = 2; g < len; g++) {\\n                for (int si = 0; si < len; si++) {\\n                    int ei = si + g;\\n                    if (ei < len && str.charAt(si) == str.charAt(ei)) {\\n                        dp[si][ei] |= dp[si + 1][ei - 1];\\n                    }\\n                }\\n            }\\n\\t\\t\\t//creating and storing only the palindromic substring\\n\\t\\t\\t// do not create each and every substring otherwise exactly O(N*N*N) time will be taken even for the best case\\n\\t\\t\\t//for example when length is 16 and all characters are unique in case only 16 palindromic strings need to be created\\n\\t\\t\\t//whereas if we create all the strings steps taken would be N*N for number of substrings and N for creation of each substring\\n\\t\\t\\t//i.e 16*16*16 along with that it will also strain java internpool for maintaining so many strings\\n\\t\\t\\t//also there would be lot of garbage for the garbage collector to collect\\n\\t\\t\\t// check https://en.wikipedia.org/wiki/String_interning\\n\\t\\t\\t\\n            for (int si = 0; si < len; si++) {\\n                for (int ei = si; ei < len; ei++) {\\n                    if(dp[si][ei])\\n                    str_arr[si][ei] = str.substring(si, ei + 1);\\n                }\\n            }\\n        }\\n\\n        public List<List<String>> partition(String s) {\\n            rv = new ArrayList<>();\\n            fill_palindromic_arr(s);\\n            helper = new ArrayList<String>(len);\\n            fill(0);\\n            return rv;\\n        }\\n\\n        public void fill(int si) {\\n            // this function is supposed to fill the complete List for string defined from si\\n            if (si >= len) {\\n\\t\\t\\t\\t//base case\\n                rv.add(new ArrayList<String>(helper));\\n                return;\\n            }\\n            for (int ei = si; ei < len; ei++) {\\n                if (dp[si][ei]) {\\n                    // the string was a palindrome\\n\\t\\t\\t\\t\\t//consume the palindrome equivalent to doing work for own\\n                    helper.add(str_arr[si][ei]);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//having faith on recursion that it will work for the subquery\\n                    fill(ei + 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//clearing the arraylist for another call\\n\\t\\t\\t\\t\\t//this string has been explored and used, now it can not be used\\n\\t\\t\\t\\t\\t//because when we return from stack trace at that time our helper\\n\\t\\t\\t\\t\\t//arraylist should not have plaindromes from index beyond its call\\n                    helper.remove(helper.size()-1);\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668300,
                "title": "c-simple-and-clean-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // Helper function to check if a certain substring is a palindrome\\n    bool isSubstringPal(int start, int end) {\\n        while (start < end) {\\n            if (str[start] != str[end])\\n                return false;\\n            start++; end--;\\n        }\\n        return true;\\n    }\\n    \\n    // The helper function is a recursive function for backtracking\\n    void backtrack(int start, vector<string> curr) {\\n        if (start >= str.size())\\n            res.push_back(curr);\\n            \\n        int end = start;\\n        while (end < str.size()) {\\n            if (isSubstringPal(start, end)) {\\n                curr.push_back(str.substr(start, end-start+1));\\n                backtrack(end+1, curr);\\n                curr.pop_back();\\n            }\\n            end++;\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        str = s;\\n        backtrack(0, {});\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<vector<string>> res;\\n    string str;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to check if a certain substring is a palindrome\\n    bool isSubstringPal(int start, int end) {\\n        while (start < end) {\\n            if (str[start] != str[end])\\n                return false;\\n            start++; end--;\\n        }\\n        return true;\\n    }\\n    \\n    // The helper function is a recursive function for backtracking\\n    void backtrack(int start, vector<string> curr) {\\n        if (start >= str.size())\\n            res.push_back(curr);\\n            \\n        int end = start;\\n        while (end < str.size()) {\\n            if (isSubstringPal(start, end)) {\\n                curr.push_back(str.substr(start, end-start+1));\\n                backtrack(end+1, curr);\\n                curr.pop_back();\\n            }\\n            end++;\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        str = s;\\n        backtrack(0, {});\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<vector<string>> res;\\n    string str;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41995,
                "title": "swift-solution-backtracking",
                "content": "```\\nclass Solution {\\n    func partition(_ s: String) -> [[String]] {\\n        var result = [[String]]()\\n        var candidate = [String]()\\n        \\n        backtracking(&result, &candidate, Array(s.characters), 0)\\n        \\n        return result\\n    }\\n    \\n    private func backtracking(_ result: inout [[String]], _ candidate: inout [String], _ characters: [Character], _ start: Int) {\\n        if start == characters.count {\\n            result.append(candidate)\\n        } else {\\n            for i in start..<characters.count {\\n                if isPalindrome(characters, start, i) {\\n                    let character = String(characters[start...i])\\n                    candidate.append(character)\\n                    backtracking(&result, &candidate, characters, i + 1)\\n                    candidate.removeLast()\\n                }\\n            }\\n        }\\n    }\\n    \\n    private func isPalindrome(_ characters: [Character], _ low: Int, _ high: Int) -> Bool {\\n        var low = low\\n        var high = high\\n        \\n        while low < high {\\n            if characters[low] != characters[high] {\\n                return false\\n            }\\n            low += 1\\n            high -= 1\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func partition(_ s: String) -> [[String]] {\\n        var result = [[String]]()\\n        var candidate = [String]()\\n        \\n        backtracking(&result, &candidate, Array(s.characters), 0)\\n        \\n        return result\\n    }\\n    \\n    private func backtracking(_ result: inout [[String]], _ candidate: inout [String], _ characters: [Character], _ start: Int) {\\n        if start == characters.count {\\n            result.append(candidate)\\n        } else {\\n            for i in start..<characters.count {\\n                if isPalindrome(characters, start, i) {\\n                    let character = String(characters[start...i])\\n                    candidate.append(character)\\n                    backtracking(&result, &candidate, characters, i + 1)\\n                    candidate.removeLast()\\n                }\\n            }\\n        }\\n    }\\n    \\n    private func isPalindrome(_ characters: [Character], _ low: Int, _ high: Int) -> Bool {\\n        var low = low\\n        var high = high\\n        \\n        while low < high {\\n            if characters[low] != characters[high] {\\n                return false\\n            }\\n            low += 1\\n            high -= 1\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42158,
                "title": "shouldn-t-we-use-dp-in-addition-to-dfs",
                "content": "I understand this problem can be solved easily with DFS. The basic idea is that for each palindromic prefix, recursively obtain the palindrome partitioning of the remaining substring. As far as I am concerned, this is, to say the least,  an O(2^N) algorithm in the worst case (e.g., for strings like \"aaaaa\") since there are 2^N partitions.\\n\\nHowever, in most implementations I saw online, people use an O(N) function to compute if each prefix is a palindrome, as in the following code, which can be found [Here][1]\\n\\n    public ArrayList<ArrayList<String>> partition(String s) {\\n\\tArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();\\n \\n\\tif (s == null || s.length() == 0) {\\n\\t\\treturn result;\\n\\t}\\n \\n\\tArrayList<String> partition = new ArrayList<String>();\\n\\taddPalindrome(s, 0, partition, result);\\n \\n\\treturn result;\\n    }\\n \\n    private void addPalindrome(String s, int start, ArrayList<String> partition,\\n\\t\\tArrayList<ArrayList<String>> result) {\\n\\t//stop condition\\n\\tif (start == s.length()) {\\n\\t\\tArrayList<String> temp = new ArrayList<String>(partition);\\n\\t\\tresult.add(temp);\\n\\t\\treturn;\\n\\t}\\n \\n\\tfor (int i = start + 1; i <= s.length(); i++) {\\n\\t\\tString str = s.substring(start, i);\\n\\t\\tif (isPalindrome(str)) {\\n\\t\\t\\tpartition.add(str);\\n\\t\\t\\taddPalindrome(s, i, partition, result);\\n\\t\\t\\tpartition.remove(partition.size() - 1);\\n\\t\\t}\\n\\t}\\n    }\\n \\n    private boolean isPalindrome(String str) {\\n\\tint left = 0;\\n\\tint right = str.length() - 1;\\n \\n\\twhile (left < right) {\\n\\t\\tif (str.charAt(left) != str.charAt(right)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n \\n\\t\\tleft++;\\n\\t\\tright--;\\n\\t}\\n \\n\\treturn true;\\n    }\\n\\nSince this function \"isPalindrome\" needs to be called once for every prefix, that would make the overall time complexity O(N * 2^N).\\n\\nSo my questions is: why don't we first use DP to find out if each substring is palindromic, which takes O(N^2) time and space? This would be nothing compared to the O(2^N) possible partitions, but saves us the need to call the O(N) isPalindrome function, thus brings down the overall time complexity to O(2^N) from O(N * 2^N). \\n\\nI would really appreciate it if someone could point out if my reasoning is correct or not. Thank you!\\n\\n  [1]: http://www.programcreek.com/2013/03/leetcode-palindrome-partitioning-java/",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "I understand this problem can be solved easily with DFS. The basic idea is that for each palindromic prefix, recursively obtain the palindrome partitioning of the remaining substring. As far as I am concerned, this is, to say the least,  an O(2^N) algorithm in the worst case (e.g., for strings like \"aaaaa\") since there are 2^N partitions.\\n\\nHowever, in most implementations I saw online, people use an O(N) function to compute if each prefix is a palindrome, as in the following code, which can be found [Here][1]\\n\\n    public ArrayList<ArrayList<String>> partition(String s) {\\n\\tArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();\\n \\n\\tif (s == null || s.length() == 0) {\\n\\t\\treturn result;\\n\\t}\\n \\n\\tArrayList<String> partition = new ArrayList<String>();\\n\\taddPalindrome(s, 0, partition, result);\\n \\n\\treturn result;\\n    }\\n \\n    private void addPalindrome(String s, int start, ArrayList<String> partition,\\n\\t\\tArrayList<ArrayList<String>> result) {\\n\\t//stop condition\\n\\tif (start == s.length()) {\\n\\t\\tArrayList<String> temp = new ArrayList<String>(partition);\\n\\t\\tresult.add(temp);\\n\\t\\treturn;\\n\\t}\\n \\n\\tfor (int i = start + 1; i <= s.length(); i++) {\\n\\t\\tString str = s.substring(start, i);\\n\\t\\tif (isPalindrome(str)) {\\n\\t\\t\\tpartition.add(str);\\n\\t\\t\\taddPalindrome(s, i, partition, result);\\n\\t\\t\\tpartition.remove(partition.size() - 1);\\n\\t\\t}\\n\\t}\\n    }\\n \\n    private boolean isPalindrome(String str) {\\n\\tint left = 0;\\n\\tint right = str.length() - 1;\\n \\n\\twhile (left < right) {\\n\\t\\tif (str.charAt(left) != str.charAt(right)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n \\n\\t\\tleft++;\\n\\t\\tright--;\\n\\t}\\n \\n\\treturn true;\\n    }\\n\\nSince this function \"isPalindrome\" needs to be called once for every prefix, that would make the overall time complexity O(N * 2^N).\\n\\nSo my questions is: why don't we first use DP to find out if each substring is palindromic, which takes O(N^2) time and space? This would be nothing compared to the O(2^N) possible partitions, but saves us the need to call the O(N) isPalindrome function, thus brings down the overall time complexity to O(2^N) from O(N * 2^N). \\n\\nI would really appreciate it if someone could point out if my reasoning is correct or not. Thank you!\\n\\n  [1]: http://www.programcreek.com/2013/03/leetcode-palindrome-partitioning-java/",
                "codeTag": "Unknown"
            },
            {
                "id": 3084373,
                "title": "java-beats-99-backtracking",
                "content": "# Intuition\\nWe are asked to return all the permutations matching the problem conditions, hence we are talking about backtracking. One can also look at the constraints and see that they are really small, so backtracking is a viable solution.\\n\\nThe idea is to keep track of the last partition index (the end index of the last substring) and to iterate from that index to the end of the array checking whether we can form a palindrome substring. If we are able to find such a substring we use recursion to continue exploring our search space. If we exhaust the whole string it means we were able to partition the string into `x` number of palindromes. Save the result and backtrack to continue exploring.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<String>> res = new ArrayList<>();\\n    \\n    public List<List<String>> partition(String s) {\\n        backtrack(0, s, new ArrayList<>());\\n        return res;\\n    }\\n\\n    private void backtrack(int i, String s, ArrayList<String> substrings) {\\n        // base case\\n        if(i == s.length()) {\\n            res.add(new ArrayList<>(substrings));\\n            return;\\n        }\\n        \\n        for(int j = i; j < s.length(); j++) {\\n            String sub = s.substring(i, j + 1);\\n            if(isPalindrome(sub)) {\\n                substrings.add(sub);\\n                backtrack(j + 1, s, substrings);\\n                substrings.remove(substrings.size() - 1);\\n            }\\n        }\\n        \\n    }\\n\\n    private boolean isPalindrome(String s) {\\n        for(int i = 0; i < s.length() / 2; i++) {\\n            if(s.charAt(i) != s.charAt(s.length() - 1 - i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<String>> res = new ArrayList<>();\\n    \\n    public List<List<String>> partition(String s) {\\n        backtrack(0, s, new ArrayList<>());\\n        return res;\\n    }\\n\\n    private void backtrack(int i, String s, ArrayList<String> substrings) {\\n        // base case\\n        if(i == s.length()) {\\n            res.add(new ArrayList<>(substrings));\\n            return;\\n        }\\n        \\n        for(int j = i; j < s.length(); j++) {\\n            String sub = s.substring(i, j + 1);\\n            if(isPalindrome(sub)) {\\n                substrings.add(sub);\\n                backtrack(j + 1, s, substrings);\\n                substrings.remove(substrings.size() - 1);\\n            }\\n        }\\n        \\n    }\\n\\n    private boolean isPalindrome(String s) {\\n        for(int i = 0; i < s.length() / 2; i++) {\\n            if(s.charAt(i) != s.charAt(s.length() - 1 - i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083480,
                "title": "backtracking-c",
                "content": "# Intuition\\nUse recursion and find all possible palindrome substring\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe are using recursion here passing required arguments \\nwe are running loop throung the string and making substring out of it using string.substr() method is the substring is palindrome we will will make recursive call for finding next palindrome substring and if the length of string will be zero we will add that in to answer container\\n\\n\\nif current substring don\\'t give palindromic substring in future we will backtrack \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSpace complexity would be O(n^2) if we won\\'t count string.substr() function (Since length of string is too small we can ignore it)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace complexity is O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isP(string s)\\n    {\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i]!=s[s.size()-1-i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void printS(vector<vector<string>>&ans,string s,vector<string>& a)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(a);\\n            return;\\n        }\\n        for(int i= 0;i<s.size();i++)\\n        {\\n            string qpr= s.substr(0,i+1);\\n            string ros = s.substr(i+1);\\n            if(isP(qpr))\\n            {\\n                a.push_back(qpr);\\n                printS(ans,ros,a);\\n                a.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>a;\\n        printS(ans,s,a);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isP(string s)\\n    {\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i]!=s[s.size()-1-i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void printS(vector<vector<string>>&ans,string s,vector<string>& a)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(a);\\n            return;\\n        }\\n        for(int i= 0;i<s.size();i++)\\n        {\\n            string qpr= s.substr(0,i+1);\\n            string ros = s.substr(i+1);\\n            if(isP(qpr))\\n            {\\n                a.push_back(qpr);\\n                printS(ans,ros,a);\\n                a.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>a;\\n        printS(ans,s,a);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004437,
                "title": "python-bottom-up-dp-solution-100-faster-iterative-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        dp = []\\n        n = len(s)\\n        \\n        for i in range(n+1):\\n            dp.append([])  # create dp of size n+1\\n            \\n        dp[-1].append([])  # because for s[n:] i.e. empty string ,  answer = [[]]\\n        \\n        # dp[i] store all possible palindrome partitions of string s[i:] \\n        \\n        for i in range(n-1,-1,-1):\\n            for j in range(i+1,n+1):\\n                curr = s[i:j] # cosider each substring of s start from i-th character\\n                \\n                if curr == curr[::-1]:  # if substring is palindrome\\n                    \\n                    # Consider first element of each partition is curr then add curr in the front of all partitions of string s[j:]  , which are already stored in dp[j] \\n                    for e in dp[j]:   \\n                        dp[i].append ([curr] + e)\\n                        \\n        return dp[0]      # All palindrome partitions of s[0:] = s\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        dp = []\\n        n = len(s)\\n        \\n        for i in range(n+1):\\n            dp.append([])  # create dp of size n+1\\n            \\n        dp[-1].append([])  # because for s[n:] i.e. empty string ,  answer = [[]]\\n        \\n        # dp[i] store all possible palindrome partitions of string s[i:] \\n        \\n        for i in range(n-1,-1,-1):\\n            for j in range(i+1,n+1):\\n                curr = s[i:j] # cosider each substring of s start from i-th character\\n                \\n                if curr == curr[::-1]:  # if substring is palindrome\\n                    \\n                    # Consider first element of each partition is curr then add curr in the front of all partitions of string s[j:]  , which are already stored in dp[j] \\n                    for e in dp[j]:   \\n                        dp[i].append ([curr] + e)\\n                        \\n        return dp[0]      # All palindrome partitions of s[0:] = s\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1668696,
                "title": "c-straight-forward-solution-only-for-beginners",
                "content": "# Only for beginners\\n\\n**First of all let\\'s we forget about the PALINDROME part of the question**\\n\\nLet us suppose we have a string of ```Size = 2``` *ab*\\nWhat would be its subarrays?\\n```\\n2.1]\\t{\\'a\\',\\'b\\'}\\n2.2]\\t{\\'ab\\'}\\n```\\nSimple right?\\uD83D\\uDE01\\nNow let\\'s try for ```Size = 3``` *abc*\\nIt\\'s subarrays are\\n```\\n3.1]\\t{\\'a\\',\\'b\\',\\'c\\'}\\n3.2]\\t{\\'a\\',\\'bc\\'}\\n3.3]\\t{\\'ab\\',\\'c\\'}\\n3.4]\\t{\\'abc\\'}\\n```\\n\\nTake the list ```2.1``` then you can do **2 operations**\\n1. Add the last element **directly to the list**.  ```{\\'a\\',\\'b\\'}``` + **\\'c\\' ->**  ```{\\'a\\',\\'b\\',\\'c\\'} ```   \\uD83D\\uDC48**Boom you got list 3.1**\\n2. Add the last element **to the last element of the list**. ```{\\'a\\',\\'b+c\\'}```  **->**  ```{\\'a\\',\\'bc\\'} ```  \\uD83D\\uDC48**Got list 3.2**\\n\\nDo the same operation to get others too\\n**From list 2.2**\\t\\t```{\\'ab\\'}``` + **\\'c\\' ->**  ```{\\'ab\\',\\'c\\'} ``` \\uD83D\\uDC48**Got list 3.3**\\n**From list 2.2**\\t\\t```{\\'ab+c\\'}```  **->**  ```{\\'abc\\'} ```       \\uD83D\\uDC48**Got list 3.4**\\n\\n\\n**And this how it goes on**\\n\\n![image](https://assets.leetcode.com/users/images/5f131924-1510-4709-b6d6-325651f093c3_1641387140.2775264.png)\\n\\n\\nNow that you have generated **all the possible answers** just check whether it is a **palindrome** or not.\\n**If any of the subarray is not a palindrome then we can delete that whole vector**\\ne.g. if ```aba``` is the string then generated answers will be \\n```\\n{\\'a\\',\\'b\\',\\'a\\'}\\n{\\'a\\',\\'ba\\'}    //<- \\'ba\\' is not a palindrome so we\\'ll erase this {\\'a\\',\\'ba\\'} whole vector\\n{\\'ab\\',\\'a\\'}    //<- \\'ab\\' is not a palindrome so we\\'ll erase this {\\'ab\\',\\'a\\'} whole vector\\n{\\'aba\\'}\\n```\\nSo answer will be\\n```\\n{\\'a\\',\\'b\\',\\'a\\'}\\n{\\'aba\\'}\\n```\\n\\n# Let\\'s see the code Now\\n**Code May look longer , I intentionally made it longer**  \\uD83D\\uDE0E\\n```\\nclass Solution\\n{\\nprivate:\\n    vector<vector<string>> res;  \\n\\t// <- This will contain all the generated vectors , from this we\\'ll erase the wrong ones\\n\\npublic:\\n\\t//This will check if the string is palindrome or not\\n    bool checkPalindrome(string &s)\\n    {\\n        int l = 0, r = s.size() - 1;\\n        while (l <= r)\\n            if (s[l] != s[r])\\n                return false;\\n            else\\n                l++, r--;\\n        return true;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t/*\\n\\tThis will check a vector\\'s all content ,\\n\\tif any string of this vector is not palindrome whole vector will be removed\\n\\t*/\\n    bool checkVector(vector<string> &v)\\n    {\\n\\n\\n        for (auto &s : v)\\n            if (!checkPalindrome(s))   // just checking all the strings \\n                return true;  \\t//return true : Means this vector will be removed\\n        return false; \\t//return false : Means this vector will NOT be removed\\n    }\\n    void recur(string &s)\\n    {\\n        if (s.size() == 1)\\n        {\\n            res.push_back({s});\\n            return;\\n        }\\n        string c = \"\";\\n        c += s.back();\\n        s.pop_back();\\n        recur(s);      //To get the answer for n-length string we need answer of (n-1)th string\\n        int n = res.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            res.push_back(res[i]);\\n            res.back().back() += c;      // This is the 2nd option {\\'a\\' +\\'b + c\\'}\\n            res[i].push_back(c);       // 1st one  {\\'a\\' + \\'b\\' } +\\'c\\'\\n        }\\n    }\\n\\n    vector<vector<string>> partition(string s)\\n    {\\n        recur(s);\\n\\t\\t/*\\n\\t\\tremove_if is from STL.\\n\\t\\tIt removes elements from specified range and a specified conditions.\\n\\t\\tFor us range = whole vector = from begin() to end()\\n\\t\\tans condition = checkVector() <- Explained above\\n        */\\n\\t\\tauto it = remove_if(res.begin(), res.end(), [&](vector<string> &v)     \\n                            { return checkVector(v); });\\n        res.resize(distance(res.begin(), it));  // resizing it bcz after removing elements size will be decreased\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```Size = 2```\n```\\n2.1]\\t{\\'a\\',\\'b\\'}\\n2.2]\\t{\\'ab\\'}\\n```\n```Size = 3```\n```\\n3.1]\\t{\\'a\\',\\'b\\',\\'c\\'}\\n3.2]\\t{\\'a\\',\\'bc\\'}\\n3.3]\\t{\\'ab\\',\\'c\\'}\\n3.4]\\t{\\'abc\\'}\\n```\n```2.1```\n```{\\'a\\',\\'b\\'}```\n```{\\'a\\',\\'b\\',\\'c\\'} ```\n```{\\'a\\',\\'b+c\\'}```\n```{\\'a\\',\\'bc\\'} ```\n```{\\'ab\\'}```\n```{\\'ab\\',\\'c\\'} ```\n```{\\'ab+c\\'}```\n```{\\'abc\\'} ```\n```aba```\n```\\n{\\'a\\',\\'b\\',\\'a\\'}\\n{\\'a\\',\\'ba\\'}    //<- \\'ba\\' is not a palindrome so we\\'ll erase this {\\'a\\',\\'ba\\'} whole vector\\n{\\'ab\\',\\'a\\'}    //<- \\'ab\\' is not a palindrome so we\\'ll erase this {\\'ab\\',\\'a\\'} whole vector\\n{\\'aba\\'}\\n```\n```\\n{\\'a\\',\\'b\\',\\'a\\'}\\n{\\'aba\\'}\\n```\n```\\nclass Solution\\n{\\nprivate:\\n    vector<vector<string>> res;  \\n\\t// <- This will contain all the generated vectors , from this we\\'ll erase the wrong ones\\n\\npublic:\\n\\t//This will check if the string is palindrome or not\\n    bool checkPalindrome(string &s)\\n    {\\n        int l = 0, r = s.size() - 1;\\n        while (l <= r)\\n            if (s[l] != s[r])\\n                return false;\\n            else\\n                l++, r--;\\n        return true;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t/*\\n\\tThis will check a vector\\'s all content ,\\n\\tif any string of this vector is not palindrome whole vector will be removed\\n\\t*/\\n    bool checkVector(vector<string> &v)\\n    {\\n\\n\\n        for (auto &s : v)\\n            if (!checkPalindrome(s))   // just checking all the strings \\n                return true;  \\t//return true : Means this vector will be removed\\n        return false; \\t//return false : Means this vector will NOT be removed\\n    }\\n    void recur(string &s)\\n    {\\n        if (s.size() == 1)\\n        {\\n            res.push_back({s});\\n            return;\\n        }\\n        string c = \"\";\\n        c += s.back();\\n        s.pop_back();\\n        recur(s);      //To get the answer for n-length string we need answer of (n-1)th string\\n        int n = res.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            res.push_back(res[i]);\\n            res.back().back() += c;      // This is the 2nd option {\\'a\\' +\\'b + c\\'}\\n            res[i].push_back(c);       // 1st one  {\\'a\\' + \\'b\\' } +\\'c\\'\\n        }\\n    }\\n\\n    vector<vector<string>> partition(string s)\\n    {\\n        recur(s);\\n\\t\\t/*\\n\\t\\tremove_if is from STL.\\n\\t\\tIt removes elements from specified range and a specified conditions.\\n\\t\\tFor us range = whole vector = from begin() to end()\\n\\t\\tans condition = checkVector() <- Explained above\\n        */\\n\\t\\tauto it = remove_if(res.begin(), res.end(), [&](vector<string> &v)     \\n                            { return checkVector(v); });\\n        res.resize(distance(res.begin(), it));  // resizing it bcz after removing elements size will be decreased\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667660,
                "title": "python3-simple-solution-with-dp-and-recursion-beating-97-in-time",
                "content": "```\\ndef partition(self, s: str) -> List[List[str]]:\\n    # dp[i][j] = True if s[i:j] is a palindrome\\n    n = len(s)\\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\\n    for diff in range(n + 1):\\n        for i in range(n + 1 - diff):\\n            j = i + diff\\n            if diff <= 1: dp[i][j] = True\\n            elif s[i] == s[j - 1]: dp[i][j] = dp[i + 1][j - 1]\\n\\n    @cache\\n    def find_part(start: int):\\n        ans = list()\\n        for i in range(start, n):\\n            if dp[start][i + 1]: # is a palindrome\\n                if i + 1 < n: ans += [[s[start:i + 1]] + p for p in find_part(i + 1)]\\n                else: ans.append([s[start:i + 1]])\\n        return ans\\n    return find_part(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef partition(self, s: str) -> List[List[str]]:\\n    # dp[i][j] = True if s[i:j] is a palindrome\\n    n = len(s)\\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\\n    for diff in range(n + 1):\\n        for i in range(n + 1 - diff):\\n            j = i + diff\\n            if diff <= 1: dp[i][j] = True\\n            elif s[i] == s[j - 1]: dp[i][j] = dp[i + 1][j - 1]\\n\\n    @cache\\n    def find_part(start: int):\\n        ans = list()\\n        for i in range(start, n):\\n            if dp[start][i + 1]: # is a palindrome\\n                if i + 1 < n: ans += [[s[start:i + 1]] + p for p in find_part(i + 1)]\\n                else: ans.append([s[start:i + 1]])\\n        return ans\\n    return find_part(0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 972148,
                "title": "c-dp-dfs-solution-backtracking",
                "content": "This solution relies on two parts:\\n- creating a dynamic programming table to cache whether given substrings are palindromic\\n- recursively going through all possible substring partitions if they are palindromic\\n\\nFor the first part of this solution, observe that we are building a dynamic programming table based on a recursive palindromic definition\\n- if a string is of length 1, then it is a palindrome\\n- if a string is of length 2, then it is a palindrome only if the first and last characters are equal\\n- otherwise, a string is a palindrome if its first and last characters are equal, and the remaining string when you remove the first and last characters is also a palindrome\\n\\nTo generate all palindromes and take advantage of this recursive definition, observe that we are looping by length and starting position, instead of starting and ending position. This allows us to use previously computed results in building our final answer, since any string of length `n` will use a string of length `n - 2` to determine whether or not it is a palindrome, provided we are above the base case.\\n\\nFrom here, we recursively iterate through the string, starting at the beginning position. Since we need the *entire* string to be split into valid palindromes, we go through all palindromes encountered at each position and then add that to our final result, recursively applying the same process on the remaining string. If we encounter the end of the string, that means we have partitioned the whole string into palindromes, so we add this to our final answer; otherwise, we omit that \"partititioning\" from our final answer.\\n\\nNote that we do not have to perform the traverse method in the main function call (`partition()`), but we can rather do it within the `if` statement in the `build()` `for` loop (instead of doing `if (dp[pos][curr])` we can change it to `if(traverse(s, pos, curr)`). This will save us a quadratic number of operations at the beginning, and will have faster net time complexity; however, for the purposes of clarity in the explanation, I chose to do it the displayed way.\\n\\nThe time complexity of this solution is exponential `(O(n * 2 ^ n)`, where `n` is the size of the string, and the space complexity is `O(n^2)` for our dynamic programming table. The  time complexity stems from the recursive operation that we have to perform when generating all possible answers, since the only way to do this is to backtrack and break up the string, which in the worst case goes through `n` choices at each level, creating an exponential complexity.\\n\\n```\\nvector<vector<int>> dp;\\nvector<vector<string>> result;\\nvector<string> storage;\\nbool traverse(string& s, int left, int right) {\\n\\tif (dp[left][right] >= 0) {\\n\\t\\treturn dp[left][right];\\n\\t}\\n\\tif (left == right) {\\n\\t\\treturn dp[left][right] = 1;\\n\\t}\\n\\tif (right - left == 1) {\\n\\t   return dp[left][right] = s[left] == s[right];\\n\\t}\\n\\treturn dp[left][right] = s[left] == s[right] && traverse(s, left + 1, right - 1);\\n}\\nvoid build(string& s, int pos) {\\n\\tif (pos == s.size()) {\\n\\t\\tresult.push_back(storage);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int curr = pos; curr < s.size(); curr++) {\\n\\t\\tif (dp[pos][curr]) {\\n\\t\\t\\tstorage.push_back(s.substr(pos, curr - pos + 1));\\n\\t\\t\\tbuild(s, curr + 1);\\n\\t\\t\\tstorage.pop_back();\\n\\t\\t}\\n\\t}\\n}\\nvector<vector<string>> partition(string s) {\\n\\tdp.resize(s.size(), vector<int>(s.size(), -1));\\n\\tfor (int len = 1; len <= s.size(); len++) {\\n\\t\\tfor (int i = 0; i <= s.size() - len; i++) {\\n\\t\\t\\ttraverse(s, i, i + len - 1);\\n\\t\\t}\\n\\t}\\n\\tbuild(s, 0);\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nvector<vector<int>> dp;\\nvector<vector<string>> result;\\nvector<string> storage;\\nbool traverse(string& s, int left, int right) {\\n\\tif (dp[left][right] >= 0) {\\n\\t\\treturn dp[left][right];\\n\\t}\\n\\tif (left == right) {\\n\\t\\treturn dp[left][right] = 1;\\n\\t}\\n\\tif (right - left == 1) {\\n\\t   return dp[left][right] = s[left] == s[right];\\n\\t}\\n\\treturn dp[left][right] = s[left] == s[right] && traverse(s, left + 1, right - 1);\\n}\\nvoid build(string& s, int pos) {\\n\\tif (pos == s.size()) {\\n\\t\\tresult.push_back(storage);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int curr = pos; curr < s.size(); curr++) {\\n\\t\\tif (dp[pos][curr]) {\\n\\t\\t\\tstorage.push_back(s.substr(pos, curr - pos + 1));\\n\\t\\t\\tbuild(s, curr + 1);\\n\\t\\t\\tstorage.pop_back();\\n\\t\\t}\\n\\t}\\n}\\nvector<vector<string>> partition(string s) {\\n\\tdp.resize(s.size(), vector<int>(s.size(), -1));\\n\\tfor (int len = 1; len <= s.size(); len++) {\\n\\t\\tfor (int i = 0; i <= s.size() - len; i++) {\\n\\t\\t\\ttraverse(s, i, i + len - 1);\\n\\t\\t}\\n\\t}\\n\\tbuild(s, 0);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42188,
                "title": "classic-recursive-solution-in-java",
                "content": "The init method computes the isPal[][] array, where isPal[i][j] is true if s[i..j] is palindrome. The helper method is doing the actual recursion, where the cut[] array records the cut positions, and the construct method reconstructs the result from the cut[] array. \\n\\nCompared to the non-recursive implementation this one saves a lot of space as you do not have to store the substrings or the cut positions up to position i for all 0 <= i < s.length(). However it does perform repetitive work compared to the DP solution, e.g., if you have found two different ways of partitioning s[0..k], you still recursively search for partitioning of s[k+1,...]. So it's a typical trade-off between space and time.\\n\\n     public class Solution {\\n        \\n        private void init(boolean[][] isPal, String s) {\\n            int len = isPal.length;\\n            for (int i=0; i<len; i++) isPal[i][i] = true;\\n            for (int k=1; k<len; k++)\\n                for (int i=0; i+k<len; i++) {\\n                    if (s.charAt(i) != s.charAt(i+k)) continue;\\n                    isPal[i][i+k] = (i+1 <= i+k-1) ? isPal[i+1][i+k-1] : true;\\n                }\\n            \\n        }\\n        \\n        private void construct(String s, boolean[] cut, List<List<String>> ans) {\\n            List<String> tmp = new ArrayList<String>();\\n            int cur = 0;\\n            for (int i=0; i<cut.length; i++) {\\n                if (cut[i]) {\\n                    tmp.add(s.substring(cur,i+1));\\n                    cur = i+1;\\n                }\\n            }\\n            ans.add(tmp);\\n        }\\n        \\n        private void helper(String s, int start, int end, boolean[] cut, List<List<String>> ans, boolean[][] isPal) {\\n            if (start > end) construct(s, cut, ans);\\n            for (int i=start; i<=end; i++) {\\n                if (isPal[start][i]) {\\n                    cut[i] = true;\\n                    helper(s, i+1, end, cut, ans, isPal);\\n                    cut[i] = false;\\n                }\\n            }\\n        }\\n    \\n        public List<List<String>> partition(String s) {\\n            int len = s.length();\\n            boolean[][] isPal = new boolean[len][len];\\n            boolean[] cut = new boolean[len];\\n            \\n            init(isPal, s);\\n            List<List<String>> ans = new ArrayList<List<String>>();\\n            helper(s, 0, len-1, cut, ans, isPal);\\n            return ans;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        private void init(boolean[][] isPal, String s) {\\n            int len = isPal.length;\\n            for (int i=0; i<len; i++) isPal[i][i] = true;\\n            for (int k=1; k<len; k++)\\n                for (int i=0; i+k<len; i++) {\\n                    if (s.charAt(i) != s.charAt(i+k)) continue;\\n                    isPal[i][i+k] = (i+1 <= i+k-1) ? isPal[i+1][i+k-1] : true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3605400,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\nExponential\\n\\n- Space complexity:\\nLinear\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void partitionHelper(int idx, string s, vector<string>& temp, vector<vector<string>>& ans) {\\n        if (idx == s.size()) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < s.size(); i++) {\\n            if (palindrome(s, idx, i) == true) {\\n                temp.push_back(s.substr(idx, i-idx+1));\\n                partitionHelper(i+1, s, temp, ans);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n\\n    bool palindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end])\\n                return false;\\n            start++;\\n            end--;    \\n        }\\n        return true;\\n    }\\n\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> temp;\\n        partitionHelper(0, s, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void partitionHelper(int idx, string s, vector<string>& temp, vector<vector<string>>& ans) {\\n        if (idx == s.size()) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < s.size(); i++) {\\n            if (palindrome(s, idx, i) == true) {\\n                temp.push_back(s.substr(idx, i-idx+1));\\n                partitionHelper(i+1, s, temp, ans);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n\\n    bool palindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end])\\n                return false;\\n            start++;\\n            end--;    \\n        }\\n        return true;\\n    }\\n\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> temp;\\n        partitionHelper(0, s, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087967,
                "title": "python3-simple-dfs-659-ms-faster-than-85-12",
                "content": "https://leetcode.com/submissions/detail/883354080/   \\nRuntime: **659 ms**, faster than 85.12% of Python3 online submissions for Palindrome Partitioning.  \\nMemory Usage: 28.2 MB, less than 99.36% of Python3 online submissions for Palindrome Partitioning.  \\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions, lst, l = [], [([], 0)], len(s)\\n        while lst: ## dfs\\n            pals, i = lst.pop()\\n            for j in range(i+1, l+1):\\n                sub = s[i:j]\\n                if sub==sub[::-1]: ## if sub is a palindrome\\n                    if j==l: ## reach the end\\n                        partitions.append(pals+[sub])\\n                    else:\\n                        lst.append((pals+[sub], j))\\n        return partitions\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions, lst, l = [], [([], 0)], len(s)\\n        while lst: ## dfs\\n            pals, i = lst.pop()\\n            for j in range(i+1, l+1):\\n                sub = s[i:j]\\n                if sub==sub[::-1]: ## if sub is a palindrome\\n                    if j==l: ## reach the end\\n                        partitions.append(pals+[sub])\\n                    else:\\n                        lst.append((pals+[sub], j))\\n        return partitions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083702,
                "title": "c-easy-solution-backtracking-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFBackTracking Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/fUs6zefC/shared\" frameBorder=\"0\" width=\"800\" height=\"1000\"></iframe>\\n\\n\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFBackTracking Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/fUs6zefC/shared\" frameBorder=\"0\" width=\"800\" height=\"1000\"></iframe>\\n\\n\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3001798,
                "title": "c-solution-backtracking-time-complexity-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMCM variation : \\n$$1$$) put cut on every index.\\n$$2$$) seperate given string in 2 parts (curr && pending). \\n$$3$$) check left is palindrome or not.\\n$$4$$) if yes push and call on pending string and remember to backtrack also\\n$$5$$) else continue\\n$$6$$) as soon size of string becomes 0 push given $$vector<string>$$ in ans \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*2^n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nbool isParlindrome(string s){\\n    int i=0,j=s.size()-1;\\n    while(i<j){\\n        if(s[i]!=s[j])return false;\\n        else {i++;j--;}\\n    }\\n    return true;\\n}\\nvoid solve(string s,vector<vector<string>>& ans,vector<string> v){\\n    if(s.size()==0){\\n        ans.push_back(v);\\n        return;\\n    }\\n    for(int i=0;i<s.size();i++){\\n        string curr = s.substr(0,i+1);\\n        string pending = s.substr(i+1);\\n        if(isParlindrome(curr)){\\n            v.push_back(curr);\\n            solve(pending,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n}\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(s,ans,v);\\n        return ans;\\n    }\\n};\\n\\n```\\nPls Upvote:) \\uD83D\\uDE42 \\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nbool isParlindrome(string s){\\n    int i=0,j=s.size()-1;\\n    while(i<j){\\n        if(s[i]!=s[j])return false;\\n        else {i++;j--;}\\n    }\\n    return true;\\n}\\nvoid solve(string s,vector<vector<string>>& ans,vector<string> v){\\n    if(s.size()==0){\\n        ans.push_back(v);\\n        return;\\n    }\\n    for(int i=0;i<s.size();i++){\\n        string curr = s.substr(0,i+1);\\n        string pending = s.substr(i+1);\\n        if(isParlindrome(curr)){\\n            v.push_back(curr);\\n            solve(pending,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n}\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(s,ans,v);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776013,
                "title": "palindrome-partitioning-java-solution-simple-partition-approach",
                "content": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList();\\n        List<String> path = new ArrayList();\\n        help(0,s,path,ans);\\n        return ans;\\n    }\\n    void help(int index, String s, List<String> path, List<List<String>> ans)\\n    {\\n        //BASE CASE\\n        if(index==s.length())\\n        {\\n            ans.add(new ArrayList(path));\\n            return;\\n        }\\n        \\n        //recursion\\n        for(int i=index; i<s.length(); i++)\\n        {\\n            if(isPalindrome(index,i,s))\\n            {\\n                path.add(s.substring(index,i+1));\\n                help(i+1,s,path,ans);\\n                path.remove(path.size()-1);\\n            }\\n        }\\n    }\\n    boolean isPalindrome(int start, int end, String s)\\n    {\\n        while(start<=end)\\n        {\\n            if(s.charAt(start)!=s.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\nTime Complexity: O( (2^n) *k*(n/2) )\\n\\nReason: O(2^n) to generate every substring and O(n/2)  to check if the substring generated is a palindrome. O(k) is for inserting the palindromes in another data structure, where k  is the average length of the palindrome list.\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList();\\n        List<String> path = new ArrayList();\\n        help(0,s,path,ans);\\n        return ans;\\n    }\\n    void help(int index, String s, List<String> path, List<List<String>> ans)\\n    {\\n        //BASE CASE\\n        if(index==s.length())\\n        {\\n            ans.add(new ArrayList(path));\\n            return;\\n        }\\n        \\n        //recursion\\n        for(int i=index; i<s.length(); i++)\\n        {\\n            if(isPalindrome(index,i,s))\\n            {\\n                path.add(s.substring(index,i+1));\\n                help(i+1,s,path,ans);\\n                path.remove(path.size()-1);\\n            }\\n        }\\n    }\\n    boolean isPalindrome(int start, int end, String s)\\n    {\\n        while(start<=end)\\n        {\\n            if(s.charAt(start)!=s.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\nTime Complexity: O( (2^n) *k*(n/2) )\\n\\nReason: O(2^n) to generate every substring and O(n/2)  to check if the substring generated is a palindrome. O(k) is for inserting the palindromes in another data structure, where k  is the average length of the palindrome list.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737723,
                "title": "java-simple-backtracking-faster-than-99-solution-easily-explained",
                "content": "Let\\'s get to the intuition: the question has three keywords, partition, substring and palindrome.\\n\\n1. Partition: Means every answer of ours has to include full string in parts.\\n2. Substring: Since, each answer of ours need to have full string means every next partition should be continuous from the previous substring.\\n3. Palindrome: \\n\\tForget palindrome for now, and suppose we have \"abaaba\" and from our above two observations, one of the answers of ours could be [\"a\", \"ba\", \"ab\", \"a\"]. \\n\\tNow, why is this not one of the answers? Each partitions that we do need to be a palindrome(same as it\\'s reverse). Means one possible solution could be [\"a\", \"baab\", \"a\"]. \\n\\tTake a look at the below image for a better understanding.\\n\\n![image](https://assets.leetcode.com/users/images/13f670c4-e925-4bc6-8fd0-791884cdd909_1643751614.6390266.png)\\n\\n\\nLet\\'s get to the code:\\n```\\nclass Solution {\\n    \\n    ArrayList<List<String>> answer;\\n    \\n    public List<List<String>> partition(String s) {\\n        answer = new ArrayList<>();\\n        solution(s, new ArrayList<String>());\\n        \\n        return answer;\\n    }\\n\\n\\tpublic boolean isPalindrome(String str) {\\n\\t\\t\\n\\t\\tint length = str.length();\\n\\t\\tfor(int idx = 0; idx < length/2; idx++) {\\n\\t\\t\\tif(str.charAt(idx) != str.charAt(length - 1 - idx)) return false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n \\n\\tpublic void solution(String str, ArrayList<String> asf) {\\n\\t\\t\\n\\t\\tif(str.length() == 0) {            \\n            answer.add(new ArrayList<>(asf));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\n\\t\\t// Take out palindromes from the starting of the question string which is left.\\n\\t\\tfor(int idx = 0; idx < str.length(); idx++) {\\n\\t\\t\\tString sub = str.substring(0, idx + 1);\\n\\t\\t\\t\\n\\t\\t\\tif(isPalindrome(sub)) {\\n                \\n                asf.add(sub);\\n                solution(str.substring(idx + 1), asf);\\n\\t\\t\\t\\t// backtrack and remove the palindromic substring added and found the next one starting from the same letter as this one `sub`.\\n                asf.remove(asf.size() - 1);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ArrayList<List<String>> answer;\\n    \\n    public List<List<String>> partition(String s) {\\n        answer = new ArrayList<>();\\n        solution(s, new ArrayList<String>());\\n        \\n        return answer;\\n    }\\n\\n\\tpublic boolean isPalindrome(String str) {\\n\\t\\t\\n\\t\\tint length = str.length();\\n\\t\\tfor(int idx = 0; idx < length/2; idx++) {\\n\\t\\t\\tif(str.charAt(idx) != str.charAt(length - 1 - idx)) return false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n \\n\\tpublic void solution(String str, ArrayList<String> asf) {\\n\\t\\t\\n\\t\\tif(str.length() == 0) {            \\n            answer.add(new ArrayList<>(asf));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\n\\t\\t// Take out palindromes from the starting of the question string which is left.\\n\\t\\tfor(int idx = 0; idx < str.length(); idx++) {\\n\\t\\t\\tString sub = str.substring(0, idx + 1);\\n\\t\\t\\t\\n\\t\\t\\tif(isPalindrome(sub)) {\\n                \\n                asf.add(sub);\\n                solution(str.substring(idx + 1), asf);\\n\\t\\t\\t\\t// backtrack and remove the palindromic substring added and found the next one starting from the same letter as this one `sub`.\\n                asf.remove(asf.size() - 1);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668702,
                "title": "backtracking-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPal(string &s , int low ,int high)\\n    {\\n        while(low < high)\\n        {\\n            if(s[low++] != s[high--])return false;\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<string>> &res , string &s , int start , vector<string> curr)\\n    {\\n        if(start == s.size()) res.push_back(curr);\\n        \\n        for(int end = start ; end < s.size() ; end++)\\n        {\\n            if(isPal(s,start,end))\\n            {\\n                curr.push_back(s.substr(start,end - start + 1));\\n                dfs(res,s,end+1,curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        dfs(res,s,0,curr);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPal(string &s , int low ,int high)\\n    {\\n        while(low < high)\\n        {\\n            if(s[low++] != s[high--])return false;\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<string>> &res , string &s , int start , vector<string> curr)\\n    {\\n        if(start == s.size()) res.push_back(curr);\\n        \\n        for(int end = start ; end < s.size() ; end++)\\n        {\\n            if(isPal(s,start,end))\\n            {\\n                curr.push_back(s.substr(start,end - start + 1));\\n                dfs(res,s,end+1,curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        dfs(res,s,0,curr);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668168,
                "title": "c-complete-dp-solution-without-backtracking-time-complexity-o-n-3",
                "content": "We start with the last index of the string and calculate ans for it and store it.\\nWe create substrings starting at index i and check if that is a palindrone and if it is palindrone, we already know the ans for remaining of substring as that is stored in dp, this way there is no need of backtracking.\\n```\\nclass Solution {\\nprivate:\\n    bool isPalindrome(string s){\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j){\\n            if(s[i]!=s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        vector<vector<vector<string>>>dp(n+1);\\n        dp[n]=vector<vector<string>>(0);\\n        for(int k=n-1;k>=0;k--){\\n            for(int i=k;i<s.size();i++){\\n                string sub=s.substr(k,i-k+1);\\n                if(isPalindrome(sub)){\\n                    vector<vector<string>>temp=dp[i+1];\\n                    if(temp.size()!=0){\\n                        for(int j=0;j<temp.size();j++){\\n                            temp[j].insert(temp[j].begin(),sub);\\n                            dp[k].push_back(temp[j]);\\n                        }\\n                    }\\n                    else{\\n                        dp[k].push_back({sub});\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\nPlease upvote if you find this solution helpful.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPalindrome(string s){\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j){\\n            if(s[i]!=s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        vector<vector<vector<string>>>dp(n+1);\\n        dp[n]=vector<vector<string>>(0);\\n        for(int k=n-1;k>=0;k--){\\n            for(int i=k;i<s.size();i++){\\n                string sub=s.substr(k,i-k+1);\\n                if(isPalindrome(sub)){\\n                    vector<vector<string>>temp=dp[i+1];\\n                    if(temp.size()!=0){\\n                        for(int j=0;j<temp.size();j++){\\n                            temp[j].insert(temp[j].begin(),sub);\\n                            dp[k].push_back(temp[j]);\\n                        }\\n                    }\\n                    else{\\n                        dp[k].push_back({sub});\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667603,
                "title": "python3-recursion-explained",
                "content": "We use a recursion function that returns all possible partitions for the string `s` starting from the `i`th index. Inside the function, we iterate over all chars starting from the index `start` and for every palindrome, we recursively call the function for a substring starting after the found palindrome. Also, we have to use memoization to avoid repeating calls for the same index. Since cached results are lists, before prepending the found palindrome, we have to copy the result.\\n\\nTime: **O(n * 2^n)** - for scans\\nSpace: **O(2^n)** - for cache\\n\\nRuntime: 692 ms, faster than **47.03%** of Python3 online submissions for Palindrome Partitioning.\\nMemory Usage: 68 MB, less than **5.18%** of Python3 online submissions for Palindrome Partitioning.\\n\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        l = len(s)\\n        \\n        def isPalindrom(s):\\n            return s == s[::-1]\\n        \\n        @cache\\n        def rec(start):\\n            if start == l:\\n                return []\\n\\n            res = []\\n            for i in range(start + 1, l + 1):\\n                sub = s[start:i]\\n\\n                if isPalindrom(sub):\\n                    subres = rec(i)\\n                    if not subres:\\n                        res.append(deque([sub]))\\n                    else:\\n                        for arr in subres:\\n                            copy = arr.copy()\\n                            copy.appendleft(sub)\\n                            res.append(copy)\\n    \\n            return res\\n            \\n        return rec(0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        l = len(s)\\n        \\n        def isPalindrom(s):\\n            return s == s[::-1]\\n        \\n        @cache\\n        def rec(start):\\n            if start == l:\\n                return []\\n\\n            res = []\\n            for i in range(start + 1, l + 1):\\n                sub = s[start:i]\\n\\n                if isPalindrom(sub):\\n                    subres = rec(i)\\n                    if not subres:\\n                        res.append(deque([sub]))\\n                    else:\\n                        for arr in subres:\\n                            copy = arr.copy()\\n                            copy.appendleft(sub)\\n                            res.append(copy)\\n    \\n            return res\\n            \\n        return rec(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619941,
                "title": "java-easy-and-clean-backtracking-solution",
                "content": "Runtime - 8ms - Faster than 83.20%\\n```\\nclass Solution {\\n    List<String> temp = new ArrayList<>();\\n    List<List<String>> ans = new ArrayList<List<String>>();\\n    public List<List<String>> partition(String s) {\\n        find(s, 0);\\n        return ans;\\n    }\\n    \\n    public void find(String s, int ptr){\\n    \\tif(ptr == s.length() && temp.size() > 0){\\n    \\t\\tans.add(new ArrayList<String>(temp));\\n            return;\\n        }\\n        \\n        for(int i = ptr; i < s.length(); i++){\\n            String str = s.substring(ptr, i + 1);\\n            if(isPalindrome(str)){\\n                temp.add(str);\\n                find(s, i + 1);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    public boolean isPalindrome(String str) {\\n    \\tint i = 0;\\n    \\tint j = str.length() - 1;\\n    \\twhile(i < j) {\\n    \\t\\tif(str.charAt(i++) != str.charAt(j--))\\n    \\t\\t\\treturn false;\\n    \\t}\\n    \\treturn true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<String> temp = new ArrayList<>();\\n    List<List<String>> ans = new ArrayList<List<String>>();\\n    public List<List<String>> partition(String s) {\\n        find(s, 0);\\n        return ans;\\n    }\\n    \\n    public void find(String s, int ptr){\\n    \\tif(ptr == s.length() && temp.size() > 0){\\n    \\t\\tans.add(new ArrayList<String>(temp));\\n            return;\\n        }\\n        \\n        for(int i = ptr; i < s.length(); i++){\\n            String str = s.substring(ptr, i + 1);\\n            if(isPalindrome(str)){\\n                temp.add(str);\\n                find(s, i + 1);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    public boolean isPalindrome(String str) {\\n    \\tint i = 0;\\n    \\tint j = str.length() - 1;\\n    \\twhile(i < j) {\\n    \\t\\tif(str.charAt(i++) != str.charAt(j--))\\n    \\t\\t\\treturn false;\\n    \\t}\\n    \\treturn true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388701,
                "title": "javascript-solution",
                "content": "**Please upvote if you find this solution useful ;)**\\n```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    let result = [];\\n    \\n    findP(0, []);\\n    return result\\n    \\n    function findP(start, arr){\\n        if(start === s.length){\\n            result.push(arr.slice());\\n            return;\\n        }\\n        \\n        for(let i=start; i<s.length; i++){\\n            let str = s.slice(start, i+1);\\n            if(isPalindrom(str)){\\n                findP(i+1, [...arr, str ])\\n            }\\n        }\\n    }\\n    \\n    function isPalindrom(str) {\\n        for(let i=0; i<str.length/2; i++){\\n            if(str[i] !== str[str.length-1-i])return false\\n        }\\n        return true\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    let result = [];\\n    \\n    findP(0, []);\\n    return result\\n    \\n    function findP(start, arr){\\n        if(start === s.length){\\n            result.push(arr.slice());\\n            return;\\n        }\\n        \\n        for(let i=start; i<s.length; i++){\\n            let str = s.slice(start, i+1);\\n            if(isPalindrom(str)){\\n                findP(i+1, [...arr, str ])\\n            }\\n        }\\n    }\\n    \\n    function isPalindrom(str) {\\n        for(let i=0; i<str.length/2; i++){\\n            if(str[i] !== str[str.length-1-i])return false\\n        }\\n        return true\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350891,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<string> temp;\\n        vector<vector<string>> res;\\n        helper(s,temp,res,0);\\n        \\n        return res;\\n    }\\n    \\n    void helper(string& s,vector<string>& temp,vector<vector<string>>& res,int idx){\\n        if(idx == s.length()){\\n            res.push_back(temp);\\n            return;\\n        }\\n        string curr = \"\";\\n        for(int i = idx;i < s.length(); i++){\\n            curr.push_back(s[i]);\\n            if(isPalindrome(curr)){\\n                temp.push_back(curr);\\n                helper(s,temp,res,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string curr){\\n        int l = 0, r = curr.length()-1;\\n        \\n        while(l < r){\\n            if(curr[l++] != curr[r--])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<string> temp;\\n        vector<vector<string>> res;\\n        helper(s,temp,res,0);\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1314559,
                "title": "python-backtracking-beats-95-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def isPalindrome(i, j): #checks if the string s[i to j] is palindrome or not\\n            while j>i:\\n                if s[i] != s[j]:\\n                    return False\\n                i += 1\\n                j -= 1\\n            return True\\n        \\n        def palindromePart(i, parts, curpart):\\n            if i == len(s): #if parsed the entire string append the current partition list to answer\\n                parts.append(curpart)\\n                \\n            for j in range(i, len(s)): #try all strings starting at i and ending at j where j = (i, len(s))\\n                if isPalindrome(i,j): #if the substring is palindrome then\\n                    palindromePart(j+1, parts, curpart + [s[i:j+1]]) #add substring to temporary substring list repeat the same process from the index after the palindrome substring ends\\n                    \\n        parts = []\\n        palindromePart(0, parts, [])\\n        return parts\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def isPalindrome(i, j): #checks if the string s[i to j] is palindrome or not\\n            while j>i:\\n                if s[i] != s[j]:\\n                    return False\\n                i += 1\\n                j -= 1\\n            return True\\n        \\n        def palindromePart(i, parts, curpart):\\n            if i == len(s): #if parsed the entire string append the current partition list to answer\\n                parts.append(curpart)\\n                \\n            for j in range(i, len(s)): #try all strings starting at i and ending at j where j = (i, len(s))\\n                if isPalindrome(i,j): #if the substring is palindrome then\\n                    palindromePart(j+1, parts, curpart + [s[i:j+1]]) #add substring to temporary substring list repeat the same process from the index after the palindrome substring ends\\n                    \\n        parts = []\\n        palindromePart(0, parts, [])\\n        return parts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789971,
                "title": "simple-backtracking-python-c-java",
                "content": "Start from current position, find the next palindrome (the substring `s[strat, end)`), and backtrack.\\n\\nPython 80ms\\n```python\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        self.backtrack(s, start=0, path=[], res=res)\\n        return res\\n\\n    def backtrack(self, s, start, path, res):\\n        if start == len(s):\\n            res.append(path)\\n            return\\n\\n        for end in range(start + 1, len(s) + 1):\\n            sub = s[start: end]\\n            if sub == sub[::-1]:\\n                self.backtrack(s, end, path + [sub], res)\\n```\\n\\nC++ 12ms\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        auto res = vector<vector<string>>();\\n        auto path = vector<string>();\\n        backtrack(s, 0, path, res);\\n        return res;\\n    }\\n    \\n    void backtrack(string &s, int start, vector<string> &path, vector<vector<string>> &res) {\\n        if (start == s.size()) {\\n            res.push_back(path);\\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= s.size(); ++end) {\\n\\t\\t\\t// [start, end)\\n            if (isPalindrome(s, start, end)) {\\n                string sub = s.substr(start, end - start);\\n                path.push_back(sub);\\n                backtrack(s, end, path, res);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string_view s, int start, int end) {\\n        for (int i = start, j = end - 1; i < j; ++i, --j) {\\n            if (s[i] != s[j]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nJava 2ms\\n```java\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<String> path = new ArrayList<String>();\\n        List<List<String>> res = new ArrayList<List<String>>();\\n        backtrack(s, 0, path, res);\\n        return res;\\n    }\\n    \\n    private void backtrack(String s, int start, List<String> path, List<List<String>> res) {\\n        if (start == s.length()) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= s.length(); ++end) {\\n\\t\\t\\t// [start, end)\\n            if (isPalindrome(s, start, end)) {\\n                String sub = s.substring(start, end);\\n                path.add(sub);\\n                backtrack(s, end, path, res);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int start, int end) {\\n        for (int i = start, j = end - 1; i < j; ++i, --j) {\\n            if (s.charAt(i) != s.charAt(j)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        self.backtrack(s, start=0, path=[], res=res)\\n        return res\\n\\n    def backtrack(self, s, start, path, res):\\n        if start == len(s):\\n            res.append(path)\\n            return\\n\\n        for end in range(start + 1, len(s) + 1):\\n            sub = s[start: end]\\n            if sub == sub[::-1]:\\n                self.backtrack(s, end, path + [sub], res)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        auto res = vector<vector<string>>();\\n        auto path = vector<string>();\\n        backtrack(s, 0, path, res);\\n        return res;\\n    }\\n    \\n    void backtrack(string &s, int start, vector<string> &path, vector<vector<string>> &res) {\\n        if (start == s.size()) {\\n            res.push_back(path);\\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= s.size(); ++end) {\\n\\t\\t\\t// [start, end)\\n            if (isPalindrome(s, start, end)) {\\n                string sub = s.substr(start, end - start);\\n                path.push_back(sub);\\n                backtrack(s, end, path, res);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string_view s, int start, int end) {\\n        for (int i = start, j = end - 1; i < j; ++i, --j) {\\n            if (s[i] != s[j]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<String> path = new ArrayList<String>();\\n        List<List<String>> res = new ArrayList<List<String>>();\\n        backtrack(s, 0, path, res);\\n        return res;\\n    }\\n    \\n    private void backtrack(String s, int start, List<String> path, List<List<String>> res) {\\n        if (start == s.length()) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= s.length(); ++end) {\\n\\t\\t\\t// [start, end)\\n            if (isPalindrome(s, start, end)) {\\n                String sub = s.substring(start, end);\\n                path.add(sub);\\n                backtrack(s, end, path, res);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int start, int end) {\\n        for (int i = start, j = end - 1; i < j; ++i, --j) {\\n            if (s.charAt(i) != s.charAt(j)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635944,
                "title": "c-two-solution-dp-with-backtracking-and-backtracking",
                "content": "DP + Backtracking\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition( string s ) {\\n        int n = s.size();\\n        vector<vector<bool>> dp( n, vector<bool>(n,false) );\\n    \\tfor( int i=0; i<n; i++ ) dp[i][i] = true;\\n\\n        for( int i=n-1; i >= 0; i-- )\\n    \\t\\tfor( int j=i+1; j < n; j++ )\\n\\t\\t    \\tif( s[i] == s[j] && ( dp[i+1][j-1] || j-i <= 2 ) )\\n\\t\\t\\t    \\tdp[i][j] = true;\\n        \\n        vector<vector<string>> result;\\n        vector<string> curr;\\n        backtrack( result, curr, 0, s, dp );\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack( vector<vector<string>>& result, vector<string>& curr,\\n                   int start, string& s, vector<vector<bool>> &dp ) {\\n        if( start == s.length() ) {\\n            result.push_back( curr );\\n            return;\\n        }\\n        for( int i=start; i < s.size(); i++ ) {\\n            if( dp[start][i] ) {\\n                curr.push_back( s.substr( start, i - start + 1 ) );\\n                backtrack( result, curr, i+1, s, dp );\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\nBackTracking\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition( string s ) {\\n        vector<vector<string>> result;\\n        vector<string> curr;\\n        backtrack( result, curr, 0, s );\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack( vector<vector<string>>& result, vector<string>& curr,\\n                   int start, string& s ) {\\n        if( start == s.length() ) {\\n            result.push_back( curr );\\n            return;\\n        }\\n        for( int i=start; i < s.size(); i++ ) {\\n            if( isPalindrome( s, start, i ) ) {\\n                curr.push_back( s.substr( start, i - start + 1 ) );\\n                backtrack( result, curr, i+1, s );\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome( string& s, int start, int end ) {\\n        while( start < end ) {\\n            if( s[start] != s[end] ) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition( string s ) {\\n        int n = s.size();\\n        vector<vector<bool>> dp( n, vector<bool>(n,false) );\\n    \\tfor( int i=0; i<n; i++ ) dp[i][i] = true;\\n\\n        for( int i=n-1; i >= 0; i-- )\\n    \\t\\tfor( int j=i+1; j < n; j++ )\\n\\t\\t    \\tif( s[i] == s[j] && ( dp[i+1][j-1] || j-i <= 2 ) )\\n\\t\\t\\t    \\tdp[i][j] = true;\\n        \\n        vector<vector<string>> result;\\n        vector<string> curr;\\n        backtrack( result, curr, 0, s, dp );\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack( vector<vector<string>>& result, vector<string>& curr,\\n                   int start, string& s, vector<vector<bool>> &dp ) {\\n        if( start == s.length() ) {\\n            result.push_back( curr );\\n            return;\\n        }\\n        for( int i=start; i < s.size(); i++ ) {\\n            if( dp[start][i] ) {\\n                curr.push_back( s.substr( start, i - start + 1 ) );\\n                backtrack( result, curr, i+1, s, dp );\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition( string s ) {\\n        vector<vector<string>> result;\\n        vector<string> curr;\\n        backtrack( result, curr, 0, s );\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack( vector<vector<string>>& result, vector<string>& curr,\\n                   int start, string& s ) {\\n        if( start == s.length() ) {\\n            result.push_back( curr );\\n            return;\\n        }\\n        for( int i=start; i < s.size(); i++ ) {\\n            if( isPalindrome( s, start, i ) ) {\\n                curr.push_back( s.substr( start, i - start + 1 ) );\\n                backtrack( result, curr, i+1, s );\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome( string& s, int start, int end ) {\\n        while( start < end ) {\\n            if( s[start] != s[end] ) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42095,
                "title": "time-complexity-why-o-n-2",
                "content": "I'm a little confused about the time complexity of time complexity using dp to solve 'palindrome partition'.\\nSee the sample code:\\n\\n    import java.lang.reflect.Array;\\n    public class Solution {\\n        public List<List<String>> partition(String s) {\\n            int n = s.length();\\n            boolean[][] isPalindrome = new boolean[n][n];\\n            for (int i = 0; i < n; i++)\\n                isPalindrome[i][i] = true;\\n            for (int i = n - 1; i >= 0; i--) {\\n                for (int j = i + 1; j < n; j++) {\\n                    if (s.charAt(i) == s.charAt(j)) {\\n                        if (j - i < 2 || isPalindrome[i + 1][j - 1])\\n                            isPalindrome[i][j] = true;\\n                    }\\n                }\\n            }\\n            List<List<String>>[] palindromes = (List<List<String>>[])Array.newInstance(List.class, n + 1);\\n     \\n            palindromes[n] = (List)(new LinkedList<List<String>>());\\n            List<String> emptyList = new LinkedList<>();\\n            palindromes[n].add(emptyList);\\n            for (int i = n - 1; i >= 0; i--) {\\n                palindromes[i] = (List)(new LinkedList<List<String>>());\\n                for (int j = i; j < n; j++) {\\n                    if (isPalindrome[i][j]) {\\n                        List<List<String>> lists = palindromes[j + 1];\\n                        String substring = s.substring(i, j + 1);\\n                        for (List<String> list : lists) {\\n                            List<String> newList = new LinkedList<>();\\n                            newList.add(substring);\\n                            newList.addAll(list);\\n                            palindromes[i].add(newList);\\n                        }\\n                    }\\n                }\\n            }\\n            return palindromes[0];\\n        }\\n    }\\n\\nMany people think the time complexity of dp solution is O(n^2).\\nBut I can't agree here. For outer for loop (i) and inner for loop (j) is O(n^2), but there is another inner most for loop (List<String> list: lists) with iterate over all partitioning combinations of a substring. So what is the number of partitioning combinations in worst case? Think about a string like 'aaaaa' in worsk case, you can break up between  any two 'a's, so the number of possible partitions is O(2^n). In this case, the time complexity of the solution would be O(n^2 * 2^n). Am I wrong?",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<String>> partition(String s) {\\n            int n = s.length();\\n            boolean[][] isPalindrome = new boolean[n][n];\\n            for (int i = 0; i < n; i++)\\n                isPalindrome[i][i] = true;\\n            for (int i = n - 1; i >= 0; i--) {\\n                for (int j = i + 1; j < n; j++) {\\n                    if (s.charAt(i) == s.charAt(j)) {\\n                        if (j - i < 2 || isPalindrome[i + 1][j - 1])\\n                            isPalindrome[i][j] = true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3223042,
                "title": "best-c-solution-ever-backtracking-string-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using String + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(N), The space complexity of the above code is O(N) [considering recursive calls also]. The Space will be used to store the recursion stack. Extra space is only allocated for the Array(output), however the output does not count towards the space complexity.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(N), The space complexity of the above code is O(N) [considering recursive calls also]. The Space will be used to store the recursion stack. Extra space is only allocated for the Array(output), however the output does not count towards the space complexity.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N*2^N), The time complexity of the above code is O(N*2^N) since every index has 2\\n    choices and for all possible combinations, we\\u2019re checking the condition of being palindrome which takes\\n    linear time. Hence, the overall complexity is O(N*2^N).\\n\\n    Space Complexity : O(N), The space complexity of the above code is O(N) [considering recursive calls also].\\n    The Space will be used to store the recursion stack. Extra space is only allocated for the Array(output),\\n    however the output does not count towards the space complexity.\\n\\n    Solved using String + Backtracking. \\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool checkPalindrome(string s, int low, int high){\\n        while(low<high){\\n            if(s[low++] != s[high--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void partition(string& s, vector<vector<string>>& output, vector<string>& temp, int index){\\n        if(index == s.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(checkPalindrome(s, index, i)){\\n                temp.push_back(s.substr(index, i-index+1));\\n                partition(s, output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> temp; \\n        partition(s, output, temp, 0);\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N*2^N), The time complexity of the above code is O(N*2^N) since every index has 2\\n    choices and for all possible combinations, we\\u2019re checking the condition of being palindrome which takes\\n    linear time. Hence, the overall complexity is O(N*2^N).\\n\\n    Space Complexity : O(N), The space complexity of the above code is O(N) [considering recursive calls also].\\n    The Space will be used to store the recursion stack. Extra space is only allocated for the Array(output),\\n    however the output does not count towards the space complexity.\\n\\n    Solved using String + Backtracking. \\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool checkPalindrome(string s, int low, int high){\\n        while(low<high){\\n            if(s[low++] != s[high--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void partition(string& s, vector<vector<string>>& output, vector<string>& temp, int index){\\n        if(index == s.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(checkPalindrome(s, index, i)){\\n                temp.push_back(s.substr(index, i-index+1));\\n                partition(s, output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> temp; \\n        partition(s, output, temp, 0);\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085728,
                "title": "python3-642-ms-faster-than-94-04-of-python3-clean-and-easy-to-understand",
                "content": "```\\n    def __init__(self):\\n        self.result = collections.defaultdict(list)\\n        \\n    def partition(self, s: str) -> List[List[str]]:\\n        if not s: return [[]]\\n        if s in self.result: \\n            return self.result[s] \\n        output = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  \\n                for suf in self.partition(s[i:]):  \\n                    output.append([s[:i]] + suf)\\n        self.result[s] = output\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    def __init__(self):\\n        self.result = collections.defaultdict(list)\\n        \\n    def partition(self, s: str) -> List[List[str]]:\\n        if not s: return [[]]\\n        if s in self.result: \\n            return self.result[s] \\n        output = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  \\n                for suf in self.partition(s[i:]):  \\n                    output.append([s[:i]] + suf)\\n        self.result[s] = output\\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3084628,
                "title": "c-recursion",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<string>> res;\\n    bool ispalindrome(string &s) \\n    {\\n        int l=0, h=s.size()-1;\\n        while(l<h)\\n        {\\n            if(s[l]!=s[h]) return false;\\n            l++;\\n            h--;\\n        }\\n        return true;\\n    }\\n\\n    void find(int i, string &s, string temp, vector<string> valid)\\n    {\\n        if(i==s.size())\\n        {\\n            if(temp.empty())\\n                res.push_back(valid);\\n            return;\\n        } \\n\\n        temp += s[i];\\n        find(i+1, s, temp, valid);\\n        if(ispalindrome(temp))\\n        {\\n            valid.push_back(temp);\\n            find(i+1, s, \"\", valid);\\n        }\\n        \\n    }\\n\\n    vector<vector<string>> partition(string s) \\n    {\\n        vector<string> valid;\\n        find(0, s, \"\", valid);\\n        return res;   \\n    }\\n};\\n```\\n\\n# Please upvote if it helps...",
                "solutionTags": [
                    "C++",
                    "String",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<string>> res;\\n    bool ispalindrome(string &s) \\n    {\\n        int l=0, h=s.size()-1;\\n        while(l<h)\\n        {\\n            if(s[l]!=s[h]) return false;\\n            l++;\\n            h--;\\n        }\\n        return true;\\n    }\\n\\n    void find(int i, string &s, string temp, vector<string> valid)\\n    {\\n        if(i==s.size())\\n        {\\n            if(temp.empty())\\n                res.push_back(valid);\\n            return;\\n        } \\n\\n        temp += s[i];\\n        find(i+1, s, temp, valid);\\n        if(ispalindrome(temp))\\n        {\\n            valid.push_back(temp);\\n            find(i+1, s, \"\", valid);\\n        }\\n        \\n    }\\n\\n    vector<vector<string>> partition(string s) \\n    {\\n        vector<string> valid;\\n        find(0, s, \"\", valid);\\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084250,
                "title": "c-solution",
                "content": "# Code\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n*Upvote solution after using it*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083569,
                "title": "python-clear-simple-backtracking-solution",
                "content": "## **Please upvote/favourite/comment if you like this solution!**\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s):\\n        i, j = 0, len(s)-1\\n        while i <= j:\\n            if s[i] != s[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n\\n    def backtrack(self, s, combo, partitions):\\n        temp = list(combo)\\n        if self.isPalindrome(s):\\n            if tuple(temp+[s]) not in partitions:\\n                partitions.add(tuple(temp+[s]))\\n        for i in range(1,len(s)):\\n            if self.isPalindrome(s[:i]):\\n                self.backtrack(s[i:],tuple(temp+[s[:i]]),partitions)\\n\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions = set()\\n        self.backtrack(s,(),partitions)\\n        answer = []\\n        for p in partitions:\\n            answer.append(list(p))\\n        return answer\\n```\\n\\n# Complexity\\n- Time complexity: $$O(2^N \\\\cdot N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s):\\n        i, j = 0, len(s)-1\\n        while i <= j:\\n            if s[i] != s[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n\\n    def backtrack(self, s, combo, partitions):\\n        temp = list(combo)\\n        if self.isPalindrome(s):\\n            if tuple(temp+[s]) not in partitions:\\n                partitions.add(tuple(temp+[s]))\\n        for i in range(1,len(s)):\\n            if self.isPalindrome(s[:i]):\\n                self.backtrack(s[i:],tuple(temp+[s[:i]]),partitions)\\n\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions = set()\\n        self.backtrack(s,(),partitions)\\n        answer = []\\n        for p in partitions:\\n            answer.append(list(p))\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021960,
                "title": "simple-and-easily-explained",
                "content": "# Intuition\\nCheck for each index till last index, whether any partition is possible where palindrome is possible, where palindrome is possible is again will be palindrome possible again in its substring.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N^2)+O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isPalindrome(string s, int l, int r)\\n{\\n    while(l<=r)\\n    {\\n        if(s[l]!=s[r])\\n        {\\n            return false;\\n        }\\n        l++;\\n        r--;\\n    }\\n    return true;\\n}\\nvoid f(string s, int indx, vector<string>&ans, vector<vector<string>>&res)\\n{\\n    if(indx==s.length())\\n    {\\n        res.push_back(ans);\\n        return;\\n    }\\n    for(int i=indx;i<s.length();i++)\\n    {\\n        if(isPalindrome(s, indx, i))\\n        {\\n            ans.push_back(s.substr(indx, i-indx+1));\\n            f(s, i+1, ans, res);\\n            ans.pop_back();\\n        }\\n    }\\n}\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string>ans;\\n        f(s, 0, ans, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isPalindrome(string s, int l, int r)\\n{\\n    while(l<=r)\\n    {\\n        if(s[l]!=s[r])\\n        {\\n            return false;\\n        }\\n        l++;\\n        r--;\\n    }\\n    return true;\\n}\\nvoid f(string s, int indx, vector<string>&ans, vector<vector<string>>&res)\\n{\\n    if(indx==s.length())\\n    {\\n        res.push_back(ans);\\n        return;\\n    }\\n    for(int i=indx;i<s.length();i++)\\n    {\\n        if(isPalindrome(s, indx, i))\\n        {\\n            ans.push_back(s.substr(indx, i-indx+1));\\n            f(s, i+1, ans, res);\\n            ans.pop_back();\\n        }\\n    }\\n}\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string>ans;\\n        f(s, 0, ans, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969507,
                "title": "go-solution-recursive",
                "content": "#### Recursive\\n\\n```\\nfunc partition(s string) [][]string {\\n    if len(s) == 0 {\\n        return [][]string{{}}\\n    }\\n    if len(s) == 1 {\\n        return [][]string{{s}}\\n    }\\n    \\n    allPartitions := make([][]string, 0, len(s))\\n    for i := 0; i < len(s); i++ {\\n        candidate := s[:i+1]\\n        if palindrome(candidate) {\\n            remaining := partition(s[i+1:])\\n            for _, r := range remaining {\\n                partition := append([]string{candidate}, r...)\\n                allPartitions = append(allPartitions, partition)\\n            }\\n        }\\n    }\\n    \\n    return allPartitions\\n}\\n\\nfunc palindrome(s string) bool {\\n    if len(s) <= 1 {\\n        return true\\n    }\\n    if s[0] != s[len(s)-1] {\\n        return false\\n    }\\n    return palindrome(s[1:len(s)-1])\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc partition(s string) [][]string {\\n    if len(s) == 0 {\\n        return [][]string{{}}\\n    }\\n    if len(s) == 1 {\\n        return [][]string{{s}}\\n    }\\n    \\n    allPartitions := make([][]string, 0, len(s))\\n    for i := 0; i < len(s); i++ {\\n        candidate := s[:i+1]\\n        if palindrome(candidate) {\\n            remaining := partition(s[i+1:])\\n            for _, r := range remaining {\\n                partition := append([]string{candidate}, r...)\\n                allPartitions = append(allPartitions, partition)\\n            }\\n        }\\n    }\\n    \\n    return allPartitions\\n}\\n\\nfunc palindrome(s string) bool {\\n    if len(s) <= 1 {\\n        return true\\n    }\\n    if s[0] != s[len(s)-1] {\\n        return false\\n    }\\n    return palindrome(s[1:len(s)-1])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937665,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r)\\n            if (s[l++] != s[r--])\\n                return false;\\n        return true;\\n    }\\n    \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if (start == n) {\\n            pars.push_back(par);\\n            return;\\n        }\\n        for (int i = start; i < n; i++) {\\n            if (isPalindrome(s, start, i)) {\\n                par.push_back(s.substr(start, i - start + 1));\\n                partition(s, i + 1, par, pars);\\n                par.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\n    \\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r)\\n            if (s[l++] != s[r--])\\n                return false;\\n        return true;\\n    }\\n    \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if (start == n) {\\n            pars.push_back(par);\\n            return;\\n        }\\n        for (int i = start; i < n; i++) {\\n            if (isPalindrome(s, start, i)) {\\n                par.push_back(s.substr(start, i - start + 1));\\n                partition(s, i + 1, par, pars);\\n                par.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691427,
                "title": "my-java-code-with-short-explanations",
                "content": "Please upvote if this helped you.\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> answer = new ArrayList<>();\\n        List<String> partition = new ArrayList<>();\\n        backTrack(s, partition, answer);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (String s, List<String> partition , List<List<String>> answer){\\n        \\n        if(s.length() == 0){\\n            answer.add(new ArrayList<>(partition));\\n            return;\\n        }\\n        else{\\n            for(int i=0; i<s.length(); i++){\\n                //cs = current sub-string\\n                String cs = s.substring(0, i+1);\\n                \\n                if(isPalindrome(cs)){\\n                    partition.add(cs);\\n                    \\n                    //moving on with next string as previous sub-string is a successfull palindrome and added into partition\\n                    //ns = new sub-string (or) next sub-string\\n                    String ns = s.substring(i+1);\\n                    backTrack(ns, partition, answer);\\n                    //removing during backtracking- only inside if block not for every for loop iteration\\n                    partition.remove(partition.size()-1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public static boolean isPalindrome(String s){\\n        int l = 0;\\n        int r = s.length()-1;\\n        \\n        while(l < r){\\n            if(s.charAt(l) != s.charAt(r)){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> answer = new ArrayList<>();\\n        List<String> partition = new ArrayList<>();\\n        backTrack(s, partition, answer);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (String s, List<String> partition , List<List<String>> answer){\\n        \\n        if(s.length() == 0){\\n            answer.add(new ArrayList<>(partition));\\n            return;\\n        }\\n        else{\\n            for(int i=0; i<s.length(); i++){\\n                //cs = current sub-string\\n                String cs = s.substring(0, i+1);\\n                \\n                if(isPalindrome(cs)){\\n                    partition.add(cs);\\n                    \\n                    //moving on with next string as previous sub-string is a successfull palindrome and added into partition\\n                    //ns = new sub-string (or) next sub-string\\n                    String ns = s.substring(i+1);\\n                    backTrack(ns, partition, answer);\\n                    //removing during backtracking- only inside if block not for every for loop iteration\\n                    partition.remove(partition.size()-1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public static boolean isPalindrome(String s){\\n        int l = 0;\\n        int r = s.length()-1;\\n        \\n        while(l < r){\\n            if(s.charAt(l) != s.charAt(r)){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584744,
                "title": "most-optimised-c-time-and-space-complexity-solution",
                "content": "\\uD83D\\uDD25 Please **Upvote** it is **FREE** from your Side\\n\\n\\u26BD\\uFE0F **Approach:-** Partition from one character and go ahead and at each step check if it is a palindrome or not. Dry run a case you\\'ll understand\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkPalin(string s){\\n        string s1 = s;\\n        reverse(s.begin(), s.end());\\n        return s==s1;\\n    }\\n    \\n    void helper(string s, vector<string> &localResult, vector<vector<string>> &result){\\n        if(s.length() == 0){\\n            result.push_back(localResult);\\n            return;\\n        }\\n\\n        for(int i = 0; i<s.length(); i++){\\n            if(checkPalin(s.substr(0,i+1))){\\n                localResult.push_back(s.substr(0, i+1));\\n                helper(s.substr(i+1), localResult, result);\\n                localResult.pop_back();\\n            }\\n        }\\n        return;\\n\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n\\t    vector<string> localResult;\\n\\t    helper(s, localResult, result);\\n\\t    return result;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/62f04a79-3578-42f5-aa59-c1b2786c67b9_1663353697.7582333.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkPalin(string s){\\n        string s1 = s;\\n        reverse(s.begin(), s.end());\\n        return s==s1;\\n    }\\n    \\n    void helper(string s, vector<string> &localResult, vector<vector<string>> &result){\\n        if(s.length() == 0){\\n            result.push_back(localResult);\\n            return;\\n        }\\n\\n        for(int i = 0; i<s.length(); i++){\\n            if(checkPalin(s.substr(0,i+1))){\\n                localResult.push_back(s.substr(0, i+1));\\n                helper(s.substr(i+1), localResult, result);\\n                localResult.pop_back();\\n            }\\n        }\\n        return;\\n\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n\\t    vector<string> localResult;\\n\\t    helper(s, localResult, result);\\n\\t    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129667,
                "title": "simplest-python-backtracking-beats-97",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \\n        \\n        res = []\\n        \\n        #SOLUTION: at each recursive step, we are passing in the remaining word and a temp array\\n        def recurse(arr ,word):\\n            #if we used up all the characters for every word, we are done\\n            if not word:\\n                res.append(arr)\\n                return \\n            \\n            #we loop from 1 to len(word) + 1 in order to splice correctly\\n            for i in range(1, len(word) + 1):\\n                \\n                #for the string \\'aabb\\'\\n                    #iteration 1: curr = a\\n                    #iteration 2: curr = aa\\n                    #iteration 3: curr = aab\\n                    #iteration 4: curr = aabb\\n                curr = word[:i]\\n                \\n                #if its a palindrome, add it to the array then pass in the remaining characters to work with\\n                if curr ==curr[::-1]:\\n                    recurse(arr + [curr], word[i:])\\n                    \\n        \\n        recurse([], s)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \\n        \\n        res = []\\n        \\n        #SOLUTION: at each recursive step, we are passing in the remaining word and a temp array\\n        def recurse(arr ,word):\\n            #if we used up all the characters for every word, we are done\\n            if not word:\\n                res.append(arr)\\n                return \\n            \\n            #we loop from 1 to len(word) + 1 in order to splice correctly\\n            for i in range(1, len(word) + 1):\\n                \\n                #for the string \\'aabb\\'\\n                    #iteration 1: curr = a\\n                    #iteration 2: curr = aa\\n                    #iteration 3: curr = aab\\n                    #iteration 4: curr = aabb\\n                curr = word[:i]\\n                \\n                #if its a palindrome, add it to the array then pass in the remaining characters to work with\\n                if curr ==curr[::-1]:\\n                    recurse(arr + [curr], word[i:])\\n                    \\n        \\n        recurse([], s)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069656,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        self.helper(res, [], s)\\n        return res\\n\\n        \\n    def helper(self, res, curr, s):\\n        if s == \"\":\\n            res.append(curr)\\n\\n        for i in range(len(s)):\\n            if self.isPalindrome(s[:i + 1]):  \\n                self.helper(res, curr + [s[:i + 1]], s[i + 1:])\\n    def isPalindrome(self, s):\\n        for i in range(len(s) // 2):\\n            if s[i] != s[len(s) - 1 - i]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        self.helper(res, [], s)\\n        return res\\n\\n        \\n    def helper(self, res, curr, s):\\n        if s == \"\":\\n            res.append(curr)\\n\\n        for i in range(len(s)):\\n            if self.isPalindrome(s[:i + 1]):  \\n                self.helper(res, curr + [s[:i + 1]], s[i + 1:])\\n    def isPalindrome(self, s):\\n        for i in range(len(s) // 2):\\n            if s[i] != s[len(s) - 1 - i]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890881,
                "title": "python-easy-to-understand-iterative-backtracking-with-stack",
                "content": "I found that iterative backtracking is much more easy to understand than a recursive one.\\n\\n```\\n    def partition(self, s: str) -> List[List[str]]:\\n        \\n        ans = []\\n        \\n        stack = [(s,[])]\\n        \\n        while stack:\\n            \\n\\t\\t\\t# ds stands for decision space\\n            ds, path = stack.pop()\\n            \\n            if not ds:\\n                ans.append(path)\\n                continue\\n                      \\n            for i in range(len(ds)):\\n                if ds[:i+1] == ds[:i+1][::-1]:\\n                    path.append(ds[:i+1])\\n                    stack.append((ds[i+1:],path[:]))\\n                    path.pop()\\n                    \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n    def partition(self, s: str) -> List[List[str]]:\\n        \\n        ans = []\\n        \\n        stack = [(s,[])]\\n        \\n        while stack:\\n            \\n\\t\\t\\t# ds stands for decision space\\n            ds, path = stack.pop()\\n            \\n            if not ds:\\n                ans.append(path)\\n                continue\\n                      \\n            for i in range(len(ds)):\\n                if ds[:i+1] == ds[:i+1][::-1]:\\n                    path.append(ds[:i+1])\\n                    stack.append((ds[i+1:],path[:]))\\n                    path.pop()\\n                    \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1668351,
                "title": "java-easy-recursion-code",
                "content": "```\\nclass Solution {\\n     List<List<String>> ans=new ArrayList<>();\\n   \\n    public boolean isPalindrome(String s){\\n        \\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)!=s.charAt(n-i-1))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    public void palpar(List<String> l,String s,int k){\\n        \\n        if(k+1==s.length()){\\n            ans.add(l);\\n            return;\\n        }\\n        \\n        for(int i=k+1;i<s.length();i++){\\n            \\n            String ns=s.substring(k+1,i+1);\\n            if(isPalindrome(ns)){\\n                List<String > nl=new ArrayList<>(l);\\n                nl.add(ns);\\n                palpar(nl,s,i);\\n                \\n                }\\n        }\\n        \\n    }\\n    public List<List<String>> partition(String s) {\\n       \\n        \\n        palpar(new ArrayList<>(),s,-1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n     List<List<String>> ans=new ArrayList<>();\\n   \\n    public boolean isPalindrome(String s){\\n        \\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)!=s.charAt(n-i-1))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    public void palpar(List<String> l,String s,int k){\\n        \\n        if(k+1==s.length()){\\n            ans.add(l);\\n            return;\\n        }\\n        \\n        for(int i=k+1;i<s.length();i++){\\n            \\n            String ns=s.substring(k+1,i+1);\\n            if(isPalindrome(ns)){\\n                List<String > nl=new ArrayList<>(l);\\n                nl.add(ns);\\n                palpar(nl,s,i);\\n                \\n                }\\n        }\\n        \\n    }\\n    public List<List<String>> partition(String s) {\\n       \\n        \\n        palpar(new ArrayList<>(),s,-1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390844,
                "title": "java-solution-dfs-backtracking-explained",
                "content": "Please upvote, if you like my solution & explanation \\uD83D\\uDE0A\\n\\n**Explanation:**\\n\\nIn this solution, we will use DFS and backtracking to compute the partitions of the strings.\\n\\n1. We will iterate the string from starting to end.\\n2. During each iteration, we will divide the string like below:\\n\\t**s = prefix + suffix** (prefix should be a valid palindrome)\\n3. Collect the prefix in a list and make recursion call for suffix\\n4. During backtracking remove the prefix from the list\\n\\nDry Run: \\n1) We need to ensure that the prefix we create is a valid Palindrome\\n\\tEx. s = \"aab\"\\n\\t\\n\\t - 1st iteration for \"aab\"\\n\\t\\t\\tprefix = \"a\" (Valid Palindrome)\\n\\t\\t\\tsuffix = \"ab\"  (Rest of the String)\\n\\t\\t\\tCollect prefix **\"a\"**, further do partitioning for suffix **ab** and then remove this prefix from the list.\\n\\t\\t\\t\\n\\t- 1st iteration for \"ab\"\\n\\t\\t\\tprefix = \"a\" (Valid Palindrome)\\n\\t\\t\\tsuffix = \"b\"\\n\\t\\t\\tCollect prefix **\"a\"**, further do partitioning for suffix **b** and then remove this prefix from the list.\\n\\t\\t\\n\\t- 1st iteration for \"b\"\\n\\t\\t\\tprefix = \"b\" (Valid Palindrome)\\n\\t\\t\\tsuffix = \"\"\\n\\t\\t\\tCollect prefix **\"b\"**, further do partitioning for suffix **\"\"** and then remove this prefix from the list.\\n\\t\\t\\t\\n\\t-  2nd iteration for \"aab\"\\n\\t\\t\\tprefix = \"aa\" (Valid Palindrome)\\n\\t\\t\\tsuffix = \"b\"  (Rest of the String)\\n\\t\\t\\tCollect prefix **\"aa\"**, further do partitioning for suffix **\"b\"** and then remove this prefix from the list.\\n\\t\\t\\n\\t- 1st iteration for \"b\"\\n\\t\\t\\tprefix = \"b\" (Valid Palindrome)\\n\\t\\t\\tsuffix = \"\"  (Rest of the String)\\n\\t\\t\\tCollect prefix **\"b\"**, further do partitioning for suffix **\"\"** and then remove this prefix from the list.\\n\\n***Base Case**: when the s becomes empty then you can add all the collected prefix in the result list and return.*\\n\\t\\n```\\n   public List<List<String>> partition(String s) {\\n        List<List<String>> lists = new ArrayList<>();\\n        partitionHelper(s, new ArrayList<>(), lists);\\n        return lists;\\n    }\\n    \\n    public void partitionHelper(String s, ArrayList<String> list, List<List<String>> lists){\\n        if(s.length() == 0){\\n            ArrayList<String> res = new ArrayList<>();\\n            res.addAll(list);\\n            lists.add(res);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            String prefix = s.substring(0, i + 1);\\n            String ros = s.substring(i + 1);\\n            if(isPalindrome(prefix)){\\n                list.add(prefix);\\n                partitionHelper(ros, list, lists);\\n\\t\\t\\t\\t// remove the last item from the list during backtracking\\n                list.remove(list.size() - 1); \\n            }\\n        }\\n    }\\n    \\n    public boolean isPalindrome(String s){\\n        int li = 0;\\n        int ri = s.length() - 1;\\n        while(li < ri){\\n            char left = s.charAt(li);\\n            char right = s.charAt(ri);\\n            li++;\\n            ri--;\\n            if(left!=right){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\n![image](https://assets.leetcode.com/users/images/1d23dc9b-61e6-44ca-8026-a39b7dcf4780_1628411969.8208523.png)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n   public List<List<String>> partition(String s) {\\n        List<List<String>> lists = new ArrayList<>();\\n        partitionHelper(s, new ArrayList<>(), lists);\\n        return lists;\\n    }\\n    \\n    public void partitionHelper(String s, ArrayList<String> list, List<List<String>> lists){\\n        if(s.length() == 0){\\n            ArrayList<String> res = new ArrayList<>();\\n            res.addAll(list);\\n            lists.add(res);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            String prefix = s.substring(0, i + 1);\\n            String ros = s.substring(i + 1);\\n            if(isPalindrome(prefix)){\\n                list.add(prefix);\\n                partitionHelper(ros, list, lists);\\n\\t\\t\\t\\t// remove the last item from the list during backtracking\\n                list.remove(list.size() - 1); \\n            }\\n        }\\n    }\\n    \\n    public boolean isPalindrome(String s){\\n        int li = 0;\\n        int ri = s.length() - 1;\\n        while(li < ri){\\n            char left = s.charAt(li);\\n            char right = s.charAt(ri);\\n            li++;\\n            ri--;\\n            if(left!=right){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352737,
                "title": "python-dp-solution-93-31",
                "content": "My approach in DP is of tabulation. So my table is a 1D table, which contains list of all possible substring combinations which forms a palindrome, upto that index (so list of list).\\n\\n3 conditions for my approach of DP:\\n1) All single character subsstrings, are palindrome.\\n2) For all lists in table[i-1] with single final character, check whether that is same as the i-th character in string. If so, then it means a 2-character palindrome. (e.g, \"aa\").\\n3) For all lists in table[i-1] with single penultimate character, check whether that is same as the i-th character in string. If so, then it means a 2+ - character palindrome. (e.g, a + <anything> + a)\\n\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        table = [[] for _ in s]\\n        table[0].append([s[0]])\\n        for i, ch in enumerate(s[1:]):\\n            for item in table[i]:\\n                # Single character\\n                table[i+1].append(item + [ch])\\n                # palindrome of 2 chars\\n                if len(item) >= 1 and len(item[-1]) == 1 and item[-1] == ch:\\n                    temp = item[-1] + ch\\n                    table[i+1].append(item[:-1] + [temp])\\n                # Palindrome of >2 chars\\n                if len(item) >= 2 and len(item[-2]) == 1 and item[-2] == ch:\\n                    temp = item[-2] + item[-1] + ch\\n                    table[i+1].append(item[:-2] + [temp])\\n        return table[-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        table = [[] for _ in s]\\n        table[0].append([s[0]])\\n        for i, ch in enumerate(s[1:]):\\n            for item in table[i]:\\n                # Single character\\n                table[i+1].append(item + [ch])\\n                # palindrome of 2 chars\\n                if len(item) >= 1 and len(item[-1]) == 1 and item[-1] == ch:\\n                    temp = item[-1] + ch\\n                    table[i+1].append(item[:-1] + [temp])\\n                # Palindrome of >2 chars\\n                if len(item) >= 2 and len(item[-2]) == 1 and item[-2] == ch:\\n                    temp = item[-2] + item[-1] + ch\\n                    table[i+1].append(item[:-2] + [temp])\\n        return table[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332296,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool isPal(string &s)\\n    {\\n        for(int i=0;i<s.length()/2;i++)\\n        {\\n            if(s[i]!=s[s.length()-i-1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void helper(string &s,int index,vector<string>&curr,vector<vector<string>>&ans)\\n    {\\n        if(index==s.length())\\n        {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        string tmp=\"\";\\n        for(int i=index;i<s.length();i++)\\n        {\\n            tmp.push_back(s[i]);\\n            if(isPal(tmp))\\n            {\\n                curr.push_back(tmp);\\n                helper(s,i+1,curr,ans);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s)\\n    {\\n        vector<string>curr;\\n        vector<vector<string>>ans;\\n        helper(s,0,curr,ans);\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isPal(string &s)\\n    {\\n        for(int i=0;i<s.length()/2;i++)\\n        {\\n            if(s[i]!=s[s.length()-i-1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void helper(string &s,int index,vector<string>&curr,vector<vector<string>>&ans)\\n    {\\n        if(index==s.length())\\n        {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        string tmp=\"\";\\n        for(int i=index;i<s.length();i++)\\n        {\\n            tmp.push_back(s[i]);\\n            if(isPal(tmp))\\n            {\\n                curr.push_back(tmp);\\n                helper(s,i+1,curr,ans);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s)\\n    {\\n        vector<string>curr;\\n        vector<vector<string>>ans;\\n        helper(s,0,curr,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262398,
                "title": "python-recursion",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        self.ans=[]\\n        ds=[]\\n        self.solve(0,s,ds)\\n        return self.ans\\n    def solve(self,idx,s,ds):\\n        if idx==len(s):\\n            self.ans.append(ds[:])\\n            return\\n        for i in range(idx,len(s)):\\n            if s[idx:i+1]==s[idx:i+1][::-1]:\\n                ds.append(s[idx:i+1])\\n                self.solve(i+1,s,ds)\\n                ds.pop()\\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        self.ans=[]\\n        ds=[]\\n        self.solve(0,s,ds)\\n        return self.ans\\n    def solve(self,idx,s,ds):\\n        if idx==len(s):\\n            self.ans.append(ds[:])\\n            return\\n        for i in range(idx,len(s)):\\n            if s[idx:i+1]==s[idx:i+1][::-1]:\\n                ds.append(s[idx:i+1])\\n                self.solve(i+1,s,ds)\\n                ds.pop()\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174542,
                "title": "java-easy-readable-code-question-answer-approach",
                "content": "**Approch :**\\nthis is a generall approch to solve lot of backtracking question make a function and pass parameter as question and answer . build answer while going up.\\n**CODE:**\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        result=new ArrayList<>();\\n        partitionHelper(s,new ArrayList<>());\\n        return result;\\n    }\\n    private List<List<String>> result;\\n    \\n    private boolean isPalindrome(String str){\\n        int low=0 , high=str.length()-1;\\n        \\n        while(low<high){\\n            if(str.charAt(low)!=str.charAt(high)) return false;\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    private void partitionHelper(String ques,List<String> ans){\\n        if(ques.length()==0){\\n            result.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        \\n        for(int i=0;i<ques.length();i++){\\n            String prefix=ques.substring(0,i+1);\\n            if(isPalindrome(prefix)){\\n          String ros=ques.substring(i+1); //ros: rest of string\\n                ans.add(prefix);\\n                partitionHelper(ros,ans);\\n                ans.remove(ans.size()-1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Complexity:**\\n`Time:O(2^n) and Space:O(n)` where n:length of string\\n\\n**Similar problem for Pratice:**\\n[subsets](https://leetcode.com/problems/subsets/)\\n[letter-combinations-of-a-phone-number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\\n[k-th-symbol-in-grammar/)](https://leetcode.com/problems/k-th-symbol-in-grammar/)\\ngo to pepcoding or aditya verma youtube channel to get command on this general approch .\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        result=new ArrayList<>();\\n        partitionHelper(s,new ArrayList<>());\\n        return result;\\n    }\\n    private List<List<String>> result;\\n    \\n    private boolean isPalindrome(String str){\\n        int low=0 , high=str.length()-1;\\n        \\n        while(low<high){\\n            if(str.charAt(low)!=str.charAt(high)) return false;\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    private void partitionHelper(String ques,List<String> ans){\\n        if(ques.length()==0){\\n            result.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        \\n        for(int i=0;i<ques.length();i++){\\n            String prefix=ques.substring(0,i+1);\\n            if(isPalindrome(prefix)){\\n          String ros=ques.substring(i+1); //ros: rest of string\\n                ans.add(prefix);\\n                partitionHelper(ros,ans);\\n                ans.remove(ans.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125624,
                "title": "easy-and-simple-backtracking-96-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        helper(res,curr,0,s);\\n        return res;\\n    }\\n    void helper(vector<vector<string>>& res,vector<string>& curr,int i,string &s)\\n    {\\n        if(i>=s.size())\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        for(int start =i;start<s.size();start++)\\n        {\\n            if(isvalid(s,i,start))\\n            {\\n                curr.push_back(s.substr(i,start-i+1));\\n                helper(res,curr,start+1,s);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    bool isvalid(string &s, int low, int high) {\\n        while (low < high) {\\n            if (s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        helper(res,curr,0,s);\\n        return res;\\n    }\\n    void helper(vector<vector<string>>& res,vector<string>& curr,int i,string &s)\\n    {\\n        if(i>=s.size())\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        for(int start =i;start<s.size();start++)\\n        {\\n            if(isvalid(s,i,start))\\n            {\\n                curr.push_back(s.substr(i,start-i+1));\\n                helper(res,curr,start+1,s);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    bool isvalid(string &s, int low, int high) {\\n        while (low < high) {\\n            if (s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089155,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \"\"\"DP.\"\"\"\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[n] = [[]]\\n        #  Candidate substring is [begin, end), includes begin, excludes end\\n        for begin in range(n - 1, -1, -1):\\n            for end in range(begin + 1, n + 1):\\n                candidate = s[begin:end]\\n                # Reverse and equal is palindrome.\\n                if candidate == candidate[::-1]:\\n                     for each in dp[end]:\\n                         new_each = [candidate]\\n                         new_each.extend(each)\\n                         dp[begin].append(new_each)\\n        return dp[0]  \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \"\"\"DP.\"\"\"\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[n] = [[]]\\n        #  Candidate substring is [begin, end), includes begin, excludes end\\n        for begin in range(n - 1, -1, -1):\\n            for end in range(begin + 1, n + 1):\\n                candidate = s[begin:end]\\n                # Reverse and equal is palindrome.\\n                if candidate == candidate[::-1]:\\n                     for each in dp[end]:\\n                         new_each = [candidate]\\n                         new_each.extend(each)\\n                         dp[begin].append(new_each)\\n        return dp[0]  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012218,
                "title": "c-dp-backtracking",
                "content": "```\\n#define vvb vector<vector<bool>>\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> finalAns;\\n    vector<string> ans;\\n    int n;\\n    \\n    // O(2^N)\\n    void findPalindromes(string &s, int st, vvb &isPalin) {\\n        \\n        if(st == n) {\\n            finalAns.push_back(ans);\\n            return;\\n        }\\n        \\n        string currString = \"\";\\n        \\n        for(int en = st ; en < n ; en++) { \\n            \\n            if( st == en or (s[st] == s[en] and (st+1==en or isPalin[st+1][en-1])) ) {\\n                isPalin[st][en] = true;\\n            }\\n            \\n            currString += s[en]; // substr not used\\n                        \\n            if(isPalin[st][en]) {\\n                ans.push_back(currString);\\n                findPalindromes(s,en+1,isPalin); \\n                ans.pop_back();\\n            } \\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        n = s.size();    \\n        vector<vector<bool>> isPalin(n, vector<bool>(n,false));\\n        findPalindromes(s,0,isPalin);\\n        return finalAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define vvb vector<vector<bool>>\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> finalAns;\\n    vector<string> ans;\\n    int n;\\n    \\n    // O(2^N)\\n    void findPalindromes(string &s, int st, vvb &isPalin) {\\n        \\n        if(st == n) {\\n            finalAns.push_back(ans);\\n            return;\\n        }\\n        \\n        string currString = \"\";\\n        \\n        for(int en = st ; en < n ; en++) { \\n            \\n            if( st == en or (s[st] == s[en] and (st+1==en or isPalin[st+1][en-1])) ) {\\n                isPalin[st][en] = true;\\n            }\\n            \\n            currString += s[en]; // substr not used\\n                        \\n            if(isPalin[st][en]) {\\n                ans.push_back(currString);\\n                findPalindromes(s,en+1,isPalin); \\n                ans.pop_back();\\n            } \\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        n = s.size();    \\n        vector<vector<bool>> isPalin(n, vector<bool>(n,false));\\n        findPalindromes(s,0,isPalin);\\n        return finalAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728379,
                "title": "python-two-solutions-dp-and-backtracking",
                "content": "##### DP:\\n\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        @lru_cache(maxsize=None)\\n        def helper(idx):\\n            if idx == len(s):\\n                return [[]]\\n            \\n            result = list()\\n            \\n            for i in range(idx, len(s)):\\n                if s[idx:i+1] == s[idx:i+1][::-1]:\\n                    sub_partitions = helper(i+1)\\n                    result += [[s[idx:i+1]] + p for p in sub_partitions]    \\n            return result\\n        \\n        return helper(0)\\n```\\n\\nTime: O(n * 2^n)\\nSpace: O(2^n)\\n\\n#### Backtracking:\\n\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def helper(idx, path):\\n            if idx == len(s):\\n                result.append(path[:])\\n                return\\n            \\n            for i in range(idx, len(s)):\\n                if s[idx:i+1] == s[idx:i+1][::-1]:\\n                    path.append(s[idx:i+1])\\n                    helper(i+1, path)\\n                    path.pop()\\n            \\n        result = list()\\n        helper(0, [])\\n        return result\\n```\\n\\nTime: O(n * 2^n)\\nSpace: O(2^n)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        @lru_cache(maxsize=None)\\n        def helper(idx):\\n            if idx == len(s):\\n                return [[]]\\n            \\n            result = list()\\n            \\n            for i in range(idx, len(s)):\\n                if s[idx:i+1] == s[idx:i+1][::-1]:\\n                    sub_partitions = helper(i+1)\\n                    result += [[s[idx:i+1]] + p for p in sub_partitions]    \\n            return result\\n        \\n        return helper(0)\\n```\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def helper(idx, path):\\n            if idx == len(s):\\n                result.append(path[:])\\n                return\\n            \\n            for i in range(idx, len(s)):\\n                if s[idx:i+1] == s[idx:i+1][::-1]:\\n                    path.append(s[idx:i+1])\\n                    helper(i+1, path)\\n                    path.pop()\\n            \\n        result = list()\\n        helper(0, [])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525250,
                "title": "java-dfs-very-readable-solution-beat-95-67",
                "content": "If you have any trouble to understand. Don\\'t hesitate to ask.\\n```\\nclass Solution {\\n    String s;\\n    int n;\\n    List<List<String>> ans;\\n    public List<List<String>> partition(String s) {\\n        if(s==null || s.length()==0){\\n            return new ArrayList();\\n        }\\n        this.ans = new ArrayList();\\n        this.s = s;\\n        this.n = s.length();\\n        recursive(new ArrayList(), 0);\\n        return ans;\\n    }\\n    \\n    public void recursive(List<String> list,int l){\\n        if(l==n){\\n            ans.add(list);\\n            return;\\n        }\\n        \\n        int i=l;\\n        \\n        while(i<n){\\n            if(isPalindrome(l, i)){\\n                List<String> list2 = new ArrayList(list);\\n                list2.add(s.substring(l, i+1));\\n                recursive(list2, i+1);\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int l, int r){\\n        while(l<r){\\n            if(s.charAt(l) != s.charAt(r)){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String s;\\n    int n;\\n    List<List<String>> ans;\\n    public List<List<String>> partition(String s) {\\n        if(s==null || s.length()==0){\\n            return new ArrayList();\\n        }\\n        this.ans = new ArrayList();\\n        this.s = s;\\n        this.n = s.length();\\n        recursive(new ArrayList(), 0);\\n        return ans;\\n    }\\n    \\n    public void recursive(List<String> list,int l){\\n        if(l==n){\\n            ans.add(list);\\n            return;\\n        }\\n        \\n        int i=l;\\n        \\n        while(i<n){\\n            if(isPalindrome(l, i)){\\n                List<String> list2 = new ArrayList(list);\\n                list2.add(s.substring(l, i+1));\\n                recursive(list2, i+1);\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int l, int r){\\n        while(l<r){\\n            if(s.charAt(l) != s.charAt(r)){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520914,
                "title": "easy-to-understand-python-backtrack-beat-80",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def ispalindrome(s):\\n            return True if s == s[::-1] else False\\n        results = []\\n        n = len(s)\\n\\t\\t#use par to store current results, cur_pos to store current index (left used and right remain)\\n        def backtrack(cur_pos, par):\\n            #the following judging methods are both correct\\n            if cur_pos == n:\\n            #if \"\".join(par) == s:\\n                results.append(par[:])\\n            else:\\n                for i in range(cur_pos+1, n+1):\\n\\t\\t\\t\\t#find a current par string, add into par then try to find more in remain elements\\n                    if ispalindrome(s[cur_pos:i]):\\n                        par.append(s[cur_pos:i])\\n                        backtrack(i,par)\\n                        par.pop()\\n        \\n        backtrack(0, [])\\n        return results\\n            \\n            \\n            \\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def ispalindrome(s):\\n            return True if s == s[::-1] else False\\n        results = []\\n        n = len(s)\\n\\t\\t#use par to store current results, cur_pos to store current index (left used and right remain)\\n        def backtrack(cur_pos, par):\\n            #the following judging methods are both correct\\n            if cur_pos == n:\\n            #if \"\".join(par) == s:\\n                results.append(par[:])\\n            else:\\n                for i in range(cur_pos+1, n+1):\\n\\t\\t\\t\\t#find a current par string, add into par then try to find more in remain elements\\n                    if ispalindrome(s[cur_pos:i]):\\n                        par.append(s[cur_pos:i])\\n                        backtrack(i,par)\\n                        par.pop()\\n        \\n        backtrack(0, [])\\n        return results\\n            \\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 324319,
                "title": "c-60-beat-iterative-solution-o-2-n",
                "content": "I counted the number of calls, it\\'s exactly O(2 ^ N) for worst case.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> aResult;\\n        vector<string> aTemp;\\n        helper(aResult, s, aTemp, 0);\\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<string>> &pResult, string &pString, vector<string> &pTemp, int pIndex) {\\n        \\n        if (pIndex >= pString.size()) {\\n            pResult.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int aLen=1;pIndex+aLen<=pString.size();aLen++) {\\n            string aChunk = pString.substr(pIndex, aLen);\\n            if (isPally(aChunk)) {\\n                pTemp.push_back(aChunk);\\n                helper(pResult, pString, pTemp, pIndex + aLen);\\n                pTemp.pop_back();\\n            }   \\n        }\\n    }\\n    \\n    bool isPally(string &s) {\\n        int aLo = 0;\\n        int aHi = s.size() - 1;\\n        while (aLo < aHi) {\\n            if (s[aLo] != s[aHi]) { return false; }\\n            aLo++;\\n            aHi--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> aResult;\\n        vector<string> aTemp;\\n        helper(aResult, s, aTemp, 0);\\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<string>> &pResult, string &pString, vector<string> &pTemp, int pIndex) {\\n        \\n        if (pIndex >= pString.size()) {\\n            pResult.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int aLen=1;pIndex+aLen<=pString.size();aLen++) {\\n            string aChunk = pString.substr(pIndex, aLen);\\n            if (isPally(aChunk)) {\\n                pTemp.push_back(aChunk);\\n                helper(pResult, pString, pTemp, pIndex + aLen);\\n                pTemp.pop_back();\\n            }   \\n        }\\n    }\\n    \\n    bool isPally(string &s) {\\n        int aLo = 0;\\n        int aHi = s.size() - 1;\\n        while (aLo < aHi) {\\n            if (s[aLo] != s[aHi]) { return false; }\\n            aLo++;\\n            aHi--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287345,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<IList<string>> Partition(string s) {\\n        var result = new List<IList<string>>();\\n\\n        var n = s.Length;\\n        if (n == 0) return result;\\n\\n        DFS(s, new List<string>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(string s, IList<string> oneResult, IList<IList<string>> result) {\\n        var n = s.Length;\\n\\n        if (n == 0) {\\n            result.Add(new List<string>(oneResult));\\n        } else {\\n            for (int count = 1; count <= n; count++) {\\n                var firstStr = s.Substring(0, count);\\n                if (isPalindrome(firstStr)) {\\n                    oneResult.Add(firstStr);\\n                    var restStr = s.Substring(count, n - count);\\n                    DFS(restStr, oneResult, result);\\n                    oneResult.RemoveAt(oneResult.Count - 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    private bool isPalindrome(string s) {\\n        var left = 0;\\n        var right = s.Length - 1;\\n        while (left < right) {\\n            if (s[left] != s[right]) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> Partition(string s) {\\n        var result = new List<IList<string>>();\\n\\n        var n = s.Length;\\n        if (n == 0) return result;\\n\\n        DFS(s, new List<string>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(string s, IList<string> oneResult, IList<IList<string>> result) {\\n        var n = s.Length;\\n\\n        if (n == 0) {\\n            result.Add(new List<string>(oneResult));\\n        } else {\\n            for (int count = 1; count <= n; count++) {\\n                var firstStr = s.Substring(0, count);\\n                if (isPalindrome(firstStr)) {\\n                    oneResult.Add(firstStr);\\n                    var restStr = s.Substring(count, n - count);\\n                    DFS(restStr, oneResult, result);\\n                    oneResult.RemoveAt(oneResult.Count - 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    private bool isPalindrome(string s) {\\n        var left = 0;\\n        var right = s.Length - 1;\\n        while (left < right) {\\n            if (s[left] != s[right]) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187586,
                "title": "short-and-clean-python-solution-beating-98-solutions",
                "content": "Use DP array to store intermediate results, and traverse from left to right. \n\n```\nclass Solution:\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        def is_palindrome(s, l, r):\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n            \n        ans = [[] for _ in range(len(s)+1)]\n        ans[0].append([])\n        for i in range(len(s)):\n            for start in range(i+1):\n                if is_palindrome(s, start, i):\n                    substr = s[start:i+1]\n                    for parts in ans[start]:\n                        ans[i+1].append(parts + [substr])\n        return ans[-1]\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        def is_palindrome(s, l, r):\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n            \n        ans = [[] for _ in range(len(s)+1)]\n        ans[0].append([])\n        for i in range(len(s)):\n            for start in range(i+1):\n                if is_palindrome(s, start, i):\n                    substr = s[start:i+1]\n                    for parts in ans[start]:\n                        ans[i+1].append(parts + [substr])\n        return ans[-1]\n```",
                "codeTag": "Java"
            },
            {
                "id": 42069,
                "title": "share-my-25-line-java-code-with-brief-explanation-beats-87-05-run-times",
                "content": "    /*\\n        s[i...j] (isPalin[i][j])\\u662f\\u4e0d\\u662fpalindromic? \\u901a\\u8fc7(s[i]==s[j] && dp[i+1][j-1])\\u6765\\u5224\\u65ad.\\n        \\n           a  a  b\\n        a  y  y  n\\n        a     y  n\\n        b        y\\n        \\n        \\u5269\\u4e0b\\u7684\\u4e8b\\u60c5\\u5c31\\u662f\\u505a\\u4e00\\u4e2adfs.\\n    */\\n    public class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> ans = new ArrayList<>();\\n            if (s==null || s.length()==0) { return ans; }\\n            int length = s.length();\\n            boolean[][] isPalin = new boolean[length][length];\\n            for (int i=0, count=length, cont; i<length; ++i, --count) {\\n                for (int j=0; j<count; ++j) {\\n                    isPalin[j][i+j] = s.charAt(j)==s.charAt(i+j) && (j+1>=i+j-1 ? true : isPalin[j+1][i+j-1]);\\n                }\\n            }\\n            dfs(ans, new ArrayList<String>(), s, isPalin, 0);\\n            return ans;\\n        }\\n        \\n        private void dfs(List<List<String>> ans, List<String> list, String s, boolean[][] isPalin, int row) {\\n            int length = s.length();\\n            if (row == length) { ans.add(new ArrayList<String>(list)); return; }\\n            for (int i=row; i<length; ++i) {\\n                if (isPalin[row][i]) {\\n                    list.add(s.substring(row, i+1));\\n                    dfs(ans, list, s, isPalin, i+1);\\n                    list.remove(list.size()-1);\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> ans = new ArrayList<>();\\n            if (s==null || s.length()==0) { return ans; }",
                "codeTag": "Java"
            },
            {
                "id": 42140,
                "title": "my-c-solution-13ms",
                "content": "    class Solution {\\n    \\tvector<vector<string> > partitionRes;\\n    \\tvector<string> oneRes;\\n    public:\\n        \\tvoid findpartition(const string &s){\\n        \\t\\tfor(int i=1; i<=s.size(); i++){\\n        \\t\\t    int l=0, r=i-1;\\n        \\t\\t\\twhile( l <= r) {\\n        \\t\\t\\t    if(s[l] != s[r]) break;\\n        \\t\\t\\t    l++; r--;\\n        \\t\\t\\t}\\n        \\t\\t\\tif(l > r){\\n        \\t\\t\\t\\toneRes.push_back(s.substr(0 ,i));\\n        \\t\\t\\t\\tif(i == s.size())partitionRes.push_back(oneRes);\\n        \\t\\t\\t\\tfindpartition(s.substr(i));\\n        \\t\\t\\t\\toneRes.pop_back();\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tvector<vector<string> > partition(string s) {\\n    \\t    \\tfindpartition(s);\\n    \\t\\t    return partitionRes;\\n        \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    \\tvector<vector<string> > partitionRes;\\n    \\tvector<string> oneRes;\\n    public:\\n        \\tvoid findpartition(const string &s){\\n        \\t\\tfor(int i=1; i<=s.size(); i++){\\n        \\t\\t    int l=0, r=i-1;\\n        \\t\\t\\twhile( l <= r) {\\n        \\t\\t\\t    if(s[l] != s[r]) break;\\n        \\t\\t\\t    l++; r--;\\n        \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3684133,
                "title": "c-backtracking-solution",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int countLength(vector<string> v) {\\n        int length = 0;\\n        for(int i = 0; i < v.size(); i++) {\\n            length += v[i].size();\\n        }\\n        return length;\\n    }\\n    bool isPalindrome(string s) {\\n        int n = s.size();\\n        if(n == 1) return true;\\n        int i = 0, j = n-1;\\n        while(i < j) {\\n            if(s[i] != s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    void backTrack(vector<vector<string>>& res, vector<string>& curr, string& s, int start) {\\n        if(countLength(curr) == s.size())\\n            res.push_back(curr);\\n        \\n        for(int i = start; i < s.size(); i++) {\\n            string temp = s.substr(start, i-start+1);\\n            if(!isPalindrome(temp)) continue;\\n            curr.push_back(temp);\\n            backTrack(res, curr, s, i+1);\\n            curr.pop_back();\\n        }\\n    }\\n\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        backTrack(res, curr, s, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countLength(vector<string> v) {\\n        int length = 0;\\n        for(int i = 0; i < v.size(); i++) {\\n            length += v[i].size();\\n        }\\n        return length;\\n    }\\n    bool isPalindrome(string s) {\\n        int n = s.size();\\n        if(n == 1) return true;\\n        int i = 0, j = n-1;\\n        while(i < j) {\\n            if(s[i] != s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    void backTrack(vector<vector<string>>& res, vector<string>& curr, string& s, int start) {\\n        if(countLength(curr) == s.size())\\n            res.push_back(curr);\\n        \\n        for(int i = start; i < s.size(); i++) {\\n            string temp = s.substr(start, i-start+1);\\n            if(!isPalindrome(temp)) continue;\\n            curr.push_back(temp);\\n            backTrack(res, curr, s, i+1);\\n            curr.pop_back();\\n        }\\n    }\\n\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        backTrack(res, curr, s, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200212,
                "title": "131-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Use a backtracking approach to generate all the possible palindrome partitions.\\n- For each character of the string, consider all possible substrings starting at the current character and check if it\\'s a palindrome.\\n- If it\\'s a palindrome, add it to the current partition and recursively find all partitions that can be formed from the rest of the string.\\n- When we have traversed the whole string, add the current partition to the final result.\\n\\nAlgorithm:\\n\\n1. Create a list to store the final result.\\n2. Create an empty list to store the current partition.\\n3.  Write a recursive function to generate all the possible partitions.\\n4. In the function, check if the current partition is a valid palindrome partition or not. If it\\'s valid, add the current partition to the final result.\\n5. For each character of the string, consider all possible substrings starting at the current character and check if it\\'s a palindrome. If it\\'s a palindrome, add it to the current partition and recursively find all partitions that can be formed from the rest of the string.\\n6. When we have traversed the whole string, add the current partition to the final result.\\n7. Return the final result.\\n\\n# Complexity\\n- Time complexity:\\nO(n*(2^n)) where n is the length of the string s. In the worst case, we have 2^n possible partitions, and for each partition, we need to check if it\\'s a valid palindrome partition or not, which takes O(n) time.\\n\\n- Space complexity:\\nO(n) where n is the length of the string s. The maximum depth of the recursion tree is n. At each level of the recursion tree, we create a new partition of length n. Therefore, the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []  # final result to store all possible palindrome partitions\\n        curr_partition = []  # to store the current partition\\n        \\n        def is_palindrome(s, i, j):\\n            # check if substring s[i:j+1] is a palindrome or not\\n            while i < j:\\n                if s[i] != s[j]:\\n                    return False\\n                i += 1\\n                j -= 1\\n            return True\\n        \\n        def backtrack(start):\\n            # base case: if we have traversed the whole string, add the current partition to the final result\\n            if start >= len(s):\\n                res.append(curr_partition.copy())\\n                return\\n            \\n            # for each character of the string, consider all possible substrings starting at the current character\\n            for end in range(start, len(s)):\\n                # check if the substring is a palindrome or not\\n                if is_palindrome(s, start, end):\\n                    # if it\\'s a palindrome, add it to the current partition and recursively find all partitions that can be formed from the rest of the string\\n                    curr_partition.append(s[start:end+1])\\n                    backtrack(end+1)\\n                    curr_partition.pop()  # backtrack to remove the last added substring\\n        \\n        backtrack(0)  # start the recursive function from the first character of the string\\n        return res  # return the final result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []  # final result to store all possible palindrome partitions\\n        curr_partition = []  # to store the current partition\\n        \\n        def is_palindrome(s, i, j):\\n            # check if substring s[i:j+1] is a palindrome or not\\n            while i < j:\\n                if s[i] != s[j]:\\n                    return False\\n                i += 1\\n                j -= 1\\n            return True\\n        \\n        def backtrack(start):\\n            # base case: if we have traversed the whole string, add the current partition to the final result\\n            if start >= len(s):\\n                res.append(curr_partition.copy())\\n                return\\n            \\n            # for each character of the string, consider all possible substrings starting at the current character\\n            for end in range(start, len(s)):\\n                # check if the substring is a palindrome or not\\n                if is_palindrome(s, start, end):\\n                    # if it\\'s a palindrome, add it to the current partition and recursively find all partitions that can be formed from the rest of the string\\n                    curr_partition.append(s[start:end+1])\\n                    backtrack(end+1)\\n                    curr_partition.pop()  # backtrack to remove the last added substring\\n        \\n        backtrack(0)  # start the recursive function from the first character of the string\\n        return res  # return the final result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086542,
                "title": "java-backtracking-explained",
                "content": "# Please Upvote :D\\n---\\nRecursion tree for a string say `aabb`.\\n\\n![image.png](https://assets.leetcode.com/users/images/f487cc11-070e-437a-9ae6-61b424c8007f_1674400154.1327956.png)\\n\\n---\\n*Read the comments carefully to understand the solution.*\\n#### Code:\\n\\n``` java []\\nclass Solution {\\n    // Globally initialise a list to store our answers\\n    private List<List<String>> ans = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        // call the recursive function which takes the sring s, index 0 as the start\\n        // and an empty list to store the partitions\\n        help(s, 0, new ArrayList<>());  \\n        return ans;     // return our answer list\\n    }\\n\\n    private void help(String s, int idx, List<String> currParts) {\\n        // BASE CASE:\\n        // If we see that we are trying to put a partition at the end of string\\n        // we stop and return\\n        // but before that we add our current partitioned string (stored in currParts) to ans\\n        if (idx == s.length()) {\\n            ans.add(new ArrayList<>(currParts));\\n            return;\\n        }\\n        // if we are at an index say i, \\n        // we will try to put partitions at every index after i\\n        // and see which one of the substrings from i to the partition is a palindrome \\n        for (int i = idx; i < s.length(); i++) {\\n            // we check using this method if the substring is a palindrome\\n            if (isPalindrome(s, idx, i)) {\\n                // if it is, we add the subtring to currParts \\n                currParts.add(s.substring(idx, i + 1));\\n                // we will call the recursion from the next index of i\\n                // by fixing the current state of partitions so far, \\n                // we will see how we can make more partitions in the remaining substring\\n                // Say we have \"a|abb\", we will try to make partitions on \"abb\" by keeping \"a|\" fixed\\n                // the function will go to the depth and make partitions and come back\\n                help(s, i + 1, currParts);\\n                // as \"a|\" was fixed, we will remove it from currParts\\n                // i will move to next index and we will fix \"aa|\" that time \\n                // and check possible partitions after \"aa|\"\\n                // this is how the whole thing will work everytime,  \\n                // Try -> Add (if potential) -> Discard -> Try new\\n                currParts.remove(currParts.size() - 1);\\n            }\\n        }\\n    }\\n\\n    // Simple method to check if a string is palidrome or not\\n    private boolean isPalindrome(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l++) != s.charAt(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n---\\n\\n#### Clean solution: \\n``` java []\\nclass Solution {\\n    private List<List<String>> ans = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        help(s, 0, new ArrayList<>());\\n        return ans;\\n    }\\n\\n    private void help(String s, int idx, List<String> currParts) {\\n        if (idx == s.length()) {\\n            ans.add(new ArrayList<>(currParts));\\n            return;\\n        }\\n        for (int i = idx; i < s.length(); i++) {\\n            if (isPalindrome(s, idx, i)) {\\n                currParts.add(s.substring(idx, i + 1));\\n                help(s, i + 1, currParts);\\n                currParts.remove(currParts.size() - 1);\\n            }\\n        }\\n    }\\n\\n    private boolean isPalindrome(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l++) != s.charAt(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n---\\n#### Time Complexity: $$O(2^n * k * n/2)$$\\n\\n$$O(2^n)$$ to generate every substring and $$O(n/2)$$  to check if the substring generated is a palindrome. $$O(k)$$ is for inserting the palindromes in another data structure, where k  is the average length of the palindrome list.\\n\\n---\\n\\n##### Space Complexity: $$O(k * x)$$\\n\\nThe space complexity can vary depending upon the length of the answer. `k` is the average length of the list of palindromes and if we have `x` such list of palindromes in our final answer. The depth of the recursion tree is `n`, so the auxiliary space required is equal to the $$O(n)$$.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` java []\\nclass Solution {\\n    // Globally initialise a list to store our answers\\n    private List<List<String>> ans = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        // call the recursive function which takes the sring s, index 0 as the start\\n        // and an empty list to store the partitions\\n        help(s, 0, new ArrayList<>());  \\n        return ans;     // return our answer list\\n    }\\n\\n    private void help(String s, int idx, List<String> currParts) {\\n        // BASE CASE:\\n        // If we see that we are trying to put a partition at the end of string\\n        // we stop and return\\n        // but before that we add our current partitioned string (stored in currParts) to ans\\n        if (idx == s.length()) {\\n            ans.add(new ArrayList<>(currParts));\\n            return;\\n        }\\n        // if we are at an index say i, \\n        // we will try to put partitions at every index after i\\n        // and see which one of the substrings from i to the partition is a palindrome \\n        for (int i = idx; i < s.length(); i++) {\\n            // we check using this method if the substring is a palindrome\\n            if (isPalindrome(s, idx, i)) {\\n                // if it is, we add the subtring to currParts \\n                currParts.add(s.substring(idx, i + 1));\\n                // we will call the recursion from the next index of i\\n                // by fixing the current state of partitions so far, \\n                // we will see how we can make more partitions in the remaining substring\\n                // Say we have \"a|abb\", we will try to make partitions on \"abb\" by keeping \"a|\" fixed\\n                // the function will go to the depth and make partitions and come back\\n                help(s, i + 1, currParts);\\n                // as \"a|\" was fixed, we will remove it from currParts\\n                // i will move to next index and we will fix \"aa|\" that time \\n                // and check possible partitions after \"aa|\"\\n                // this is how the whole thing will work everytime,  \\n                // Try -> Add (if potential) -> Discard -> Try new\\n                currParts.remove(currParts.size() - 1);\\n            }\\n        }\\n    }\\n\\n    // Simple method to check if a string is palidrome or not\\n    private boolean isPalindrome(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l++) != s.charAt(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    private List<List<String>> ans = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        help(s, 0, new ArrayList<>());\\n        return ans;\\n    }\\n\\n    private void help(String s, int idx, List<String> currParts) {\\n        if (idx == s.length()) {\\n            ans.add(new ArrayList<>(currParts));\\n            return;\\n        }\\n        for (int i = idx; i < s.length(); i++) {\\n            if (isPalindrome(s, idx, i)) {\\n                currParts.add(s.substring(idx, i + 1));\\n                help(s, i + 1, currParts);\\n                currParts.remove(currParts.size() - 1);\\n            }\\n        }\\n    }\\n\\n    private boolean isPalindrome(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l++) != s.charAt(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085947,
                "title": "java-c-100-solution-with-explanation-using-backtracking-palindrome-partitioning",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe aim is to partition the string into all possible palindrome combinations. To achieve this, we must generate all possible substrings of a string by partitioning at every index until we reach the end of the string. Example, abba can be partitioned as [\"a\",\"ab\",\"abb\",\"abba\"]. Each generated substring is considered as a potential candidate if it a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to generate all possible substrings of a given string and expand each possibility if it is a potential candidate. The first thing that comes to mind is Depth First Search. In Depth First Search, we recursively expand potential candidates until the defined goal is achieved. After that, we backtrack to explore the next potential candidate.\\n\\nBacktracking incrementally build the candidates for the solution and discards the candidates (backtrack) if they doesn\\'t satisfy the condition.\\n\\nThe backtracking algorithms consists of the following steps:\\n\\n- Choose: Choose the potential candidate. Here, our potential candidates are all substrings that could be generated from the given string.\\n\\n- Constraint: Define a constraint that must be satisfied by the chosen candidate. In this case, the constraint is that the string must be a palindrome.\\n\\n- Goal: We must define the goal that determines if have found the required solution and we must backtrack. Here, our goal is achieved if we have reached the end of the string.\\n\\n# Complexity\\n- Time complexity: $$O(n*2^n)$$ where $$n$$ is the length of string s. This is the worst-case time complexity when all the possible substrings are palindrome.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, where $$n$$ is the length of the string s. This space will be used to store the recursion stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    List<List<String>> ans = new ArrayList<>();\\n    List<String> curr = new ArrayList<>();\\n    boolean isPalindrome(String s, int low, int high) {\\n        while (low < high)\\n            if (s.charAt(low++) != s.charAt(high--)) return false;\\n\\n        return true;\\n    }\\n    void genrate(String s,int start)\\n    {\\n        if(start >=s.length())\\n            ans.add(new ArrayList<>(curr));\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s,start,i))\\n            {\\n                curr.add(s.substring(start,i+1));\\n                genrate(s,i+1);\\n                curr.remove(curr.size()-1);\\n            }\\n        }\\n    }\\n    public List<List<String>> partition(String s) {\\n        genrate(s,0);\\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\nvector<vector<string>> ans;\\nvector<string> curr;\\n    bool isPalindrome(string &s, int low, int high) {\\n        while (low < high) {\\n            if (s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n    void genrate(string &s,int start)\\n    {\\n        if(start >=s.length())\\n            ans.push_back(curr);\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s,start,i))\\n            {\\n                curr.push_back(s.substr(start,i-start+1));\\n                genrate(s,i+1);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        genrate(s,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```Java []\\nclass Solution {\\n    List<List<String>> ans = new ArrayList<>();\\n    List<String> curr = new ArrayList<>();\\n    boolean isPalindrome(String s, int low, int high) {\\n        while (low < high)\\n            if (s.charAt(low++) != s.charAt(high--)) return false;\\n\\n        return true;\\n    }\\n    void genrate(String s,int start)\\n    {\\n        if(start >=s.length())\\n            ans.add(new ArrayList<>(curr));\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s,start,i))\\n            {\\n                curr.add(s.substring(start,i+1));\\n                genrate(s,i+1);\\n                curr.remove(curr.size()-1);\\n            }\\n        }\\n    }\\n    public List<List<String>> partition(String s) {\\n        genrate(s,0);\\n        return ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\nvector<vector<string>> ans;\\nvector<string> curr;\\n    bool isPalindrome(string &s, int low, int high) {\\n        while (low < high) {\\n            if (s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n    void genrate(string &s,int start)\\n    {\\n        if(start >=s.length())\\n            ans.push_back(curr);\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s,start,i))\\n            {\\n                curr.push_back(s.substr(start,i-start+1));\\n                genrate(s,i+1);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        genrate(s,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085574,
                "title": "dp-solution-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst We Store The Status whether a substring is pallindrome or not.\\nAfter That We Use The Concept of Longest Increasing Subsequence but here we are storing the vector of partitioned (valid ones)strings in vector at that index.....which means till that index we find the possible partitions that could be done and are valid then if the next substring that is to be added is pallindrome too, then we push that substr and push the vector at that index at \"partitionspossibletillhere\".\\nWe Can do Recursion and Backtracking but I haven\\'t tried that coz if it might give me TLE.\\nIf someone tried that plz share the statusd.\\n\\n# Complexity\\n- Time complexity:\\nO(N^3*max(string size))\\n\\n- Space complexity:\\nO(N^3*max(string size))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<string>>>partitionspossibletillhere;\\n    vector<bool>zeros;\\n    vector<vector<bool>>ispallindrome;\\n    string str;\\n    void assign(string &s)\\n    {\\n        zeros.assign(s.size(),false);\\n        ispallindrome.assign(s.size(),zeros);\\n        partitionspossibletillhere.assign(s.size(),{});\\n        int i,j;\\n        ispallindrome[0][0]=true;\\n        for(i=1;i<s.size();i++)\\n        {\\n            ispallindrome[i][i]=true;\\n            if(s[i]==s[i-1])\\n            {\\n                ispallindrome[i-1][i]=true;\\n            }\\n        }\\n        for(j=2;j<=s.size()-1;j++)\\n        {\\n            for(i=j;i<s.size();i++)\\n            {\\n                if((s[i]==s[i-j])&&(ispallindrome[i-j+1][i-1]==1))\\n                {\\n                    ispallindrome[i-j][i]=true;\\n                }\\n            }\\n        }\\n        str=s;\\n        return;\\n    }\\n    void partitioning(int index)\\n    {\\n        if(index==str.size())\\n        {\\n            return;\\n        }\\n        if(ispallindrome[0][index])\\n        {\\n            partitionspossibletillhere[index].push_back({str.substr(0,index+1)});\\n        }\\n        for(int i=0;i<index;i++)\\n        {\\n            if(ispallindrome[i+1][index])\\n            {\\n                string topush=str.substr(i+1,index-i);\\n                for(auto j:partitionspossibletillhere[i])\\n                {\\n                    j.push_back(topush);\\n                    partitionspossibletillhere[index].push_back(j);\\n                }\\n            }\\n        }\\n        partitioning(index+1);\\n        return;\\n    }\\n    vector<vector<string>> partition(string s) \\n    {\\n        assign(s);\\n        partitioning(0);\\n        return partitionspossibletillhere.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<string>>>partitionspossibletillhere;\\n    vector<bool>zeros;\\n    vector<vector<bool>>ispallindrome;\\n    string str;\\n    void assign(string &s)\\n    {\\n        zeros.assign(s.size(),false);\\n        ispallindrome.assign(s.size(),zeros);\\n        partitionspossibletillhere.assign(s.size(),{});\\n        int i,j;\\n        ispallindrome[0][0]=true;\\n        for(i=1;i<s.size();i++)\\n        {\\n            ispallindrome[i][i]=true;\\n            if(s[i]==s[i-1])\\n            {\\n                ispallindrome[i-1][i]=true;\\n            }\\n        }\\n        for(j=2;j<=s.size()-1;j++)\\n        {\\n            for(i=j;i<s.size();i++)\\n            {\\n                if((s[i]==s[i-j])&&(ispallindrome[i-j+1][i-1]==1))\\n                {\\n                    ispallindrome[i-j][i]=true;\\n                }\\n            }\\n        }\\n        str=s;\\n        return;\\n    }\\n    void partitioning(int index)\\n    {\\n        if(index==str.size())\\n        {\\n            return;\\n        }\\n        if(ispallindrome[0][index])\\n        {\\n            partitionspossibletillhere[index].push_back({str.substr(0,index+1)});\\n        }\\n        for(int i=0;i<index;i++)\\n        {\\n            if(ispallindrome[i+1][index])\\n            {\\n                string topush=str.substr(i+1,index-i);\\n                for(auto j:partitionspossibletillhere[i])\\n                {\\n                    j.push_back(topush);\\n                    partitionspossibletillhere[index].push_back(j);\\n                }\\n            }\\n        }\\n        partitioning(index+1);\\n        return;\\n    }\\n    vector<vector<string>> partition(string s) \\n    {\\n        assign(s);\\n        partitioning(0);\\n        return partitionspossibletillhere.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084759,
                "title": "c-begineer-friendly-easy-understanding-backtrack-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=9puyFLBesS4/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(2^n.n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n // to store the ans.\\n     vector<vector<string>> ans;\\n     bool palindrome(string s,int start,int end ){\\n         while(start<end){\\n             if(s[start++] != s[end--]){return false;}\\n         }\\n         return true;\\n     }\\n\\n     void recursion(string s,vector<string>&temp,int index ){\\n\\n        //  base case\\n        if(index == s.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        // loop and do partition based on if palindrome string from 0 to index.\\n        for(int i=index;i<s.size();i++){\\n            // if it is palindrome\\n            if(palindrome(s,index,i)){\\n                temp.push_back(s.substr(index,i-index+1));\\n                recursion(s,temp,i+1);\\n                // pop out value in backtracking for new seq if possible.\\n                temp.pop_back();\\n            }\\n        }\\n     }\\n\\n    vector<vector<string>> partition(string s) {\\n       vector<string> temp;\\n\\n        recursion(s,temp,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n // to store the ans.\\n     vector<vector<string>> ans;\\n     bool palindrome(string s,int start,int end ){\\n         while(start<end){\\n             if(s[start++] != s[end--]){return false;}\\n         }\\n         return true;\\n     }\\n\\n     void recursion(string s,vector<string>&temp,int index ){\\n\\n        //  base case\\n        if(index == s.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        // loop and do partition based on if palindrome string from 0 to index.\\n        for(int i=index;i<s.size();i++){\\n            // if it is palindrome\\n            if(palindrome(s,index,i)){\\n                temp.push_back(s.substr(index,i-index+1));\\n                recursion(s,temp,i+1);\\n                // pop out value in backtracking for new seq if possible.\\n                temp.pop_back();\\n            }\\n        }\\n     }\\n\\n    vector<vector<string>> partition(string s) {\\n       vector<string> temp;\\n\\n        recursion(s,temp,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084617,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    string st;\\n\\n    bool isPalindrome(int i,int j) {\\n        while(i < j) {\\n            if(st[i] != st[j]) return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\n\\n    void solve(int id, vector<string> &v) {\\n        if(st.size() == id) {\\n            ans.push_back(v); \\n            return;\\n        }\\n        for(int i=id; i<st.length(); i++) {\\n            if(isPalindrome(id, i)) {\\n                v.push_back(st.substr(id, i - id + 1));\\n                solve(i+1, v);\\n                v.pop_back();\\n            }\\n        }   \\n    }\\n\\n    vector<vector<string>> partition(string s) {\\n        st = s;\\n        vector<string> v;\\n        solve(0, v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    string st;\\n\\n    bool isPalindrome(int i,int j) {\\n        while(i < j) {\\n            if(st[i] != st[j]) return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\n\\n    void solve(int id, vector<string> &v) {\\n        if(st.size() == id) {\\n            ans.push_back(v); \\n            return;\\n        }\\n        for(int i=id; i<st.length(); i++) {\\n            if(isPalindrome(id, i)) {\\n                v.push_back(st.substr(id, i - id + 1));\\n                solve(i+1, v);\\n                v.pop_back();\\n            }\\n        }   \\n    }\\n\\n    vector<vector<string>> partition(string s) {\\n        st = s;\\n        vector<string> v;\\n        solve(0, v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084595,
                "title": "easy-c-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool issafe(int index,int i,string s){\\n        while(index<=i){\\n            if(s[index++]!=s[i--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void part(vector<string>&path,vector<vector<string>>&ans,string s,int index){\\n        if(index==s.size()){\\n            ans.push_back(path);\\n            return;\\n        }\\n        for(int i=index;i<s.size();i++)\\n        {\\n        if(issafe(index,i,s)){\\n        path.push_back(s.substr(index,i-index+1));\\n        part(path,ans,s,i+1);\\n        path.pop_back();\\n        }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>path;\\n        part(path,ans,s,0);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool issafe(int index,int i,string s){\\n        while(index<=i){\\n            if(s[index++]!=s[i--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void part(vector<string>&path,vector<vector<string>>&ans,string s,int index){\\n        if(index==s.size()){\\n            ans.push_back(path);\\n            return;\\n        }\\n        for(int i=index;i<s.size();i++)\\n        {\\n        if(issafe(index,i,s)){\\n        path.push_back(s.substr(index,i-index+1));\\n        part(path,ans,s,i+1);\\n        path.pop_back();\\n        }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>path;\\n        part(path,ans,s,0);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084121,
                "title": "proper-explanation-included",
                "content": "# Intuition\\nThe problem is to partition a given string s into a list of substrings such that each substring is a palindrome. The goal is to return all possible partitions of the string s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne approach to solving this problem is to use backtracking. The idea is to iterate through the characters of the string and for each character, check if the substring from that character to the end of the string is a palindrome. If it is, we add that substring to the current partition and recursively call the function for the remaining substring. Once we reach the end of the string, we add the current partition to the final list of partitions.\\n\\n# Algorithm\\n1. Create an empty list `partitions` to store the final partitions\\n2. Create a helper function `backtrack(start, partition)` that takes the current starting index and the current partition as input\\n3. Within the helper function, check if the current starting index is equal to the length of the string. If it is, add the current partition to the `partitions` list and return\\n4. Iterate through the characters from the current starting index to the end of the string\\n5. For each character, check if the substring from that character to the end of the string is a palindrome. If it is, add that substring to the current partition and recursively call the `backtrack()` function for the remaining substring\\n6. Return the `partitions` list\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$ where n is the length of the input string. This is because for each character, we are calling the function recursively and at each level, we are iterating through all the characters from the current starting index to the end of the string. This results in a worst-case time complexity of $$O(2^n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(n)$$ because we are storing the partitions in a list and the maximum number of partitions can be n.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions = []  # create an empty list to store the final partitions\\n        \\n        def backtrack(start, partition):\\n            if start == len(s):  # check if the current starting index is equal to the length of the string\\n                partitions.append(partition)  # if it is, add the current partition to the final list\\n                return\\n            \\n            for i in range(start, len(s)):  # iterate through the characters from the current starting index to the end of the string\\n                if s[start:i+1] == s[start:i+1][::-1]:  # check if the substring is a palindrome\\n                    backtrack(i+1, partition + [s[start:i+1]])  # if it is, add that substring to the current partition and recursively call the function for the remaining substring\\n        \\n        backtrack(0, [])  # call the helper function with starting index 0 and an empty partition\\n        return partitions  # return the final list of partitions\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions = []  # create an empty list to store the final partitions\\n        \\n        def backtrack(start, partition):\\n            if start == len(s):  # check if the current starting index is equal to the length of the string\\n                partitions.append(partition)  # if it is, add the current partition to the final list\\n                return\\n            \\n            for i in range(start, len(s)):  # iterate through the characters from the current starting index to the end of the string\\n                if s[start:i+1] == s[start:i+1][::-1]:  # check if the substring is a palindrome\\n                    backtrack(i+1, partition + [s[start:i+1]])  # if it is, add that substring to the current partition and recursively call the function for the remaining substring\\n        \\n        backtrack(0, [])  # call the helper function with starting index 0 and an empty partition\\n        return partitions  # return the final list of partitions\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084040,
                "title": "c-easiest-soln",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(2^n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkPalindrome(string str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str[startIndex] != str[lastIndex])\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    void palindromePartition(int index, vector<string>& ds, vector<vector<string>>& output, string str){\\n        if(index == str.length()){\\n            output.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.push_back(str.substr(index, i - index + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> ds;\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkPalindrome(string str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str[startIndex] != str[lastIndex])\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    void palindromePartition(int index, vector<string>& ds, vector<vector<string>>& output, string str){\\n        if(index == str.length()){\\n            output.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.push_back(str.substr(index, i - index + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> ds;\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083686,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/pdh4_26-_6k\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    let isPalindrome = (str) =>{\\n        let left = 0;\\n        let right = str.length-1;\\n        while(left<right){\\n            if(str[left] != str[right]) return false;\\n            left++\\n            right--\\n        }\\n        return true;\\n    }\\n    let result = []\\n    let iterate = (str,temp) =>{\\n        if(str.length ==0){\\n            result.push(temp)\\n            return;\\n        }\\n\\n        for(let i =1; i<=str.length; i++){\\n            let value = str.slice(0,i);\\n            if(isPalindrome(value)){\\n                iterate(str.slice(i),[...temp,value])\\n            }\\n        }\\n    }\\n    iterate(s,[])\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    let isPalindrome = (str) =>{\\n        let left = 0;\\n        let right = str.length-1;\\n        while(left<right){\\n            if(str[left] != str[right]) return false;\\n            left++\\n            right--\\n        }\\n        return true;\\n    }\\n    let result = []\\n    let iterate = (str,temp) =>{\\n        if(str.length ==0){\\n            result.push(temp)\\n            return;\\n        }\\n\\n        for(let i =1; i<=str.length; i++){\\n            let value = str.slice(0,i);\\n            if(isPalindrome(value)){\\n                iterate(str.slice(i),[...temp,value])\\n            }\\n        }\\n    }\\n    iterate(s,[])\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083599,
                "title": "python-backtracking-beats-91-1-in-runtime-78-51-in-memory",
                "content": "![Screenshot (97).png](https://assets.leetcode.com/users/images/b146496d-edd1-4087-81c3-bc293d304fcd_1674353637.8267994.png)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe partition method of the Solution class is solving the problem of finding all possible partitions of a given input string s into palindromes.\\nIt first creates a 2D boolean array isPalindrome of the same length as the input string s, to keep track of whether a substring of s is a palindrome or not.\\nIt then uses a nested loop to fill in the isPalindrome array by checking if a substring from start to end is a palindrome or not.\\nThe outer loop iterates over all possible substring lengths, starting from 2 and ending at the length of the input string. The inner loop iterates over all possible starting positions for the substring.\\n\\nIt then uses a recursive helper function helper to explore all possible partitions of the input string s. The function takes the current index of the string, the current partition path, and the overall results as input.\\nIt then loops over all possible end positions of the current partition, checking if the substring from the current index to the end position is a palindrome. If it is, it adds the substring to the current partition path and recursively calls the helper function with the updated index and partition path.\\nOnce the index reaches the end of the input string, it adds the current partition path to the overall results.\\n\\nFinally, the partition method initializes an empty list results and calls the helper function with the initial index of 0 and an empty partition path, returning the results list containing all possible partitions of the input string s into palindromes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the partition method of the Solution class is a backtracking approach. It uses a recursive helper function to explore all possible partitions of the input string s into palindromes.\\n\\nThe method starts by creating a 2D boolean array isPalindrome of the same length as the input string s, to keep track of whether a substring of s is a palindrome or not.\\nIt then uses a nested loop to fill in the isPalindrome array by checking if a substring from start to end is a palindrome or not.\\nThe outer loop iterates over all possible substring lengths, starting from 2 and ending at the length of the input string. The inner loop iterates over all possible starting positions for the substring.\\n\\nNext, it uses a recursive helper function helper to explore all possible partitions of the input string s.\\nThe function takes the current index of the string, the current partition path, and the overall results as input.\\nIt then loops over all possible end positions of the current partition, checking if the substring from the current index to the end position is a palindrome (by checking the isPalindrome array).\\nIf it is, it adds the substring to the current partition path and recursively calls the helper function with the updated index and partition path.\\nOnce the index reaches the end of the input string, it adds the current partition path to the overall results.\\n\\nFinally, the partition method initializes an empty list results and calls the helper function with the initial index of 0 and an empty partition path, returning the results list containing all possible partitions of the input string s into palindromes.\\n\\nThe backtracking approach allows us to explore all possible partitions of the input string s into palindromes by generating all possible partitions recursively, and then backtracking when a partition doesn\\'t meet the requirements (i.e. a substring is not a palindrome). This allows us to generate all possible partitions without having to check all possible partitions in advance which would be an exponential time complexity.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the partition method of the Solution class is O(n^2) where n is the length of the input string s.\\n\\nThe first step of the method is to fill the isPalindrome array, which takes O(n^2) time.\\nThe nested loop iterates over all possible substrings of s and checks if they are palindromes, which takes O(n^2) time in total.\\n\\nThe next step is to use the recursive helper function helper to explore all possible partitions of the input string s.\\nIn the worst case, the function is called for all possible partitions of the input string, which would take O(n^2) time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the partition method is O(n^2) as well.\\nThe isPalindrome array takes O(n^2) space to store the information about all possible substrings of s being palindrome or not.\\nThe recursive calls in the helper function also takes O(n^2) space in the worst case, where all possible partitions are stored in the results list.\\n\\nTherefore, the time complexity of the partition method is O(n^2) and the space complexity is also O(n^2) where n is the length of the input string s.\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.isPalindrome = None\\n    \\n    def helper(self, s: str, index: int, path: List[str], results: List[List[str]]):\\n        if index == len(s):\\n            results.append(path)\\n            return\\n        \\n        for end in range(index, len(s)):\\n            if self.isPalindrome[index][end]:\\n                newPath = path[:]\\n                newPath.append(s[index:end+1])\\n                self.helper(s, end + 1, newPath, results)\\n    \\n    def partition(self, s: str) -> List[List[str]]:\\n        self.isPalindrome = [[False for i in range(len(s))] for j in range(len(s))]\\n        \\n        for i in range(len(s)):\\n            self.isPalindrome[i][i] = True\\n        \\n        for length in range(2, len(s) + 1):\\n            for start in range(len(s) - length + 1):\\n                end = start + length - 1\\n                if s[start] == s[end]:\\n                    if length == 2:\\n                        self.isPalindrome[start][end] = True\\n                    else:\\n                        self.isPalindrome[start][end] |= self.isPalindrome[start + 1][end - 1]\\n        \\n        results = []\\n        self.helper(s, 0, [], results)\\n        return results\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.isPalindrome = None\\n    \\n    def helper(self, s: str, index: int, path: List[str], results: List[List[str]]):\\n        if index == len(s):\\n            results.append(path)\\n            return\\n        \\n        for end in range(index, len(s)):\\n            if self.isPalindrome[index][end]:\\n                newPath = path[:]\\n                newPath.append(s[index:end+1])\\n                self.helper(s, end + 1, newPath, results)\\n    \\n    def partition(self, s: str) -> List[List[str]]:\\n        self.isPalindrome = [[False for i in range(len(s))] for j in range(len(s))]\\n        \\n        for i in range(len(s)):\\n            self.isPalindrome[i][i] = True\\n        \\n        for length in range(2, len(s) + 1):\\n            for start in range(len(s) - length + 1):\\n                end = start + length - 1\\n                if s[start] == s[end]:\\n                    if length == 2:\\n                        self.isPalindrome[start][end] = True\\n                    else:\\n                        self.isPalindrome[start][end] |= self.isPalindrome[start + 1][end - 1]\\n        \\n        results = []\\n        self.helper(s, 0, [], results)\\n        return results\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083533,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isPalindrome(string s){//This function returns true if the string is Palindrome else returns false\\n        int n=s.size();\\n        for(int i=0;i<=s.size()/2;i++){\\n            if(s[i]!=s[n-1-i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solve(int idx,string s,vector<string>& ds){\\n        if(idx==s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=idx;i<s.size();i++){\\n            string temp=s.substr(idx,i-idx+1);\\n            if(isPalindrome(temp)){//if the string starting from index idx to i is Palindrome then\\n\\t\\t\\t//we can push that string to ds and check for palindromes from index i+1\\n                ds.push_back(temp);\\n                solve(i+1,s,ds);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string> ds;\\n        solve(0,s,ds);\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/65075f44-2b96-4c66-8984-b0732bd2fee6_1674350894.9909735.png)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isPalindrome(string s){//This function returns true if the string is Palindrome else returns false\\n        int n=s.size();\\n        for(int i=0;i<=s.size()/2;i++){\\n            if(s[i]!=s[n-1-i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solve(int idx,string s,vector<string>& ds){\\n        if(idx==s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=idx;i<s.size();i++){\\n            string temp=s.substr(idx,i-idx+1);\\n            if(isPalindrome(temp)){//if the string starting from index idx to i is Palindrome then\\n\\t\\t\\t//we can push that string to ds and check for palindromes from index i+1\\n                ds.push_back(temp);\\n                solve(i+1,s,ds);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string> ds;\\n        solve(0,s,ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083438,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083424,
                "title": "daily-leetcoding-challenge-january-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2957699,
                "title": "c-simple-backtracking-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<string>>ans;\\n    vector<string>v;\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        permutation(0,s,\"\");\\n        return ans;\\n    }\\n    void permutation(int pos, string s, string val) {\\n        if(pos>=s.length()) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i = pos; i<s.length(); i++) {\\n            val+=s[i];\\n            if(is_palindrome(val)) {\\n                v.push_back(val);\\n                permutation(i+1, s, \"\");\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    bool is_palindrome(string s) {\\n        int n = s.length();\\n        for(int i=0; i<n/2; i++) {\\n            if(s[i] != s[n-1-i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<string>>ans;\\n    vector<string>v;\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        permutation(0,s,\"\");\\n        return ans;\\n    }\\n    void permutation(int pos, string s, string val) {\\n        if(pos>=s.length()) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i = pos; i<s.length(); i++) {\\n            val+=s[i];\\n            if(is_palindrome(val)) {\\n                v.push_back(val);\\n                permutation(i+1, s, \"\");\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    bool is_palindrome(string s) {\\n        int n = s.length();\\n        for(int i=0; i<n/2; i++) {\\n            if(s[i] != s[n-1-i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614054,
                "title": "simple-understanding-c-clean-code-using-backtracking",
                "content": "**Important Points:**\\n* Let **`start`** and **`end`** be the index where the string is to be partioned.\\n* `substr(i,j)` in c++ works as start from `i` and **add** `j` steps(`jth` step is exclusive). \\n\\t* Eg:`str = 01234567`, substr(1,3) = `s[1] to s[1 + 3] = s[4] (exclusive)`. =  `123`.\\n\\n**Understanding recursive steps:**\\n1. Try partioning a substring from `start` till  `end`.\\n2. Check if the partioned substring `( s.substr(start, end -start + 1) )` is a `palindrome or not`.\\n\\n\\t2.1) If **yes**, include into the answer, try searching for next string where the **new start =  end + 1** (repeat step 1: Recursion called).\\n\\t\\n\\t2.2) Also try to backtrack as from one index(`ie: start`) there can be multiple indexes `ie(end)`, which can generate a palindrome substring. So its important to backtrack and check for other string too.\\n\\n**Example Explaining Point 2.2:**\\n\\nstring = `aaa`. lets say `start = 0, end = 1`. ie(substring = `aa`) makes a palindrome.\\n**BUT**\\n`start = 0, end = 3` ie(substring `aaa`) **ALSO MAKES** a new palindrome. Thus, its important to backtrack the last inserted substring into the answer so in order to try new combinations.\\n\\n**Algo/Idea:**\\n1. Start trying to check every substring from  `[start- end] till end == s.size() (ie. The end of string)`.\\n2. Loop from `start` to `s.size()` and check which substring is a `paindrome` partition.\\n3. If the substring is a palindrome, insert it into the `ds` and call the next recrusive function with now **`(start = end + 1)`, so that it can start partioning again with the next index with the help of recursive function.**.\\n4. Remove the last inserted string in order to try other partitions too.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isPalindrome(string s, int low , int high){\\n        while(low < high){\\n            if(s[low] != s[high])\\n                return false;\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    void solve(int start, string s, vector<vector<string>> &ans, vector<string> &ds){\\n        \\n        if(start == s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int end = start; end < s.size(); end++){\\n            \\n            if(isPalindrome(s,start,end)){\\n                string str = s.substr(start, end - start + 1);\\n                ds.push_back(str);\\n                solve(end + 1, s, ans, ds); // Note: Here solve(end+1) and not \"start + 1\" as \"end\" will be the latest index where the new palindome string is found and inserted.\\n                ds.pop_back(); // Backtracking it, so that we can try the last palindrome inserted with other next indexes too.\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> ds;\\n        int start = 0;\\n        solve(start,s,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPalindrome(string s, int low , int high){\\n        while(low < high){\\n            if(s[low] != s[high])\\n                return false;\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    void solve(int start, string s, vector<vector<string>> &ans, vector<string> &ds){\\n        \\n        if(start == s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int end = start; end < s.size(); end++){\\n            \\n            if(isPalindrome(s,start,end)){\\n                string str = s.substr(start, end - start + 1);\\n                ds.push_back(str);\\n                solve(end + 1, s, ans, ds); // Note: Here solve(end+1) and not \"start + 1\" as \"end\" will be the latest index where the new palindome string is found and inserted.\\n                ds.pop_back(); // Backtracking it, so that we can try the last palindrome inserted with other next indexes too.\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> ds;\\n        int start = 0;\\n        solve(start,s,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490846,
                "title": "c-100-fastest-solution-detailed-explanation-easy-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Please upvote if you like it!!!!!***\\n\\n**Approach:-**\\nThe initial idea will be to make partitions to generate substring and check if the substring generated out of the partition will be a palindrome. Partitioning means we would end up generating every substring and checking for palindrome at every step. Since this is a repetitive task being done again and again, at this point we should think of recursion. The recursion continues until the entire string is exhausted. After partitioning, every palindromic substring is inserted in a data structure When the base case has reached the list of palindromes generated during that recursion call is inserted in a vector of vectors/list of list.\\n\\n**Dry Run:-**\\n\\n![image](https://assets.leetcode.com/users/images/dbedad9b-a814-417f-b23a-ba9cdf252259_1661613943.4511516.jpeg)\\n\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    //fuction to check given range is palindrome or not?\\n    bool isPalindrome(string s,int st,int ed){\\n        while(st<ed){\\n            if(s[st++]!=s[ed--]) return false;\\n        }\\n        return true;\\n    }\\n    //Recursive fuction \\n    void solve(int ind,int n,string s,vector<vector<string>>& ans,vector<string>& temp){\\n        // if ind is equal to n it means string exhausted then push temp string inside ans vector\\n        if(ind==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        //looping for all char in string which make palindrome sub string\\n        for(int i=ind;i<n;i++){\\n            //check if substring will make palindrome, then push that stirng inside the temp and call recursive for further check\\n            if(isPalindrome(s,ind,i)){\\n                temp.push_back(s.substr(ind,i-ind+1));\\n                solve(i+1,n,s,ans,temp);\\n                // when you back from current call, then pop last inseted string\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        //For storing ans substring\\n        vector<vector<string>> ans;\\n        //For temperary inserting and poping substring\\n        vector<string> temp;\\n        // Call solve fucntion\\n        solve(0,s.length(),s,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //fuction to check given range is palindrome or not?\\n    bool isPalindrome(string s,int st,int ed){\\n        while(st<ed){\\n            if(s[st++]!=s[ed--]) return false;\\n        }\\n        return true;\\n    }\\n    //Recursive fuction \\n    void solve(int ind,int n,string s,vector<vector<string>>& ans,vector<string>& temp){\\n        // if ind is equal to n it means string exhausted then push temp string inside ans vector\\n        if(ind==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        //looping for all char in string which make palindrome sub string\\n        for(int i=ind;i<n;i++){\\n            //check if substring will make palindrome, then push that stirng inside the temp and call recursive for further check\\n            if(isPalindrome(s,ind,i)){\\n                temp.push_back(s.substr(ind,i-ind+1));\\n                solve(i+1,n,s,ans,temp);\\n                // when you back from current call, then pop last inseted string\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        //For storing ans substring\\n        vector<vector<string>> ans;\\n        //For temperary inserting and poping substring\\n        vector<string> temp;\\n        // Call solve fucntion\\n        solve(0,s.length(),s,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263662,
                "title": "easy-python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res, part = [], []\\n        \\n        def dfs(i):\\n            if i >= len(s):\\n                res.append(part.copy())\\n                return\\n            for j in range(i, len(s)):\\n                if isPali(s, i, j):\\n                    part.append(s[i:j+1])\\n                    dfs(j + 1)\\n                    part.pop()\\n        dfs(0)\\n        return res\\n    \\ndef isPali( s, l, r):\\n        while l < r:\\n            if s[l] != s[r]:\\n                return False\\n            l, r = l + 1, r - 1\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res, part = [], []\\n        \\n        def dfs(i):\\n            if i >= len(s):\\n                res.append(part.copy())\\n                return\\n            for j in range(i, len(s)):\\n                if isPali(s, i, j):\\n                    part.append(s[i:j+1])\\n                    dfs(j + 1)\\n                    part.pop()\\n        dfs(0)\\n        return res\\n    \\ndef isPali( s, l, r):\\n        while l < r:\\n            if s[l] != s[r]:\\n                return False\\n            l, r = l + 1, r - 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187611,
                "title": "c-easy-explanation-to-recursive-palindrome-partitioning",
                "content": "**Approach: -** \\n![image](https://assets.leetcode.com/users/images/878b057e-25b8-4916-9de0-bd600e279093_1655992962.6974993.png)\\n\\n**Notations: -** \\n1. Red line shows the partition of the strings that we will be performing.\\n2. **Note: -** one very important thing to keep in mind is that anything before a red line or a part of a string in between two red lines (highlighted by green underline) should be a palindrome or else the partition cannot take place.\\n3. Orange cross shows that we reached the end of string and palindrome at last portion was not discovered so we kill the branch.\\n\\n**Intuition: -** \\nWe will need two additional functions: - a recursive helper function and a boolean isPalindrome functrion to verify whether our substring in question is a palindrome or not.\\n1. isPalindrome(): - which uses a two pointer approach to check whether a substring is palindrome or not.\\n2. helperFunc(): - \\n\\ta) base case :- if we reach the end of string then we push our ds array into the ans 2-d array.\\n\\tb) recursive function: - in recursive function we call and check whether if a substr is palindrome or not if it is we push it onto the ds and recursive do this until we reach the end of string s.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string sh, int start, int end){\\n        while(start <= end){\\n            if(sh[start++] != sh[end--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void helperFunc(int index, vector<string> &ds, vector<vector<string>> &ans, string s){\\n        if(index == s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(isPalindrome(s, index, i)){\\n                ds.push_back(s.substr(index, i-index+1));\\n                helperFunc(i+1, ds, ans, s);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string> ds;\\n        vector<vector<string>> ans;\\n        helperFunc(0, ds, ans, s);\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote, it helps :}",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string sh, int start, int end){\\n        while(start <= end){\\n            if(sh[start++] != sh[end--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void helperFunc(int index, vector<string> &ds, vector<vector<string>> &ans, string s){\\n        if(index == s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(isPalindrome(s, index, i)){\\n                ds.push_back(s.substr(index, i-index+1));\\n                helperFunc(i+1, ds, ans, s);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string> ds;\\n        vector<vector<string>> ans;\\n        helperFunc(0, ds, ans, s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166251,
                "title": "simple-python-solution",
                "content": "I hope it\\'s helpful.\\nif you have some advices please let me know.\\nI have a lot to learn. \\nUpvote if you like solution and feel free to ask If you have any question.\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        def dfs(i,curr) :\\n            if i >= len(s) :\\n                res.append(curr.copy())\\n                return\\n\\n            for j in range(i,len(s)) :\\n                if s[i:j+1] ==  s[i:j+1][::-1]:\\n                    curr.append(s[i:j+1])\\n                    dfs(j+1,curr)\\n                    curr.pop()\\n\\n        dfs(0,[])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        def dfs(i,curr) :\\n            if i >= len(s) :\\n                res.append(curr.copy())\\n                return\\n\\n            for j in range(i,len(s)) :\\n                if s[i:j+1] ==  s[i:j+1][::-1]:\\n                    curr.append(s[i:j+1])\\n                    dfs(j+1,curr)\\n                    curr.pop()\\n\\n        dfs(0,[])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667875,
                "title": "backtracking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> ans;\\n    vector<string> curr;\\n    \\n    bool check(string &s)\\n    {\\n        int i=0,j=s.length()-1;\\n        \\n        while(i<=j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n    \\n    void find(int i,string &s)\\n    {\\n        if(i==s.length())\\n        {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        string tmp;\\n        \\n        for(int j=i;j<s.length();j++)\\n        {\\n            tmp+=s[j];\\n            \\n            if(check(tmp))\\n            {\\n                curr.push_back(tmp);\\n                find(j+1,s);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) \\n    {\\n        find(0,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> ans;\\n    vector<string> curr;\\n    \\n    bool check(string &s)\\n    {\\n        int i=0,j=s.length()-1;\\n        \\n        while(i<=j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n    \\n    void find(int i,string &s)\\n    {\\n        if(i==s.length())\\n        {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        string tmp;\\n        \\n        for(int j=i;j<s.length();j++)\\n        {\\n            tmp+=s[j];\\n            \\n            if(check(tmp))\\n            {\\n                curr.push_back(tmp);\\n                find(j+1,s);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) \\n    {\\n        find(0,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667868,
                "title": "c-easy-to-understand-backtracking-recursion",
                "content": "**Please upvote if you find helpful!**\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string str, int start, int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(str[start]!=str[end])\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    void generateall(string s, int curridx, int n, vector<vector<string>>&v, vector<string>&curr)\\n    {\\n        if(curridx>=n)\\n        {\\n            v.push_back(curr);\\n            return;\\n        }\\n        for(int i=curridx; i<n; i++)\\n        {\\n            if(isPalindrome(s, curridx, i)) {\\n                curr.push_back(s.substr(curridx, i-curridx+1));\\n                generateall(s, i+1, n, v, curr);\\n                curr.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>v;\\n        vector<string>curr;\\n        generateall(s, 0, s.length(), v, curr);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string str, int start, int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(str[start]!=str[end])\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    void generateall(string s, int curridx, int n, vector<vector<string>>&v, vector<string>&curr)\\n    {\\n        if(curridx>=n)\\n        {\\n            v.push_back(curr);\\n            return;\\n        }\\n        for(int i=curridx; i<n; i++)\\n        {\\n            if(isPalindrome(s, curridx, i)) {\\n                curr.push_back(s.substr(curridx, i-curridx+1));\\n                generateall(s, i+1, n, v, curr);\\n                curr.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>v;\\n        vector<string>curr;\\n        generateall(s, 0, s.length(), v, curr);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310312,
                "title": "c-easy-solution-using-backtracking-and-recursion-faster",
                "content": "Hi,\\nAs we need all palindromes so we need to first keep track of indexes that will tell us if substring ```l to r``` is palindrome or not.\\nSo for this we will create matrix say ```dp``` of ``` n*n``` where ``` n = s.size() ```. And in this matrix each entry ```dp[i][j]``` will tell us is ```substring( i to j )``` palindrome or not. \\n\\nNote : Matrix is not necessarily needed its here for easy understanding. You can remove matrix and can put palindrome check function ```ispalin(i,j-i+1)``` in place of ```dp[i][j]``` in solve function.\\n\\nLets see an example \\n- We have ```s = \"aab\"```.\\n- Matrix for this will be (here string is not stored in matrix its illustration to understand)\\n\\t![image](https://assets.leetcode.com/users/images/47bffff1-71b0-4800-9e0e-719316ccda1c_1625195409.9045327.png)\\n\\n- here 1 denotes that ```substr(i,j)``` is palindrome and 0 denotes not a palindrome.\\n- now we need to go from ```i=0``` to ```i=n-1``` and push substrings if corresponding entry is 1 else break.\\n- We will traverse in the following way\\n- 1. i=0 , j=0\\n- 2. at this point we have 3 choices either we can take ```substr(0 to 0) ```or ```substr (0 to 1)``` or ```substr (0 to 2)```\\n\\t-  1.  we can take  ```substr( 0 to 0)``` because ```dp[0][0] =1```. so if we take it then ```i = 1``` and ```j = 1```\\n\\t- 2. now again we have two choices either we take ```substr( 1 to 1)``` or ```substr(1 to 2)```.\\n\\t\\t- 1. Lets take ```substr(1 to 1)```.Since ```dp[1][1] =1``` so we can take it and ```i=2``` and ```j=2```.\\n\\t\\t- 2. Now we have only one choice ```substr(2 to 2)``` and ```dp[2][2]=1``` so we will take it too. Now ```i and j``` reaches to maximum length so our one answer would be ``` [ \"a\", \"a\" , \"b\" ]```.\\n\\t\\t- 1. Now lets choose ```substr(1 to 2)``` after 2nd step instead of ```substr(1 to 1)``` then we can see that ```dp[1][2]=0``` its not 1 that means this is not a palindrome so we cant consider it.\\n\\t- 1. Choose ```substr(0 to 1)``` instead of ```substr(0 to 0)``` in 2nd step. Since ```dp[0][1]=1``` we can take it and ```i=2 and j=2```.\\n\\t\\t- 1. for ```i=2 and j=2``` we have only one choice ```substr(2 to 2)``` and ```dp[2][2]=1``` so we can take it too. Now ```i and j``` reaches to maximum length again so our another answer would be ``` [ \"aa\" , \"b\" ]```.\\n\\t- 1. now we are left with one more choice in step 2 that is ```substr(0 to 2)``` but again ```dp[0][2]=0``` that means its not a palindrome ans we cant consider it.\\n- So we covered all choices and we have answer as ``` [ \"a\", \"a\" , \"b\" ] , [ \"aa\" , \"b\" ]```.\\n### Code with Matrix\\n\\n```\\nclass Solution {\\npublic:\\n// define matrix to check palindrome from i to j\\n    vector<vector<bool>> dp;\\n\\t\\n\\t// answer vector\\n    vector<vector<string>> ans;\\n\\t\\n\\t//palindrome function return true if s is palindrome else returns false\\n    bool ispalin(string s){\\n        int n=s.size();\\n        for(int i=0;i<=n/2;i++){\\n            if(s[i]!=s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n\\t// temporary answer for each choice\\n    vector<string> v;\\n\\t\\n\\t//recursive function to implement backtracking\\n    void solve(string s,int i,int j,int n){\\n\\t\\n\\t// if i reaches to maximum length that is n then push temporary answer to final answer\\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(;j<n;j++){\\n            if(dp[i][j]){\\n                v.push_back(s.substr(i,j-i+1));\\n                solve(s,j+1,j+1,n);\\n                v.pop_back();\\n            }\\n        }\\n\\n        return;\\n        \\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,vector<bool>(n+1,0));\\n        \\n        // initializing and filling all entries of matrix\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(i==j) dp[i][j]=1;\\n                else if(ispalin(s.substr(i,j-i+1))){\\n                    dp[i][j]=1;\\n                }\\n            }\\n        }\\n        solve(s,0,0,n);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n### Code without Matrix\\n```\\nclass Solution {\\npublic:\\n\\t// answer vector\\n    vector<vector<string>> ans;\\n\\t\\n\\t//palindrome function return true if s is palindrome else returns false\\n    bool ispalin(string s){\\n        int n=s.size();\\n        for(int i=0;i<=n/2;i++){\\n            if(s[i]!=s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n\\t// temporary answer for each choice\\n    vector<string> v;\\n\\t\\n\\t//recursive function to implement backtracking\\n    void solve(string s,int i,int j,int n){\\n\\t\\n\\t// if i reaches to maximum length that is n then push temporary answer to final answer\\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(;j<n;j++){\\n            if(ispalin(i,j-i+1){\\n                v.push_back(s.substr(i,j-i+1));\\n                solve(s,j+1,j+1,n);\\n                v.pop_back();\\n            }\\n        }\\n\\n        return;\\n        \\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        solve(s,0,0,n);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```l to r```\n```dp```\n``` n*n```\n``` n = s.size() ```\n```dp[i][j]```\n```substring( i to j )```\n```ispalin(i,j-i+1)```\n```dp[i][j]```\n```s = \"aab\"```\n```substr(i,j)```\n```i=0```\n```i=n-1```\n```substr(0 to 0) ```\n```substr (0 to 1)```\n```substr (0 to 2)```\n```substr( 0 to 0)```\n```dp[0][0] =1```\n```i = 1```\n```j = 1```\n```substr( 1 to 1)```\n```substr(1 to 2)```\n```substr(1 to 1)```\n```dp[1][1] =1```\n```i=2```\n```j=2```\n```substr(2 to 2)```\n```dp[2][2]=1```\n```i and j```\n``` [ \"a\", \"a\" , \"b\" ]```\n```substr(1 to 2)```\n```substr(1 to 1)```\n```dp[1][2]=0```\n```substr(0 to 1)```\n```substr(0 to 0)```\n```dp[0][1]=1```\n```i=2 and j=2```\n```i=2 and j=2```\n```substr(2 to 2)```\n```dp[2][2]=1```\n```i and j```\n``` [ \"aa\" , \"b\" ]```\n```substr(0 to 2)```\n```dp[0][2]=0```\n``` [ \"a\", \"a\" , \"b\" ] , [ \"aa\" , \"b\" ]```\n```\\nclass Solution {\\npublic:\\n// define matrix to check palindrome from i to j\\n    vector<vector<bool>> dp;\\n\\t\\n\\t// answer vector\\n    vector<vector<string>> ans;\\n\\t\\n\\t//palindrome function return true if s is palindrome else returns false\\n    bool ispalin(string s){\\n        int n=s.size();\\n        for(int i=0;i<=n/2;i++){\\n            if(s[i]!=s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n\\t// temporary answer for each choice\\n    vector<string> v;\\n\\t\\n\\t//recursive function to implement backtracking\\n    void solve(string s,int i,int j,int n){\\n\\t\\n\\t// if i reaches to maximum length that is n then push temporary answer to final answer\\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(;j<n;j++){\\n            if(dp[i][j]){\\n                v.push_back(s.substr(i,j-i+1));\\n                solve(s,j+1,j+1,n);\\n                v.pop_back();\\n            }\\n        }\\n\\n        return;\\n        \\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,vector<bool>(n+1,0));\\n        \\n        // initializing and filling all entries of matrix\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(i==j) dp[i][j]=1;\\n                else if(ispalin(s.substr(i,j-i+1))){\\n                    dp[i][j]=1;\\n                }\\n            }\\n        }\\n        solve(s,0,0,n);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\t// answer vector\\n    vector<vector<string>> ans;\\n\\t\\n\\t//palindrome function return true if s is palindrome else returns false\\n    bool ispalin(string s){\\n        int n=s.size();\\n        for(int i=0;i<=n/2;i++){\\n            if(s[i]!=s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n\\t// temporary answer for each choice\\n    vector<string> v;\\n\\t\\n\\t//recursive function to implement backtracking\\n    void solve(string s,int i,int j,int n){\\n\\t\\n\\t// if i reaches to maximum length that is n then push temporary answer to final answer\\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(;j<n;j++){\\n            if(ispalin(i,j-i+1){\\n                v.push_back(s.substr(i,j-i+1));\\n                solve(s,j+1,j+1,n);\\n                v.pop_back();\\n            }\\n        }\\n\\n        return;\\n        \\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        solve(s,0,0,n);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223318,
                "title": "lessons-learned",
                "content": "* **Pattern**: Loop + Recursion (backtrack to be precise) combo\\nThis is a **classic problem from Elements of Programming** under Recursion chapter. The problems under this pattern are solved in **O(2^n) time** without DP (where the paths are required). In some problems where DP could be applied (where paths are not required, like just check if an answer/path is possible), can be solved in O(n^2) (or O(n^3), depends on funtions like .substring() etc)\\n\\t\\n* **Time complexity analysis** of this pattern problems - O(2^n): https://leetcode.com/problems/word-break/discuss/889885/Lessons-learned\\n\\n* **DP or not**:\\nThough this can be solved by DP (the real DP), you could first confirm with interviewer about poterntial effect in time complexity.\\n\\t* LC DP: The **DP approach mentioned in LC is actually not DP** (my opinion). What it does is it **chaches the palindromic computation** of subproblems (which is good from interview perspective, and I would prefer implementing this as an optimization after implementing the recursive approach) and reuses it. But the original problem\\'s result (here path) is not obtained from its subproblems. instead is **re-computed** (same as the simple bactrack one). \\n\\t* Why the **real DP approach of O(n^2)** is **not beneficial** here is because here its actually not O(n^2), instead is **O(n^2 + 2^n)**. \\n**Reason**: \\nThere are **O(n(n+1)/2) prefixSubstrings** for a string s, which equates to the time complezity of total recursions. \\nEach prefixSubstring has to add itself with the partitioning combinations (the cache items) of its suffixSubstring. And there are **O(2^n) partitioning combinations for all the suffixStrings in total** in worst case (eg: suffixSubstring = \"aaaa..\") (Refer image at bottom)\\n**Links**: https://leetcode.com/problems/palindrome-partitioning/discuss/42095/Time-complexity:-why-O(n2) and https://leetcode.com/problems/palindrome-partitioning/discuss/42095/Time-complexity:-why-O(n2)/945251\\n\\n* **Variations** of problem in this pattern: \\n\\t* is a path possible: dfs + dp OR bfs (word break, concatenated words, partition 2 equal sum subsets, partition k equal sum subsets). Bfs for Partition 2 equal is not yet discovered. Also, right now Partition k equal is oy solvable via backtracking.\\n\\t* shortest path length: dfs + dp OR bfs (palindrome partion 2)\\n\\t* return valid paths: backtrack (ie dfs) (palindrome partition, word break 2). Applying dp is not beneficial in time and space.\\n\\n**Code**:\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList<>();\\n        recurse(0, s, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void recurse(int start, String s, List<List<String>> ans, List<String> list) {\\n        if (start >= s.length()) {\\n            ans.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int end = start; end < s.length(); ++end) {\\n            if (isPalindrome(s, start, end)) {\\n                list.add(s.substring(start, end + 1));\\n                recurse(end + 1, s, ans, list);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right) {\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```\\n\\nThe string input \\'abcde\\' in image can be considered as \\'aaaaa\\'.\\n![image](https://assets.leetcode.com/users/images/021cf80f-cfab-4484-b4e2-4c2597705251_1621706267.8458343.jpeg)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList<>();\\n        recurse(0, s, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void recurse(int start, String s, List<List<String>> ans, List<String> list) {\\n        if (start >= s.length()) {\\n            ans.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int end = start; end < s.length(); ++end) {\\n            if (isPalindrome(s, start, end)) {\\n                list.add(s.substring(start, end + 1));\\n                recurse(end + 1, s, ans, list);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right) {\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201634,
                "title": "backtracking-in-a-nutshell-relating-all-the-famous-backtracking-problems",
                "content": "Tried to refine @issac3\\'s article and used CPP here\\n\\n\\n 78. Subsets\\n\\nGiven an integer array nums of unique elements, return all possible subsets (the power set).\\n\\nThe solution set must not contain duplicate subsets. Return the solution in any order.\\n\\n \\n\\nExample 1:\\n\\nInput: nums = [1,2,3]\\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\nExample 2:\\n\\nInput: nums = [0]\\nOutput: [[],[0]]\\nConstraints:\\n\\n1 <= nums.length <= 10\\n-10 <= nums[i] <= 10\\nAll the numbers of nums are unique\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp, vector<int> in,int index)\\n    {\\n        out.push_back(temp);\\n        for(int i=index;i<in.size();i++)\\n        {\\n            temp.push_back(in[i]);\\n            helper(out,temp,in,i+1);//for exploring all possible ways set i+1 here and if you want to traverse array just once then use index+1 here, in most cases we use i\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) \\n    {\\n        vector<vector<int>> out;\\n        sort(nums.begin(),nums.end());\\n        helper(out,{},nums,0);\\n        return out;\\n    }\\n};\\n```\\n90. Subsets II (when given array may contain duplicates)\\n\\nGiven an integer array nums that may contain duplicates, return all possible subsets (the power set).\\n\\nThe solution set must not contain duplicate subsets. Return the solution in any order.\\n\\n \\n\\nExample 1:\\n\\nInput: nums = [1,2,2]\\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\\nExample 2:\\n\\nInput: nums = [0]\\nOutput: [[],[0]]\\n \\n\\nConstraints:\\n\\n1 <= nums.length <= 10\\n-10 <= nums[i] <= 10\\n```\\nclass Solution \\n{\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp, vector<int> in,int index)\\n    {\\n        out.push_back(temp);\\n        for(int i=index;i<in.size();i++)\\n        {\\n            if(i>index)//try to visualize a tree and notice in which branches can duplicates occur, break that branch\\n            {\\n            if(in[i]==in[i-1])continue;\\n            }\\n            temp.push_back(in[i]);\\n        helper(out,temp,in,i+1);//important its not index +1 its i+1 \\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums)\\n    {\\n        vector<vector<int>> out;\\n        sort(nums.begin(),nums.end());//very important here to remove dupicates\\n        helper(out,{},nums,0);\\n        return out;\\n    }\\n};\\n```\\n46. Permutations\\nMedium\\n\\nGiven an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\\n\\nExample 1:\\n\\nInput: nums = [1,2,3]\\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\\nExample 2:\\n\\nInput: nums = [0,1]\\nOutput: [[0,1],[1,0]]\\nExample 3:\\n\\nInput: nums = [1]\\nOutput: [[1]]\\n \\n\\nConstraints:\\n\\n1 <= nums.length <= 6\\n-10 <= nums[i] <= 10\\nAll the integers of nums are unique.\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > permute(vector<int> &num) {\\n\\t    vector<vector<int> > result;\\n\\t    \\n\\t    permuteRecursive(num, 0, result);\\n\\t    return result;\\n    }\\n    \\n\\tvoid permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)\\t{\\n\\t\\tif (begin == num.size()) {\\n\\t\\t    // one permutation instance\\n\\t\\t    result.push_back(num);\\n\\t\\t    return;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = begin; i < num.size(); i++) {\\n\\t\\t    swap(num[begin], num[i]);\\n\\t\\t    permuteRecursive(num, begin + 1, result);\\n\\t\\t    // reset\\n\\t\\t    swap(num[begin], num[i]);\\n\\t\\t}\\n    }\\n};\\n```\\n47. Permutations II\\n\\nGiven a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\\n\\nExample 1:\\n\\nInput: nums = [1,1,2]\\nOutput:\\n[[1,1,2],\\n [1,2,1],\\n [2,1,1]]\\nExample 2:\\n\\nInput: nums = [1,2,3]\\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\\n ```\\n class Solution {\\n\\nprivate:\\n    vector<vector<int>> permutations;\\n    \\n    void permute(vector<int>& nums, int start)\\n    {\\n        if (start == nums.size() - 1) { permutations.push_back(nums); }\\n            \\n        unordered_set<int> seen;  \\n        for (int i = start; i < nums.size(); ++i)\\n        {\\n            if (seen.find(nums[i]) == seen.end())\\n            {\\n                swap(nums[start], nums[i]);\\n                permute(nums, start+1);\\n                swap(nums[start], nums[i]);  // backtrack\\n                seen.insert(nums[i]);\\n            }\\n        }     \\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums)\\n    {\\n        if (nums.size() < 2) { return {nums}; }\\n        permute(nums, 0);\\n        return permutations;\\n    }\\n};      \\n```\\n39. Combination Sum\\n\\nGiven an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\\n\\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\\n\\nIt is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\\n\\n\\nExample 1:\\n\\nInput: candidates = [2,3,6,7], target = 7\\nOutput: [[2,2,3],[7]]\\nExplanation:\\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\n7 is a candidate, and 7 = 7.\\nThese are the only two combinations.\\nExample 2:\\n\\nInput: candidates = [2,3,5], target = 8\\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\\nExample 3:\\n\\nInput: candidates = [2], target = 1\\nOutput: []\\nExample 4:\\n\\nInput: candidates = [1], target = 1\\nOutput: [[1]]\\nExample 5:\\n\\nInput: candidates = [1], target = 2\\nOutput: [[1,1]]\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp,vector<int> A,int remain,int index)\\n    {\\n        if(remain<0)return;\\n        else if(remain==0)out.push_back(temp);\\n        else\\n        {\\n            for(int i=index;i<A.size();i++)\\n            {\\n                temp.push_back(A[i]);\\n                helper(out,temp,A,remain-A[i],i);//we can take same item multiple times so we did\\'nt do i+1\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target)\\n    {\\n        //target is to be reached\\n        vector<vector<int>> out;\\n        sort(candidates.begin(),candidates.end());\\n        helper(out,{},candidates,target,0);\\n        return out;\\n    }\\n};\\n```\\n40. Combination Sum II\\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\\n\\nEach number in candidates may only be used once in the combination.\\n\\nNote: The solution set must not contain duplicate combinations.\\n\\n \\n\\nExample 1:\\n\\nInput: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]\\nExample 2:\\n\\nInput: candidates = [2,5,2,1,2], target = 5\\nOutput: \\n[\\n[1,2,2],\\n[5]\\n]\\n \\n\\nConstraints:\\n\\n1 <= candidates.length <= 100\\n1 <= candidates[i] <= 50\\n1 <= target <= 30\\n\\n\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp,vector<int> A,int remain,int index)\\n    {\\n        if(remain<0)return;\\n        else if(remain==0)out.push_back(temp);\\n        else\\n        {\\n            for(int i=index;i<A.size();i++)\\n            {\\n                if(i>index&&A[i]==A[i-1])continue;\\n                temp.push_back(A[i]);\\n                helper(out,temp,A,remain-A[i],i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target)\\n    {\\n        //target is to be reached\\n        vector<vector<int>> out;\\n        sort(candidates.begin(),candidates.end());\\n        helper(out,{},candidates,target,0);\\n        return out;\\n    }\\n};\\n```\\n131. Palindrome Partitioning\\nGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\n\\nA palindrome string is a string that reads the same backward as forward.\\n\\n \\nExample 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\nExample 2:\\n\\nInput: s = \"a\"\\nOutput: [[\"a\"]]\\n \\n\\nConstraints:\\n\\n1 <= s.length <= 16\\ns contains only lowercase English letters.\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s, int low, int high)\\n    {\\n     while(low <high)\\n        if(s[low++]!=s[high--]) return false;\\n    return true;\\n    } \\n    void helper(vector<vector<string>> &out, string A, vector<string> temp, int index)\\n    {\\n        if(index==A.size())\\n            out.push_back(temp);\\n        for(int i=index;i<A.size();i++)\\n        {            \\n            if(isPalindrome(A,index,i))\\n            {\\n                temp.push_back(A.substr(index,i-index+1));\\n                helper(out,A,temp,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s)\\n    {\\n        vector<vector<string>> out;\\n        helper(out,s,{},0);\\n        return out;\\n    }\\n};                                              \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp, vector<int> in,int index)\\n    {\\n        out.push_back(temp);\\n        for(int i=index;i<in.size();i++)\\n        {\\n            temp.push_back(in[i]);\\n            helper(out,temp,in,i+1);//for exploring all possible ways set i+1 here and if you want to traverse array just once then use index+1 here, in most cases we use i\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) \\n    {\\n        vector<vector<int>> out;\\n        sort(nums.begin(),nums.end());\\n        helper(out,{},nums,0);\\n        return out;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp, vector<int> in,int index)\\n    {\\n        out.push_back(temp);\\n        for(int i=index;i<in.size();i++)\\n        {\\n            if(i>index)//try to visualize a tree and notice in which branches can duplicates occur, break that branch\\n            {\\n            if(in[i]==in[i-1])continue;\\n            }\\n            temp.push_back(in[i]);\\n        helper(out,temp,in,i+1);//important its not index +1 its i+1 \\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums)\\n    {\\n        vector<vector<int>> out;\\n        sort(nums.begin(),nums.end());//very important here to remove dupicates\\n        helper(out,{},nums,0);\\n        return out;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > permute(vector<int> &num) {\\n\\t    vector<vector<int> > result;\\n\\t    \\n\\t    permuteRecursive(num, 0, result);\\n\\t    return result;\\n    }\\n    \\n\\tvoid permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)\\t{\\n\\t\\tif (begin == num.size()) {\\n\\t\\t    // one permutation instance\\n\\t\\t    result.push_back(num);\\n\\t\\t    return;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = begin; i < num.size(); i++) {\\n\\t\\t    swap(num[begin], num[i]);\\n\\t\\t    permuteRecursive(num, begin + 1, result);\\n\\t\\t    // reset\\n\\t\\t    swap(num[begin], num[i]);\\n\\t\\t}\\n    }\\n};\\n```\n```\\n class Solution {\\n\\nprivate:\\n    vector<vector<int>> permutations;\\n    \\n    void permute(vector<int>& nums, int start)\\n    {\\n        if (start == nums.size() - 1) { permutations.push_back(nums); }\\n            \\n        unordered_set<int> seen;  \\n        for (int i = start; i < nums.size(); ++i)\\n        {\\n            if (seen.find(nums[i]) == seen.end())\\n            {\\n                swap(nums[start], nums[i]);\\n                permute(nums, start+1);\\n                swap(nums[start], nums[i]);  // backtrack\\n                seen.insert(nums[i]);\\n            }\\n        }     \\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums)\\n    {\\n        if (nums.size() < 2) { return {nums}; }\\n        permute(nums, 0);\\n        return permutations;\\n    }\\n};      \\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp,vector<int> A,int remain,int index)\\n    {\\n        if(remain<0)return;\\n        else if(remain==0)out.push_back(temp);\\n        else\\n        {\\n            for(int i=index;i<A.size();i++)\\n            {\\n                temp.push_back(A[i]);\\n                helper(out,temp,A,remain-A[i],i);//we can take same item multiple times so we did\\'nt do i+1\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target)\\n    {\\n        //target is to be reached\\n        vector<vector<int>> out;\\n        sort(candidates.begin(),candidates.end());\\n        helper(out,{},candidates,target,0);\\n        return out;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp,vector<int> A,int remain,int index)\\n    {\\n        if(remain<0)return;\\n        else if(remain==0)out.push_back(temp);\\n        else\\n        {\\n            for(int i=index;i<A.size();i++)\\n            {\\n                if(i>index&&A[i]==A[i-1])continue;\\n                temp.push_back(A[i]);\\n                helper(out,temp,A,remain-A[i],i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target)\\n    {\\n        //target is to be reached\\n        vector<vector<int>> out;\\n        sort(candidates.begin(),candidates.end());\\n        helper(out,{},candidates,target,0);\\n        return out;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s, int low, int high)\\n    {\\n     while(low <high)\\n        if(s[low++]!=s[high--]) return false;\\n    return true;\\n    } \\n    void helper(vector<vector<string>> &out, string A, vector<string> temp, int index)\\n    {\\n        if(index==A.size())\\n            out.push_back(temp);\\n        for(int i=index;i<A.size();i++)\\n        {            \\n            if(isPalindrome(A,index,i))\\n            {\\n                temp.push_back(A.substr(index,i-index+1));\\n                helper(out,A,temp,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s)\\n    {\\n        vector<vector<string>> out;\\n        helper(out,s,{},0);\\n        return out;\\n    }\\n};                                              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089142,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \"\"\"Backtracking.\"\"\"\\n        def depth_first_search(rest: str):\\n            if not rest:\\n                result.append(current[:])\\n            for end in range(1, len(rest) + 1):\\n                # Reverse and equal is palindrome. You can save result for\\n                # each substring in a dp[n][n] to avoid repeating check in the\\n                # future.\\n                if rest[:end] == rest[end-1::-1]:\\n                    current.append(rest[:end])\\n                    depth_first_search(rest[end:])\\n                    current.pop()\\n        result = []\\n        current = []\\n        depth_first_search(s)\\n        return result        \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \"\"\"Backtracking.\"\"\"\\n        def depth_first_search(rest: str):\\n            if not rest:\\n                result.append(current[:])\\n            for end in range(1, len(rest) + 1):\\n                # Reverse and equal is palindrome. You can save result for\\n                # each substring in a dp[n][n] to avoid repeating check in the\\n                # future.\\n                if rest[:end] == rest[end-1::-1]:\\n                    current.append(rest[:end])\\n                    depth_first_search(rest[end:])\\n                    current.pop()\\n        result = []\\n        current = []\\n        depth_first_search(s)\\n        return result        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 971924,
                "title": "python-simple-recursive-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def recur(s,part,res):\\n            if not s:\\n                res.append(part)\\n            n=len(s)\\n            for i in range(1,n+1):\\n                if s[:i]==s[:i][::-1]:\\n                    recur(s[i:],part+[s[:i]],res)\\n        res=[]\\n        recur(s,[],res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def recur(s,part,res):\\n            if not s:\\n                res.append(part)\\n            n=len(s)\\n            for i in range(1,n+1):\\n                if s[:i]==s[:i][::-1]:\\n                    recur(s[i:],part+[s[:i]],res)\\n        res=[]\\n        recur(s,[],res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870547,
                "title": "python-easy-to-understand-solution-using-backtracking",
                "content": "````\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def isPalindrome(s):\\n            left = 0\\n            right = len(s) - 1\\n            while(left<=right):\\n                if s[left] != s[right]:\\n                    return False\\n                left += 1\\n                right -= 1\\n            return True\\n        \\n        def helper(palindromes, start, end):\\n            nonlocal result\\n\\t\\t\\t# will only happen when the string is divided correctly into palindromes\\n            if start >= len(s): \\n                result.append(palindromes)\\n                return\\n\\t\\t\\t# end overflow, so return\\n            if end >=len(s):\\n                return\\n\\t\\t\\t# check if the values of start and end make a palindrome\\n            if isPalindrome(s[start:end+1]):\\n                helper(palindromes+[s[start:end+1]], end+1, end+1)\\n            # keep going with the same value of start and increment end by 1\\n            helper(palindromes, start, end+1)\\n        \\n        result = []\\n        helper([], 0, 0)\\n        return result\\n            \\n````\\nIf N is length of s:\\n- Space complexity: O(N)  (i.e. recursion stack max length)\\n- Time Complexity: O(N*2^N) \\n\\t-  How? form a recursion tree, for any index i we will call palindrome at most 2 times",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "````\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def isPalindrome(s):\\n            left = 0\\n            right = len(s) - 1\\n            while(left<=right):\\n                if s[left] != s[right]:\\n                    return False\\n                left += 1\\n                right -= 1\\n            return True\\n        \\n        def helper(palindromes, start, end):\\n            nonlocal result\\n\\t\\t\\t# will only happen when the string is divided correctly into palindromes\\n            if start >= len(s): \\n                result.append(palindromes)\\n                return\\n\\t\\t\\t# end overflow, so return\\n            if end >=len(s):\\n                return\\n\\t\\t\\t# check if the values of start and end make a palindrome\\n            if isPalindrome(s[start:end+1]):\\n                helper(palindromes+[s[start:end+1]], end+1, end+1)\\n            # keep going with the same value of start and increment end by 1\\n            helper(palindromes, start, end+1)\\n        \\n        result = []\\n        helper([], 0, 0)\\n        return result\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 852283,
                "title": "c-with-recursion-backtracking",
                "content": "With the use of backtracking use can get the solution easily. Just check the left subpart and then if it is palindrome, check whether it\\'s right subpart is palindrome or not and if yes then it\\'s left and so on....\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> temp;\\n        findAll(s,result,temp);\\n        \\n        return result;\\n    }\\n    \\n    void findAll(string s,vector<vector<string>> &result, vector<string> temp){\\n            if(s.length()==0)\\n                result.push_back(temp);\\n        \\n        \\n        for(int i=0;i<s.length();i++){\\n            string leftpar = s.substr(0,i+1);\\n            if(isPalindrome(leftpar)){\\n                temp.push_back(leftpar);\\n                findAll(s.substr(i+1),result,temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string st){\\n        int left=0;\\n        int right = st.size()-1;\\n        if(left==right) return true;\\n        \\n        while(left < right){\\n            if(st[left]!=st[right]) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    } ```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> temp;\\n        findAll(s,result,temp);\\n        \\n        return result;\\n    }\\n    \\n    void findAll(string s,vector<vector<string>> &result, vector<string> temp){\\n            if(s.length()==0)\\n                result.push_back(temp);\\n        \\n        \\n        for(int i=0;i<s.length();i++){\\n            string leftpar = s.substr(0,i+1);\\n            if(isPalindrome(leftpar)){\\n                temp.push_back(leftpar);\\n                findAll(s.substr(i+1),result,temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string st){\\n        int left=0;\\n        int right = st.size()-1;\\n        if(left==right) return true;\\n        \\n        while(left < right){\\n            if(st[left]!=st[right]) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    } ```",
                "codeTag": "Java"
            },
            {
                "id": 829241,
                "title": "c-backtracking-alternative-approach-faster-than-100-with-explanation",
                "content": "The approach I took to solve this problem is a little different than what I\\'ve seen in the discussion board (correct me if I\\'m wrong).\\n\\nMost backtracking solutions iterate through every substring, check if it\\'s a palindrome and call a DFS function recursively. What I ended up doing is generating an array of palindrome combinations per index. The inspiration for this solution came from [Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/). We can iterate through the string and for each *S[i]* use 2 pointers (namely left and right) and keep expanding them for as long as they form a palindrome. The left pointer will eventual point to the beginning index (the palindrome\\'s starting point).\\n\\nFor example, for the string `aab`, the combinations array looks like this:\\n```\\npalindromes[0] => \"a\", \"aa\"\\npalindromes[1] => \"a\"\\npalindromes[2] => \"b\"\\n```\\n\\nOnce the array was generated, I used backtracing by advancing the index based on the size of the current palindrome combination.\\n\\nThis is my last run:\\n\\n**Runtime:** 4 ms, faster than 100.00% of C++ online submissions for Palindrome Partitioning.\\n**Memory Usage:** 9 MB, less than 92.26% of C++ online submissions for Palindrome Partitioning.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string str) {\\n        vector<vector<string>> palindromes(size(str));\\n        for (int i = 0; i < size(str); ++i) {\\n            int left = i, right = i;\\n            \\n            // single char palindrome\\n            palindromes[left].emplace_back(str.substr(i, 1));\\n            \\n            // expand to the right if possible (each expansion is a new palindrome)\\n            while (i < size(str) - 1 && str[right + 1] == str[right]) {\\n                ++right;\\n                palindromes[left].emplace_back(str.substr(i, right - left + 1));\\n            }\\n            \\n            // expand from the center if possible (each expansion is a new palindrome)\\n            while (left > 0 && right < size(str) - 1 && str[left - 1] == str[right + 1]) {\\n                ++right, --left;\\n                palindromes[left].emplace_back(str.substr(left, right - left + 1));\\n            }\\n        }\\n\\n        vector<vector<string>> output;\\n        vector<string> curr;\\n        generatePalindromePermutations(output, palindromes, curr, 0);\\n        return output;\\n    }\\nprivate:\\n    void generatePalindromePermutations(vector<vector<string>>& output, const vector<vector<string>>& palindromes, vector<string>& curr, int idx) {\\n        if (idx >= size(palindromes)) {\\n            output.emplace_back(curr);\\n            return;\\n        }\\n        for (int i = 0; i < size(palindromes[idx]); ++i) {\\n            curr.emplace_back(palindromes[idx][i]);\\n            generatePalindromePermutations(output, palindromes, curr, idx + size(palindromes[idx][i]));\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\npalindromes[0] => \"a\", \"aa\"\\npalindromes[1] => \"a\"\\npalindromes[2] => \"b\"\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string str) {\\n        vector<vector<string>> palindromes(size(str));\\n        for (int i = 0; i < size(str); ++i) {\\n            int left = i, right = i;\\n            \\n            // single char palindrome\\n            palindromes[left].emplace_back(str.substr(i, 1));\\n            \\n            // expand to the right if possible (each expansion is a new palindrome)\\n            while (i < size(str) - 1 && str[right + 1] == str[right]) {\\n                ++right;\\n                palindromes[left].emplace_back(str.substr(i, right - left + 1));\\n            }\\n            \\n            // expand from the center if possible (each expansion is a new palindrome)\\n            while (left > 0 && right < size(str) - 1 && str[left - 1] == str[right + 1]) {\\n                ++right, --left;\\n                palindromes[left].emplace_back(str.substr(left, right - left + 1));\\n            }\\n        }\\n\\n        vector<vector<string>> output;\\n        vector<string> curr;\\n        generatePalindromePermutations(output, palindromes, curr, 0);\\n        return output;\\n    }\\nprivate:\\n    void generatePalindromePermutations(vector<vector<string>>& output, const vector<vector<string>>& palindromes, vector<string>& curr, int idx) {\\n        if (idx >= size(palindromes)) {\\n            output.emplace_back(curr);\\n            return;\\n        }\\n        for (int i = 0; i < size(palindromes[idx]); ++i) {\\n            curr.emplace_back(palindromes[idx][i]);\\n            generatePalindromePermutations(output, palindromes, curr, idx + size(palindromes[idx][i]));\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690701,
                "title": "python-very-simple-dfs-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        ## RC ##\\n        ## APPROACH : BACKTRACKING ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(2 ^ N) ##\\n\\t\\t## SPACE COMPLEXITY : O(2 ^ N) ##\\n\\n        def isPalindrome(string):\\n            start = 0;\\n            end = len(string)-1\\n            while(start < end):\\n                if(string[start] != string[end]):\\n                    return False\\n                start += 1\\n                end -= 1\\n            return True\\n        \\n        def makePartitions(curr, s):\\n            \\n            if(len(s) == 0): \\n                result.append(curr[:])\\n                return\\n            \\n            for i in range(1,len(s)+1):\\n                if(isPalindrome(s[:i])):\\n                    makePartitions(curr + [s[:i]], s[i:])\\n              \\n        result = []\\n        makePartitions([], s)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        ## RC ##\\n        ## APPROACH : BACKTRACKING ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(2 ^ N) ##\\n\\t\\t## SPACE COMPLEXITY : O(2 ^ N) ##\\n\\n        def isPalindrome(string):\\n            start = 0;\\n            end = len(string)-1\\n            while(start < end):\\n                if(string[start] != string[end]):\\n                    return False\\n                start += 1\\n                end -= 1\\n            return True\\n        \\n        def makePartitions(curr, s):\\n            \\n            if(len(s) == 0): \\n                result.append(curr[:])\\n                return\\n            \\n            for i in range(1,len(s)+1):\\n                if(isPalindrome(s[:i])):\\n                    makePartitions(curr + [s[:i]], s[i:])\\n              \\n        result = []\\n        makePartitions([], s)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672300,
                "title": "java-1-ms-faster-than-100-00-backtracking",
                "content": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        if (s == null || \"\".equals(s)) {\\n            res.add(new ArrayList<>());\\n            return res;\\n        }\\n        \\n        dfs(s, 0, new ArrayList<>(), res);\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(String s, int offSet, List<String> pal, List<List<String>> res) {\\n        if (offSet == s.length()) {\\n            res.add(new ArrayList<>(pal));\\n            return;\\n        }\\n        \\n        int currLength = pal.size();\\n        for (int i = offSet; i < s.length(); i++) {\\n            if (isPalindrome(s, offSet, i)) {\\n                pal.add(s.substring(offSet, i + 1));\\n                dfs(s, i + 1, pal, res);\\n                pal.remove(currLength);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int start, int end) {\\n        while (start < end) {\\n            if (s.charAt(start) != s.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        \\n        return true;\\n    }\\n}\\n",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        if (s == null || \"\".equals(s)) {\\n            res.add(new ArrayList<>());\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 647796,
                "title": "java-1ms-beats-100",
                "content": "Recursive Approach: Create a list of list of integers, and for each index, store the next index, between which(both inclusive) the string will be a pallindrome.\\nNext use recursive approach to find all possible paths to reach the end of the string, while add pallindrominc substrings to a list, and if the end is reached, add that list to the result.\\nFor example: for input \"aabaab\", the list of list of integers having pallindrome substring information would be:\\n[ [0,1,4] , [1,3] , [2,5] , [3,4] , [4] , [5]]\\nFor each index, there is a list of indices.\\nLike, at index 0, the list is [0,1,4], which means that\\n1.the substring between index 0, and the list index 0, i.e., \"a\" is a pallindrome\\n2.1.the substring between index 0, and the list index 1, i.e., \"aa\" is a pallindrome\\n3.1.the substring between index 0, and the list index 4, i.e., \"aabaa\" is a pallindrome\\n\\nAfter we have creeated this list of lists, we will use recursion to find all possible exclusive substrings which constitute to form the whole string, and add it to the result.\\nFor example: index 0 to index 1, then index 2 to index 5\\nor index 0 to index 0, then index 1 to index 3, then index 4 to index 4, then index 5 to index 5\\nand many more.\\n\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        StringBuilder str = new StringBuilder();\\n        str.append(s);\\n        int len = str.length();\\n        List<List<Integer>> entries = new ArrayList<>();\\n        entries.add(new ArrayList<Integer>());\\n        entries.get(0).add(0);\\n        for(int i=1; i<len; i++){  //In this loop we will create the list of list of integers which will keep information about all possible substrings of the string as described above.\\n            entries.add(new ArrayList<Integer>());\\n            int j=0;\\n            while(i-j>=0 && i+j<len){ //for odd length substrings, we expand equally towards left and right\\n                if(str.charAt(i-j)!=str.charAt(i+j))\\n                    break;\\n                entries.get(i-j).add(i+j);\\n                j++;\\n            }\\n            j=0;\\n            while(i-j-1>=0 && i+j<len){ //for even length substring we expand one extra to the left, than to the right\\n                if(str.charAt(i-j-1)!=str.charAt(i+j))\\n                    break;\\n                entries.get(i-j-1).add(i+j);\\n                j++;\\n            }\\n        }\\n        addPallindromes(entries, res, new ArrayList<String>(), 0, str);\\n        return res;\\n    }\\n    \\n    public void addPallindromes(List<List<Integer>> entries, List<List<String>> res, List<String> pallindrome, int index, StringBuilder str){\\n        if(index==str.length()){ //If we have reached the end of the string, then all exclusive substrings have constituted to complete the string, hence we can add it to the result\\n            res.add(pallindrome);\\n            return;\\n        }\\n        int target;\\n        for(int i=0; i<entries.get(index).size(); i++){  //for each index, we would travers the list of indices, pairing which, the substring would be pallindromic.\\n            target = entries.get(index).get(i);\\n            List<String> pal = new ArrayList<>(pallindrome);\\n            pal.add(str.substring(index, target+1)); //then we will do the same for the index, ahead of the current pallindromic substring.\\n            addPallindromes(entries, res, pal, target+1, str);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        StringBuilder str = new StringBuilder();\\n        str.append(s);\\n        int len = str.length();\\n        List<List<Integer>> entries = new ArrayList<>();\\n        entries.add(new ArrayList<Integer>());\\n        entries.get(0).add(0);\\n        for(int i=1; i<len; i++){  //In this loop we will create the list of list of integers which will keep information about all possible substrings of the string as described above.\\n            entries.add(new ArrayList<Integer>());\\n            int j=0;\\n            while(i-j>=0 && i+j<len){ //for odd length substrings, we expand equally towards left and right\\n                if(str.charAt(i-j)!=str.charAt(i+j))\\n                    break;\\n                entries.get(i-j).add(i+j);\\n                j++;\\n            }\\n            j=0;\\n            while(i-j-1>=0 && i+j<len){ //for even length substring we expand one extra to the left, than to the right\\n                if(str.charAt(i-j-1)!=str.charAt(i+j))\\n                    break;\\n                entries.get(i-j-1).add(i+j);\\n                j++;\\n            }\\n        }\\n        addPallindromes(entries, res, new ArrayList<String>(), 0, str);\\n        return res;\\n    }\\n    \\n    public void addPallindromes(List<List<Integer>> entries, List<List<String>> res, List<String> pallindrome, int index, StringBuilder str){\\n        if(index==str.length()){ //If we have reached the end of the string, then all exclusive substrings have constituted to complete the string, hence we can add it to the result\\n            res.add(pallindrome);\\n            return;\\n        }\\n        int target;\\n        for(int i=0; i<entries.get(index).size(); i++){  //for each index, we would travers the list of indices, pairing which, the substring would be pallindromic.\\n            target = entries.get(index).get(i);\\n            List<String> pal = new ArrayList<>(pallindrome);\\n            pal.add(str.substring(index, target+1)); //then we will do the same for the index, ahead of the current pallindromic substring.\\n            addPallindromes(entries, res, pal, target+1, str);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483424,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 16 ms, faster than 100.00% of Go online submissions for Palindrome Partitioning.\\nMemory Usage: 9.2 MB, less than 100.00% of Go online submissions for Palindrome Partitioning.\\n\\n```go\\nfunc partition(s string) [][]string {\\n    res := [][]string{}\\n    helper(s, 0, []string{}, &res)\\n    return res\\n}\\n\\nfunc helper(s string, index int, S []string, res *[][]string) {\\n    if index == len(s) {\\n        *res = append(*res, append([]string{}, S...))\\n        return \\n    }\\n    for i := index + 1; i <= len(s); i++ {\\n        if isPalindrome(s[index:i]) {\\n            S = append(S, s[index:i])\\n            helper(s, i, S, res)\\n            S = S[:len(S)-1]\\n        }\\n    }\\n}\\n\\nfunc isPalindrome(s string) bool {\\n    a := 0\\n    b := len(s) - 1\\n    for a < b {\\n        if s[a] != s[b] { return false }\\n        a++\\n        b--\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc partition(s string) [][]string {\\n    res := [][]string{}\\n    helper(s, 0, []string{}, &res)\\n    return res\\n}\\n\\nfunc helper(s string, index int, S []string, res *[][]string) {\\n    if index == len(s) {\\n        *res = append(*res, append([]string{}, S...))\\n        return \\n    }\\n    for i := index + 1; i <= len(s); i++ {\\n        if isPalindrome(s[index:i]) {\\n            S = append(S, s[index:i])\\n            helper(s, i, S, res)\\n            S = S[:len(S)-1]\\n        }\\n    }\\n}\\n\\nfunc isPalindrome(s string) bool {\\n    a := 0\\n    b := len(s) - 1\\n    for a < b {\\n        if s[a] != s[b] { return false }\\n        a++\\n        b--\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 356285,
                "title": "java-concise-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new LinkedList<>();\\n        List<String> cur = new LinkedList<>();\\n        dfs(0,s.length()-1,s,cur,res);\\n        return res;\\n        \\n    }\\n    private void dfs(int start, int end, String s, List<String> cur, List<List<String>> res){\\n        if(start > end){ \\n            res.add(new LinkedList<>(cur));\\n            return;\\n        }\\n        for(int i = start; i <= end; i ++){\\n            if(isPalindrome(s, start, i)){\\n                cur.add(s.substring(start,i+1));\\n                dfs(i+1,end,s,cur,res);\\n                cur.remove(cur.size()-1);\\n            }\\n        }\\n    }\\n    private boolean isPalindrome(String s, int start, int end){\\n        while(start < end){\\n            if(s.charAt(start)!=s.charAt(end)){\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new LinkedList<>();\\n        List<String> cur = new LinkedList<>();\\n        dfs(0,s.length()-1,s,cur,res);\\n        return res;\\n        \\n    }\\n    private void dfs(int start, int end, String s, List<String> cur, List<List<String>> res){\\n        if(start > end){ \\n            res.add(new LinkedList<>(cur));\\n            return;\\n        }\\n        for(int i = start; i <= end; i ++){\\n            if(isPalindrome(s, start, i)){\\n                cur.add(s.substring(start,i+1));\\n                dfs(i+1,end,s,cur,res);\\n                cur.remove(cur.size()-1);\\n            }\\n        }\\n    }\\n    private boolean isPalindrome(String s, int start, int end){\\n        while(start < end){\\n            if(s.charAt(start)!=s.charAt(end)){\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349012,
                "title": "c-clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalin(string s) {\\n        int i = 0, j = s.size() - 1;\\n        while(i <= j) {\\n            if(s[i++] != s[j--]) return false;\\n        }\\n        return true;\\n    }\\n    void generate(vector<vector<string>>&ans, vector<string> temp, string s, int idx) {\\n        if(idx == s.size()) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        string t;\\n        for(int i = idx; i < s.size(); i++) {\\n            t += s[i];\\n            if(isPalin(t)) {\\n                temp.push_back(t);\\n                generate(ans, temp, s, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector< vector<string >> ans;\\n        generate(ans, {}, s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalin(string s) {\\n        int i = 0, j = s.size() - 1;\\n        while(i <= j) {\\n            if(s[i++] != s[j--]) return false;\\n        }\\n        return true;\\n    }\\n    void generate(vector<vector<string>>&ans, vector<string> temp, string s, int idx) {\\n        if(idx == s.size()) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        string t;\\n        for(int i = idx; i < s.size(); i++) {\\n            t += s[i];\\n            if(isPalin(t)) {\\n                temp.push_back(t);\\n                generate(ans, temp, s, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector< vector<string >> ans;\\n        generate(ans, {}, s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296690,
                "title": "backtracking-solution-for-slow-learners-like-myself-2ms",
                "content": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> partitions = new ArrayList<>();\\n        if (s == null || s.length() == 0) \\n\\t\\t\\treturn partitions;\\n        addPalindromePartitions(partitions, new ArrayList<>(), s);\\n        return partitions;\\n    }\\n    \\n    private void addPalindromePartitions(List<List<String>> partitions, List<String> partition, String s) {\\n\\t    //base case -- we recurse until the substring given is empty string\\n\\t    //if it means its empty string it implies we cannot backtrack anymore so add the current list to the solution\\n        if (s.length() == 0) {\\n            partitions.add(new ArrayList<>(partition));\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= s.length(); i++) {\\n\\t\\t    //check if the current prefix from 0 to i is a palindrome. If it happens to be a palindrome, add the\\n\\t\\t\\t//current prefix to the recursion list, and recurse further with the suffix as a substring\\n\\t\\t\\t//discard the current add once we are done with the current backtrack call\\n            if (isPalindrome(s, i - 1)) {\\n                partition.add(s.substring(0, i));\\n                addPalindromePartitions(partitions, partition, s.substring(i));\\n                partition.remove(partition.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int right) {\\n        int left = 0;\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right--)) \\n\\t\\t\\t\\treturn false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> partitions = new ArrayList<>();\\n        if (s == null || s.length() == 0) \\n\\t\\t\\treturn partitions;\\n        addPalindromePartitions(partitions, new ArrayList<>(), s);\\n        return partitions;\\n    }\\n    \\n    private void addPalindromePartitions(List<List<String>> partitions, List<String> partition, String s) {\\n\\t    //base case -- we recurse until the substring given is empty string\\n\\t    //if it means its empty string it implies we cannot backtrack anymore so add the current list to the solution\\n        if (s.length() == 0) {\\n            partitions.add(new ArrayList<>(partition));\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= s.length(); i++) {\\n\\t\\t    //check if the current prefix from 0 to i is a palindrome. If it happens to be a palindrome, add the\\n\\t\\t\\t//current prefix to the recursion list, and recurse further with the suffix as a substring\\n\\t\\t\\t//discard the current add once we are done with the current backtrack call\\n            if (isPalindrome(s, i - 1)) {\\n                partition.add(s.substring(0, i));\\n                addPalindromePartitions(partitions, partition, s.substring(i));\\n                partition.remove(partition.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int right) {\\n        int left = 0;\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right--)) \\n\\t\\t\\t\\treturn false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291914,
                "title": "java-dfs-dp-with-detailed-explanation-easy-to-understand",
                "content": "\\nBy observing, we can use DFS to solve the problem. DFS is extremely useful on problems like permutation combination etc..\\n\\nWhen we trying to solve a problem with Depth First Search (backtracking), it is useful for us to generate a recursion tree and speaks out the meaning of each level and each branches.\\n\\nIn this particular problem, each level representing a particular subproblems where s[0...level - 1] has already formed valid palindrome partition. The subproblem becomes solving the following s[level...end] subproblems. In the subproblems, we iterate index i from the current level index to the end of the string, if we see s[level...i] is a palindrome, then we can add the current substring s[level...i] to the list and going to the next subproblems s[i+1...end] by recursive call with updated parameter. \\n\\nFollowing the analysis, we can see that there are O(n!) levels of node in the recursive tree, and there are at most n level of recursion on the call stack. \\n\\nThen, the problem becomes how to check a string is palindrome. A Naive but working solution is to iterate the string with two pointers walking in the opposite direction:\\n\\n```\\nboolean isPalindrome(String s, int start, int end) {\\n\\twhile (start < end) {\\n\\t\\tif (s.charAt(start++) != s.charAt(end--)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nBy taking this method we need O(n) time to check whether a substring s[i...j] is palindrome by calling isPalindrome(s, i, j).\\nThe total time complexity is O(n!*n).\\nSince there are at most O(n) recursive calls on the call stack and no extra data structure is allocated, space complexity O(n).\\n\\nHowever, I noticed that the palindrome problem can be solved by dynamic programming by the following observation:\\n1. The big problem (string) can be divided into smaller problem (substring or even characters)\\n2. The minimum sized problems (a single character) have identical or similar properties. \\n\\nAbove observation implies that using dynamic programming would be a choice. All we need to do is to figure out the base case and induction rules of the problem.\\n\\nbase case: dp[i][i] -> true (a single character is palindrome)\\ninduction rule: \\n\\t\\tdp[i][j] representing whether s[i...j] is a palindrome\\n\\t\\tdp[i][j] = true if s[i] == s[j] and s[i], s[j] is next to each other (i - j < 2), \\n\\t\\t\\t\\t\\t\\tor s[i] == s[j] and the subproblem s[i+1...j-1] is a valid palindrome (dp[i+1][j-1])\\n\\nwith the following dp relation we can take O(n^2) time and O(n^2) space to build up the memory:\\n\\n```\\nprivate boolean[][] generateMap(String s) {\\n\\tboolean[][] map = new boolean[s.length()][s.length()];\\n\\tfor (int i = s.length() - 1; i >= 0; i--) {\\n\\t\\tfor (int j = i; j < s.length(); j++) {\\n\\t\\t\\tmap[i][j] = (s.charAt(i) == s.charAt(j) && (j - i <= 2 || map[i + 1][j - 1]));\\n\\t\\t}\\n\\t}\\n\\treturn map;\\n}\\n\\n```\\n\\nWith the memory we can know isPalindrome(s, i, j) in O(1) time by looking at the memory.\\nTotal time complexity is O(n!). If we count for the substring API of java, it would take O(n) time worse cases. A better approach might be using char[] array as input and use the String(char[] array, int offset, int length) constructor.\\nTotal space complexity is O(n^2)\\n               \\nAttached is the full code.\\n\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (s == null || s.isEmpty()) {\\n            return result;\\n        }\\n        boolean[][] isPalindrome = generateMap(s);\\n        DFS(0, s, new ArrayList<>(), result, isPalindrome);\\n        return result;\\n    }\\n    \\n    private void DFS(int index, String input, List<String> curr, List<List<String>> result, boolean[][] isPalindrome) {\\n        if (index == input.length()) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        for (int i = index; i < input.length(); i++) {\\n            if (isPalindrome[index][i]) {\\n                curr.add(input.substring(index, i + 1));\\n                DFS(i + 1, input, curr, result, isPalindrome);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean[][] generateMap(String s) {\\n        boolean[][] map = new boolean[s.length()][s.length()];\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            for (int j = i; j < s.length(); j++) {\\n                map[i][j] = (s.charAt(i) == s.charAt(j) && (j - i <= 2 || map[i + 1][j - 1]));\\n            }\\n        }\\n        return map;\\n    }\\n}\\n```\\n\\nI wrote down these words to help myself better understand the problem, and hopefully it would helps other.\\nAnd please tell me if any mistake is made! Thanks a lot.",
                "solutionTags": [],
                "code": "```\\nboolean isPalindrome(String s, int start, int end) {\\n\\twhile (start < end) {\\n\\t\\tif (s.charAt(start++) != s.charAt(end--)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nprivate boolean[][] generateMap(String s) {\\n\\tboolean[][] map = new boolean[s.length()][s.length()];\\n\\tfor (int i = s.length() - 1; i >= 0; i--) {\\n\\t\\tfor (int j = i; j < s.length(); j++) {\\n\\t\\t\\tmap[i][j] = (s.charAt(i) == s.charAt(j) && (j - i <= 2 || map[i + 1][j - 1]));\\n\\t\\t}\\n\\t}\\n\\treturn map;\\n}\\n\\n```\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (s == null || s.isEmpty()) {\\n            return result;\\n        }\\n        boolean[][] isPalindrome = generateMap(s);\\n        DFS(0, s, new ArrayList<>(), result, isPalindrome);\\n        return result;\\n    }\\n    \\n    private void DFS(int index, String input, List<String> curr, List<List<String>> result, boolean[][] isPalindrome) {\\n        if (index == input.length()) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        for (int i = index; i < input.length(); i++) {\\n            if (isPalindrome[index][i]) {\\n                curr.add(input.substring(index, i + 1));\\n                DFS(i + 1, input, curr, result, isPalindrome);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean[][] generateMap(String s) {\\n        boolean[][] map = new boolean[s.length()][s.length()];\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            for (int j = i; j < s.length(); j++) {\\n                map[i][j] = (s.charAt(i) == s.charAt(j) && (j - i <= 2 || map[i + 1][j - 1]));\\n            }\\n        }\\n        return map;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42008,
                "title": "clean-6ms-c-solution-using-dp-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        std::vector<std::vector<std::string>> ans;\\n        int length = s.length();\\n        if (length == 0) {\\n            return ans;\\n        }\\n\\n        // Construct the palindrome lookup table.\\n        std::vector<std::vector<bool>> isPalin(length, std::vector<bool>(length));\\n\\n        for (int i = 0 ; i < length ; ++i) {\\n            isPalin[i][i] = true;\\n        }\\n        for (int i = 0, j = 1 ; i < length - 1 ; ++i, ++j) {\\n            isPalin[i][j] = s[i] == s[j];\\n        }\\n        for (int l = 2 ; l < length ; ++l) {\\n            for (int i = 0 ; i < length - l ; ++i) {\\n                int j = i + l;\\n                isPalin[i][j] = (s[i] == s[j]) && isPalin[i + 1][j - 1];\\n            }\\n        }\\n\\n        // Apply backtracking to discover all the palindrome partitions.\\n        std::vector<std::vector<std::pair<int, int>>> records;\\n        std::vector<std::pair<int, int>> partition;\\n        backtrack(0, length, isPalin, partition, records);\\n\\n        for (const auto& partition : records) {\\n            std::vector<std::string> palin;\\n            for (const auto& pair : partition) {\\n                int bgn = pair.first;\\n                int length = pair.second - bgn + 1;\\n                palin.push_back(s.substr(bgn, length));\\n            }\\n            ans.push_back(std::move(palin));\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    void backtrack(int bgn, int bound, const std::vector<std::vector<bool>>& isPalin, \\n            std::vector<std::pair<int, int>>& partition, \\n            std::vector<std::vector<std::pair<int, int>>>& records) {\\n\\n        if (bgn == bound) {\\n            records.push_back(partition);\\n            return;\\n        }\\n\\n        for (int end = bgn ; end < bound ; ++end) {\\n            if (!isPalin[bgn][end]) {\\n                continue;\\n            }\\n\\n            partition.push_back(std::make_pair(bgn, end));\\n            backtrack(end + 1, bound, isPalin, partition, records);\\n            partition.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        std::vector<std::vector<std::string>> ans;\\n        int length = s.length();\\n        if (length == 0) {\\n            return ans;\\n        }\\n\\n        // Construct the palindrome lookup table.\\n        std::vector<std::vector<bool>> isPalin(length, std::vector<bool>(length));\\n\\n        for (int i = 0 ; i < length ; ++i) {\\n            isPalin[i][i] = true;\\n        }\\n        for (int i = 0, j = 1 ; i < length - 1 ; ++i, ++j) {\\n            isPalin[i][j] = s[i] == s[j];\\n        }\\n        for (int l = 2 ; l < length ; ++l) {\\n            for (int i = 0 ; i < length - l ; ++i) {\\n                int j = i + l;\\n                isPalin[i][j] = (s[i] == s[j]) && isPalin[i + 1][j - 1];\\n            }\\n        }\\n\\n        // Apply backtracking to discover all the palindrome partitions.\\n        std::vector<std::vector<std::pair<int, int>>> records;\\n        std::vector<std::pair<int, int>> partition;\\n        backtrack(0, length, isPalin, partition, records);\\n\\n        for (const auto& partition : records) {\\n            std::vector<std::string> palin;\\n            for (const auto& pair : partition) {\\n                int bgn = pair.first;\\n                int length = pair.second - bgn + 1;\\n                palin.push_back(s.substr(bgn, length));\\n            }\\n            ans.push_back(std::move(palin));\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    void backtrack(int bgn, int bound, const std::vector<std::vector<bool>>& isPalin, \\n            std::vector<std::pair<int, int>>& partition, \\n            std::vector<std::vector<std::pair<int, int>>>& records) {\\n\\n        if (bgn == bound) {\\n            records.push_back(partition);\\n            return;\\n        }\\n\\n        for (int end = bgn ; end < bound ; ++end) {\\n            if (!isPalin[bgn][end]) {\\n                continue;\\n            }\\n\\n            partition.push_back(std::make_pair(bgn, end));\\n            backtrack(end + 1, bound, isPalin, partition, records);\\n            partition.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42051,
                "title": "recursion-with-memorization-java-solution-easy-to-understand",
                "content": "This problem is very similar to **Word Break 2**.\\nFor example, a string of length **n** can be partitioned into **n** pairs:\\n\\n* \"\" + s1s2...sn\\n* s1 + s2...sn\\n* s1s2 + s3...sn\\n* s1s2...s(n-1) + sn\\n\\nThe first part we call it a **word**, the second part we call it a **sentence**. Firtly, we check if the **word** is  a palindrome, if true, we do recursion on the **sentence**. To reduce redundant computation, we use a HashMap to store intermediate results, and here is the AC java code:\\n```\\nprivate Map<String, List<List<String>>> map = new HashMap<>();\\n\\n    public boolean isPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public List<List<String>> partition(String s) {\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        List<List<String>> lists = new ArrayList<>();\\n        if (isPalindrome(s)) {\\n            lists.add(new ArrayList<>(Arrays.asList(s)));\\n        }\\n        int n = s.length();\\n        for (int i = 1; i < n; i++) {\\n            String word = s.substring(0, i);\\n            if (isPalindrome(word)) {\\n                List<List<String>> right = partition(s.substring(i));\\n                for (List<String> list : right) {\\n                    List<String> list1 = new ArrayList<>();\\n                    list1.add(word);\\n                    list1.addAll(list);\\n                    lists.add(list1);\\n                }\\n            }\\n        }\\n        map.put(s, lists);\\n        return lists;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\nprivate Map<String, List<List<String>>> map = new HashMap<>();\\n\\n    public boolean isPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public List<List<String>> partition(String s) {\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        List<List<String>> lists = new ArrayList<>();\\n        if (isPalindrome(s)) {\\n            lists.add(new ArrayList<>(Arrays.asList(s)));\\n        }\\n        int n = s.length();\\n        for (int i = 1; i < n; i++) {\\n            String word = s.substring(0, i);\\n            if (isPalindrome(word)) {\\n                List<List<String>> right = partition(s.substring(i));\\n                for (List<String> list : right) {\\n                    List<String> list1 = new ArrayList<>();\\n                    list1.add(word);\\n                    list1.addAll(list);\\n                    lists.add(list1);\\n                }\\n            }\\n        }\\n        map.put(s, lists);\\n        return lists;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42055,
                "title": "java-easy-follow-recursive-solution-can-convert-to-dp-easily-what-is-complexity-o-n-2",
                "content": "    public class Solution {\\n        \\n        public boolean isPalindrom(String s) {\\n            int start = 0;\\n            int end = s.length()-1;\\n            while(start<end) {\\n                if(s.charAt(start)!=s.charAt(end))\\n                    return false;\\n                start++;\\n                end--;\\n            }\\n            return true;\\n        }\\n        \\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            if(s.length()==0) {\\n                res.add(new ArrayList<String>());\\n                return res;\\n            }\\n            if(s.length()==1) {\\n                List<String> subLs = new ArrayList<String>();\\n                subLs.add(s);\\n                res.add(subLs);\\n                return res;\\n            }\\n            for(int i=0; i<s.length(); i++) {\\n                String subS = s.substring(0,i+1);\\n                if(isPalindrom(subS)) {\\n                    List<List<String>> subRes = partition(s.substring(i+1));\\n                    for(List<String> l : subRes) {\\n                        l.add(0,subS);\\n                        res.add(l);\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        public boolean isPalindrom(String s) {\\n            int start = 0;\\n            int end = s.length()-1;\\n            while(start<end) {\\n                if(s.charAt(start)!=s.charAt(end))\\n                    return false;\\n                start++;\\n                end--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 42067,
                "title": "fast-dp-solutions-in-python-with-storing-palindromes-in-memo-beat-99",
                "content": "    class Solution(object):\\n        def partition(self, s, set_pal=set(), memo={}):\\n            if not len(s):\\n                return []\\n            if s in memo:\\n                return memo[s]\\n            ret_list, flag = [], False\\n            for i in range(1, len(s) + 1):\\n                left = s[:i]\\n                if left in set_pal or left == left[::-1]:\\n                    set_pal.add(left)\\n                    list_rec = self.partition(s[i:], set_pal, memo)\\n                    if list_rec is not None:\\n                        flag = True\\n                        for this_list in list_rec:\\n                            ret_list.append([left] + this_list)\\n                        if not list_rec:\\n                            ret_list.append([left])\\n            \\n            memo[s] = ret_list if flag else None\\n            return memo[s]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution(object):\\n        def partition(self, s, set_pal=set(), memo={}",
                "codeTag": "Java"
            },
            {
                "id": 42071,
                "title": "c-dfs-dp-16ms-solution",
                "content": "    class Solution {\\n    public:\\n      \\n      vector<vector<string>> partition(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        //   build dp : if i through j (inclusive) makes a palindrome, dp[i][j] = true;\\n        for(int l = 1; l <=n; l++){\\n          for(int i = 0; i < n; i++){\\n            int j = i + l - 1;\\n            if(j >= n) break;\\n            dp[i][j] = (i + 1 > j - 1 || dp[i + 1][j - 1]) && s[i] == s[j];\\n          }\\n        }\\n        \\n        //  dfs\\n        vector<string> path;\\n        vector<vector<string>> result;\\n        dfs(s, 0, path, result, dp);\\n    \\n        return result;\\n      }\\n      \\n      void dfs(string& s, int start, vector<string>& path, vector<vector<string>>& result, vector<vector<bool>>& dp){\\n        int n = s.size();\\n        if(start == n){\\n          result.push_back(path);\\n          return;\\n        } \\n        \\n        for(int i = start; i < n; i++){\\n          if(!dp[start][i]) continue;\\n          \\n          path.push_back(s.substr(start, i - start + 1));\\n          dfs(s, i + 1, path, result, dp);\\n          path.pop_back();\\n        } \\n      }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n      \\n      vector<vector<string>> partition(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        //   build dp : if i through j (inclusive) makes a palindrome, dp[i][j] = true;\\n        for(int l = 1; l <=n; l++){\\n          for(int i = 0; i < n; i++){\\n            int j = i + l - 1;\\n            if(j >= n) break;\\n            dp[i][j] = (i + 1 > j - 1 || dp[i + 1][j - 1]) && s[i] == s[j];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 42070,
                "title": "easiest-4ms-java-solution-95-99",
                "content": "This is a standard backtracking problem. At first I used dp, surprisingly the followings are nearly `2X` faster than dp. The key to performance is to use  `toCharArray` instead of `substring`:\\n\\n    String s = new String(c, pos, i - pos + 1);\\n\\nHope it helps!\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(res, new ArrayList<String>(), s.toCharArray(), 0);\\n        return res;\\n    }\\n\\n    void dfs(List<List<String>> res, ArrayList<String> list, char[] c, int pos) {\\n        if (pos == c.length) res.add(new ArrayList<>(list));\\n        for (int i = pos; i < c.length; i++) {\\n            if (isPal(c, pos, i)){\\n                list.add(new String(c, pos, i - pos + 1)); \\n                dfs(res, list, c, i + 1);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n\\n    boolean isPal(char[] c, int lo, int hi) {\\n        while (lo < hi) if (c[lo++] != c[hi--]) return false;\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This is a standard backtracking problem. At first I used dp, surprisingly the followings are nearly `2X` faster than dp. The key to performance is to use  `toCharArray` instead of `substring`:\\n\\n    String s = new String(c, pos, i - pos + 1);\\n\\nHope it helps!\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(res, new ArrayList<String>(), s.toCharArray(), 0);\\n        return res;\\n    }\\n\\n    void dfs(List<List<String>> res, ArrayList<String> list, char[] c, int pos) {\\n        if (pos == c.length) res.add(new ArrayList<>(list));\\n        for (int i = pos; i < c.length; i++) {\\n            if (isPal(c, pos, i)){\\n                list.add(new String(c, pos, i - pos + 1)); \\n                dfs(res, list, c, i + 1);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n\\n    boolean isPal(char[] c, int lo, int hi) {\\n        while (lo < hi) if (c[lo++] != c[hi--]) return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1724406,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1724409,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1768589,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1707027,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1565576,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1567207,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1574685,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1767651,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1768675,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1769287,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1724406,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1724409,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1768589,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1707027,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1565576,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1567207,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1574685,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1767651,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1768675,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1769287,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1570734,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1770095,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1574342,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1571282,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1811680,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1771865,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1770204,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1769865,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1769657,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1768700,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 2026530,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 2019630,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1986595,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1984638,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1941163,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1878417,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1846527,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1796212,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1774308,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1770101,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1770088,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769856,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769814,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769625,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769570,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769426,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769378,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769132,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1768981,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1768753,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            }
        ]
    }
]