[
    {
        "title": "Bitwise XOR of All Pairings",
        "question_content": "You are given two 0-indexed arrays, nums1 and nums2, consisting of non-negative integers. There exists another array, nums3, which contains the bitwise XOR of all pairings of integers between nums1 and nums2 (every integer in nums1 is paired with every integer in nums2 exactly once).\nReturn the bitwise XOR of all integers in nums3.\n&nbsp;\nExample 1:\n\nInput: nums1 = [2,1,3], nums2 = [10,2,5,0]\nOutput: 13\nExplanation:\nA possible nums3 array is [8,0,7,2,11,3,4,1,9,1,6,3].\nThe bitwise XOR of all these numbers is 13, so we return 13.\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 0\nExplanation:\nAll possible pairs of bitwise XORs are nums1[0] ^ nums2[0], nums1[0] ^ nums2[1], nums1[1] ^ nums2[0],\nand nums1[1] ^ nums2[1].\nThus, one possible nums3 array is [2,5,1,6].\n2 ^ 5 ^ 1 ^ 6 = 0, so we return 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums1.length, nums2.length <= 105\n\t0 <= nums1[i], nums2[j] <= 109",
        "solutions": [
            {
                "id": 2646552,
                "title": "java-c-python-easy-and-concise",
                "content": "# **Intuition**\\n`ai ^ b1, ai ^ b2, ai ^ b3`....\\n`ai` will construct `B.length` pairs\\n`bi` will construct `A.length` pairs\\n\\n\\n# **Explanation**\\nIf `B.length` is even,\\n`ai` will xor even times,\\nand equal to 0.\\n\\nIf `B.length` is odd,\\n`ai` will xor odd times,\\nand equal to `ai`.\\n\\nSame for `bi`\\n\\n\\nIf A.length is even and B.length is even,\\n`res = 0`\\n\\nIf A.length is odd and B.length is even,\\n`res = B[0] ^ B[1] ^ ...`\\n\\nIf A.length is even and B.length is odd,\\n`res = A[0] ^ A[1] ^ ...`\\n\\nIf A.length is even and B.length is even,\\n`res = A[0] ^ A[1] ^ ... ^ B[0] ^ B[1] ^ ...`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int xorAllNums(int[] A, int[] B) {\\n        int x = 0, y = 0;\\n        for (int a: A)\\n            x ^= a;\\n        for (int b: B)\\n            y ^= b;\\n        return (A.length % 2 * y) ^ (B.length % 2 * x);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int xorAllNums(vector<int>& A, vector<int>& B) {\\n        int x = 0, y = 0;\\n        for (int a : A)\\n            x ^= a;\\n        for (int b : B)\\n            y ^= b;\\n        return (A.size() % 2 * y) ^ (B.size() % 2 * x);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def xorAllNums(self, A, B):\\n        x = y = 0\\n        for a in A:\\n            x ^= a\\n        for b in B:\\n            y ^= b\\n        return (len(A) % 2 * y) ^ (len(B) % 2 * x)\\n```\\n**Python**\\n```py\\n    def xorAllNums(self, A, B):\\n        return (len(A) % 2 * reduce(xor, B)) ^ (len(B) % 2 * reduce(xor, A))\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int xorAllNums(int[] A, int[] B) {\\n        int x = 0, y = 0;\\n        for (int a: A)\\n            x ^= a;\\n        for (int b: B)\\n            y ^= b;\\n        return (A.length % 2 * y) ^ (B.length % 2 * x);\\n    }\\n```\n```cpp\\n    int xorAllNums(vector<int>& A, vector<int>& B) {\\n        int x = 0, y = 0;\\n        for (int a : A)\\n            x ^= a;\\n        for (int b : B)\\n            y ^= b;\\n        return (A.size() % 2 * y) ^ (B.size() % 2 * x);\\n    }\\n```\n```py\\n    def xorAllNums(self, A, B):\\n        x = y = 0\\n        for a in A:\\n            x ^= a\\n        for b in B:\\n            y ^= b\\n        return (len(A) % 2 * y) ^ (len(B) % 2 * x)\\n```\n```py\\n    def xorAllNums(self, A, B):\\n        return (len(A) % 2 * reduce(xor, B)) ^ (len(B) % 2 * reduce(xor, A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2646801,
                "title": "java-beats-100-beginner-friendly-with-comments-detail-explaination",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    private int xor(int[] nums) {\\n        int res = 0;\\n        for (int num : nums) {\\n            res ^= num;\\n        }\\n        return res;\\n    }\\n\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        if (nums1.length % 2 == 0 && nums2.length % 2 == 0) { // if both arrays have even length\\n            return 0;\\n        }\\n        int xorone = xor(nums1), xortwo = xor(nums2);\\n        // if both arrays have odd length then xor of both arrays is the answer or else\\n        // xor of one even length array is the answer\\n        return nums1.length % 2 == 1 && nums2.length % 2 == 1 ? xorone ^ xortwo\\n                : (nums1.length % 2 != 0 ? xortwo : xorone);\\n    }\\n}\\n```\\n# Approach\\n![20221001_212221.jpeg](https://assets.leetcode.com/users/images/c71303a0-ced9-414c-ba7a-f44df8fb2ee6_1664640902.7415357.jpeg)\\n![20221001_212238.jpeg](https://assets.leetcode.com/users/images/b819444d-5ac2-46ff-a6bc-2752c90284d2_1664640914.0998785.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int xor(int[] nums) {\\n        int res = 0;\\n        for (int num : nums) {\\n            res ^= num;\\n        }\\n        return res;\\n    }\\n\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        if (nums1.length % 2 == 0 && nums2.length % 2 == 0) { // if both arrays have even length\\n            return 0;\\n        }\\n        int xorone = xor(nums1), xortwo = xor(nums2);\\n        // if both arrays have odd length then xor of both arrays is the answer or else\\n        // xor of one even length array is the answer\\n        return nums1.length % 2 == 1 && nums2.length % 2 == 1 ? xorone ^ xortwo\\n                : (nums1.length % 2 != 0 ? xortwo : xorone);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646502,
                "title": "c-with-explanation-very-simple-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution\\n```\\n/* \\n  XOR is associative so, the total no. of xor we have to do is\\n  equal to num1.size time each of the number of num2 array elements  \\n  and num2.size time each of the number of num1 array elements.\\n  Also if we xor a number even number of times that results into \\n  zero. So with these properties we write the fllowing logic: \\n  1. if both the array size are even then ans will be zero\\n  2. if num2 size is odd then take xor of all element of num1\\n  3. if num3 size is even then take xor of all element of num2\\n */\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size()%2 == 0 && nums2.size()%2 == 0) return 0;\\n        int ans = 0;\\n        if(nums2.size() % 2 ) for(auto n: nums1) ans = ans^n;\\n        if(nums1.size() % 2 ) for(auto n: nums2) ans = ans^n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/* \\n  XOR is associative so, the total no. of xor we have to do is\\n  equal to num1.size time each of the number of num2 array elements  \\n  and num2.size time each of the number of num1 array elements.\\n  Also if we xor a number even number of times that results into \\n  zero. So with these properties we write the fllowing logic: \\n  1. if both the array size are even then ans will be zero\\n  2. if num2 size is odd then take xor of all element of num1\\n  3. if num3 size is even then take xor of all element of num2\\n */\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size()%2 == 0 && nums2.size()%2 == 0) return 0;\\n        int ans = 0;\\n        if(nums2.size() % 2 ) for(auto n: nums1) ans = ans^n;\\n        if(nums1.size() % 2 ) for(auto n: nums2) ans = ans^n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646655,
                "title": "java-python-3-bit-manipulations-analysis",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**xor of any two duplicates is `0`**. Thefore, we need to get rid of all pairs of duplicates. The xor of the remaining distinct numbers is the solution.\\n\\nSince each number will pair with all numbers of the other array, which implies if the other array has even size the number will occur even times in the final xor operation, and we can exclude the number. **Hence we only count in the number if the other array has odd size.**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If `nums1` has odd size, xor of all numbers in `nums2`; otherwise the result is `0`\\n2. if `nums2` has odd size, xor of all numbers in `nums1`; otherwise the result is `0`\\n3. return the xor value of above 1 & 2.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(m + n)`, where `m = nums1.length, n = nums2.length`.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(1)`\\n# Code\\n```java\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int odd1 = nums1.length % 2, odd2 = nums2.length % 2;\\n        int xor1 = 0, xor2 = 0;\\n        for (int n : nums1) {\\n            xor1 ^= n;\\n        }\\n        for (int n : nums2) {\\n            xor2 ^= n;\\n        }\\n        return (odd1 * xor2) ^ (odd2 * xor1);\\n    }\\n}\\n```\\nor \\n```java\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = nums1.length % 2 * IntStream.of(nums2).reduce(0, (a, b) -> a ^ b);\\n        xor ^= nums2.length % 2 * IntStream.of(nums1).reduce(0, (a, b) -> a ^ b);\\n        return xor;\\n    }\\n}\\n```\\n# Code\\n```python\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        m, n = map(len, (nums1, nums2))\\n        return (m % 2 * reduce(xor, nums2)) ^ (n % 2 * reduce(xor, nums1))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int odd1 = nums1.length % 2, odd2 = nums2.length % 2;\\n        int xor1 = 0, xor2 = 0;\\n        for (int n : nums1) {\\n            xor1 ^= n;\\n        }\\n        for (int n : nums2) {\\n            xor2 ^= n;\\n        }\\n        return (odd1 * xor2) ^ (odd2 * xor1);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = nums1.length % 2 * IntStream.of(nums2).reduce(0, (a, b) -> a ^ b);\\n        xor ^= nums2.length % 2 * IntStream.of(nums1).reduce(0, (a, b) -> a ^ b);\\n        return xor;\\n    }\\n}\\n```\n```python\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        m, n = map(len, (nums1, nums2))\\n        return (m % 2 * reduce(xor, nums2)) ^ (n % 2 * reduce(xor, nums1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646843,
                "title": "c-super-easy-approach-beginner-friendly",
                "content": "**Approach**: If you observe after making the pair in the last you have any element from num1, num2.size() times and any element of num2, num1.size() times. We can take profit of this see how.\\n\\nnum1 = [1, 2]\\nnum2 = [3, 4]\\nAll possible pairs of bitwise XORs are = (1^3) ^ (1^4) ^ (2^3) ^ (2^4). here every element of num1 appearing 2 times(size of num2) and every element of num2 appearing 2 times(num1 size).\\n\\nSo we can just do the XOR of all nums1 elements num2 times and do xor of num2 elments num1 times and return **(xor1^xor2)**\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        int val1 = nums1[0], val2 = nums2[0];\\n        //xor1\\n        for(int i=1; i<n1; i++){\\n            val1 = (val1^nums1[i]);\\n        }\\n        \\n        //num2 size times multiply\\n        int temp1 = val1;\\n        for(int i=1; i<n2; i++)\\n            temp1= (temp1^val1);\\n        \\n        //xor2\\n        for(int j=1; j<n2; j++){\\n            val2 = (val2^nums2[j]);\\n        }\\n        \\n        int temp2 = val2;\\n        //num1 size times multiply\\n        for(int j=1; j<n1; j++)\\n            temp2= (temp2^val2);\\n        \\n        \\n        return (temp1^temp2);\\n    }\\n};\\n```\\n\\n**Please do upvote if you like the approach:)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        int val1 = nums1[0], val2 = nums2[0];\\n        //xor1\\n        for(int i=1; i<n1; i++){\\n            val1 = (val1^nums1[i]);\\n        }\\n        \\n        //num2 size times multiply\\n        int temp1 = val1;\\n        for(int i=1; i<n2; i++)\\n            temp1= (temp1^val1);\\n        \\n        //xor2\\n        for(int j=1; j<n2; j++){\\n            val2 = (val2^nums2[j]);\\n        }\\n        \\n        int temp2 = val2;\\n        //num1 size times multiply\\n        for(int j=1; j<n1; j++)\\n            temp2= (temp2^val2);\\n        \\n        \\n        return (temp1^temp2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646580,
                "title": "java-1ms-100-o-n-m",
                "content": "```\\npublic int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        if( n1 % 2 == 0 && n2 % 2 == 0) return 0;\\n        if( n1 % 2 == 0) return xor(nums1);\\n        if( n2 % 2 == 0) return xor(nums2);\\n        return xor(nums1) ^ xor(nums2);\\n    }\\n    \\n    private int xor(int[] nums){\\n        int val = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            val ^= nums[i];\\n        }\\n        return val;\\n    }\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        if( n1 % 2 == 0 && n2 % 2 == 0) return 0;\\n        if( n1 % 2 == 0) return xor(nums1);\\n        if( n2 % 2 == 0) return xor(nums2);\\n        return xor(nums1) ^ xor(nums2);\\n    }\\n    \\n    private int xor(int[] nums){\\n        int val = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            val ^= nums[i];\\n        }\\n        return val;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3688259,
                "title": "easy-o-m-n-solution-java-implementation",
                "content": "# Intuition\\nTaking every  pair I XOR the values.\\n\\n# Approach\\nEvery element is XORed exactly \\'n\\' no. of times where n is the size of vector of which theelement belongs. \\nSo if size of both array is even then return 0,\\nif size of one array is even and other is odd return XOR of all elements of odd length array.\\nif size of both arrays is odd then return XOR of all elements.\\n\\n# Complexity\\n- Time complexity: *O(m+n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(1)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        if( n1 % 2 == 0 && n2 % 2 == 0) return 0;\\n        if( n1 % 2 == 0) return xor(nums1);\\n        if( n2 % 2 == 0) return xor(nums2);\\n        return xor(nums1) ^ xor(nums2);\\n    }\\n    \\n    private int xor(int[] nums){\\n        int val = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            val ^= nums[i];\\n        }\\n        return val;\\n    }\\n\\t\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        if( n1 % 2 == 0 && n2 % 2 == 0) return 0;\\n        if( n1 % 2 == 0) return xor(nums1);\\n        if( n2 % 2 == 0) return xor(nums2);\\n        return xor(nums1) ^ xor(nums2);\\n    }\\n    \\n    private int xor(int[] nums){\\n        int val = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            val ^= nums[i];\\n        }\\n        return val;\\n    }\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647957,
                "title": "python-3-3-lines-boolean-algebra-t-m-1035ms-32-8mb",
                "content": "```\\nclass Solution:     # Example:  nums1 = [2,1,3] ; nums2 = [10,4,5,0]\\n                    # \\n                    #    From Boolean algebra we know that n^0 = n and n^n = 0, from which we can infer that\\n                    #    the xor of an even count of an integer n is 0, and the xor of an odd count of an\\n                    #    integer n is n. We also know that the ^ operator is commutative and associative. \\n                    #    So, from the Example:        \\n\\n                    #       =>  nums3 = [2^10,2^2,2^5,2^0,1^10,1^2,1^5,3^0,3^10,3^2,3^5,3^0]\\n\\n                    #       => answer = (2^10)^(2^4)^(2^5)^(2^0)^(1^10)^(1^4)^(1^5)^(3^0)^(3^10)^(3^4)^(3^5)^(3^0)\\n                    #                 = (2^2^2^2)^(1^1^1^1)^(3^3^3^3) ^ (10^10^10)^(4^4^4)^(5^5^5)^^(0^0^0)\\n                    #                 = 0^0^0  ^  10^4^5^0   =   0^11   =   11\\n                    #\\n                    #    The inferences we draw from this example lead to the code below.\\n                    #           \\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        n1 = 0 if not len(nums2)%2 else reduce(xor,nums1)\\n        n2 = 0 if not len(nums1)%2 else reduce(xor,nums2)\\n        return n1^n2\\n```\\n[https://leetcode.com/submissions/detail/812980296/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:     # Example:  nums1 = [2,1,3] ; nums2 = [10,4,5,0]\\n                    # \\n                    #    From Boolean algebra we know that n^0 = n and n^n = 0, from which we can infer that\\n                    #    the xor of an even count of an integer n is 0, and the xor of an odd count of an\\n                    #    integer n is n. We also know that the ^ operator is commutative and associative. \\n                    #    So, from the Example:        \\n\\n                    #       =>  nums3 = [2^10,2^2,2^5,2^0,1^10,1^2,1^5,3^0,3^10,3^2,3^5,3^0]\\n\\n                    #       => answer = (2^10)^(2^4)^(2^5)^(2^0)^(1^10)^(1^4)^(1^5)^(3^0)^(3^10)^(3^4)^(3^5)^(3^0)\\n                    #                 = (2^2^2^2)^(1^1^1^1)^(3^3^3^3) ^ (10^10^10)^(4^4^4)^(5^5^5)^^(0^0^0)\\n                    #                 = 0^0^0  ^  10^4^5^0   =   0^11   =   11\\n                    #\\n                    #    The inferences we draw from this example lead to the code below.\\n                    #           \\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        n1 = 0 if not len(nums2)%2 else reduce(xor,nums1)\\n        n2 = 0 if not len(nums1)%2 else reduce(xor,nums2)\\n        return n1^n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647607,
                "title": "c-std-accumulate-std-reduce-std-bit-xor-o-n-m-one-liner",
                "content": "### Intuition\\n\\nXOR is associative and commutative, which means we can reorder the operations as we want. The other things to keep in mind is that XORing a value with itself yields zero. This means everytime we xor a value an even number of times with itself we don\\'t have to worry about it. This leads to something like the following:\\n\\n```cpp\\n    static int xorAllNums(const vector<int>& nums1, const vector<int>& nums2) {\\n        int ans = 0;\\n        if (size(nums2) & 1) for (int n : nums1) ans ^= n;\\n        if (size(nums1) & 1) for (int n : nums2) ans ^= n;\\n        return ans;\\n    }\\n```\\n\\nIf we don\\'t want to use raw loops we land at the following approach:\\n\\n### Approach 1: std::accumulate\\n\\nThe element in ```nums1``` are used ```size(nums2)```, i.e. they only matter if the lenght of ```nums2``` is odd, and the other way around for ```nums2```.\\n\\n```cpp\\n    static int xorAllNums(const vector<int>& nums1, const vector<int>& nums2) {\\n        int ans = 0;\\n        if (size(nums2) & 1) ans = accumulate(begin(nums1), end(nums1), 0, [](int sum, int x) { return sum ^ x; });\\n        if (size(nums1) & 1) ans ^= accumulate(begin(nums2), end(nums2), 0, [](int sum, int x) { return sum ^ x; });\\n        return ans;\\n    }\\n```\\n\\n@PencilBro27 pointed out that we can use ```bit_xor()``` instead of the custom lambda function, which turns the solution into:\\n\\n```cpp\\n    static int xorAllNums(const vector<int>& nums1, const vector<int>& nums2) {\\n        int ans = 0;\\n        if (size(nums2) & 1) ans = accumulate(begin(nums1), end(nums1), 0, bit_xor());\\n        if (size(nums1) & 1) ans ^= accumulate(begin(nums2), end(nums2), 0, bit_xor());\\n        return ans;\\n    }\\n```\\n\\nFurthermore @PencilBro27 suggested to use ```std::reduce``` instead of ```std::accumulate``` (please look online for good old ```std::accumulate``` vs the new and shiny ```std::reduce```):\\n\\n```cpp\\n    static int xorAllNums(const vector<int>& nums1, const vector<int>& nums2) {\\n        int ans = 0;\\n        if (size(nums2) & 1) ans = reduce(begin(nums1), end(nums1), 0, bit_xor());\\n        if (size(nums1) & 1) ans ^= reduce(begin(nums2), end(nums2), 0, bit_xor());\\n        return ans;\\n    }\\n```\\n\\nIf we push a bit harder on this we can turn this even into a long one liner:\\n\\n```cpp\\n    static int xorAllNums(const vector<int>& a, const vector<int>& b) {\\n        return (size(b) & 1 ? reduce(begin(a), end(a), 0, bit_xor()) : 0) ^ (size(a) & 1 ? reduce(begin(b), end(b), 0, bit_xor()) : 0);\\n    }\\n```\\n\\nAs a next step it would be intersting to use ```std::execution::par``` with ```std::reduce```, but couldn\\'t get it to compile on leetcode.\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n + m)$$ if $$m$$ is length of ```nums1``` and $$n$$ is the length of ```nums2```\\n  * Space Complexity: $$O(1)$$\\n\\n_As alwasy: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy. :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int xorAllNums(const vector<int>& nums1, const vector<int>& nums2) {\\n        int ans = 0;\\n        if (size(nums2) & 1) for (int n : nums1) ans ^= n;\\n        if (size(nums1) & 1) for (int n : nums2) ans ^= n;\\n        return ans;\\n    }\\n```\n```nums1```\n```size(nums2)```\n```nums2```\n```nums2```\n```cpp\\n    static int xorAllNums(const vector<int>& nums1, const vector<int>& nums2) {\\n        int ans = 0;\\n        if (size(nums2) & 1) ans = accumulate(begin(nums1), end(nums1), 0, [](int sum, int x) { return sum ^ x; });\\n        if (size(nums1) & 1) ans ^= accumulate(begin(nums2), end(nums2), 0, [](int sum, int x) { return sum ^ x; });\\n        return ans;\\n    }\\n```\n```bit_xor()```\n```cpp\\n    static int xorAllNums(const vector<int>& nums1, const vector<int>& nums2) {\\n        int ans = 0;\\n        if (size(nums2) & 1) ans = accumulate(begin(nums1), end(nums1), 0, bit_xor());\\n        if (size(nums1) & 1) ans ^= accumulate(begin(nums2), end(nums2), 0, bit_xor());\\n        return ans;\\n    }\\n```\n```std::reduce```\n```std::accumulate```\n```std::accumulate```\n```std::reduce```\n```cpp\\n    static int xorAllNums(const vector<int>& nums1, const vector<int>& nums2) {\\n        int ans = 0;\\n        if (size(nums2) & 1) ans = reduce(begin(nums1), end(nums1), 0, bit_xor());\\n        if (size(nums1) & 1) ans ^= reduce(begin(nums2), end(nums2), 0, bit_xor());\\n        return ans;\\n    }\\n```\n```cpp\\n    static int xorAllNums(const vector<int>& a, const vector<int>& b) {\\n        return (size(b) & 1 ? reduce(begin(a), end(a), 0, bit_xor()) : 0) ^ (size(a) & 1 ? reduce(begin(b), end(b), 0, bit_xor()) : 0);\\n    }\\n```\n```std::execution::par```\n```std::reduce```\n```nums1```\n```nums2```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646750,
                "title": "easy-explanation-intuition",
                "content": "**Logic - If a number is xored even number of times then the result is. Similarly if the  number is xored even number of times then the result is the number itself.**\\n* The question asks us to xor every element of an array (arr) which have all pairs of integers between nums1 and nums2.\\n* \\tarr will have nums1[i] even number of times if the size of arr2 is even. Similarly if the size of size is odd then nums1[i] will occur odd number of times.\\n```\\nint xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(nums2.size()%2!=0){\\n                ans^=nums1[i];\\n            }\\n        }\\n        for(int i = 0; i < nums2.size(); i++){\\n            if(nums1.size()%2!=0){\\n                ans^=nums2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n***Do upvote if you liked the solution.***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(nums2.size()%2!=0){\\n                ans^=nums1[i];\\n            }\\n        }\\n        for(int i = 0; i < nums2.size(); i++){\\n            if(nums1.size()%2!=0){\\n                ans^=nums2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646589,
                "title": "c-with-bitwisexor",
                "content": "calculate bitwise xor of 2nd array in temp variable\\nif size of 2nd array is odd\\n\\tplace every nums1[i] = temp ^ nums1[i]\\nelse\\n\\tplace every nums1[i] = temp because xor of same number is zero\\n\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int temp = 0;\\n        for(auto i : nums2)\\n        {\\n            temp = temp ^ i;\\n                \\n        }\\n        int a = 0;\\n        for(int i = 0; i < nums1.size(); i++)\\n        {\\n            if(nums2.size() % 2)\\n                nums1[i] = temp ^ nums1[i];\\n            else\\n                nums1[i] = temp;\\n        }\\n        for(auto i : nums1)\\n            a = a^i;\\n        \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int temp = 0;\\n        for(auto i : nums2)\\n        {\\n            temp = temp ^ i;\\n                \\n        }\\n        int a = 0;\\n        for(int i = 0; i < nums1.size(); i++)\\n        {\\n            if(nums2.size() % 2)\\n                nums1[i] = temp ^ nums1[i];\\n            else\\n                nums1[i] = temp;\\n        }\\n        for(auto i : nums1)\\n            a = a^i;\\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647700,
                "title": "java-easy-time-o-n-o-1-space-with-explanation-100-beats",
                "content": "if you like it kindly upvote \\n// the idea is we use xor odd even property as we know that a^a==0 so if we took xor with even times then the xor will be zero if odd then the xor will the only element for which we r finding the xor so if a^a^a^a^a^a^a^a......==0 (if \\'a\\' is even times) otherwise \\'a\\' .\\nso by this property we see that if both arrays  length is even then we directly return 0;if both array length are odd then we directly took the xor of each array then we took xor of both array if one array is odd and one is even then we took xor of even length array thats is the idea if you like it kindly upvote\\n\\nExplanation\\nIf B.length is even,\\nai will xor even times,\\nand equal to 0.\\n\\nIf B.length is odd,\\nai will xor odd times,\\nand equal to ai.\\n\\nSame for bi\\n\\nIf A.length is even and B.length is even,\\nres = 0\\n\\nIf A.length is odd and B.length is even,\\nres = B[0] ^ B[1] ^ ...\\n\\nIf A.length is even and B.length is odd,\\nres = A[0] ^ A[1] ^ ...\\n\\nIf A.length is odd and B.length is odd,\\nres = A[0] ^ A[1] ^ ... ^ B[0] ^ B[1] ^ ...\\n\\n\\nComplexity\\nTime O(n)\\nSpace O(1)\\n\\n\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res1=0;\\n        int res2=0;\\n        if(nums1.length%2==0 && nums2.length%2==0){\\n            return 0;\\n        }  \\n            for(int i:nums1){\\n                res1=res1^i;\\n            }\\n            for(int i:nums2){\\n                res2=res2^i;\\n            }\\n        if(nums1.length%2==1 && nums2.length%2==1){\\n            return res1^res2;\\n        }\\n        if(nums1.length%2==0 && nums2.length%2==1){\\n            return res1;\\n        }\\n        if(nums1.length%2==1 && nums2.length%2==0){\\n            return res2;\\n        }\\n        return res1;\\n    }\\n}\\n````\\n\\nwe can modify this solution above solution is for understanding purpose \\n\\n\\nafter modifying we can reduce if else conditions\\n\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res=0;\\n        if(nums1.length%2==1 ){\\n              for(int i:nums2){\\n                res=res^i;\\n            }\\n        }  \\n\\t\\t  if(nums2.length%2==1 ){\\n              for(int i:nums1){\\n                res=res^i;\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res1=0;\\n        int res2=0;\\n        if(nums1.length%2==0 && nums2.length%2==0){\\n            return 0;\\n        }  \\n            for(int i:nums1){\\n                res1=res1^i;\\n            }\\n            for(int i:nums2){\\n                res2=res2^i;\\n            }\\n        if(nums1.length%2==1 && nums2.length%2==1){\\n            return res1^res2;\\n        }\\n        if(nums1.length%2==0 && nums2.length%2==1){\\n            return res1;\\n        }\\n        if(nums1.length%2==1 && nums2.length%2==0){\\n            return res2;\\n        }\\n        return res1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res=0;\\n        if(nums1.length%2==1 ){\\n              for(int i:nums2){\\n                res=res^i;\\n            }\\n        }  \\n\\t\\t  if(nums2.length%2==1 ){\\n              for(int i:nums1){\\n                res=res^i;\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646782,
                "title": "beginner-c-approach-using-basic-xor-property-and-map",
                "content": "We have to find bitwise XOR of elements obtained by finding XOR of every integer in nums1 when paired with every integer in nums2 exactly once.\\n\\nLet\\'s understand with example:\\nGiven nums1 = [2,1,3] and nums2 = [10,2,5,0]\\nFirst find all pairs:\\n[2,10] [2,2] [2,5] [2,0] \\n[1,10] [1,2] [1,5] [1,0]\\n[3,10] [3,2] [3,5] [3,0]\\nNow we have to find xor value of every pair and then answer of every pair is xor again to get the final answer.\\n\\nSo basically we are xoring all the pairs:\\n2^10^2^2^2^5^2^0^1^10^1^2^1^5^1^0^3^10^3^2^3^5^3^0 which gives 13.\\n\\nNow we use 2 XOR property:\\n 1.a^a=0\\n 2.a^0=a or 0^a=a\\nwhere a is 0 or postive number\\n\\nBy using above property problem is boiled down to finding the number with odd appearances.\\ne.g. 2 appears (nums2.size() + no. of 2 in nums1) times.\\nif 2 appearance is even it becomes 0 (a^a=0) else 2 is considered (a^0=a).\\n\\nSo above approach is applied using two unordered_map to map both array values.\\nSee code to understand better.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size();\\n        unordered_map<int,int> mp1,mp2;\\n        for(int i=0;i<n;i++)\\n            mp1[nums1[i]]++;\\n        for(int i=0;i<m;i++)\\n            mp2[nums2[i]]++;\\n        int xrval=0;\\n        for(int i=0;i<n;i++){\\n            int cnt=m+mp2[nums1[i]];   //adding nums2.size() because this number appears that times\\n            if(cnt%2==1)\\n                xrval^=nums1[i];\\n        }\\n        for(int i=0;i<m;i++){\\n            int cnt=n+mp1[nums2[i]];   //adding nums1.size() because this number appears that times\\n            if(cnt%2==1)\\n                xrval^=nums2[i];\\n        }\\n        return xrval;\\n    }\\n};\\n```\\n\\nTC: O(N) for Traversing array.\\nSC: O(N) for unordered_map.\\nwhere N is size of num array.\\n\\nIf you like the solution do upvote :) Happy Coding.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size();\\n        unordered_map<int,int> mp1,mp2;\\n        for(int i=0;i<n;i++)\\n            mp1[nums1[i]]++;\\n        for(int i=0;i<m;i++)\\n            mp2[nums2[i]]++;\\n        int xrval=0;\\n        for(int i=0;i<n;i++){\\n            int cnt=m+mp2[nums1[i]];   //adding nums2.size() because this number appears that times\\n            if(cnt%2==1)\\n                xrval^=nums1[i];\\n        }\\n        for(int i=0;i<m;i++){\\n            int cnt=n+mp1[nums2[i]];   //adding nums1.size() because this number appears that times\\n            if(cnt%2==1)\\n                xrval^=nums2[i];\\n        }\\n        return xrval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646571,
                "title": "python-elegant-short-o-n-m",
                "content": "```\\nfrom functools import reduce\\nfrom operator import xor\\n\\n\\nclass Solution:\\n    def xorAllNums(self, a: List[int], b: List[int]) -> int:\\n        return reduce(xor, a * (len(b) & 1) + b * (len(a) & 1), 0)\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom functools import reduce\\nfrom operator import xor\\n\\n\\nclass Solution:\\n    def xorAllNums(self, a: List[int], b: List[int]) -> int:\\n        return reduce(xor, a * (len(b) & 1) + b * (len(a) & 1), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696115,
                "title": "best-c-solution-approach-explained-with-example-beats-100",
                "content": "# Intuition\\nLets take the first example: \\n`nums1 = [2,1,3] and nums2 = [10,2,5,0] `\\nNow, nums3 is formed with its elements being **Every element in nums1 XOR every element in nums2** \\nThe first four elements of nums3 are `[8, 0, 7, 2]` which can be written as `[2^10, 2^2, 2^5, 2^0]`\\nThis clearly shows that `2 from nums1 occurs 4 times which is also equal to nums2.size()` \\nLastly, we have to take **XOR of all elements in nums3** to obtain the final answer. \\nThe **XOR of first four elements of nums3** will be equal to `10^2^5^0` because **2 occurs even number of times and we know XOR of a number occuring even number of times is 0**\\nTherefore, we need to check if any of the two array is of odd length and then perform XOR of elements in the other array. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0, n1 = nums1.size(), n2 = nums2.size();\\n        if(n2%2==1){\\n            for(int i=0; i<n1; i++)\\n                ans ^= nums1[i];\\n        }\\n        if(n1%2==1){\\n            for(int i=0; i<n2; i++)\\n                ans ^= nums2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0, n1 = nums1.size(), n2 = nums2.size();\\n        if(n2%2==1){\\n            for(int i=0; i<n1; i++)\\n                ans ^= nums1[i];\\n        }\\n        if(n1%2==1){\\n            for(int i=0; i<n2; i++)\\n                ans ^= nums2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516772,
                "title": "easy-beginner-friendly-solution-t-c-o-n",
                "content": "# BRUTE Force\\n**T.C.=O(N^2)\\n   S.C.=O(N)\\n   BUT this solution will give TLE because of O(N^2) Time Complexity**\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        if(n==1 && m==1){\\n            return (nums1[0]^nums2[0]);\\n        }\\n       vector<int>ans;\\n        int xor_ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                ans.push_back(nums1[i]^nums2[j]);\\n            }\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            cout<<ans[i]<<\" \";\\n            xor_ans=xor_ans^ans[i];\\n        }\\n        return xor_ans;\\n    }\\n};\\n```\\n# some how OPTIMIZED approach\\n**if you know the property of XOR\\nthen,\\nstep1-: m=size of nums1 and n=size of nums2\\nstep2-: ans1 will store the XOR of nums1 and ans2 will store the XOR of nums2\\nstep3-:if m is even and n is even then return 0;\\nstep4-:else if m is odd and n is odd then return XOR of ans1  and an2 (i.e. ans1^ans2)\\nstep5-: else if m is odd and n is even then return ans2\\nstep6-: else if m is even and n is odd then return ans1**\\n\\n**T.C.=O(N)\\nS.C.=O(1)**\\n```\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        \\n        int ans1=0,ans2=0;\\n         for(int i=0;i<m;i++){\\n             ans1=ans1^nums1[i];\\n         }\\n        \\n        for(int i=0;i<n;i++){\\n            ans2=ans2^nums2[i];\\n        }\\n        \\n        if(m%2==0 && n%2==0)\\n            return 0;\\n        \\n        else if(m%2!=0 && n%2!=0)\\n            return (ans1^ans2);\\n        \\n        else if(m%2==0 && n%2!=0)\\n            return  ans1;\\n        else if(m%2!=0 && n%2==0)\\n            return ans2;\\n        \\n        return 0;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/3545e62a-06db-429d-8b60-f3903020a7e4_1683907783.131422.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        if(n==1 && m==1){\\n            return (nums1[0]^nums2[0]);\\n        }\\n       vector<int>ans;\\n        int xor_ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                ans.push_back(nums1[i]^nums2[j]);\\n            }\\n        }\\n        for(int i=0;i<ans.size();i++){\\n            cout<<ans[i]<<\" \";\\n            xor_ans=xor_ans^ans[i];\\n        }\\n        return xor_ans;\\n    }\\n};\\n```\n```\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size();\\n        int n=nums2.size();\\n        \\n        int ans1=0,ans2=0;\\n         for(int i=0;i<m;i++){\\n             ans1=ans1^nums1[i];\\n         }\\n        \\n        for(int i=0;i<n;i++){\\n            ans2=ans2^nums2[i];\\n        }\\n        \\n        if(m%2==0 && n%2==0)\\n            return 0;\\n        \\n        else if(m%2!=0 && n%2!=0)\\n            return (ans1^ans2);\\n        \\n        else if(m%2==0 && n%2!=0)\\n            return  ans1;\\n        else if(m%2!=0 && n%2==0)\\n            return ans2;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3319615,
                "title": "c-with-bitwise-xor-concept",
                "content": "**You should know the basic concept of Xor that \"Xor of same number is 0\"\\neg:- 2^2=0.\\nlet us understand this question with an example. suppose nums1={1,2} , nums2{3,4,5} therefore nums3 will be { 1^3 , 1^4,1^5, 2^3, 2^4,2^5} , Now we have to output the Xor of nums3 element which is (1^3^1^4^1^5^2^3^2^4^2^5). Now by the above Xor property we get output=  1^2*.\\nso we have to take only those element which will exist in odd number of times in nums3. This is possible only if multiplying array has odd number of element.*\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size(),ans=0;\\n        if(m%2!=0){\\n            for(int i=0; i<n; i++){\\n                ans=ans^nums1[i];\\n            }\\n        }\\n        if(n%2!=0){\\n            for(int i=0; i<m; i++){\\n                ans=ans^nums2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size(),ans=0;\\n        if(m%2!=0){\\n            for(int i=0; i<n; i++){\\n                ans=ans^nums1[i];\\n            }\\n        }\\n        if(n%2!=0){\\n            for(int i=0; i<m; i++){\\n                ans=ans^nums2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714668,
                "title": "c-easy-to-understand-brute-force-soln",
                "content": "```\\n/*If the size of the vector is odd, then only include the xor of the vector elements, \\notherwuse return 0*/\\nint xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size(), x1=0, x2=0, x;\\n        for(int i=0;i<m;i++) x1^=nums2[i];\\n        for(int i=0;i<n;i++) x2^=nums1[i];\\n        if(n%2==0 && m%2==0) x=0;\\n        else if(m%2==1 && n%2==1) x=x1^x2;\\n        else if(n%2==0) x=x2;\\n        else if(m%2==0) x=x1;\\n        return x;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*If the size of the vector is odd, then only include the xor of the vector elements, \\notherwuse return 0*/\\nint xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size(), x1=0, x2=0, x;\\n        for(int i=0;i<m;i++) x1^=nums2[i];\\n        for(int i=0;i<n;i++) x2^=nums1[i];\\n        if(n%2==0 && m%2==0) x=0;\\n        else if(m%2==1 && n%2==1) x=x1^x2;\\n        else if(n%2==0) x=x2;\\n        else if(m%2==0) x=x1;\\n        return x;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668390,
                "title": "c-easy-iterative-approach",
                "content": "**Approch** :-\\n1.] The main logic of this quection is how many times a perticular number going to present in xor operation\\n2.] We know that if sum number is going to xor with it self in even number of time ans would be **0** other wise ans will be *number it self*\\n3.] So here we have to xor every pair possible form nums1 and nums2 and letter we have to find xor of that all the pair\\n4.] so we can say that all the numbers from any array are going to make pair length of another array times\\n5.] so if in xor of all the pairs we are going to consider only those arrays number wen another have odd length\\n\\n**c++ code**\\n```\\nint xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans1=0;\\n        for(auto &x:nums1){\\n            ans1=ans1^x;\\n        }\\n        int ans2=0;\\n        for(auto &x:nums2){\\n            ans2=ans2^x;\\n        }\\n        \\n        int ans=0;\\n        if(nums1.size()%2==1){\\n            ans=ans^ans2;\\n        }\\n        if(nums2.size()%2==1){\\n            ans=ans^ans1;\\n        }\\n        return ans;\\n    }\\n\\t//code by sachin\\n```\\n**Upvote is solution was helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nint xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans1=0;\\n        for(auto &x:nums1){\\n            ans1=ans1^x;\\n        }\\n        int ans2=0;\\n        for(auto &x:nums2){\\n            ans2=ans2^x;\\n        }\\n        \\n        int ans=0;\\n        if(nums1.size()%2==1){\\n            ans=ans^ans2;\\n        }\\n        if(nums2.size()%2==1){\\n            ans=ans^ans1;\\n        }\\n        return ans;\\n    }\\n\\t//code by sachin\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2659065,
                "title": "c-if-else-fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif length of both vector are even , then answer will be zero.\\nif length of both vectror are odd , then asnwer will be x^y.\\nif length of vectors are d/f in parity , then the answer will be power of element of vector whose length is even.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n       int res=0;\\n    int n = nums1.size();\\n        int m = nums2.size();\\n        int x=0;\\n        int y=0;\\n        for (int i=0;i<n;i++)\\n            x^=nums1[i];\\n        for (int i=0;i<m;i++)\\n            y^=nums2[i];\\n         if (n%2==0 && m%2==0 )\\n            res=0;\\n  \\n        else if (m%2==0 && n%2!=0)\\n            res=y;\\n        else if (n%2!=0 && m%2!=0)\\n            res=x ^ y;\\n        else if (n%2==0 && m%2!=0)\\n            res=x;\\n        \\n        return res;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n       int res=0;\\n    int n = nums1.size();\\n        int m = nums2.size();\\n        int x=0;\\n        int y=0;\\n        for (int i=0;i<n;i++)\\n            x^=nums1[i];\\n        for (int i=0;i<m;i++)\\n            y^=nums2[i];\\n         if (n%2==0 && m%2==0 )\\n            res=0;\\n  \\n        else if (m%2==0 && n%2!=0)\\n            res=y;\\n        else if (n%2!=0 && m%2!=0)\\n            res=x ^ y;\\n        else if (n%2==0 && m%2!=0)\\n            res=x;\\n        \\n        return res;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647436,
                "title": "c-linear-time-mathematics-explained-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nExor of x even number of times is 0 & Exor of x odd number of times is x itself\\n\\nA Exor A =0 \\n\\n0 Exor A = A\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n####### Consider both even length :-\\n\\nnums1 :- a,b\\nnums2 :- c,d\\n\\nnums3 :- (a^c), (a^d), (b^c), (b^d)\\n\\nfor final result :- a^c^a^d^b^c^b^d , a will cancel a ,b will cancel b, c will cancel c & d will cancel d so finaly 0\\n\\nso if both array has even length result will be always 0\\n\\n\\n####### Consider both odd length :-\\n\\nnums1 :- a,b,e\\nnums2 :- c,d,f\\n\\nnums3 :- (a^c), (a^d), (a^f), (b^c), (b^d), (b^f), (e^c), (e^d), (e^f)\\n\\nfor final result :- a will cancel a but one a will remain ,b will cancel b but one b will remain, similar for others\\n\\nso if both array has odd length result will be always Exor of all the element of nums1 & Exor of all the element of nums2 i.e exor1^exor2\\n\\n\\n\\n####### Consider nums1 even length & nums2 odd length :-\\n\\nnums1 :- a,b\\nnums2 :- c,d,e\\n\\nnums3 :- (a^c), (a^d), (a^e) , (b^c), (b^d), (b^e)\\n\\nwe can see that each elements of nums2 will exored even number of times so they will be cancel out so only remaining is exor1  \\n\\n\\n####### Consider nums1 odd length & nums2 even length :-\\n\\nnums1 :- a,b,c\\nnums2 :- d,e\\n\\nnums3 :- (a^d), (a^e), (b^d) , (b^e), (c^d), (c^e)\\n\\nwe can see that each elements of nums1 will exored even number of times so they will be cancel out so only remaining is exor2 \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int exor1=0,exor2=0,n=nums1.size(),m=nums2.size();\\n\\n        for(auto elem:nums1)\\n        {\\n            exor1=(exor1^elem);\\n        }\\n\\n        for(auto elem:nums2)\\n        {\\n            exor2=(exor2^elem);\\n        }\\n\\n        if(n%2==0 && m%2==0)\\n        {\\n            return 0;\\n        }\\n        else if(n%2==0)\\n        {\\n            return exor1;\\n        }\\n        else if(m%2==0)\\n        {\\n            return exor2;\\n        }\\n\\n        return exor1^exor2;\\n    }\\n};\\n```\\n\\n**Upvote += \"Helpful\" ? 1 : 0 ;\\nplease feel free to drop any suggestion :)\\nthanks & regard\\nAKS**\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int exor1=0,exor2=0,n=nums1.size(),m=nums2.size();\\n\\n        for(auto elem:nums1)\\n        {\\n            exor1=(exor1^elem);\\n        }\\n\\n        for(auto elem:nums2)\\n        {\\n            exor2=(exor2^elem);\\n        }\\n\\n        if(n%2==0 && m%2==0)\\n        {\\n            return 0;\\n        }\\n        else if(n%2==0)\\n        {\\n            return exor1;\\n        }\\n        else if(m%2==0)\\n        {\\n            return exor2;\\n        }\\n\\n        return exor1^exor2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647199,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Xor***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        // (x ^ x = 0)\\n        \\n        vector<int> res;\\n        \\n        for(int i = 0; i < n1; i++)\\n        {\\n            // if the size of nums2 is odd\\n            \\n            if(n2 % 2 == 1)\\n            {\\n                res.push_back(nums1[i]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < n2; i++)\\n        {\\n            // if the size of nums1 is odd\\n            \\n            if(n1 % 2 == 1)\\n            {\\n                res.push_back(nums2[i]);\\n            }\\n        }\\n        \\n        // find the xor of res array\\n        \\n        int xorr = 0;\\n        \\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            xorr = (xorr ^ res[i]);\\n        }\\n        \\n        return xorr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        // (x ^ x = 0)\\n        \\n        vector<int> res;\\n        \\n        for(int i = 0; i < n1; i++)\\n        {\\n            // if the size of nums2 is odd\\n            \\n            if(n2 % 2 == 1)\\n            {\\n                res.push_back(nums1[i]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < n2; i++)\\n        {\\n            // if the size of nums1 is odd\\n            \\n            if(n1 % 2 == 1)\\n            {\\n                res.push_back(nums2[i]);\\n            }\\n        }\\n        \\n        // find the xor of res array\\n        \\n        int xorr = 0;\\n        \\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            xorr = (xorr ^ res[i]);\\n        }\\n        \\n        return xorr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647142,
                "title": "two-if-checks-o-n-m-very-simple-with-image-explained",
                "content": "# Intuition\\nLOGIC : Because XOR of same elements is 0 i.e cancels out\\n# Approach\\nJust check 2 cases :\\nIf length of nums1 is odd , xor all elements of nums2 once.\\nIf length of nums2 is odd , xor all elements of nums1 once.\\n\\n\\n![Bitwise XOR Logic.PNG](https://assets.leetcode.com/users/images/85ffc96c-08df-44a1-b051-5ab683b355cd_1664643901.0644596.png)\\n\\n# Complexity\\n- Time complexity: O(n + m)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {        \\n        int ansxor=0;        \\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        \\n        if(n1 % 2 == 1){\\n            for(int i=0; i<n2; i++){\\n                ansxor ^= nums2[i];\\n            }\\n        }\\n        if(n2 % 2 == 1){\\n            for(int i=0; i<n1; i++){\\n                ansxor ^= nums1[i];\\n            }\\n        }       \\n        return ansxor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {        \\n        int ansxor=0;        \\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        \\n        if(n1 % 2 == 1){\\n            for(int i=0; i<n2; i++){\\n                ansxor ^= nums2[i];\\n            }\\n        }\\n        if(n2 % 2 == 1){\\n            for(int i=0; i<n1; i++){\\n                ansxor ^= nums1[i];\\n            }\\n        }       \\n        return ansxor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646898,
                "title": "java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nxor property -> num ^ num = 0\\nif a number has occured even times if would make the effective xor to 0\\nstore the frequency for numbers in map and do the xor of only odd frequency numbers.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m) + O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m+n)$$\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n\\t        int m = nums1.length;\\n\\t        int n = nums2.length;\\n\\t        Map<Integer, Integer> freq = new HashMap<>();\\n\\t        \\n\\t        for(int i = 0; i < m; i++) {\\n\\t            int c = freq.getOrDefault(nums1[i], 0);\\n\\t            freq.put(nums1[i], c + n);\\n\\t        }\\n\\t        \\n\\t        for(int i = 0; i < n; i++) {\\n\\t            int c = freq.getOrDefault(nums2[i], 0);\\n\\t            freq.put(nums2[i], c + m);\\n\\t        }\\n\\t        \\n\\t        int xor = 0;\\n\\t        \\n\\t        for(int key: freq.keySet()) {\\n\\t        \\tif(freq.get(key) % 2 == 1) {\\n\\t        \\t\\txor ^= key;\\n\\t        \\t}\\n\\t        }\\n\\t        \\n\\t        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n\\t        int m = nums1.length;\\n\\t        int n = nums2.length;\\n\\t        Map<Integer, Integer> freq = new HashMap<>();\\n\\t        \\n\\t        for(int i = 0; i < m; i++) {\\n\\t            int c = freq.getOrDefault(nums1[i], 0);\\n\\t            freq.put(nums1[i], c + n);\\n\\t        }\\n\\t        \\n\\t        for(int i = 0; i < n; i++) {\\n\\t            int c = freq.getOrDefault(nums2[i], 0);\\n\\t            freq.put(nums2[i], c + m);\\n\\t        }\\n\\t        \\n\\t        int xor = 0;\\n\\t        \\n\\t        for(int key: freq.keySet()) {\\n\\t        \\tif(freq.get(key) % 2 == 1) {\\n\\t        \\t\\txor ^= key;\\n\\t        \\t}\\n\\t        }\\n\\t        \\n\\t        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646888,
                "title": "beginner-friendly-easy-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int> &nums1, vector<int> &nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        int xor1 = 0 , xor2 = 0, ans = 0;\\n        for (int &x : nums1) xor1 ^= x;\\n        for (int &y : nums2) xor2 ^= y;\\n        if (n % 2 && m % 2 == 0) ans = xor2;\\n        else if (n % 2 == 0 && m % 2) ans = xor1;\\n        else if (n % 2 && m % 2 ) ans = xor1 ^ xor2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int> &nums1, vector<int> &nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        int xor1 = 0 , xor2 = 0, ans = 0;\\n        for (int &x : nums1) xor1 ^= x;\\n        for (int &y : nums2) xor2 ^= y;\\n        if (n % 2 && m % 2 == 0) ans = xor2;\\n        else if (n % 2 == 0 && m % 2) ans = xor1;\\n        else if (n % 2 && m % 2 ) ans = xor1 ^ xor2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646831,
                "title": "observations-logic-explained-commented-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int size_nums1 = nums1.size() ; \\n        int size_nums2 = nums2.size() ; \\n     \\n        int first = 0 , second = 0  , xor_value=0;\\n  // store xor of nums1 and nums2\\n        for(auto&i:nums1) first=(first^i);\\n        for(auto&i:nums2) second=(second^i);\\n        \\n        //cases --> 4 possible\\n//1st ex-> nums1 = 2,1,3 nums2 = 10,2,5,0 --> ans = 13\\n//(which is xor value of all the elements of nums2)\\n        if((size_nums1&1)  && !(size_nums2&1) ){\\n            return second ;\\n        }\\n     \\n//2nd ex-> nums1 = 2,1 nums2 = 3,4 --> ans = 0 (both even size)\\n        else if(!(size_nums1&1)  && !(size_nums2&1) ){\\n            return 0 ;\\n        }\\n\\n//3rd ex-> nums1 = 10,2,5,0 nums2 = 2,1,3  --> ans = 13\\n//(which is xor value of all the elements of nums1)\\n        else if(!(size_nums1&1)  && (size_nums2&1) ){\\n            return first ;\\n        }\\n        \\n//4th ex-> nums1 = 1 nums2 = 2 --> ans = 3 (both odd size)\\n//(ans = 1^2 i.e xor of all the elements of nums1 and nums2)\\n          else if((size_nums1&1)  && (size_nums2&1) ){\\n              int res= (first^second);\\n            return res ;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int size_nums1 = nums1.size() ; \\n        int size_nums2 = nums2.size() ; \\n     \\n        int first = 0 , second = 0  , xor_value=0;\\n  // store xor of nums1 and nums2\\n        for(auto&i:nums1) first=(first^i);\\n        for(auto&i:nums2) second=(second^i);\\n        \\n        //cases --> 4 possible\\n//1st ex-> nums1 = 2,1,3 nums2 = 10,2,5,0 --> ans = 13\\n//(which is xor value of all the elements of nums2)\\n        if((size_nums1&1)  && !(size_nums2&1) ){\\n            return second ;\\n        }\\n     \\n//2nd ex-> nums1 = 2,1 nums2 = 3,4 --> ans = 0 (both even size)\\n        else if(!(size_nums1&1)  && !(size_nums2&1) ){\\n            return 0 ;\\n        }\\n\\n//3rd ex-> nums1 = 10,2,5,0 nums2 = 2,1,3  --> ans = 13\\n//(which is xor value of all the elements of nums1)\\n        else if(!(size_nums1&1)  && (size_nums2&1) ){\\n            return first ;\\n        }\\n        \\n//4th ex-> nums1 = 1 nums2 = 2 --> ans = 3 (both odd size)\\n//(ans = 1^2 i.e xor of all the elements of nums1 and nums2)\\n          else if((size_nums1&1)  && (size_nums2&1) ){\\n              int res= (first^second);\\n            return res ;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646829,
                "title": "python-clean",
                "content": "```\\n# N3. Bitwise XOR of All Pairings\\nclass Solution:\\n    def xorAllNums(self, nums1, nums2) -> int:\\n        bw = 0\\n\\n        # we only need to know oddity of the times number is xored\\n        if len(nums2) % 2:\\n            for a in nums1:\\n                bw ^= a\\n        if len(nums1) % 2:\\n            for a in nums2:\\n                bw ^= a\\n\\n        return bw\\n```",
                "solutionTags": [],
                "code": "```\\n# N3. Bitwise XOR of All Pairings\\nclass Solution:\\n    def xorAllNums(self, nums1, nums2) -> int:\\n        bw = 0\\n\\n        # we only need to know oddity of the times number is xored\\n        if len(nums2) % 2:\\n            for a in nums1:\\n                bw ^= a\\n        if len(nums1) % 2:\\n            for a in nums2:\\n                bw ^= a\\n\\n        return bw\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646769,
                "title": "python-o-n-greedy-solution",
                "content": "Hi guys,\\n\\nA straightforward approach to this problem :\\n\\n\\t \\n        n1=len(nums1)\\n        n2=len(nums2)\\n        bit1=0\\n        bit2=0\\n        for i in range (n2):\\n            bit2^=nums2[i]\\n        for i in range (n1):\\n            bit1^=nums1[i]\\n        if n1%2==0 and n2%2==0:\\n            return 0\\n        elif n1%2==1 and n2%2==0:\\n            return bit2\\n        elif n1%2==0 and n2%2==1:\\n            return bit1\\n        else:\\n            return bit1^bit2\\n\\t\\t\\t\\nWe know that elements from nums1 will appear len(nums2) times and elements from nums2 will appear len(nums1) times in the calculation.\\nGiven that x^x=0 and x^0=x we know that, depending on the lengths of each array, we just need to take the XOR of the first array or the XOR of the second array or the XOR of these XORs.\\n\\nPlease upvote if you liked,\\nBerthouille",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "Hi guys,\\n\\nA straightforward approach to this problem :\\n\\n\\t \\n        n1=len(nums1)\\n        n2=len(nums2)\\n        bit1=0\\n        bit2=0\\n        for i in range (n2):\\n            bit2^=nums2[i]\\n        for i in range (n1):\\n            bit1^=nums1[i]\\n        if n1%2==0 and n2%2==0:\\n            return 0\\n        elif n1%2==1 and n2%2==0:\\n            return bit2\\n        elif n1%2==0 and n2%2==1:\\n            return bit1\\n        else:\\n            return bit1^bit2\\n\\t\\t\\t\\nWe know that elements from nums1 will appear len(nums2) times and elements from nums2 will appear len(nums1) times in the calculation.\\nGiven that x^x=0 and x^0=x we know that, depending on the lengths of each array, we just need to take the XOR of the first array or the XOR of the second array or the XOR of these XORs.\\n\\nPlease upvote if you liked,\\nBerthouille",
                "codeTag": "Unknown"
            },
            {
                "id": 2646758,
                "title": "java-very-simple-xor-operation-explations-o-m-n",
                "content": "Important properties of XOR\\n\\nThere are 4 very important properties of XOR that we will be making use of. These are formal mathematical terms but actually the concepts are very simple.\\n\\n    Commutative : A \\u2295 B = B \\u2295 A\\n\\n    This is clear from the definition of XOR: it doesn\\u2019t matter which way round you order the two inputs.\\n    Associative : A \\u2295 ( B \\u2295 C ) = ( A \\u2295 B ) \\u2295 C\\n\\n    This means that XOR operations can be chained together and the order doesn\\u2019t matter. If you aren\\u2019t convinced of the truth of this statement, try drawing the truth tables.\\n    Identity element : A \\u2295 0 = A\\n\\n    This means that any value XOR\\u2019d with zero is left unchanged.\\n    Self-inverse : A \\u2295 A = 0\\n\\n    This means that any value XOR\\u2019d with itself gives zero.\\n\\t\\n\\tExplaination:\\n\\tif there are 2 array [a, b] and [c, d] both are even length;\\n\\tfinal output is (a \\u2295 c ) \\u2295 (a \\u2295 d) \\u2295 (b \\u2295 c)  \\u2295(b \\u2295 d)\\n\\t=> (a \\u2295 a ) \\u2295 (b \\u2295 b) \\u2295 (c \\u2295 c) \\u2295 (d \\u2295 d)\\n\\t=> 0\\n\\telse if one is odd i.e. [a, b] and [c, d, e]\\n\\tfinal output is (a \\u2295 c ) \\u2295 (a \\u2295 d) \\u2295 (a \\u2295 e) \\u2295 (b \\u2295 c) \\u2295 (b \\u2295 d)\\u2295 (b \\u2295 e) \\n\\t=> (a \\u2295 a \\u2295 a)\\u2295 (b \\u2295 b \\u2295 b) \\u2295 (c \\u2295 c) \\u2295 (d \\u2295 d) \\u2295(e\\u2295)\\n\\t=> a \\u2295 b\\n\\t\\n\\tfor [a, b, c] and [d, e]\\n\\t=> d \\u2295 e\\n\\t\\n\\tfor [a, b, c] and [d, e, f]\\n\\t=> a \\u2295 b  \\u2295 c  \\u2295 d  \\u2295 e  \\u2295 f\\n\\n\\n```\\npublic int xorAllNums(int[] nums1, int[] nums2) {\\n        int result = 0;\\n        if(nums2.length % 2 != 0){\\n           for(int i = 0; i < nums1.length; i++) {\\n             result ^= nums1[i];\\n           } \\n        }\\n        if(nums1.length % 2 != 0){\\n           for(int i = 0; i < nums2.length; i++) {\\n             result ^= nums2[i];\\n           }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int xorAllNums(int[] nums1, int[] nums2) {\\n        int result = 0;\\n        if(nums2.length % 2 != 0){\\n           for(int i = 0; i < nums1.length; i++) {\\n             result ^= nums1[i];\\n           } \\n        }\\n        if(nums1.length % 2 != 0){\\n           for(int i = 0; i < nums2.length; i++) {\\n             result ^= nums2[i];\\n           }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646726,
                "title": "simple-java-o-n-solution-easy-to-understand-with-simple-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nXor of same numbers equals to 0. i.e, xor(5^5) = 0.\\nXor of number and zero is equals to number itself. i.e, xor(7^0) = 7\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet n1 = nums1.length and n2 = nums2.length\\n\\nif n1 and n2 both are even, it means all the elements in both array will appear even times in the xor of all elements.\\nSo, ans = 0\\nexample:\\nnums1 = [2,3], nums2 = [4,5]\\nnums3 = [2^4, 2^5, 3^4, 3^5] (all elements is appearing even times)\\nans = xor(nums3) = 0\\n\\nif n1 and n2 both are odd, it means all elements in both array will be taken for the xor.\\nans = xor(nums1)^xor(nums2)\\nexample:\\nnums1 = [2,3,6], nums2 = [4,5,7]\\nnums3 = [2^4, 2^5, 2^7, 3^4, 3^5, 3^7, 6^4, 6^5, 6^7,] (all elements is appearing odd times)\\nans = xor(nums3) = xor(nums1) ^ xor(nums2)\\n\\nif either of them(n1, n2) is even, it means array having odd length will be discarded because it will come even times. So, only even length array will be responsible for ans.\\nans = xor(even_length_array)\\nexample:\\nnums1 = [2,3], nums2 = [4,5,7]\\nnums3 = [2^4, 2^5, 2^7, 3^4, 3^5, 3^7] (all elements in even length array is appearing odd times and all elements in odd length array is appearing even times)\\nans = xor(nums3) = xor(even_length_array) = xor(nums1)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    o(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    o(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int xor(int[] a) {\\n        int ans = 0;\\n        for(int n: a) {\\n            ans ^= n;\\n        }\\n        return ans;\\n    }\\n    \\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        if(n1%2==0 && n2%2==0) {\\n            return 0;\\n        }\\n        if(n1%2==1 && n2%2==1) {\\n            return xor(nums1)^xor(nums2);\\n        }\\n        \\n        if(n1%2==0) {\\n            return xor(nums1);\\n        }\\n        \\n        return xor(nums2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xor(int[] a) {\\n        int ans = 0;\\n        for(int n: a) {\\n            ans ^= n;\\n        }\\n        return ans;\\n    }\\n    \\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        if(n1%2==0 && n2%2==0) {\\n            return 0;\\n        }\\n        if(n1%2==1 && n2%2==1) {\\n            return xor(nums1)^xor(nums2);\\n        }\\n        \\n        if(n1%2==0) {\\n            return xor(nums1);\\n        }\\n        \\n        return xor(nums2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646616,
                "title": "simple-python3-explained-o-n1-n2",
                "content": "XOR is commutative, meaning the order of operand\\'s doesn\\'t change the result\\n\\nThus we can ignore order and say, in the entire xor result, we must have:\\n- n2 copies of each num in nums1\\n- n1 copies of each num in nums2\\n\\nWe can take advantage of the fact that, when a number is xor\\'d with some number of itself, only the parity matters:\\n- if the number of operands is odd, we get the original number: 7 ^ 7 ^ 7 = 7  (111)\\n- if even, we just get 0: 7 ^ 7 ^ 7 ^ 7 = 0 (because in the final xor, all the bits are the same)\\n\\nSo instead of making all the pairs, we can leverege the commutativity and do it in O(n1 + n2) time.\\n\\nPlease upvote if it helps! :)\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        n1, n2 = len(nums1), len(nums2)\\n        res = 0\\n     \\n        for num in nums1:\\n            if n2 % 2:\\n                res ^= num\\n                \\n        for num in nums2:\\n            if n1 % 2:\\n                res ^= num\\n        \\n        return res",
                "solutionTags": [
                    "Python3"
                ],
                "code": "XOR is commutative, meaning the order of operand\\'s doesn\\'t change the result\\n\\nThus we can ignore order and say, in the entire xor result, we must have:\\n- n2 copies of each num in nums1\\n- n1 copies of each num in nums2\\n\\nWe can take advantage of the fact that, when a number is xor\\'d with some number of itself, only the parity matters:\\n- if the number of operands is odd, we get the original number: 7 ^ 7 ^ 7 = 7  (111)\\n- if even, we just get 0: 7 ^ 7 ^ 7 ^ 7 = 0 (because in the final xor, all the bits are the same)\\n\\nSo instead of making all the pairs, we can leverege the commutativity and do it in O(n1 + n2) time.\\n\\nPlease upvote if it helps! :)\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        n1, n2 = len(nums1), len(nums2)\\n        res = 0\\n     \\n        for num in nums1:\\n            if n2 % 2:\\n                res ^= num\\n                \\n        for num in nums2:\\n            if n1 % 2:\\n                res ^= num\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2646603,
                "title": "simple-map-solution-o-n-time-complexity-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n       \\n        unordered_map<int,int>mp1;  \\n        unordered_map<int,int>mp2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            mp1[nums1[i]]++;    //storing frequency of elements in mp1 map\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            mp2[nums2[i]]++;   // storing frequency of elements of in mp2 map\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(nums2.size()%2==1)\\n            {\\n                ans^=nums1[i];     // if nums2 is of size which is of odd partiy then XOR it to the answer\\n            }\\n           \\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            if(nums1.size()%2==1)\\n            {\\n                ans^=nums2[i];   // similarly if nums1 is of size which is of odd parity then XOR it again\\n            }\\n        } \\n        return ans;  // return the answer\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n       \\n        unordered_map<int,int>mp1;  \\n        unordered_map<int,int>mp2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            mp1[nums1[i]]++;    //storing frequency of elements in mp1 map\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            mp2[nums2[i]]++;   // storing frequency of elements of in mp2 map\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(nums2.size()%2==1)\\n            {\\n                ans^=nums1[i];     // if nums2 is of size which is of odd partiy then XOR it to the answer\\n            }\\n           \\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            if(nums1.size()%2==1)\\n            {\\n                ans^=nums2[i];   // similarly if nums1 is of size which is of odd parity then XOR it again\\n            }\\n        } \\n        return ans;  // return the answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980875,
                "title": "easy-python3",
                "content": "Example \\n\\n```python\\nnums1 = [2, 1, 3]\\nnums2 = [10, 2, 5, 0]\\n```\\n\\n1. Calculate the lengths of `nums1` and `nums2`:\\n   ```\\n   n1 = 3\\n   n2 = 4\\n   ```\\n\\n2. Check if the lengths of `nums1` and `nums2` are odd. In this case, `n1` is odd and `n2` is even.\\n\\n3. If `n1` is odd, calculate the XOR of all elements in `nums2`:\\n   ```\\n   xorArray([10, 2, 5, 0]) = 10 ^ 2 ^ 5 ^ 0 = 13\\n   ```\\n\\n4. The calculated XOR value (`13`) is assigned to `ansxor`.\\n\\n5. Since `n2` is even, we don\\'t perform any additional XOR operation on `nums1`.\\n\\n6. Return the calculated `ansxor`, which is `13`.\\n\\nSo, in this case, the algorithm calculates the XOR of all integers in `nums2` because the length of `nums1` is odd. The final result is `13`.\\n\\nLet\\'s also consider the second example:\\n\\n```python\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n```\\n\\n1. Calculate the lengths of `nums1` and `nums2`:\\n   ```\\n   n1 = 2\\n   n2 = 2\\n   ```\\n\\n2. Both `n1` and `n2` are even, so we don\\'t perform any additional XOR operations on either array.\\n\\n3. Return `ansxor`, which is `0`.\\n\\nIn this case, since both array lengths are even, there are no additional XOR operations performed beyond the initial calculation, leading to a result of `0`.\\n\\nThe algorithm follows these steps to efficiently determine the bitwise XOR of all integers in the resulting `nums3` array for the given pairing of `nums1` and `nums2`.\\n\\n# Code\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        ansxor = 0\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        \\n        if n1 % 2 == 1:\\n            ansxor = self.xorArray(nums2)\\n        if n2 % 2 == 1:\\n            ansxor ^= self.xorArray(nums1)\\n        \\n        return ansxor\\n    \\n    def xorArray(self, arr: List[int]) -> int:\\n        result = 0\\n        for num in arr:\\n            result ^= num\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nnums1 = [2, 1, 3]\\nnums2 = [10, 2, 5, 0]\\n```\n```\\n   n1 = 3\\n   n2 = 4\\n   ```\n```\\n   xorArray([10, 2, 5, 0]) = 10 ^ 2 ^ 5 ^ 0 = 13\\n   ```\n```python\\nnums1 = [1, 2]\\nnums2 = [3, 4]\\n```\n```\\n   n1 = 2\\n   n2 = 2\\n   ```\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        ansxor = 0\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        \\n        if n1 % 2 == 1:\\n            ansxor = self.xorArray(nums2)\\n        if n2 % 2 == 1:\\n            ansxor ^= self.xorArray(nums1)\\n        \\n        return ansxor\\n    \\n    def xorArray(self, arr: List[int]) -> int:\\n        result = 0\\n        for num in arr:\\n            result ^= num\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713466,
                "title": "bitwise-xor-of-all-pairings-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int xor2=0;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            xor2^=nums2[i];\\n        }\\n        \\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int ans=0;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(n2%2==1)\\n            {\\n                ans^=nums1[i]^xor2;\\n            }\\n            else\\n            {\\n                ans^=xor2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int xor2=0;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            xor2^=nums2[i];\\n        }\\n        \\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int ans=0;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(n2%2==1)\\n            {\\n                ans^=nums1[i]^xor2;\\n            }\\n            else\\n            {\\n                ans^=xor2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272921,
                "title": "explanation-easy-to-understand-approach",
                "content": "```\\n    // T.C O(n+m) S.C O(1)\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        //in final xor each number comes number of times == length of other array\\n        //eg [1,2] [3,4,5] --> [1^3, 1^4, 1^5, 2^3, 2^4, 2^5] //we can see 1,2 come 3 times whereas 2,4,5 come 2 times\\n        //We know property of xor a^a = 0, a^a^a = a ---> odd number of time ,  0-->even numer of times \\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        int ans = 0;\\n        \\n        if(n2%2==1)\\n        {\\n            for(int i=0;i<n1;i++)\\n                ans^=nums1[i];\\n        }\\n        if(n1%2==1)\\n        {\\n            for(int i=0;i<n2;i++)\\n                ans^=nums2[i];\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n    // T.C O(n+m) S.C O(1)\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        //in final xor each number comes number of times == length of other array\\n        //eg [1,2] [3,4,5] --> [1^3, 1^4, 1^5, 2^3, 2^4, 2^5] //we can see 1,2 come 3 times whereas 2,4,5 come 2 times\\n        //We know property of xor a^a = 0, a^a^a = a ---> odd number of time ,  0-->even numer of times \\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        int ans = 0;\\n        \\n        if(n2%2==1)\\n        {\\n            for(int i=0;i<n1;i++)\\n                ans^=nums1[i];\\n        }\\n        if(n1%2==1)\\n        {\\n            for(int i=0;i<n2;i++)\\n                ans^=nums2[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2665672,
                "title": "c-simple-approach",
                "content": "```\\n1.  int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>v;\\n       int n=nums1.size();\\n        int m=nums2.size();\\n        int ans=0;\\n        if(n%2==0 && m%2==0)\\n            return 0;\\n       else  if(n%2==1 && m%2==0)\\n       {\\n           for(int i=0;i<m;i++)\\n               ans^=nums2[i];\\n           return ans;\\n       }\\n         else  if(n%2==0 && m%2==1)\\n       {\\n           for(int i=0;i<n;i++)\\n               ans^=nums1[i];\\n             return ans;\\n       }\\n         else  if(n%2==1 && m%2==1)\\n             \\n       {\\n             int ans2=0;\\n            int ans1=0;\\n             for(int i=0;i<n;i++)\\n               ans1^=nums1[i];\\n             for(int i=0;i<m;i++)\\n                ans2^=nums2[i];\\n             ans=ans1^ans2;\\n             return ans;\\n       }\\n        return 0 ;\\n```",
                "solutionTags": [],
                "code": "```\\n1.  int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>v;\\n       int n=nums1.size();\\n        int m=nums2.size();\\n        int ans=0;\\n        if(n%2==0 && m%2==0)\\n            return 0;\\n       else  if(n%2==1 && m%2==0)\\n       {\\n           for(int i=0;i<m;i++)\\n               ans^=nums2[i];\\n           return ans;\\n       }\\n         else  if(n%2==0 && m%2==1)\\n       {\\n           for(int i=0;i<n;i++)\\n               ans^=nums1[i];\\n             return ans;\\n       }\\n         else  if(n%2==1 && m%2==1)\\n             \\n       {\\n             int ans2=0;\\n            int ans1=0;\\n             for(int i=0;i<n;i++)\\n               ans1^=nums1[i];\\n             for(int i=0;i<m;i++)\\n                ans2^=nums2[i];\\n             ans=ans1^ans2;\\n             return ans;\\n       }\\n        return 0 ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2665136,
                "title": "rust-solution",
                "content": "# Intuition\\n\\nEvery element in $num_i$ will xor $num_{1-i}.len()$ times\\n\\n# Complexity\\n- Time complexity: $O(N)$\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn xor_all_nums(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        let mut ret = 0;\\n        if nums1.len() % 2 == 1 {\\n            ret ^= nums2.iter().fold(0, |n, x| {n^x});\\n        }\\n        if nums2.len() % 2 == 1 {\\n           ret ^= nums1.iter().fold(0, |n, x| {n^x});\\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn xor_all_nums(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        let mut ret = 0;\\n        if nums1.len() % 2 == 1 {\\n            ret ^= nums2.iter().fold(0, |n, x| {n^x});\\n        }\\n        if nums2.len() % 2 == 1 {\\n           ret ^= nums1.iter().fold(0, |n, x| {n^x});\\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2656557,
                "title": "faster-than-100-00-of-c-online-submissions-for-bitwise-xor-of-all-pairings",
                "content": "\\n```\\n  int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n         map<long, long> mp;\\n        long long n = nums1.size();\\n        long long m = nums2.size();\\n        for(auto x:nums1){\\n            mp[x]+=m;\\n        }\\n        for(auto x:nums2){\\n            mp[x]+=n;\\n        }\\n        for(auto x:mp){\\n            mp[x.first]%=2;\\n        }\\n        long long ans=0;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                ans^=x.first;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n  int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n         map<long, long> mp;\\n        long long n = nums1.size();\\n        long long m = nums2.size();\\n        for(auto x:nums1){\\n            mp[x]+=m;\\n        }\\n        for(auto x:nums2){\\n            mp[x]+=n;\\n        }\\n        for(auto x:mp){\\n            mp[x.first]%=2;\\n        }\\n        long long ans=0;\\n        for(auto x:mp){\\n            if(x.second==1){\\n                ans^=x.first;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2653456,
                "title": "xor-property-explained-c-solution",
                "content": "Property of xor  \\n\\t1-> if we **xor** a number **even** number of time with it **self them XOR will be ZERO**;\\n\\t2-> if we **xor** a number odd number of time with itself then **xor will be same number**;\\n\\t\\n**observation**\\n\\tif n1.size() is **even** then every element into n2 will be repeated even numver of times so we will xor n2 \\n\\t**and**\\n\\tif n2.size() is even then we will xor n1 every element ;\\n\\t\\n\\t\\n**solution 1->**\\n\\n\\tint code1(v&nums1 , v&nums2)\\n    {\\n        vector<int> ans;\\n        int i=0, j=0; \\n        while(i<nums1.size() and j<nums2.size())\\n        {\\n            ans.push_back(nums1[i++]^nums2[j++]);\\n        }\\n        if(nums1.size()>nums2.size())\\n        {\\n           while(i<nums1.size()) ans.push_back(nums1[i++]);\\n        }\\n        else while(j<nums2.size()) ans.push_back(nums2[j++]);\\n        int ans = 0;\\n        for(int i=0; i<ans.size(); i++)\\n        {\\n            ans ^= ans[i];\\n        }\\n        return ans;\\n    }\\n\\t\\n**time 0(N*M)****\\n**space O(N*M)**\\n**result TLE for large test case**\\n\\n__________________________________________________________________________________________________________\\n**solution 2->**    \\n\\n    int code2(vector<int> &n1,vector<int> &n2){\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// using xor property that i expained above ;\\n        if(n1.size()%2)  for(int i=0; i<n2.size(); i++)   ans = ans^n2[i];\\n           \\n        if(n2.size()%2) for(int i=0;i<n1.size();i++) ans^=n1[i];\\n        return ans;\\n    }\\n\\t\\n**Runtime**: 453 ms, faster than **100.00% of C++** online submissions for Bitwise XOR of All Pairings\\n.\\n**Memory Usage**: 60.5 MB, less than **100.00% of C++** online submissions for Bitwise XOR of All Pairings.\\n\\t\\n****Upvote if u like this solution and comment if you have any query reguarding this or any question****",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Property of xor  \\n\\t1-> if we **xor** a number **even** number of time with it **self them XOR will be ZERO**;\\n\\t2-> if we **xor** a number odd number of time with itself then **xor will be same number**;\\n\\t\\n**observation**\\n\\tif n1.size() is **even** then every element into n2 will be repeated even numver of times so we will xor n2 \\n\\t**and**\\n\\tif n2.size() is even then we will xor n1 every element ;\\n\\t\\n\\t\\n**solution 1->**\\n\\n\\tint code1(v&nums1 , v&nums2)\\n    {\\n        vector<int> ans;\\n        int i=0, j=0; \\n        while(i<nums1.size() and j<nums2.size())\\n        {\\n            ans.push_back(nums1[i++]^nums2[j++]);\\n        }\\n        if(nums1.size()>nums2.size())\\n        {\\n           while(i<nums1.size()) ans.push_back(nums1[i++]);\\n        }\\n        else while(j<nums2.size()) ans.push_back(nums2[j++]);\\n        int ans = 0;\\n        for(int i=0; i<ans.size(); i++)\\n        {\\n            ans ^= ans[i];\\n        }\\n        return ans;\\n    }\\n\\t\\n**time 0(N*M)****\\n**space O(N*M)**\\n**result TLE for large test case**\\n\\n__________________________________________________________________________________________________________\\n**solution 2->**    \\n\\n    int code2(vector<int> &n1,vector<int> &n2){\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// using xor property that i expained above ;\\n        if(n1.size()%2)  for(int i=0; i<n2.size(); i++)   ans = ans^n2[i];\\n           \\n        if(n2.size()%2) for(int i=0;i<n1.size();i++) ans^=n1[i];\\n        return ans;\\n    }\\n\\t\\n**Runtime**: 453 ms, faster than **100.00% of C++** online submissions for Bitwise XOR of All Pairings\\n.\\n**Memory Usage**: 60.5 MB, less than **100.00% of C++** online submissions for Bitwise XOR of All Pairings.\\n\\t\\n****Upvote if u like this solution and comment if you have any query reguarding this or any question****",
                "codeTag": "Unknown"
            },
            {
                "id": 2652862,
                "title": "100-faster-c-6-lines-code-with-explanation",
                "content": "* \\tthe basic idea is:\\n\\t\\t\\t2 ^ 2 ^ 2 = 2  **BUT**  2 ^ 2 = 0\\n* \\tso if total frequency of a*i* is odd so add a*i* to the XOR otherwise ignore it.\\n* **Feel free to ask me if you don\\'t understand :) and upvote if you liked it**\\n-----------------------------------------------------------------------------------------\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint xorAllNums(vector<int>& num1, vector<int>& num2) \\n\\t\\t{\\n\\t\\t\\tint XOR = 0;\\n\\n\\t\\t\\tif(num2.size() & 1)\\n\\t\\t\\t\\tfor(int i = 0 ; i < num1.size() ; i++)\\n\\t\\t\\t\\t   XOR = XOR ^ num1[i];\\n\\n\\t\\t\\tif(num1.size() & 1)\\n\\t\\t\\t\\tfor(int i = 0 ; i < num2.size() ; i++)\\n\\t\\t\\t\\t   XOR = XOR ^ num2[i];\\n\\n\\t\\t\\treturn XOR;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint xorAllNums(vector<int>& num1, vector<int>& num2) \\n\\t\\t{\\n\\t\\t\\tint XOR = 0;\\n\\n\\t\\t\\tif(num2.size() & 1)\\n\\t\\t\\t\\tfor(int i = 0 ; i < num1.size() ; i++)\\n\\t\\t\\t\\t   XOR = XOR ^ num1[i];\\n\\n\\t\\t\\tif(num1.size() & 1)\\n\\t\\t\\t\\tfor(int i = 0 ; i < num2.size() ; i++)\\n\\t\\t\\t\\t   XOR = XOR ^ num2[i];\\n\\n\\t\\t\\treturn XOR;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2652679,
                "title": "basic-practice-use-basic-properties-of-xor-python",
                "content": "1- Two Solution formats\\n````\\nclass Solution:\\n    def xorAllNums_v1(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        from_nums1, from_nums2 = 0, 0\\n        m, n = len(nums1), len(nums2)\\n        \\n        if n % 2 != 0:\\n            for y in nums1:\\n                from_nums1 ^= y\\n        if m % 2 != 0:\\n            for y in nums2:\\n                from_nums2 ^= y\\n        \\n        return from_nums1 ^ from_nums2\\n    \\n    \\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        from_nums1, from_nums2 = 0, 0\\n        m, n = len(nums1), len(nums2)\\n        \\n        if n % 2 != 0:\\n            from_nums1 = reduce(lambda x, y: x ^ y, nums1)\\n        if m % 2 != 0:\\n            from_nums2 = reduce(lambda x, y: x ^ y, nums2)\\n        \\n        return from_nums1 ^ from_nums2\\n````\\n2- Video Explanation: [Video Link](https://youtu.be/YJq1-abgwnw;)\\n\\n3- Analysis or summary\\n\\nMethod: use the properties of bitwise XOR\\n\\n(Definition) 1 ^ 1 = 0 ^ 0 = 0; 1 ^ 0 = 0 ^ 1 = 1\\n\\n(1) XOR is commutative, and associate, i.e., \\n\\na ^ b = b ^ a\\na ^ b ^ c = (a ^ b) ^ c = a ^ (b ^ c)\\n\\nand \\n\\n(2) a ^ a = 0\\n\\n\\nAssume m = len(nums1), n = len(nums2). We aim to compute XOR for numbers\\n\\nXOR[nums1[i] ^ nums2[j] for 0 <= i <= m - 1 and 0 <= j <= n - 1]\\n\\nEach nums1[i] appears n times, and each nums2[j] appears m times.\\n\\nFor a nums1[i], if n is even, its contribution is 0; if n is odd, its contribution is one nums1[i].\\n\\nSame for a nums2[j].\\n\\nEx-1 nums1 = [2,1,3], nums2 = [10,2,5,0]\\nAs nums2 has length even, every number in nums1 contributes to the final res 0\\nAs nums1 has length odd, every number in nums2 contributes to the final res the number itself.\\nSo this example is to compute the XOR of all numbers in nums2.",
                "solutionTags": [],
                "code": "````\\nclass Solution:\\n    def xorAllNums_v1(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        from_nums1, from_nums2 = 0, 0\\n        m, n = len(nums1), len(nums2)\\n        \\n        if n % 2 != 0:\\n            for y in nums1:\\n                from_nums1 ^= y\\n        if m % 2 != 0:\\n            for y in nums2:\\n                from_nums2 ^= y\\n        \\n        return from_nums1 ^ from_nums2\\n    \\n    \\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        from_nums1, from_nums2 = 0, 0\\n        m, n = len(nums1), len(nums2)\\n        \\n        if n % 2 != 0:\\n            from_nums1 = reduce(lambda x, y: x ^ y, nums1)\\n        if m % 2 != 0:\\n            from_nums2 = reduce(lambda x, y: x ^ y, nums2)\\n        \\n        return from_nums1 ^ from_nums2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651619,
                "title": "java-solution-100-faster-o-n-time-o-1-space",
                "content": "```java\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor=0;\\n        if(nums2.length%2==1){\\n        for(int x:nums1)\\n            xor^=x;\\n        }\\n        if(nums1.length%2==1){\\n        for(int x:nums2)\\n            xor^=x;\\n        }\\n        return xor;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor=0;\\n        if(nums2.length%2==1){\\n        for(int x:nums1)\\n            xor^=x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2649980,
                "title": "java-one-of-the-easiest-solution-bitwise-xor-property-with-explanation",
                "content": "Question is totaly based on the XOR property, If you havent done bitmanuplation you may find this question little hard but this question is quitye simple, if you know the property of XOR.\\n\\nApproach - lets say you have one number x whose frequency is odd then x^x^x = x, and if that number frequency os even like x^x^x^x = 0;\\n\\nfollowed this approched to get the ans;\\n\\n```\\npublic int xorAllNums(int[] nums1, int[] nums2) {\\n        int ans = 0;\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        \\n        if(m % 2 !=0){\\n            for(int i=0;i<n;i++){\\n                ans ^=nums1[i];\\n            }\\n        }\\n        \\n        if(n%2!=0){\\n            for(int i=0;i<m;i++){\\n                ans^=nums2[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int xorAllNums(int[] nums1, int[] nums2) {\\n        int ans = 0;\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        \\n        if(m % 2 !=0){\\n            for(int i=0;i<n;i++){\\n                ans ^=nums1[i];\\n            }\\n        }\\n        \\n        if(n%2!=0){\\n            for(int i=0;i<m;i++){\\n                ans^=nums2[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2649558,
                "title": "java-easy-and-concise",
                "content": "The trick is to find length of both the nums and then manuplating them on based of its length. \\n\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = 0;\\n        if(nums1.length % 2 == 0 && nums2.length % 2 == 0){\\n            return 0;\\n        }\\n        if(nums2.length % 2 != 0){\\n            for(int i: nums1){\\n                xor ^= i;\\n            }\\n        }\\n        if(nums1.length % 2 != 0){\\n            for(int i: nums2){\\n                xor ^= i;\\n            }\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = 0;\\n        if(nums1.length % 2 == 0 && nums2.length % 2 == 0){\\n            return 0;\\n        }\\n        if(nums2.length % 2 != 0){\\n            for(int i: nums1){\\n                xor ^= i;\\n            }\\n        }\\n        if(nums1.length % 2 != 0){\\n            for(int i: nums2){\\n                xor ^= i;\\n            }\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649369,
                "title": "python3-math-sol-for-reference",
                "content": "# Intuition\\nXOR follows identity, associative and commutative rules. \\n\\n# Approach\\n[a,b] [c,d,e] results in the following.\\na^c ^ a^d ^ a^e ^ b^c ^ b^d b^e\\n\\nDepending on the even or odd number of the second array, number of \\'a\\' can be decided. \\n\\na^a = 0\\na^a^a = a \\n\\nThe same rule can be applied reverse from second to first array. \\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        n1 = len(nums1)%2\\n        n2 = len(nums2)%2\\n\\n        n1xor = 0 \\n        n2xor = 0 \\n        \\n        if n2 == 1:\\n            for n in nums1:\\n                n1xor ^= n\\n        \\n        if n1 == 1:\\n            for n in nums2:\\n                n2xor ^= n      \\n\\n        return n1xor ^ n2xor\\n                \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        n1 = len(nums1)%2\\n        n2 = len(nums2)%2\\n\\n        n1xor = 0 \\n        n2xor = 0 \\n        \\n        if n2 == 1:\\n            for n in nums1:\\n                n1xor ^= n\\n        \\n        if n1 == 1:\\n            for n in nums2:\\n                n2xor ^= n      \\n\\n        return n1xor ^ n2xor\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649232,
                "title": "java-100-fast-easy-explained",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        \\n        // let us take up an example and understand how to approach this problem\\n\\n        // num1 = [2,1,3], num2 = [10,2,5,0]\\n\\n        // Pairs:\\n        // (2,10),(2,2),(2,5),(2,0),\\n        // (1,10),(1,2),(1,5),(1,0),\\n        // (3,10),(3,2),(3,5),(3,0)\\n\\n        // Let us rearrange things up:\\n        // (2,2,2,2), (10,2,5,0)\\n        // (1,1,1,1), (10,2,5,0)\\n        // (3,3,3,3), (10,2,5,0)\\n\\n        // Now we know for even occurences - the xor is = 0\\n\\n        // We can now build the idea that if odd length num1 is paired with an even length num2 \\n        // Then, num2\\'s xor would be result\\n\\n        // If even length num1 is paired with odd length num2\\n        // Then, num1\\'s xor is result\\n\\n        // If even length num1 and even length num2\\n        // Then, 0\\n\\n        // If odd length num1 and odd length num2\\n        // Then (xor of num1)xor(xor of num2)\\n\\n        int len1 = nums1.length;\\n        int len2 = nums2.length;\\n\\n        int res = 0;\\n\\n        if(len1%2 != 0) // if num1 is odd\\n        {\\n            // first case\\n            for(int i=0;i<len2;i++)\\n            {\\n                res = res^nums2[i];\\n            }           \\n        }\\n\\n        if(len2%2 != 0) // if num2 is odd\\n        {\\n            // second case\\n            for(int i=0;i<len1;i++)\\n            {\\n                res = res^nums1[i];\\n            }           \\n        }\\n\\n        // fourth case: both if will run\\n        // third case: no if will execute - res = 0\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        \\n        // let us take up an example and understand how to approach this problem\\n\\n        // num1 = [2,1,3], num2 = [10,2,5,0]\\n\\n        // Pairs:\\n        // (2,10),(2,2),(2,5),(2,0),\\n        // (1,10),(1,2),(1,5),(1,0),\\n        // (3,10),(3,2),(3,5),(3,0)\\n\\n        // Let us rearrange things up:\\n        // (2,2,2,2), (10,2,5,0)\\n        // (1,1,1,1), (10,2,5,0)\\n        // (3,3,3,3), (10,2,5,0)\\n\\n        // Now we know for even occurences - the xor is = 0\\n\\n        // We can now build the idea that if odd length num1 is paired with an even length num2 \\n        // Then, num2\\'s xor would be result\\n\\n        // If even length num1 is paired with odd length num2\\n        // Then, num1\\'s xor is result\\n\\n        // If even length num1 and even length num2\\n        // Then, 0\\n\\n        // If odd length num1 and odd length num2\\n        // Then (xor of num1)xor(xor of num2)\\n\\n        int len1 = nums1.length;\\n        int len2 = nums2.length;\\n\\n        int res = 0;\\n\\n        if(len1%2 != 0) // if num1 is odd\\n        {\\n            // first case\\n            for(int i=0;i<len2;i++)\\n            {\\n                res = res^nums2[i];\\n            }           \\n        }\\n\\n        if(len2%2 != 0) // if num2 is odd\\n        {\\n            // second case\\n            for(int i=0;i<len1;i++)\\n            {\\n                res = res^nums1[i];\\n            }           \\n        }\\n\\n        // fourth case: both if will run\\n        // third case: no if will execute - res = 0\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648041,
                "title": "python-utilize-xor-commutation-runtime-980-ms-memory-usage-51-1-mb",
                "content": "For xor operations: `(a^b)^c = a^(b^c)`\\nAlso `0^a = a`, `a^a = 0`\\n```\\n        a1,    a2,    ..., ai\\nb1      a1^b1, a2^b1, ..., ai^b1     --------- (a1^a2^...^ai) ^ (b1^b1...)\\u3010for the product of the bs, if j%2==0, 0; else b1\\u3011\\nb2      a1^b2, a2^b2, ..., ai^b2     --------- (a1^a2^...^ai) ^ (b2^b2...)\\u3010for the product of the bs, if j%2==0, 0; else b2\\u3011\\n.       .      .           .\\n.       .      .           .\\n.       .      .           .\\nbj      a1^bj, a2^bj, ..., ai^bj     --------- (a1^a2^...^ai) ^ (bj^bj...)\\u3010for the product of the bs, if j%2==0, 0; else bj\\u3011\\n```\\nAll together if both `i` and `j` are even, return 0^0=0.\\nIf only `j` is even, return `a1^a2^...^ai`.\\nSimilarly if only `i` is even, return `b1^b2^...^bj`.\\nIf both `i` and `j` are odd, return `(a1^a2^...^ai) ^ (b1^b2^...^bj)`.\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        x1, x2 = 0, 0\\n        if len(nums2)%2: \\n            for n in nums1:\\n                x1 ^= n\\n        if len(nums1)%2:\\n            for n in nums2:\\n                x2 ^= n   \\n        return x1^x2\\n```\\n\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        a1,    a2,    ..., ai\\nb1      a1^b1, a2^b1, ..., ai^b1     --------- (a1^a2^...^ai) ^ (b1^b1...)\\u3010for the product of the bs, if j%2==0, 0; else b1\\u3011\\nb2      a1^b2, a2^b2, ..., ai^b2     --------- (a1^a2^...^ai) ^ (b2^b2...)\\u3010for the product of the bs, if j%2==0, 0; else b2\\u3011\\n.       .      .           .\\n.       .      .           .\\n.       .      .           .\\nbj      a1^bj, a2^bj, ..., ai^bj     --------- (a1^a2^...^ai) ^ (bj^bj...)\\u3010for the product of the bs, if j%2==0, 0; else bj\\u3011\\n```\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        x1, x2 = 0, 0\\n        if len(nums2)%2: \\n            for n in nums1:\\n                x1 ^= n\\n        if len(nums1)%2:\\n            for n in nums2:\\n                x2 ^= n   \\n        return x1^x2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647850,
                "title": "explanation-xor-property-easy",
                "content": "Using xor property:\\n* If isEven(nums1.length) && isEven(nums2.length):\\n\\t* return true;\\n* else if isEven(nums1.length) && isOdd(nums2.length):\\n\\t* return xor of all elements of nums1;\\n* else if isOdd(nums1.length) && isEven(nums2.length):\\n\\t* return xor of all elements of nums2;\\n* else if isOdd(nums1.length) && isOdd(nums2.length):\\n\\t* return xor of all elements of nums1 and nums2;\\n\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = 0;\\n        if(!isEven(nums1.length)) {\\n            for(int num : nums2) {\\n                xor ^= num;\\n            }\\n        } \\n        if(!isEven(nums2.length)) {\\n            for(int num : nums1) {\\n                xor ^= num;\\n            }\\n        } \\n        \\n        return xor;\\n    }\\n    \\n    private boolean isEven(int n) {\\n        return n%2==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = 0;\\n        if(!isEven(nums1.length)) {\\n            for(int num : nums2) {\\n                xor ^= num;\\n            }\\n        } \\n        if(!isEven(nums2.length)) {\\n            for(int num : nums1) {\\n                xor ^= num;\\n            }\\n        } \\n        \\n        return xor;\\n    }\\n    \\n    private boolean isEven(int n) {\\n        return n%2==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647849,
                "title": "java-faster-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res1=1;\\n        int res2=1;\\n        if(nums2.length%2==0){\\n            res1=1;\\n        }\\n        else{\\n            for(int i=0; i<nums1.length; i++){\\n                res1=res1^nums1[i];\\n            }\\n        }\\n        if(nums1.length%2==0){\\n            res2=1;\\n        }\\n        else{\\n            for(int i=0; i<nums2.length; i++){\\n                res2=res2^nums2[i];\\n            }\\n        }\\n        return res2^res1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res1=1;\\n        int res2=1;\\n        if(nums2.length%2==0){\\n            res1=1;\\n        }\\n        else{\\n            for(int i=0; i<nums1.length; i++){\\n                res1=res1^nums1[i];\\n            }\\n        }\\n        if(nums1.length%2==0){\\n            res2=1;\\n        }\\n        else{\\n            for(int i=0; i<nums2.length; i++){\\n                res2=res2^nums2[i];\\n            }\\n        }\\n        return res2^res1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647562,
                "title": "java-100-faster-easiest-map",
                "content": "**Hi Family**\\n\\nI put the proper comment in the code \\n\\n```\\n\\tpublic int xorAllNums(int[] nums1, int[] nums2) {\\n        int m = nums1.length;\\n        int n = nums2.length;\\n        \\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        \\n        /*\\n\\t    *                              Intution\\n        *   same no of xor is zero like :-    6^6 = 0, 8^8 = 0\\n        *   x = [2,1,3] and y = [10,2,5,0]\\n        *   xor with every no. :- ( (2^10) ^ (2^2) ^  (2^5) ^ (2^0) ) ^ // first pair\\n        *                         ( (1^10) ^ (1^2) ^ (1^5) ^ (1^0) ) ^  // second pair\\n        *                         ( (3^10) ^ (3^2) ^ (3^5) ^ (3^0) )    // third pair\\n        *\\n        *   combine all the pairs:- \\n        *   (1 ^ 1 ^ 1 ^ 1) ^ (2 ^ 2 ^ 2 ^ 2 ^ 2 ^ 2 ^ 2) ^ (3 ^ 3 ^ 3 ^ 3) ^ (5 ^ 5 ^ 5) ^ (10 ^ 10 ^ 10)\\n        *    - > all the even number become 0\\n        *    - > all the odd numbers become single number like (2 ^ 2 ^ 2) -> ((2 ^ 2) ^ 2) -> 2\\n        *   \\n        *   last step find the xor of all the odd numbers :- 2 ^ 5 ^ 10 = 13 ans\\n        *\\n        */\\n        \\n        for(int i = 0; i < m; i++) {\\n\\t        if (hm.containsKey(nums1[i])) hm.put(nums1[i],hm.get(nums1[i]) + n);\\n            else hm.put(nums1[i],n);\\n\\t    }\\n\\t        \\n\\t    for(int i = 0; i < n; i++) {\\n\\t        if (hm.containsKey(nums2[i])) hm.put(nums2[i],hm.get(nums2[i]) + m);\\n            else hm.put(nums2[i],m);\\n\\t    }\\n        \\n        int xor = 0;\\n        for (Map.Entry<Integer,Integer> map:hm.entrySet()){\\n            if (map.getValue() % 2 != 0){\\n                xor ^= map.getKey();\\n            }\\n        }\\n        return xor;\\n    }\\n```\\n\\nIf you liked the Approach, Please Please Please upvote\\nThanks !!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int xorAllNums(int[] nums1, int[] nums2) {\\n        int m = nums1.length;\\n        int n = nums2.length;\\n        \\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        \\n        /*\\n\\t    *                              Intution\\n        *   same no of xor is zero like :-    6^6 = 0, 8^8 = 0\\n        *   x = [2,1,3] and y = [10,2,5,0]\\n        *   xor with every no. :- ( (2^10) ^ (2^2) ^  (2^5) ^ (2^0) ) ^ // first pair\\n        *                         ( (1^10) ^ (1^2) ^ (1^5) ^ (1^0) ) ^  // second pair\\n        *                         ( (3^10) ^ (3^2) ^ (3^5) ^ (3^0) )    // third pair\\n        *\\n        *   combine all the pairs:- \\n        *   (1 ^ 1 ^ 1 ^ 1) ^ (2 ^ 2 ^ 2 ^ 2 ^ 2 ^ 2 ^ 2) ^ (3 ^ 3 ^ 3 ^ 3) ^ (5 ^ 5 ^ 5) ^ (10 ^ 10 ^ 10)\\n        *    - > all the even number become 0\\n        *    - > all the odd numbers become single number like (2 ^ 2 ^ 2) -> ((2 ^ 2) ^ 2) -> 2\\n        *   \\n        *   last step find the xor of all the odd numbers :- 2 ^ 5 ^ 10 = 13 ans\\n        *\\n        */\\n        \\n        for(int i = 0; i < m; i++) {\\n\\t        if (hm.containsKey(nums1[i])) hm.put(nums1[i],hm.get(nums1[i]) + n);\\n            else hm.put(nums1[i],n);\\n\\t    }\\n\\t        \\n\\t    for(int i = 0; i < n; i++) {\\n\\t        if (hm.containsKey(nums2[i])) hm.put(nums2[i],hm.get(nums2[i]) + m);\\n            else hm.put(nums2[i],m);\\n\\t    }\\n        \\n        int xor = 0;\\n        for (Map.Entry<Integer,Integer> map:hm.entrySet()){\\n            if (map.getValue() % 2 != 0){\\n                xor ^= map.getKey();\\n            }\\n        }\\n        return xor;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647469,
                "title": "java-lazy-loading-o-n-m-solution",
                "content": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        \\n        int m = nums1.length;\\n        int n = nums2.length;\\n        \\n        int xor = 0;\\n        \\n        if(n % 2 != 0) {\\n            for(int i : nums1) {\\n                xor ^= i;\\n            }\\n        }\\n        \\n        if(m % 2 != 0) {\\n            for(int i : nums2) {\\n                xor ^= i;\\n            }\\n        }\\n        \\n        return xor;\\n    }\\n}   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        \\n        int m = nums1.length;\\n        int n = nums2.length;\\n        \\n        int xor = 0;\\n        \\n        if(n % 2 != 0) {\\n            for(int i : nums1) {\\n                xor ^= i;\\n            }\\n        }\\n        \\n        if(m % 2 != 0) {\\n            for(int i : nums2) {\\n                xor ^= i;\\n            }\\n        }\\n        \\n        return xor;\\n    }\\n}   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647402,
                "title": "o-n-using-checking-odd-and-even-attributes-of-length-array-examples",
                "content": "***Main Idea***:\\n+ XOR attribute: a ^ a = 0, a ^ a ^ a = a\\n+ Counting odd and even attributes of the number of occuring every elements in nums1 and nums2\\n  + nums1[i] occurs n2 times \\n  + nums2[i] occurs n1 times\\n+ Calculating ans as follow:\\n  + ans1 <- xor(all nums1[i]) if n2%1==1 or 0\\n  + ans2 <- xor(all nums2[i]) if n1%1==1 or 0  \\n  + ans <- ans1 xor ans2\\n\\n**Examples**:\\n```\\nExampe1: nums1 = [2,1,3], nums2 = [10,2,5,0]\\nn2 = 4: ans1 = 0\\nn1 = 3: ans2 = 10 ^ 2 ^ 5 ^ 0 = 13\\nans = ans1 ^ ans2 = 0 ^ 13 = 13\\n\\nExample 2: nums1 = [1,2], nums2 = [3,4]\\nn2 = 2: ans1 = 0\\nn1 = 2: ans2 = 0\\nans = ans1 ^ ans2 = 0 ^ 0 = 0\\n```\\n\\n**Code**:\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n#         nums3 = []\\n#         for n1 in nums1:\\n#             for n2 in nums2:\\n#                 nums3.append(n1 ^ n2)\\n                \\n#         ans1 = 0\\n#         for i in range(len(nums3)):\\n#             ans1 = ans1 ^ nums3[i]\\n        \\n        n1, n2 = len(nums1), len(nums2)\\n        ans = 0\\n        if n2%2==1:\\n            for i in range(n1):\\n                ans = ans ^ nums1[i]\\n        \\n        if n1%2==1:\\n            for i in range(n2):\\n                ans = ans ^ nums2[i]\\n        \\n        # print(ans1, ans)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nExampe1: nums1 = [2,1,3], nums2 = [10,2,5,0]\\nn2 = 4: ans1 = 0\\nn1 = 3: ans2 = 10 ^ 2 ^ 5 ^ 0 = 13\\nans = ans1 ^ ans2 = 0 ^ 13 = 13\\n\\nExample 2: nums1 = [1,2], nums2 = [3,4]\\nn2 = 2: ans1 = 0\\nn1 = 2: ans2 = 0\\nans = ans1 ^ ans2 = 0 ^ 0 = 0\\n```\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n#         nums3 = []\\n#         for n1 in nums1:\\n#             for n2 in nums2:\\n#                 nums3.append(n1 ^ n2)\\n                \\n#         ans1 = 0\\n#         for i in range(len(nums3)):\\n#             ans1 = ans1 ^ nums3[i]\\n        \\n        n1, n2 = len(nums1), len(nums2)\\n        ans = 0\\n        if n2%2==1:\\n            for i in range(n1):\\n                ans = ans ^ nums1[i]\\n        \\n        if n1%2==1:\\n            for i in range(n2):\\n                ans = ans ^ nums2[i]\\n        \\n        # print(ans1, ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647321,
                "title": "java-3-approaches-easy",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n##### 1. Brute force approach: \\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = 0;\\n\\n        for (int i : nums1) {\\n            for (int j : nums2) {\\n                xor ^= (i ^ j);\\n            }\\n        }\\n\\n        return xor;\\n    }\\n}\\n\\n// TC: O(n * m)\\n```\\n##### 2. An optimal + time consuming approach:\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n\\n        int xor1 = 0 , xor2 = 0;\\n\\n        for (int i : nums1) xor1 ^= i;\\n        for (int i : nums2) xor2 ^= i;\\n\\n        int ans = 0;\\n\\n        if (n % 2 == 1 && m % 2 == 0)  ans = xor2;\\n        else if (n % 2 == 0 && m % 2 == 1) ans = xor1;\\n        else if (n % 2 == 0 && m % 2 == 0) ans = 0;\\n        else ans = xor1 ^ xor2 ;\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n + m)\\n```\\n##### 3. Optimal approach:\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = 0;\\n\\n        if (nums1.length % 2 != 0) {\\n            for (int n : nums2) xor ^= n;\\n        }\\n\\n        if (nums2.length % 2 != 0) {\\n            for (int n : nums1) xor ^= n;\\n        }\\n\\n        return xor;\\n    }\\n}\\n\\n// TC: O(n + m)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = 0;\\n\\n        for (int i : nums1) {\\n            for (int j : nums2) {\\n                xor ^= (i ^ j);\\n            }\\n        }\\n\\n        return xor;\\n    }\\n}\\n\\n// TC: O(n * m)\\n```\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n\\n        int xor1 = 0 , xor2 = 0;\\n\\n        for (int i : nums1) xor1 ^= i;\\n        for (int i : nums2) xor2 ^= i;\\n\\n        int ans = 0;\\n\\n        if (n % 2 == 1 && m % 2 == 0)  ans = xor2;\\n        else if (n % 2 == 0 && m % 2 == 1) ans = xor1;\\n        else if (n % 2 == 0 && m % 2 == 0) ans = 0;\\n        else ans = xor1 ^ xor2 ;\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n + m)\\n```\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = 0;\\n\\n        if (nums1.length % 2 != 0) {\\n            for (int n : nums2) xor ^= n;\\n        }\\n\\n        if (nums2.length % 2 != 0) {\\n            for (int n : nums1) xor ^= n;\\n        }\\n\\n        return xor;\\n    }\\n}\\n\\n// TC: O(n + m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647285,
                "title": "c-solution-with-explanation",
                "content": "# Intuition\\nXOR of any number with itself equals 0\\nXOR of any number with 0 equals the number\\nA XOR A = 0\\nA XOR 0 = A\\n\\n# Approach\\nthere are 3 cases\\n\\n1.\\nif both vectors have even number of elements the result will be 0\\n\\n2.\\nif one of them have even number of elements and the other odd then the result will be the XOR of the even vector\\n\\n3.\\nboth of them have odd number of elements then the result is the XOR of both of them\\n\\n# Complexity\\n- Time complexity:\\nworst case O(n+m) // case 3\\nbest case O(1) // case 1\\naverage O(n) // case 2 given n is the number of even elements\\n\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if (nums1.size() % 2 == 0 && nums2.size() % 2 == 0) {\\n            return 0;\\n        }\\n        int x = 0;\\n        if (nums1.size() % 2 == 0) {\\n            for (auto y : nums1) {\\n                x = x ^ y;\\n            }\\n        }\\n        else if (nums2.size()%2==0){\\n            for (auto y : nums2) {\\n                x = x ^ y;\\n            }\\n        }\\n        else {\\n            for (auto y : nums2) {\\n                x = x ^ y;\\n            }\\n            for (auto y : nums1) {\\n                x = x ^ y;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if (nums1.size() % 2 == 0 && nums2.size() % 2 == 0) {\\n            return 0;\\n        }\\n        int x = 0;\\n        if (nums1.size() % 2 == 0) {\\n            for (auto y : nums1) {\\n                x = x ^ y;\\n            }\\n        }\\n        else if (nums2.size()%2==0){\\n            for (auto y : nums2) {\\n                x = x ^ y;\\n            }\\n        }\\n        else {\\n            for (auto y : nums2) {\\n                x = x ^ y;\\n            }\\n            for (auto y : nums1) {\\n                x = x ^ y;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647268,
                "title": "easiest-cleanest-best-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## **Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int size1=nums1.size(),size2=nums2.size(),check1,check2,ans=0;\\n        if((size1 & 1))\\n            check1=1;   //Initializing odd size with 1 & even size with 0\\n        else\\n            check1=0;\\n        if((size2 & 1))\\n            check2=1;\\n        else\\n            check2=0;\\n        if(check1==0 && check2==0)  //If both arrays size are even then the bitwise xor of all their pairs would cancel each other to zero\\n            return 0;\\n        else if(check1==1 && check2==1){\\n            for(auto it:nums1)\\n                ans^=it;\\n            for(auto it:nums2)\\n                ans^=it;\\n        }\\n        else if(check1==0){  //If ONLY nums1 size is even then in final xor only nums1 elements would remain present while nums2 elements would cancel each other as we know that xor of same elements cancel each other \\n            for(auto it:nums1)\\n                ans^=it;\\n        }\\n        else{\\n            for(auto it:nums2)\\n                ans^=it;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n## **For better clearance dry run the code & read my steps properly then u will get it perfectly\\uD83D\\uDE42**\\n**Happy LeetCoding**\\uD83D\\uDCAF\\n**Please UPvote**\\uD83D\\uDE42\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int size1=nums1.size(),size2=nums2.size(),check1,check2,ans=0;\\n        if((size1 & 1))\\n            check1=1;   //Initializing odd size with 1 & even size with 0\\n        else\\n            check1=0;\\n        if((size2 & 1))\\n            check2=1;\\n        else\\n            check2=0;\\n        if(check1==0 && check2==0)  //If both arrays size are even then the bitwise xor of all their pairs would cancel each other to zero\\n            return 0;\\n        else if(check1==1 && check2==1){\\n            for(auto it:nums1)\\n                ans^=it;\\n            for(auto it:nums2)\\n                ans^=it;\\n        }\\n        else if(check1==0){  //If ONLY nums1 size is even then in final xor only nums1 elements would remain present while nums2 elements would cancel each other as we know that xor of same elements cancel each other \\n            for(auto it:nums1)\\n                ans^=it;\\n        }\\n        else{\\n            for(auto it:nums2)\\n                ans^=it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647255,
                "title": "java-easy-to-understand",
                "content": "```\\n\\n    //Runtime: 5 ms, faster than 100.00% of Java online submissions for Bitwise XOR of All Pairings.\\n    //Memory Usage: 85.5 MB, less than 100.00% of Java online submissions for Bitwise XOR of All Pairings.\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res = 0;\\n        if (nums2.length % 2 != 0)\\n            for (int num : nums1) res = res ^ num;\\n\\n        if (nums1.length % 2 != 0)\\n            for (int num : nums2) res = res ^ num;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    //Runtime: 5 ms, faster than 100.00% of Java online submissions for Bitwise XOR of All Pairings.\\n    //Memory Usage: 85.5 MB, less than 100.00% of Java online submissions for Bitwise XOR of All Pairings.\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res = 0;\\n        if (nums2.length % 2 != 0)\\n            for (int num : nums1) res = res ^ num;\\n\\n        if (nums1.length % 2 != 0)\\n            for (int num : nums2) res = res ^ num;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647144,
                "title": "c-bit-manipulation",
                "content": "* We need to use the xor property that ** xor of  a number with itself is zero .**\\n* We will use the above property to find the contribution of each bit in the final answer.\\n\\n* Let suppose the size of array A be n and array B be m.\\n* There are 4 cases for n and m i.e.\\n* If both n and m are even => In this case every number in array A will contribute even times (array C is created by xoring every element of A with array B elements). Same goes for array B elements they will also contribute even times. So overall xor is zero.\\n* If one is odd and other is even.In this case even sized array elements will contribute to answer.\\n* If both n and m is odd.Both array elements contribute to answer.\\n\\nFor calculating the contribution of every element we will strore its   ** contribution bitwise**\\n\\nAfter storing contribution bitwise we will check if the bit occurs overall even or odd times. If it is even it will cancel out each other else if odd will contribute .\\n\\nFor example 2^2=0  and 2^2^2=2;\\n\\n```\\nclass Solution {\\npublic:\\n        long long power(long long n)   // function to calculate 2^n \\n        {\\n                long long ans=1;\\n                for(int i=1;i<=n;i++)\\n                        ans*=2;\\n                return ans;\\n        }\\n    long long xorAllNums(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<long long> bits(32,0);                     // vector for storing each bit frequency \\n         int n=nums1.size(),m=nums2.size();         // size of vectors nums1 and nums2\\n\\t\\t \\n         for(auto it:nums1)                         //for every number N in vector nums1\\n         {\\n                 for(int i=0;i<32;i++)             //for every bit B in number N\\n                 {\\n                         if(it>>i&1)                  //  if the bit is set  it will contribute m times i,.e size of nums2 \\n                         {\\n                                 bits[i]+=m;                 \\n                         }\\n                 }\\n         } \\n\\t\\t \\n\\t\\t \\n            for(auto it:nums2)                       //for every number N in vector nums2\\n         {\\n                 for(int i=0;i<32;i++)              //for every bit B in number N\\n                 {\\n                         if(it>>i&1)\\n                         {                                    //  if the bit is set  it will contribute n times i,.e size of nums1\\n                                 bits[i]+=n;\\n                         }\\n                 }\\n         }\\n            \\n            long long ans=0;\\n            for(int i=0;i<32;i++)\\n            {\\n                    if(bits[i]&1)                              // if overall contribution of bit is odd it will count in final ans\\n                    {                                                 \\n                            ans+=power(i);             // calculating 2 raised to power i (bit value in decimal) \\n                    }\\n            }\\n            return ans;                           \\n            \\n            \\n            \\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n        long long power(long long n)   // function to calculate 2^n \\n        {\\n                long long ans=1;\\n                for(int i=1;i<=n;i++)\\n                        ans*=2;\\n                return ans;\\n        }\\n    long long xorAllNums(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        vector<long long> bits(32,0);                     // vector for storing each bit frequency \\n         int n=nums1.size(),m=nums2.size();         // size of vectors nums1 and nums2\\n\\t\\t \\n         for(auto it:nums1)                         //for every number N in vector nums1\\n         {\\n                 for(int i=0;i<32;i++)             //for every bit B in number N\\n                 {\\n                         if(it>>i&1)                  //  if the bit is set  it will contribute m times i,.e size of nums2 \\n                         {\\n                                 bits[i]+=m;                 \\n                         }\\n                 }\\n         } \\n\\t\\t \\n\\t\\t \\n            for(auto it:nums2)                       //for every number N in vector nums2\\n         {\\n                 for(int i=0;i<32;i++)              //for every bit B in number N\\n                 {\\n                         if(it>>i&1)\\n                         {                                    //  if the bit is set  it will contribute n times i,.e size of nums1\\n                                 bits[i]+=n;\\n                         }\\n                 }\\n         }\\n            \\n            long long ans=0;\\n            for(int i=0;i<32;i++)\\n            {\\n                    if(bits[i]&1)                              // if overall contribution of bit is odd it will count in final ans\\n                    {                                                 \\n                            ans+=power(i);             // calculating 2 raised to power i (bit value in decimal) \\n                    }\\n            }\\n            return ans;                           \\n            \\n            \\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647101,
                "title": "python-made-easy-xor-trick-explained",
                "content": "Properties:\\n**x ^ x = 0**\\n**x ^ 0 = x**\\n\\nWhen you form pairs of elements in X with Y and if Y has even length, then all elements in X appears even number of times in the ans. When they appear even number of times, they become 0.\\n\\nWhen Y has odd number of elements, the elements in X appear odd number of times e.g. x ^ x ^ x = x. So only x remains. So you only need to consider x once.\\n\\nComment if something needs improvement. **Upvote if you like the solution :)**\\n\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1) % 2 == 0 and len(nums2) % 2 == 0:\\n            return 0\\n        elif len(nums1) % 2 and len(nums2) % 2:\\n            ans = 0\\n            \\n            for n in nums1:\\n                ans ^= n\\n            for n in nums2:\\n                ans ^= n\\n            \\n            return ans\\n        elif len(nums1) % 2 == 1:\\n            ans = 0\\n            \\n            for n in nums2:\\n                ans ^= n\\n                \\n            return ans\\n        else:\\n            ans = 0\\n            \\n            for n in nums1:\\n                ans ^= n\\n                \\n            return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1) % 2 == 0 and len(nums2) % 2 == 0:\\n            return 0\\n        elif len(nums1) % 2 and len(nums2) % 2:\\n            ans = 0\\n            \\n            for n in nums1:\\n                ans ^= n\\n            for n in nums2:\\n                ans ^= n\\n            \\n            return ans\\n        elif len(nums1) % 2 == 1:\\n            ans = 0\\n            \\n            for n in nums2:\\n                ans ^= n\\n                \\n            return ans\\n        else:\\n            ans = 0\\n            \\n            for n in nums1:\\n                ans ^= n\\n                \\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647091,
                "title": "java-solution-using-bit-manipulation",
                "content": "> # Intuition\\nLook at Problem it just ask to do XOR. I try to solve this problem using Bit Manipulation Logic.\\n\\n> # Approach\\nIam considering 4 different senerios for solving this question.\\n1. **When the length of nums1 is even and nums2 is even too:**\\n    a) we know if both are even then utimately equal to zero.\\n    b) Ex - nums1 = [7,8] and nums2 = [3,4].\\n    c) Now, we xor of nums1 is 15 and nums2 is 7.\\n    d) But if try to map each value of nums1 to nums2 in xor we get 0, Since the length is zero.\\n\\n2. **When the length of nums1 is even and nums2 is odd:**\\n    a) It is clear that after mapping nums1 xor value to nums2 xor.\\n    b) we get value equal to nums1 xor.Since nums1 is even length.\\n\\n3. **When the length of nums2 is even and nums1 is odd:**\\n    a) It is clear that after mapping nums1 xor value to nums2 xor.\\n    b) we get value equal to nums2 xor.Since nums2 is even length.\\n\\n4. **When the length of nums1 is odd and nums2 is odd too:**\\n    a) It is clear that after mapping nums1 xor value to nums2 xor.\\n    b) we get value equal to xor of nums1 xor and nums2 xor value.  \\n    c) Since both nums1 and nums2 are odd length;\\n\\n> # Complexity\\n- Time complexity:\\nO(n + m) \\n\\n- Space complexity:\\nO(constant)\\n> **Hope you understood the logic. Upvote if you like the solution :)**\\n\\n> # JAVA Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor1 = 0,xor2 = 0;\\n        for(int val: nums1){\\n            xor1 ^= val;\\n        }\\n        for(int val: nums2){\\n            xor2 ^= val;\\n        }\\n        if(nums1.length % 2 == 0 && nums2.length % 2 == 0){\\n            return 0;\\n        } else if(nums1.length % 2 == 0 && nums2.length % 2 == 1){\\n            return xor1;\\n        } else if(nums1.length % 2 == 1 && nums2.length % 2 == 0){\\n            return xor2;\\n        } else{\\n            return xor1 ^ xor2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor1 = 0,xor2 = 0;\\n        for(int val: nums1){\\n            xor1 ^= val;\\n        }\\n        for(int val: nums2){\\n            xor2 ^= val;\\n        }\\n        if(nums1.length % 2 == 0 && nums2.length % 2 == 0){\\n            return 0;\\n        } else if(nums1.length % 2 == 0 && nums2.length % 2 == 1){\\n            return xor1;\\n        } else if(nums1.length % 2 == 1 && nums2.length % 2 == 0){\\n            return xor2;\\n        } else{\\n            return xor1 ^ xor2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647064,
                "title": "c-solution-o-m-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\n`O(m+n)` -> \\n`m` is the length of array `nums1`\\n`n` is the length of array `nums2`\\n\\n- Space complexity:\\n`O(1)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int xorAllNums(const vector<int>& nums1, const vector<int>& nums2) {\\n        int ret = 0;\\n        if (size(nums1) & 1)\\n            ret ^= reduce(begin(nums2), end(nums2), 0, bit_xor());\\n        if (size(nums2) & 1)\\n            ret ^= reduce(begin(nums1), end(nums1), 0, bit_xor());\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int xorAllNums(const vector<int>& nums1, const vector<int>& nums2) {\\n        int ret = 0;\\n        if (size(nums1) & 1)\\n            ret ^= reduce(begin(nums2), end(nums2), 0, bit_xor());\\n        if (size(nums2) & 1)\\n            ret ^= reduce(begin(nums1), end(nums1), 0, bit_xor());\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647056,
                "title": "c-solution-constant-space-solution",
                "content": "```\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int one = nums2.size();\\n        int two = nums1.size();\\n        int xor_one = 0;\\n        int xor_two = 0;\\n        if(one%2!=0){\\n            for(int i=0;i<two;i++) xor_one^=nums1[i];\\n        }\\n        if(two%2!=0){\\n            for(int i=0;i<one;i++) xor_two^=nums2[i];\\n        }\\n        return xor_one^xor_two;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int one = nums2.size();\\n        int two = nums1.size();\\n        int xor_one = 0;\\n        int xor_two = 0;\\n        if(one%2!=0){\\n            for(int i=0;i<two;i++) xor_one^=nums1[i];\\n        }\\n        if(two%2!=0){\\n            for(int i=0;i<one;i++) xor_two^=nums2[i];\\n        }\\n        return xor_one^xor_two;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647018,
                "title": "easy-solution-only-handle-3-cases",
                "content": "Only three Cases are possible:\\n1. Both array are of even size : xor will be zero\\n2. Both array are of odd size : overall xor will be the individual xor of both arrays ( x1 ^ x2)\\n3. One is even size other is odd : xor will be the xor of only even sized array  \\n```\\n int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\t // check for case 1\\n        if((nums1.size() % 2 == 0) && (nums2.size() % 2 == 0)) return 0;\\n        int firstXor = 0;\\n        int secondXor = 0;\\n        for(auto &num : nums1){\\n            firstXor ^= num;\\n        }\\n        for(int &num : nums2){\\n            secondXor ^= num;\\n        }\\n\\t\\t// check for case 2\\n        if((nums1.size() % 2 != 0) && (nums2.size() % 2 != 0)) return (firstXor ^ secondXor);\\n\\t\\t// return even sized array xor\\n        return (nums1.size() % 2 != 0) ? secondXor : firstXor;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\t // check for case 1\\n        if((nums1.size() % 2 == 0) && (nums2.size() % 2 == 0)) return 0;\\n        int firstXor = 0;\\n        int secondXor = 0;\\n        for(auto &num : nums1){\\n            firstXor ^= num;\\n        }\\n        for(int &num : nums2){\\n            secondXor ^= num;\\n        }\\n\\t\\t// check for case 2\\n        if((nums1.size() % 2 != 0) && (nums2.size() % 2 != 0)) return (firstXor ^ secondXor);\\n\\t\\t// return even sized array xor\\n        return (nums1.size() % 2 != 0) ? secondXor : firstXor;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646975,
                "title": "swift-solution-using-reduce-function",
                "content": "```\\nclass Solution {\\n    func xorAllNums(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        if nums1.count.isMultiple(of: 2), nums2.count.isMultiple(of: 2) {\\n            return 0\\n        } else if nums1.count.isMultiple(of: 2) {\\n            return nums1.reduce(0, ^)\\n        } else if nums2.count.isMultiple(of: 2) {\\n            return nums2.reduce(0, ^)\\n        } else {\\n            return nums2.reduce(0, ^) ^ nums1.reduce(0, ^)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func xorAllNums(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        if nums1.count.isMultiple(of: 2), nums2.count.isMultiple(of: 2) {\\n            return 0\\n        } else if nums1.count.isMultiple(of: 2) {\\n            return nums1.reduce(0, ^)\\n        } else if nums2.count.isMultiple(of: 2) {\\n            return nums2.reduce(0, ^)\\n        } else {\\n            return nums2.reduce(0, ^) ^ nums1.reduce(0, ^)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646854,
                "title": "c-xor-basic-concept-easy",
                "content": "Concept used:- \\n**XOR of even times of a number is zero (0);\\nXOR of odd times of a number is number itself;**\\nhere,\\nn=nums1.size() and m=nums2.size();\\n\\n**case 1:** when n and m is even\\nsuppose nums1={a,b}, nums2={c,d}\\ntaking xor => {a^c,a^d,b^c,b^d }\\nfinally taking xor of all => {a^c^a^d^b^c^b^d}     ------ (1)\\nwe know that x^x=0(even times xor with self = 0)\\nNow, (1) becomes => {a^a^b^b^c^c^d^d} => {0^0^0^0} =0\\n**RESULT(case 1) =0;**\\n\\n**case 2 :** when both are odd\\nLet\\'s x1= xor of all elements of nums1, x2=xor of all elements of nums2\\nsuppose nums1={a}, nums2={c} (you can deduce by yourself, I am taking the easier one , take nums1={a,b,c}, nums2={d,e,f}  and solve it)\\ntaking xor => {a^c}\\n**RESULT (case 2) = (x1 ^x2)**\\n**\\n\\nCase 3/4:** when one of them is odd and other is even\\nnums1={a,b,c}, nums2={d,e} \\nHere, all terms of nums1 comes even times(m times) in final xorr => so, we can take them as zero\\nAnd, all terms of nums2 comes odd times(n times) => so, we can take odd=(even+1) => 1 times x2\\nx1=a^b^c, x2=d^e\\n**\\n**RESULT(CASE 3/4) = x2(if m is even) , = x1 (if n is even)**\\n\\n```\\nclass Solution {\\npublic:\\n    int xx(vector<int> &nums){ //calculating xor of all elements\\n        int x=0;\\n        for(auto it:nums)x^=it;\\n        return x;\\n    }\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int x1=xx(nums1), x2=xx(nums2);\\n        int n=nums1.size(), m=nums2.size();\\n        if(n%2==0 && m%2==0)return 0; //both even\\n        else if(n%2 && m%2==0){ // odd,even\\n            return x2;\\n        }\\n        else if(n%2==0 && m%2){ // even,odd\\n            return x1;\\n        }\\n        return (x1^x2); // odd,odd\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xx(vector<int> &nums){ //calculating xor of all elements\\n        int x=0;\\n        for(auto it:nums)x^=it;\\n        return x;\\n    }\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int x1=xx(nums1), x2=xx(nums2);\\n        int n=nums1.size(), m=nums2.size();\\n        if(n%2==0 && m%2==0)return 0; //both even\\n        else if(n%2 && m%2==0){ // odd,even\\n            return x2;\\n        }\\n        else if(n%2==0 && m%2){ // even,odd\\n            return x1;\\n        }\\n        return (x1^x2); // odd,odd\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646818,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int xorAllNums(vector<int> &nums1, vector<int> &nums2)\\n        {\\n            int sum = 0;\\n            int n, m;\\n            n = nums1.size();\\n            m = nums2.size();\\n            if (n % 2 == 0 && m % 2 == 0)\\n            {\\n                return 0;\\n            }\\n            if (n % 2 == 1 && m % 2 == 1)\\n            {\\n                for (int i = 0; i < m; i++)\\n                {\\n                    sum ^= nums2[i];\\n                }\\n                for (int i = 0; i < n; i++)\\n                {\\n                    sum ^= nums1[i];\\n                }\\n                return sum;\\n            }\\n            if (n % 2 == 0 && m % 2 == 1)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    sum ^= nums1[i];\\n                }\\n                return sum;\\n            }\\n            for (int i = 0; i < m; i++)\\n            {\\n                sum ^= nums2[i];\\n            }\\n            return sum;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int xorAllNums(vector<int> &nums1, vector<int> &nums2)\\n        {\\n            int sum = 0;\\n            int n, m;\\n            n = nums1.size();\\n            m = nums2.size();\\n            if (n % 2 == 0 && m % 2 == 0)\\n            {\\n                return 0;\\n            }\\n            if (n % 2 == 1 && m % 2 == 1)\\n            {\\n                for (int i = 0; i < m; i++)\\n                {\\n                    sum ^= nums2[i];\\n                }\\n                for (int i = 0; i < n; i++)\\n                {\\n                    sum ^= nums1[i];\\n                }\\n                return sum;\\n            }\\n            if (n % 2 == 0 && m % 2 == 1)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    sum ^= nums1[i];\\n                }\\n                return sum;\\n            }\\n            for (int i = 0; i < m; i++)\\n            {\\n                sum ^= nums2[i];\\n            }\\n            return sum;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646785,
                "title": "python-xor-operation-easy-solution",
                "content": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        l1 = len(nums1)\\n        l2 = len(nums2)\\n        a1 = 0\\n        a2 = 0\\n        if l1%2 != 0:\\n            for i in nums2:\\n                a1 ^= i\\n        if l2%2 != 0:\\n            for i in nums1:\\n                a2 ^= i\\n        # for i in nums3:\\n            \\n        return a2^a1\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        l1 = len(nums1)\\n        l2 = len(nums2)\\n        a1 = 0\\n        a2 = 0\\n        if l1%2 != 0:\\n            for i in nums2:\\n                a1 ^= i\\n        if l2%2 != 0:\\n            for i in nums1:\\n                a2 ^= i\\n        # for i in nums3:\\n            \\n        return a2^a1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646735,
                "title": "simplest-solution-o-n",
                "content": "\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int ans = 0;\\n        if(m%2){\\n            for(auto i:nums1){\\n                ans = ans ^ i;\\n            }   \\n        }\\n        \\n        if(n%2){\\n            for(auto i:nums2){\\n                ans = ans ^ i;\\n            }   \\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int ans = 0;\\n        if(m%2){\\n            for(auto i:nums1){\\n                ans = ans ^ i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2646720,
                "title": "c-java-python-very-easy-and-concise-clean-code-with-explanations",
                "content": "n1 = nums 1 size\\nn2 = nums 2 size\\n\\nEvery element of n1 is paired up with n2 elements \\nso every element of nums1 comes n2 times , \\n\\nand similiarly\\nevery elment of nums2 is paired up with single element of n1 , nums2 elements comes n1 times\\n\\nNOW\\n\\nXOR of even frequency elements are 0\\nso if n1 is even , nums2 elements won\\'t contribute to the answer\\nand if n2 is even , nums1 elements won\\'t contribute to the answer\\n\\nand for odd frequence , elements will be counted as 1 , as even frequency elements will cancel out each other\\n\\n\\n#### C++\\n```\\nint xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n         if(nums1.size()%2==0 and nums2.size()%2==0) return 0;\\n        int v1=0;\\n        if(nums2.size()%2) for(int n:nums1) v1=v1^n;\\n        if(nums1.size()%2) for(int n:nums2) v1=v1^n;\\n        return v1;\\n    }\\n```\\n\\n#### Java\\n```\\npublic int xorAllNums(int[] nums1, int[] nums2) {\\n         if(nums1.length%2==0 && nums2.length%2==0) return 0;\\n        int v1=0;\\n        if(nums2.length%2==1) for(int n:nums1) v1=v1^n;\\n        if(nums1.length%2==1) for(int n:nums2) v1=v1^n;\\n        return v1;\\n    }\\n```\\n\\n### Python\\n\\n```\\ndef xorAllNums(self, nums1, nums2):\\n        if len(nums1)%2==0 and len(nums2)%2==0 : return 0\\n        v1=0\\n        if len(nums2)%2: \\n            for n in nums1 :  v1=v1^n\\n        if len(nums1)%2: \\n            for n in nums2 :  v1=v1^n\\n        return v1\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nint xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n         if(nums1.size()%2==0 and nums2.size()%2==0) return 0;\\n        int v1=0;\\n        if(nums2.size()%2) for(int n:nums1) v1=v1^n;\\n        if(nums1.size()%2) for(int n:nums2) v1=v1^n;\\n        return v1;\\n    }\\n```\n```\\npublic int xorAllNums(int[] nums1, int[] nums2) {\\n         if(nums1.length%2==0 && nums2.length%2==0) return 0;\\n        int v1=0;\\n        if(nums2.length%2==1) for(int n:nums1) v1=v1^n;\\n        if(nums1.length%2==1) for(int n:nums2) v1=v1^n;\\n        return v1;\\n    }\\n```\n```\\ndef xorAllNums(self, nums1, nums2):\\n        if len(nums1)%2==0 and len(nums2)%2==0 : return 0\\n        v1=0\\n        if len(nums2)%2: \\n            for n in nums1 :  v1=v1^n\\n        if len(nums1)%2: \\n            for n in nums2 :  v1=v1^n\\n        return v1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2646698,
                "title": "c-explanation-with-comments-beginner-friendly",
                "content": "**intution:-** we have 2 array and for each element we have to xor it with another array, and then xor all numbers so we finaly have each element that will be xor\\'ed to it self in the given number of another array.\\n now lets understand it with ex:-\\n \\n **example**\\n lets say we have array [a,b] and [c,d,e] so according to question:\\n 1) we will have numbers a^c ,  a^d,  a^e, b^c, b^d  , b^e;\\n 2) final number will be a^c ^ a^d ^ a^e ^b^c^ b^d  ^ b^e;\\n\\nif we try to see pattern here a comes 3 times ,b 3 times c 2 times d 2 times and e 2 times which is nothing but the number of other array.\\n\\nand by xor property we know if we xor any number to self even times it will become 0 or if we do odd times it will become itself\\n\\nso now problem reduce to find the xor of all element in the array which have odd length which we can solve.\\n\\n\\n\\n**code:-**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans=0,i,j,n=nums1.size(),m=nums2.size();\\n\\t\\t//if both have even length both will be canceled hence return 0\\n        if((n&1)==0 && (m&1)==0) return 0;\\n\\t\\t\\n\\t\\t//if first is of odd length that means we have to xor all elements in 2nd array\\n        if(n&1){\\n            for(i=0;i<m;i++){\\n                ans^=nums2[i];\\n            }\\n            cout<<ans<<\" \";\\n        }\\n\\t\\t\\n\\t\\t//if second is of odd length that means we have to xor all elements in 1st array\\n        if(m&1){\\n            for(i=0;i<n;i++){\\n                ans^=nums1[i];\\n            }\\n            cout<<ans<<\" \";\\n        }\\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans=0,i,j,n=nums1.size(),m=nums2.size();\\n\\t\\t//if both have even length both will be canceled hence return 0\\n        if((n&1)==0 && (m&1)==0) return 0;\\n\\t\\t\\n\\t\\t//if first is of odd length that means we have to xor all elements in 2nd array\\n        if(n&1){\\n            for(i=0;i<m;i++){\\n                ans^=nums2[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2646662,
                "title": "using-xor-property",
                "content": "```\\n int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size();\\n        int a=0,b=0;\\n        for(int i=0;i<nums1.size();i++){\\n            a^=nums1[i];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            b^=nums2[i];\\n        }\\n        if(n%2 && m%2){\\n            return a^b;\\n        }\\n        else if(n%2){\\n            return b;\\n        }\\n        else if(m%2){\\n            return a;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size();\\n        int a=0,b=0;\\n        for(int i=0;i<nums1.size();i++){\\n            a^=nums1[i];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            b^=nums2[i];\\n        }\\n        if(n%2 && m%2){\\n            return a^b;\\n        }\\n        else if(n%2){\\n            return b;\\n        }\\n        else if(m%2){\\n            return a;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646660,
                "title": "faster-100-c-o-n",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint xorAllNums(vector<int>& num1, vector<int>& num2) \\n\\t\\t{\\n\\t\\t\\tint n = num1.size();\\n\\t\\t\\tint m = num2.size();\\n\\t\\t\\tint XOR = 0;\\n\\n\\t\\t\\tif(m & 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0 ; i < n ; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t   XOR = XOR ^ num1[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(n & 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0 ; i < m ; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t   XOR = XOR ^ num2[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn XOR;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint xorAllNums(vector<int>& num1, vector<int>& num2) \\n\\t\\t{\\n\\t\\t\\tint n = num1.size();\\n\\t\\t\\tint m = num2.size();\\n\\t\\t\\tint XOR = 0;\\n\\n\\t\\t\\tif(m & 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int i = 0 ; i < n ; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t   XOR = XOR ^ num1[i];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2646644,
                "title": "c-easy-in-o-n",
                "content": "# Intuition\\nThinking on the Bit Level\\n\\n# Approach\\nInstead of O(n^2) we can optimise it to O(30*n) by just knowing if in the final result the bit is gonna be set or not and if it will be set then the ans will be added by the pow(2,that position).\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>nums1,vector<int>nums2) \\n    {\\n        vector<long long int>setbits1,setbits2;\\n        setbits1.assign(31,0);\\n        setbits2.assign(31,0);\\n        int i,j;\\n        for(i=0;i<31;i++)\\n        {\\n            for(j=0;j<nums1.size();j++)\\n            {\\n                if(((1<<i)&nums1[j])>0)\\n                {\\n                    setbits1[i]++;\\n                }\\n            }\\n        }\\n        for(i=0;i<31;i++)\\n        {\\n            for(j=0;j<nums2.size();j++)\\n            {\\n                if(((1<<i)&nums2[j])>0)\\n                {\\n                    setbits2[i]++;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(i=0;i<31;i++)\\n        {\\n            long long int num0=setbits1[i]*setbits2[i]+(nums1.size()-setbits1[i])*(nums2.size()-setbits2[i]);\\n            long long int num1=setbits1[i]*(nums2.size()-setbits2[i])+setbits2[i]*(nums1.size()-setbits1[i]);\\n            if(num1%2==1 && num0%2==0)\\n            {\\n                ans+=(1<<i);\\n            }\\n            else if(num1%2==1 && num0%2==1)\\n            {\\n                ans+=(1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>nums1,vector<int>nums2) \\n    {\\n        vector<long long int>setbits1,setbits2;\\n        setbits1.assign(31,0);\\n        setbits2.assign(31,0);\\n        int i,j;\\n        for(i=0;i<31;i++)\\n        {\\n            for(j=0;j<nums1.size();j++)\\n            {\\n                if(((1<<i)&nums1[j])>0)\\n                {\\n                    setbits1[i]++;\\n                }\\n            }\\n        }\\n        for(i=0;i<31;i++)\\n        {\\n            for(j=0;j<nums2.size();j++)\\n            {\\n                if(((1<<i)&nums2[j])>0)\\n                {\\n                    setbits2[i]++;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(i=0;i<31;i++)\\n        {\\n            long long int num0=setbits1[i]*setbits2[i]+(nums1.size()-setbits1[i])*(nums2.size()-setbits2[i]);\\n            long long int num1=setbits1[i]*(nums2.size()-setbits2[i])+setbits2[i]*(nums1.size()-setbits1[i]);\\n            if(num1%2==1 && num0%2==0)\\n            {\\n                ans+=(1<<i);\\n            }\\n            else if(num1%2==1 && num0%2==1)\\n            {\\n                ans+=(1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646623,
                "title": "c-o-n1-n2-odd-even",
                "content": "```\\n\\t\\tint a = nums1.size();\\n        int b = nums2.size();\\n        if(a%2 == 0 && b%2 == 0)\\n        {\\n            return 0;\\n        }\\n        int ans1 = 0;\\n        for(auto it:nums1)\\n        {\\n            ans1  = ans1 xor it;\\n        }\\n        int ans2 = 0;\\n        for(auto it:nums2)\\n        {\\n            ans2  = ans2 xor it;\\n        }\\n        if(a%2 == 0 || b%2 == 0)\\n        {\\n            if(a%2 == 0)\\n            {\\n                return ans1;\\n            }\\n            else{\\n                return ans2;\\n            }\\n        }\\n        return ans1 xor ans2;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t\\tint a = nums1.size();\\n        int b = nums2.size();\\n        if(a%2 == 0 && b%2 == 0)\\n        {\\n            return 0;\\n        }\\n        int ans1 = 0;\\n        for(auto it:nums1)\\n        {\\n            ans1  = ans1 xor it;\\n        }\\n        int ans2 = 0;\\n        for(auto it:nums2)\\n        {\\n            ans2  = ans2 xor it;\\n        }\\n        if(a%2 == 0 || b%2 == 0)\\n        {\\n            if(a%2 == 0)\\n            {\\n                return ans1;\\n            }\\n            else{\\n                return ans2;\\n            }\\n        }\\n        return ans1 xor ans2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646586,
                "title": "c-linear-time-xoring-100-time-150ms-100-space-60-4mb",
                "content": "The trick here is just to figure out that if the one array is even lengthed, all the pairing with any element of the other array wil cancel each other, since we will have for each element in `n1` at position `x` this situation: `(n1[x] ^ n2[0]) ^ (n1[x] ^ n2[1]) ^ (n1[x] ^ n2[0]) ^ ... ^ (n1[x] ^ n2[n2.size() - 1])`.\\n\\nGiven the property of the XOR operator, easy to spot that if `n2` had an even length, they will cancel each other out (`n ^ n == 0`), otherwise we will just keep that element.\\n\\nAnd if that is not the case (ie: the other array is odd lengthed), rinse and repeate for all the values and we will keep only the XORed value of each item once.\\n\\nWith that in mind, we can solve our problem right neatly.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        // support variables\\n        int l1 = nums1.size(), l2 = nums2.size(), res = 0;\\n        // parsing nums2, only if l1 is odd lengthed\\n        if (l1 & 1) {\\n            for (int n: nums2) res ^= n;\\n        }\\n        // parsing nums1, only if l2 is odd lengthed\\n        if (l2 & 1) {\\n            for (int n: nums1) res ^= n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        // support variables\\n        int l1 = nums1.size(), l2 = nums2.size(), res = 0;\\n        // parsing nums2, only if l1 is odd lengthed\\n        if (l1 & 1) {\\n            for (int n: nums2) res ^= n;\\n        }\\n        // parsing nums1, only if l2 is odd lengthed\\n        if (l2 & 1) {\\n            for (int n: nums1) res ^= n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646570,
                "title": "c-explained-example-walk-through",
                "content": "Please upvote if you find this post useful\\nINTUTION :-\\n```\\n        we are aware that bitwise XOR gives out a value 1 for odd number of 1\\'s\\n        and gives out 0 for even number of 1\\'s\\n            \\n        for example\\n            consider the value 5 -> 0101\\n            we are aware that 5 ^ 5 gives 0 (holds true for every number if they are present in even quantities) \\n            \\n            0101\\n            0101\\n            _XOR_ (even number of one\\'s)\\n            0000\\n        \\n        so since we are to consider the pairing of every integer in nums1 with every\\n        integer of nums2\\n        \\n        we see that if either of sz1 or sz2 (both being the respective sizes of the vectors) is even\\n        then the other array\\'s XOR with its elements will cancel each other out leaving our first array\\'s element.\\n            \\n        for ex - \\n        nums1 = [2,1,3], nums2 = [10,2,5,0]\\n        sz1 = 3, sz2 = 4\\n        \\n        performing XOR over all the pairings we get\\n        \\n        (2 ^ 10) ^ (2 ^ 2) ^ (2 ^ 5) ^ (2 ^ 0)     == > cancelling out even number of 2\\'s from nums1\\n                        ^\\n        (1 ^ 10) ^ (1 ^ 2) ^ (1 ^ 5) ^ (1 ^ 0)     == > cancelling out even number of 1\\'s from nums1\\n                        ^\\n        (3 ^ 10) ^ (3 ^ 2) ^ (3 ^ 5) ^ (3 ^ 0)     == > cancelling out even number of 3\\'s from nums1\\n            \\n        \\n        in the end we are left with only the values of nums2 which happen to be present in an odd number of quantities.\\n        \\n                   \\n        result => we only need to consider the XOR of the values of the array that has an even number as its size\\n                  if neither of the two have even numbers as their size then we need to find the XOR of every element once\\n        \\n        TC - best case - (both are even sizes) O(1)\\n             avg case - O(sz1/sz2) \\n             worst case - O(sz1 + sz2)\\n        \\n        SC - O(1)\\n```\\n\\n\\nCODE - \\n\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {            \\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        \\n        int ans = 0;\\n        if(sz1 % 2 == 0 and sz2 % 2 == 0) {\\n            return 0;\\n        }\\n        else if(sz1 % 2 == 0 and sz2 % 2 != 0) {\\n            for(auto it: nums1) {\\n                ans ^= it;\\n            }\\n            return ans;\\n        }\\n        else if(sz1 % 2 != 0 and sz2 % 2 == 0) {\\n            for(auto it: nums2) {\\n                ans ^= it;\\n            }\\n        }\\n        else {\\n            for(int i = 0; i < sz1; i++) {\\n                ans ^= nums1[i];\\n            }\\n            for(int i = 0; i < sz2; i++) {\\n                ans ^= nums2[i];\\n            }\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nI have a youtube channel on which I post leetcode daily challenge solutions and leetcode contest solutions as well\\nLink - https://www.youtube.com/channel/UCsg3P5gwHTVxfUjFyd5Tsfg\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n        we are aware that bitwise XOR gives out a value 1 for odd number of 1\\'s\\n        and gives out 0 for even number of 1\\'s\\n            \\n        for example\\n            consider the value 5 -> 0101\\n            we are aware that 5 ^ 5 gives 0 (holds true for every number if they are present in even quantities) \\n            \\n            0101\\n            0101\\n            _XOR_ (even number of one\\'s)\\n            0000\\n        \\n        so since we are to consider the pairing of every integer in nums1 with every\\n        integer of nums2\\n        \\n        we see that if either of sz1 or sz2 (both being the respective sizes of the vectors) is even\\n        then the other array\\'s XOR with its elements will cancel each other out leaving our first array\\'s element.\\n            \\n        for ex - \\n        nums1 = [2,1,3], nums2 = [10,2,5,0]\\n        sz1 = 3, sz2 = 4\\n        \\n        performing XOR over all the pairings we get\\n        \\n        (2 ^ 10) ^ (2 ^ 2) ^ (2 ^ 5) ^ (2 ^ 0)     == > cancelling out even number of 2\\'s from nums1\\n                        ^\\n        (1 ^ 10) ^ (1 ^ 2) ^ (1 ^ 5) ^ (1 ^ 0)     == > cancelling out even number of 1\\'s from nums1\\n                        ^\\n        (3 ^ 10) ^ (3 ^ 2) ^ (3 ^ 5) ^ (3 ^ 0)     == > cancelling out even number of 3\\'s from nums1\\n            \\n        \\n        in the end we are left with only the values of nums2 which happen to be present in an odd number of quantities.\\n        \\n                   \\n        result => we only need to consider the XOR of the values of the array that has an even number as its size\\n                  if neither of the two have even numbers as their size then we need to find the XOR of every element once\\n        \\n        TC - best case - (both are even sizes) O(1)\\n             avg case - O(sz1/sz2) \\n             worst case - O(sz1 + sz2)\\n        \\n        SC - O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {            \\n        int sz1 = nums1.size();\\n        int sz2 = nums2.size();\\n        \\n        int ans = 0;\\n        if(sz1 % 2 == 0 and sz2 % 2 == 0) {\\n            return 0;\\n        }\\n        else if(sz1 % 2 == 0 and sz2 % 2 != 0) {\\n            for(auto it: nums1) {\\n                ans ^= it;\\n            }\\n            return ans;\\n        }\\n        else if(sz1 % 2 != 0 and sz2 % 2 == 0) {\\n            for(auto it: nums2) {\\n                ans ^= it;\\n            }\\n        }\\n        else {\\n            for(int i = 0; i < sz1; i++) {\\n                ans ^= nums1[i];\\n            }\\n            for(int i = 0; i < sz2; i++) {\\n                ans ^= nums2[i];\\n            }\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646546,
                "title": "xor-concept-important-observation-4-lines-c-explained",
                "content": "XOR Concept:\\na xor a = 0\\n(a xor b) xor c = a xor (b xor c)\\n\\nImportant Observation:\\nTake Example 1: nums1 = [2,1,3], nums2 = [10,2,5,0]\\n\\nConsidering only 1st element in nums1:\\n(2 ^ 10) ^ (2 ^ 2) ^ (2 ^ 5) ^ (2 ^ 0)\\t\\tis same as\\t(2 ^ 2 ^ 2 ^ 2) ^ (10 ^ 2 ^ 5 ^ 0)\\nYou can clearly see that the first term after rearranging becomes 0 (Because we are doing xor even number of times)\\nSimilarly when we do for all elements in nums1, only second term will remain.\\nNow talking about the second term, the same second term will come for all elements in nums1.\\nSince nums1 is in odd size, computing only one term is enough. All other terms will cancel each other.\\nSimilarly do for nums2 also.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int i, n1 = nums1.size(), n2 = nums2.size(), ans = 0;\\n        if(n2 % 2)   for(i=0;i<n1;i++)   ans ^= nums1[i];\\n        if(n1 % 2)   for(i=0;i<n2;i++)   ans ^= nums2[i];\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity: O(m + n)\\nSapce Complexity: O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int i, n1 = nums1.size(), n2 = nums2.size(), ans = 0;\\n        if(n2 % 2)   for(i=0;i<n1;i++)   ans ^= nums1[i];\\n        if(n1 % 2)   for(i=0;i<n2;i++)   ans ^= nums2[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646543,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res = 0;\\n        if(nums2.length % 2 != 0) {\\n            for(int i : nums1) {\\n                res ^= i;\\n            }\\n        }\\n        \\n        if(nums1.length % 2 != 0) {\\n            for(int i : nums2) {\\n                res ^= i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res = 0;\\n        if(nums2.length % 2 != 0) {\\n            for(int i : nums1) {\\n                res ^= i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2646537,
                "title": "commented-solution-c",
                "content": "```c++\\nint xorAllNums(vector<int>& A, vector<int>& B) {\\n        //let\\'s take two arrays\\n        // A =[a,b,c];\\n        // B= [d,e,f,g];\\n        //now create all possible combinations using pen and paper\\n        // you will notice elements in A appear B.size() times and\\n        //elements of B appear A.size() times;\\n        //depending on value of A.size() and B.size(), if they are even or not we will get our answer;\\n        int x=A.size(),y=B.size();\\n        //if they both are even then they will be cancelled out.\\n        if(x%2==0&&y%2==0)  return 0;\\n        //if size of A is even then B will cancel out\\n        else if(x%2==0)\\n        {\\n            int sol=A[0];\\n            for(int i=1;i<x;i++)\\n            {\\n                sol^=A[i];\\n            }\\n            return sol;\\n        }\\n        else if(y%2==0)\\n        {\\n            int sol=B[0];\\n            for(int i=1;i<y;i++)\\n            {\\n                sol^=B[i];\\n            }\\n            return sol;\\n        }\\n        //if they both are odd no one will cancel\\n        // take xor of all\\n        else\\n        {\\n            int sol=A[0];\\n            for(int i=1;i<x;i++)\\n            {\\n                sol^=A[i];\\n            }\\n            for(int i=0;i<y;i++)\\n            {\\n                sol^=B[i];\\n            }\\n            return sol;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\nint xorAllNums(vector<int>& A, vector<int>& B) {\\n        //let\\'s take two arrays\\n        // A =[a,b,c];\\n        // B= [d,e,f,g];\\n        //now create all possible combinations using pen and paper\\n        // you will notice elements in A appear B.size() times and\\n        //elements of B appear A.size() times;\\n        //depending on value of A.size() and B.size(), if they are even or not we will get our answer;\\n        int x=A.size(),y=B.size();\\n        //if they both are even then they will be cancelled out.\\n        if(x%2==0&&y%2==0)  return 0;\\n        //if size of A is even then B will cancel out\\n        else if(x%2==0)\\n        {\\n            int sol=A[0];\\n            for(int i=1;i<x;i++)\\n            {\\n                sol^=A[i];\\n            }\\n            return sol;\\n        }\\n        else if(y%2==0)\\n        {\\n            int sol=B[0];\\n            for(int i=1;i<y;i++)\\n            {\\n                sol^=B[i];\\n            }\\n            return sol;\\n        }\\n        //if they both are odd no one will cancel\\n        // take xor of all\\n        else\\n        {\\n            int sol=A[0];\\n            for(int i=1;i<x;i++)\\n            {\\n                sol^=A[i];\\n            }\\n            for(int i=0;i<y;i++)\\n            {\\n                sol^=B[i];\\n            }\\n            return sol;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646519,
                "title": "bit-maths-with-explanation",
                "content": "The first thing you have to notice is that is \\n(a^b)^(c^d)=(a^c)^(b^d)=(a^d)^(c^b)\\n\\nand Xor of same number is always 0.\\n\\nso arr1 elements will come arr2.size() times and similarly arr2 elements will come arr1.size() times.\\nSo if any element is comming 2 times then we can take its XOR from itself and make it 0.\\nSo therefore we can remove all elements which will occur multiple of 2 times.\\n\\nSo if arr1.size() is divisible by 2 the arr2 elements will get cancelled and will give zero , similar thing will happen to arr1 elements if arr2.size is divisible by 2.\\n\\nif both are divisible by 2 , then we will return 0.\\n\\nif 1 of them is divisible by 2 then we will return the XOR of the other array\\'s element.\\n\\nbut if no ones size is divisble by 2 then we will return the XOR of first array and second array.\\n\\n\\n\\n\\n```\\nint xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size()%2 ==0 and nums2.size()%2==0)return 0;\\n        \\n        if(nums1.size()%2==0){\\n            int ret=nums1[0];\\n            for(int i=1;i<nums1.size();i++){\\n                ret^=nums1[i];\\n            }\\n            return ret;\\n        }\\n        \\n        if(nums2.size()%2==0){\\n             int ret=nums2[0];\\n            for(int i=1;i<nums2.size();i++){\\n                ret^=nums2[i];\\n            }\\n            return ret;\\n        }\\n        int ret=nums1[0];\\n            for(int i=1;i<nums1.size();i++){\\n                ret^=nums1[i];\\n            }\\n            for(int i=0;i<nums2.size();i++){\\n                ret^=nums2[i];\\n            }\\n        \\n        return ret;\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nint xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size()%2 ==0 and nums2.size()%2==0)return 0;\\n        \\n        if(nums1.size()%2==0){\\n            int ret=nums1[0];\\n            for(int i=1;i<nums1.size();i++){\\n                ret^=nums1[i];\\n            }\\n            return ret;\\n        }\\n        \\n        if(nums2.size()%2==0){\\n             int ret=nums2[0];\\n            for(int i=1;i<nums2.size();i++){\\n                ret^=nums2[i];\\n            }\\n            return ret;\\n        }\\n        int ret=nums1[0];\\n            for(int i=1;i<nums1.size();i++){\\n                ret^=nums1[i];\\n            }\\n            for(int i=0;i<nums2.size();i++){\\n                ret^=nums2[i];\\n            }\\n        \\n        return ret;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646501,
                "title": "simple-code-xor-property",
                "content": "```\\n// xor of same elements is 0\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        int x1 = 0, x2 = 0;\\n        \\n        for(int i: nums1)\\n            x1 ^= i;\\n        for(int j: nums2)\\n            x2 ^= j;\\n        \\n        int ans = 0;\\n        if(n1%2)\\n            ans ^= x2;\\n        \\n        if(n2%2)\\n            ans ^= x1;\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n// xor of same elements is 0\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        int x1 = 0, x2 = 0;\\n        \\n        for(int i: nums1)\\n            x1 ^= i;\\n        for(int j: nums2)\\n            x2 ^= j;\\n        \\n        int ans = 0;\\n        if(n1%2)\\n            ans ^= x2;\\n        \\n        if(n2%2)\\n            ans ^= x1;\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646500,
                "title": "c-easy-and-concise",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size() % 2 == 0 && nums2.size() % 2 == 0) return 0;\\n        \\n        int ans = 0, ans1 = 0;\\n        for(auto &it : nums1){\\n            ans ^= it;\\n        }\\n        \\n        if(nums1.size() % 2 == 0) return ans;\\n        \\n        for(auto &it : nums2){\\n            ans1 ^= it;\\n        }\\n        \\n        if(nums2.size() % 2 == 0) return ans1;\\n        \\n        return ans ^ ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size() % 2 == 0 && nums2.size() % 2 == 0) return 0;\\n        \\n        int ans = 0, ans1 = 0;\\n        for(auto &it : nums1){\\n            ans ^= it;\\n        }\\n        \\n        if(nums1.size() % 2 == 0) return ans;\\n        \\n        for(auto &it : nums2){\\n            ans1 ^= it;\\n        }\\n        \\n        if(nums2.size() % 2 == 0) return ans1;\\n        \\n        return ans ^ ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646495,
                "title": "accepted-c-simple-solution",
                "content": "**Solution 1:**\\n```\\nclass Solution {\\npublic:\\n    \\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(),m = nums2.size();\\n        if(n%2==0 and m%2==0)return 0;\\n        int res = 0;\\n        bool flag = n%2!=0 and m%2!=0;\\n        if(n%2!=0 and m%2==0){\\n            for(auto ele:nums2)res^=ele;\\n        }else if(n%2==0 and m%2!=0){\\n            for(auto ele:nums1)res^=ele;\\n        }else{\\n             for(auto ele:nums2)res^=ele;\\n             for(auto ele:nums1)res^=ele;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Solution 2:**\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(),m = nums2.size();\\n        int res = 0;\\n        if(m%2)for(auto ele:nums1)res^=ele;\\n        if(n%2)for(auto ele:nums2)res^=ele;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(),m = nums2.size();\\n        if(n%2==0 and m%2==0)return 0;\\n        int res = 0;\\n        bool flag = n%2!=0 and m%2!=0;\\n        if(n%2!=0 and m%2==0){\\n            for(auto ele:nums2)res^=ele;\\n        }else if(n%2==0 and m%2!=0){\\n            for(auto ele:nums1)res^=ele;\\n        }else{\\n             for(auto ele:nums2)res^=ele;\\n             for(auto ele:nums1)res^=ele;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(),m = nums2.size();\\n        int res = 0;\\n        if(m%2)for(auto ele:nums1)res^=ele;\\n        if(n%2)for(auto ele:nums2)res^=ele;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096183,
                "title": "c-python-solution-with-explanation",
                "content": "x ^ x = 0, 0 ^ x = x.\\nif size of nums2 is odd,\\nwhich means each number of nums1 will be xor odd times.\\nif not, number of nums1 will be xor even times, it will be 0.\\n\\nsize of nums1 too.\\n\\n\\n### python\\n```python\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        ans = 0\\n        if len(nums2) % 2:\\n            for x in nums1:\\n                ans ^= x\\n        if len(nums1) % 2:\\n            for x in nums2:\\n                ans ^= x\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        if (nums2.size() % 2) {\\n            for (int& x: nums1)\\n                ans ^= x;\\n        }\\n        if (nums1.size() % 2) {\\n            for (int& x: nums2)\\n                ans ^= x;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        ans = 0\\n        if len(nums2) % 2:\\n            for x in nums1:\\n                ans ^= x\\n        if len(nums1) % 2:\\n            for x in nums2:\\n                ans ^= x\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        if (nums2.size() % 2) {\\n            for (int& x: nums1)\\n                ans ^= x;\\n        }\\n        if (nums1.size() % 2) {\\n            for (int& x: nums2)\\n                ans ^= x;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043982,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf both the array size are even then all the element in pairing will repeated even times thus XOR will be zero. If both of them odd then xor of all the element of both of them should give the result. If any of them is odd because the odd array is xored even times and even length array numbers are xored odd times.\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int XOR=0;\\n        int idx=0;\\n       if (((nums1.size() & 0x1) == 0)  &&  ((nums2.size() & 0x1) == 0))\\n       {\\n           return 0;\\n       }\\n       else if (((nums1.size() & 0x1) == 1)  &&  ((nums2.size() & 0x1) == 1))\\n       {\\n           idx=0;\\n           while (idx<nums1.size())\\n           {\\n               XOR = XOR ^ nums1[idx];\\n               idx++;\\n           }\\n\\n           idx=0;\\n           while (idx<nums2.size())\\n           {\\n               XOR = XOR ^ nums2[idx];\\n               idx++;\\n           }\\n       }\\n       else if (((nums1.size() & 0x1) == 1)  &&  ((nums2.size() & 0x1) == 0))\\n       {\\n           idx=0;\\n           while (idx<nums2.size())\\n           {\\n               XOR = XOR ^ nums2[idx];\\n               idx++;\\n           }\\n        }\\n        else\\n        {\\n           idx=0;\\n           while (idx<nums1.size())\\n           {\\n               XOR = XOR ^ nums1[idx];\\n               idx++;\\n           }\\n\\n        }\\n        return XOR;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int XOR=0;\\n        int idx=0;\\n       if (((nums1.size() & 0x1) == 0)  &&  ((nums2.size() & 0x1) == 0))\\n       {\\n           return 0;\\n       }\\n       else if (((nums1.size() & 0x1) == 1)  &&  ((nums2.size() & 0x1) == 1))\\n       {\\n           idx=0;\\n           while (idx<nums1.size())\\n           {\\n               XOR = XOR ^ nums1[idx];\\n               idx++;\\n           }\\n\\n           idx=0;\\n           while (idx<nums2.size())\\n           {\\n               XOR = XOR ^ nums2[idx];\\n               idx++;\\n           }\\n       }\\n       else if (((nums1.size() & 0x1) == 1)  &&  ((nums2.size() & 0x1) == 0))\\n       {\\n           idx=0;\\n           while (idx<nums2.size())\\n           {\\n               XOR = XOR ^ nums2[idx];\\n               idx++;\\n           }\\n        }\\n        else\\n        {\\n           idx=0;\\n           while (idx<nums1.size())\\n           {\\n               XOR = XOR ^ nums1[idx];\\n               idx++;\\n           }\\n\\n        }\\n        return XOR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015816,
                "title": "beginner-friendly-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int count=0;\\n        if(n%2==0 && m%2==0)\\n        {\\n            return count;\\n        }\\n\\n        if(n%2==1)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n               count=count^nums2[i];\\n            }\\n        }\\n         \\n        if(m%2==1)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                count=count^nums1[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int count=0;\\n        if(n%2==0 && m%2==0)\\n        {\\n            return count;\\n        }\\n\\n        if(n%2==1)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n               count=count^nums2[i];\\n            }\\n        }\\n         \\n        if(m%2==1)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                count=count^nums1[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981925,
                "title": "beginner-friendly-easy-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUSE basic XOR opeartion \\nLet the vector be [1,2,3] and [4,5]\\n\\nHow will you brute force it\\n\\n(1^4) ^ (1^5) ^ (2^4) ^ (2^5) ^ (3^4) ^ (3^5)\\n\\nif we reaarange it\\n\\n(1^1) ^ (2^2) ^ (3^3) ^ (4^4^4) ^ (5^5^5)\\n\\nwe see that the elements in array1 is xored to itself n2 number of times with is the size of other array2. Like wise for other array2 is xored to itself n1 number of times\\n\\nwe know from the property of XOR that if X^X = 0 and X^0 = X.\\n\\ntherefore effective calculation\\n\\n0 ^ 0 ^ 0 ^ 4 ^ 5 = 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake xor of every element in an array just keep in mind if the element will be 0 or the element itself based on number of elements in other array.\\n\\nFinally XOR of both.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$ \\nSince basic iteration of arrays\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\nNo extra space needed\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n2 = nums2.size();\\n        int n1 = nums1.size();\\n        int x = 0;\\n        for(auto y:nums1){\\n            if(n2%2==0){\\n                x^=0;\\n            }\\n            else x^=y;\\n            \\n        }\\n        int z = 0;\\n        for(auto y:nums2){\\n            if(n1%2==0){\\n                z^=0;\\n            }\\n            else z^=y;\\n            \\n        }\\n        return x^z;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n2 = nums2.size();\\n        int n1 = nums1.size();\\n        int x = 0;\\n        for(auto y:nums1){\\n            if(n2%2==0){\\n                x^=0;\\n            }\\n            else x^=y;\\n            \\n        }\\n        int z = 0;\\n        for(auto y:nums2){\\n            if(n1%2==0){\\n                z^=0;\\n            }\\n            else z^=y;\\n            \\n        }\\n        return x^z;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980961,
                "title": "cpp-simple-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        if(s2%2)\\n        for(auto i : nums1){\\n            ans^=i;\\n        }\\n        if(s1%2)\\n        for(auto i : nums2){\\n            ans^=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        if(s2%2)\\n        for(auto i : nums1){\\n            ans^=i;\\n        }\\n        if(s1%2)\\n        for(auto i : nums2){\\n            ans^=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954136,
                "title": "c-bit-manipulation-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        // We start with zero as zero is the identity of xor i.e x = 0^x\\n        int ans = 0;\\n        // Then we also know that xor has the commutative property\\n        // So we just need to find out how many times each element is getting xored finally\\n        // Also we use the fact that x^x = 0 and 0^x = x\\n        // Thus if we xor x with itself odd number of times we get x itself and 0 otherwise\\n        for(auto x : nums1)\\n        {\\n            if(m%2 != 0)\\n            {\\n                ans = ans ^ x;\\n            }\\n        }\\n        for(auto x : nums2)\\n        {\\n            if(n%2 != 0)\\n            {\\n                ans = ans ^ x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Good solution but gives TLE\\n// class Solution {\\n// public:\\n//     int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n//         vector<int> nums3;\\n//         int n1 = nums1.size();\\n//         int n2 = nums2.size();\\n//         for(auto x : nums1)\\n//         {\\n//             for(auto y : nums2)\\n//             {\\n//                 nums3.push_back(x^y);\\n//             }\\n//         }\\n//         int n3 = nums3.size();\\n//         for(int i = 1; i < n3 ; i++)\\n//         {\\n//             nums3[i] = nums3[i] ^ nums3[i-1];\\n//         }\\n//         return nums3[n3-1];\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        // We start with zero as zero is the identity of xor i.e x = 0^x\\n        int ans = 0;\\n        // Then we also know that xor has the commutative property\\n        // So we just need to find out how many times each element is getting xored finally\\n        // Also we use the fact that x^x = 0 and 0^x = x\\n        // Thus if we xor x with itself odd number of times we get x itself and 0 otherwise\\n        for(auto x : nums1)\\n        {\\n            if(m%2 != 0)\\n            {\\n                ans = ans ^ x;\\n            }\\n        }\\n        for(auto x : nums2)\\n        {\\n            if(n%2 != 0)\\n            {\\n                ans = ans ^ x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Good solution but gives TLE\\n// class Solution {\\n// public:\\n//     int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n//         vector<int> nums3;\\n//         int n1 = nums1.size();\\n//         int n2 = nums2.size();\\n//         for(auto x : nums1)\\n//         {\\n//             for(auto y : nums2)\\n//             {\\n//                 nums3.push_back(x^y);\\n//             }\\n//         }\\n//         int n3 = nums3.size();\\n//         for(int i = 1; i < n3 ; i++)\\n//         {\\n//             nums3[i] = nums3[i] ^ nums3[i-1];\\n//         }\\n//         return nums3[n3-1];\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937694,
                "title": "both-approaches-brute-force-optimized",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        // int xor = 0;\\n        // for(int i = 0 ; i < nums1.length ; i++){\\n        //     for(int j = 0 ; j < nums2.length ; j++){\\n        //         xor ^= nums1[i] ^ nums2[j];\\n        //     }\\n        // }\\n        // return xor;  general approach tle\\n        if(nums1.length %2==0 && nums2.length %2==0) return 0;\\n        if(nums1.length%2==0) return helper(nums1);\\n        if(nums2.length%2==0) return helper(nums2);\\n        return helper(nums1) ^ helper(nums2);\\n    }\\n    int helper(int nums[]){\\n        int f = nums[0];\\n        for(int i = 1 ; i < nums.length ; i++){\\n            f^=nums[i];\\n        }\\n        return f;\\n    }\\n}\\n```\\nupvote needed :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        // int xor = 0;\\n        // for(int i = 0 ; i < nums1.length ; i++){\\n        //     for(int j = 0 ; j < nums2.length ; j++){\\n        //         xor ^= nums1[i] ^ nums2[j];\\n        //     }\\n        // }\\n        // return xor;  general approach tle\\n        if(nums1.length %2==0 && nums2.length %2==0) return 0;\\n        if(nums1.length%2==0) return helper(nums1);\\n        if(nums2.length%2==0) return helper(nums2);\\n        return helper(nums1) ^ helper(nums2);\\n    }\\n    int helper(int nums[]){\\n        int f = nums[0];\\n        for(int i = 1 ; i < nums.length ; i++){\\n            f^=nums[i];\\n        }\\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925895,
                "title": "c-easy-to-understand-linear",
                "content": "# Intuition\\nUse XOR property \\na ^ a = 0;\\n\\n# Approach\\nIf one array is odd size, the final ans will have XOR for the other array\\n\\n# Complexity\\n- Time complexity:\\nlinear\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        if (nums1.size()%2) for(auto i:nums2) ans ^= i;\\n        if (nums2.size()%2) for(auto i:nums1) ans ^= i;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        if (nums1.size()%2) for(auto i:nums2) ans ^= i;\\n        if (nums2.size()%2) for(auto i:nums1) ans ^= i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882688,
                "title": "java-code-with-explanation",
                "content": "\\n# Approach\\nAs we know a^a=a^a^a^a=0..... suppose we take a element from 1st array and take xor with all element of 2nd array  if the length of 2nd array is even then  apply a^a=a^a^a^a=0.... we can say\\nif size of both array is even then return 0,\\nif size of one array is even and other is odd return XOR of all elements of even length array.\\nif size of both arrays is odd then return XOR of all elements.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    static int xor(int[] nums){\\n        int val = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            val ^= nums[i];\\n        }\\n        return val;\\n    }\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        if( n1 % 2 == 0 && n2 % 2 == 0) return 0;\\n        if( n1 % 2 == 0) return xor(nums1);\\n        if( n2 % 2 == 0) return xor(nums2);\\n        return xor(nums1) ^ xor(nums2);\\n    }\\n    \\n    \\n\\t\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int xor(int[] nums){\\n        int val = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            val ^= nums[i];\\n        }\\n        return val;\\n    }\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        if( n1 % 2 == 0 && n2 % 2 == 0) return 0;\\n        if( n1 % 2 == 0) return xor(nums1);\\n        if( n2 % 2 == 0) return xor(nums2);\\n        return xor(nums1) ^ xor(nums2);\\n    }\\n    \\n    \\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864582,
                "title": "simple-xor-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0,x_or=0;\\n\\n        for(int j=0;j<nums2.size();j++)\\n        {\\n            x_or=x_or^nums2[j];\\n        }\\n\\n\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ans=ans^x_or;\\n            if(nums2.size()%2==1)\\n                ans=ans^nums1[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0,x_or=0;\\n\\n        for(int j=0;j<nums2.size();j++)\\n        {\\n            x_or=x_or^nums2[j];\\n        }\\n\\n\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ans=ans^x_or;\\n            if(nums2.size()%2==1)\\n                ans=ans^nums1[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864308,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size();\\n        int res=0;\\n        if(n%2==1){\\n                for(int i=0;i<m;i++){\\n                    res^=nums2[i];\\n                }\\n        }\\n        if(m%2==1){\\n            for(int i=0;i<n;i++){\\n                res^=nums1[i];\\n            }\\n        }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size();\\n        int res=0;\\n        if(n%2==1){\\n                for(int i=0;i<m;i++){\\n                    res^=nums2[i];\\n                }\\n        }\\n        if(m%2==1){\\n            for(int i=0;i<n;i++){\\n                res^=nums1[i];\\n            }\\n        }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845447,
                "title": "beats-99-79",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        int n = nums1.size();\\n        if(n&1)\\n        {\\n            for(int i=0;i<nums2.size();i++)\\n            ans = ans^nums2[i];\\n        }\\n        n = nums2.size();\\n        if(n&1)\\n        {\\n            for(int i=0;i<nums1.size();i++)\\n            ans= ans^nums1[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        int n = nums1.size();\\n        if(n&1)\\n        {\\n            for(int i=0;i<nums2.size();i++)\\n            ans = ans^nums2[i];\\n        }\\n        n = nums2.size();\\n        if(n&1)\\n        {\\n            for(int i=0;i<nums1.size();i++)\\n            ans= ans^nums1[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820388,
                "title": "python3-using-even-and-odd-length-if-xor-easy-to-understand",
                "content": "# Intuition\\n    1) The number XOR with itself is 0.\\n    2) If the number of elements in array1 is even then there are equal no of elements to pair hence the result is 0.We wan to take the total XOR of array2. \\n    3) If the number of elements in array2 is even then there are equal no of elements to pair hence the result is 0.We wan to take the total XOR of array1.\\n    4)ex-array1=[1,3,4] array2=[2,3,4,5]\\n            The array2 is even so, the all numbers are cancelled each other in array2 and the ans is XOR of array1.\\n        1^1^1^1^3^3^3^3^4^4^4^4=0\\n        0^2^3^4^5=result.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        result=0\\n        if len(nums1)%2==1:\\n            for i in nums2:\\n                result^=i\\n        if len(nums2)%2==1:\\n            for i in nums1:\\n                result^=i\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        result=0\\n        if len(nums1)%2==1:\\n            for i in nums2:\\n                result^=i\\n        if len(nums2)%2==1:\\n            for i in nums1:\\n                result^=i\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793980,
                "title": "python-ez-bitwise",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        l1 = len(nums1)\\n        l2 = len(nums2)\\n        res = []\\n        if l1%2 == 0 and l2%2 == 0:\\n            return 0\\n        elif l1%2 == 0:\\n            res = nums1\\n        elif l2%2 == 0:\\n            res = nums2\\n        else:\\n            res = nums1 + nums2\\n        \\n        ans = 0\\n        for e in res:\\n            ans ^= e\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        l1 = len(nums1)\\n        l2 = len(nums2)\\n        res = []\\n        if l1%2 == 0 and l2%2 == 0:\\n            return 0\\n        elif l1%2 == 0:\\n            res = nums1\\n        elif l2%2 == 0:\\n            res = nums2\\n        else:\\n            res = nums1 + nums2\\n        \\n        ans = 0\\n        for e in res:\\n            ans ^= e\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782285,
                "title": "simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int ans=0;\\n        if(s1%2!=0 && s2%2==0)\\n        {\\n            for(auto it:nums2)\\n            {\\n                ans^=it;\\n                \\n            }\\n            \\n        }\\n        if(s1%2==0 && s2%2!=0)\\n        {\\n            for(auto it:nums1)\\n            {\\n                ans^=it;\\n                \\n            }\\n            \\n        }\\n        if(s1%2==0 && s2%2==0)\\n        {\\n                ans=0;\\n        }\\n        if(s1%2!=0 && s2%2!=0)\\n        {\\n            for(auto it:nums2)\\n            {\\n                ans^=it;\\n                \\n            }\\n            for(auto it:nums1)\\n            {\\n                ans^=it;\\n                \\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int s1=nums1.size();\\n        int s2=nums2.size();\\n        int ans=0;\\n        if(s1%2!=0 && s2%2==0)\\n        {\\n            for(auto it:nums2)\\n            {\\n                ans^=it;\\n                \\n            }\\n            \\n        }\\n        if(s1%2==0 && s2%2!=0)\\n        {\\n            for(auto it:nums1)\\n            {\\n                ans^=it;\\n                \\n            }\\n            \\n        }\\n        if(s1%2==0 && s2%2==0)\\n        {\\n                ans=0;\\n        }\\n        if(s1%2!=0 && s2%2!=0)\\n        {\\n            for(auto it:nums2)\\n            {\\n                ans^=it;\\n                \\n            }\\n            for(auto it:nums1)\\n            {\\n                ans^=it;\\n                \\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774475,
                "title": "easy-c-sol-explained",
                "content": "# Observation\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nobserve that if both array size is even that xor is 0;\\nif one of array size is even and other is odd then ans is xor of\\neven size array elements.\\nif both array size is odd then the ans is xor of all elements present in both array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size();int n2=nums2.size();\\n        int Xor=0;\\n        if(n1%2==0 && n2%2==0)return 0;\\n         if(n2%2==0)\\n        {\\n            for(int i=0;i<n2;i++)Xor^=nums2[i];\\n        }\\n        else if(n1%2==0)\\n        {\\n            for(int i=0;i<n1;i++)Xor^=nums1[i];\\n        }\\n        else if(n1%2==1 && n2%2==1)\\n        {\\n            for(int i=0;i<n1;i++)Xor^=nums1[i];\\n            for(int i=0;i<n2;i++)Xor^=nums2[i];\\n        }\\n        return Xor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size();int n2=nums2.size();\\n        int Xor=0;\\n        if(n1%2==0 && n2%2==0)return 0;\\n         if(n2%2==0)\\n        {\\n            for(int i=0;i<n2;i++)Xor^=nums2[i];\\n        }\\n        else if(n1%2==0)\\n        {\\n            for(int i=0;i<n1;i++)Xor^=nums1[i];\\n        }\\n        else if(n1%2==1 && n2%2==1)\\n        {\\n            for(int i=0;i<n1;i++)Xor^=nums1[i];\\n            for(int i=0;i<n2;i++)Xor^=nums2[i];\\n        }\\n        return Xor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767999,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef int ll;\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        ll n = nums1.size();\\n        ll m = nums2.size();\\n        ll ans = 0;\\n        if(n%2==0 && m%2==0)return ans;\\n        if(n%2==0 && m%2==1)\\n        {\\n            for(ll i = 0;i<n;i++)ans^=nums1[i];\\n            return ans;\\n        }\\n        if(n%2==1 && m%2==0)\\n        {\\n            for(ll i = 0;i<m;i++)ans^=nums2[i];\\n            return ans;\\n        }\\n        for(ll i = 0;i<n;i++)ans^=nums1[i];\\n        for(ll i = 0;i<m;i++)ans^=nums2[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef int ll;\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        ll n = nums1.size();\\n        ll m = nums2.size();\\n        ll ans = 0;\\n        if(n%2==0 && m%2==0)return ans;\\n        if(n%2==0 && m%2==1)\\n        {\\n            for(ll i = 0;i<n;i++)ans^=nums1[i];\\n            return ans;\\n        }\\n        if(n%2==1 && m%2==0)\\n        {\\n            for(ll i = 0;i<m;i++)ans^=nums2[i];\\n            return ans;\\n        }\\n        for(ll i = 0;i<n;i++)ans^=nums1[i];\\n        for(ll i = 0;i<m;i++)ans^=nums2[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762869,
                "title": "very-easy-solution-by-using-xor-property",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy using **XOR** property (i.e a^a = 0  and  a^a^a = a) means number xor to itself by **k** times gives either **0** or that **number itself** which is depend on k is either **even** or **odd** respectively. \\n\\n# Complexity\\n- Time complexity:**O(n+m)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int len1 = nums1.size();\\n        int len2 = nums2.size();\\n        int ans = 0;\\n           \\n          for(int i = 0; i < len1; i++){\\n                  if(len2%2==1) ans = ans^nums1[i];\\n                  else ans = ans^0;\\n          }\\n            for(int i = 0; i < len2; i++){\\n                  if(len1%2==1) ans = ans^nums2[i];\\n                  else ans = ans^0;\\n          }\\n            \\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int len1 = nums1.size();\\n        int len2 = nums2.size();\\n        int ans = 0;\\n           \\n          for(int i = 0; i < len1; i++){\\n                  if(len2%2==1) ans = ans^nums1[i];\\n                  else ans = ans^0;\\n          }\\n            for(int i = 0; i < len2; i++){\\n                  if(len1%2==1) ans = ans^nums2[i];\\n                  else ans = ans^0;\\n          }\\n            \\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728858,
                "title": "very-simple-java-solution-with-xor-theory-and-example",
                "content": "**Approach**\\nWe use the XOR concept to solve the problem\\nXOR of 2 same numbers =0\\n5^5=0\\nso if the size of the second array is even then all the elements of first array would repeat itself even number of times so they would all cancel out themselves\\nsame goes for the first array\\nnow if the length of the second array is odd then every element of the first array repeats itself for odd number of times\\nfor eg say 9 times \\nthey could form 4 pairs and cancel each other out so the remaining would be one occurance of each element \\n\\nThe problem reduces to :\\nEither we wont consider the array at all or \\nWe will consider just 1 occurance of every element\\n![image](https://assets.leetcode.com/users/images/efc21ffc-517f-4c91-82a1-ecf619fbd2c4_1688670113.7245362.png)\\n![image](https://assets.leetcode.com/users/images/277ce37a-4403-4933-9614-2c853ec9101a_1688670120.8901935.png)\\n\\n\\n**Code**\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor=0;\\n        if(nums2.length%2==1)\\n        {\\n            for(int i=0;i<nums1.length;i++)\\n                xor^=nums1[i];\\n        }\\n        if(nums1.length%2==1)\\n        {\\n            for(int i=0;i<nums2.length;i++)\\n                xor^=nums2[i];\\n        }\\n        return xor;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor=0;\\n        if(nums2.length%2==1)\\n        {\\n            for(int i=0;i<nums1.length;i++)\\n                xor^=nums1[i];\\n        }\\n        if(nums1.length%2==1)\\n        {\\n            for(int i=0;i<nums2.length;i++)\\n                xor^=nums2[i];\\n        }\\n        return xor;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699018,
                "title": "1ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int a=nums1.length;\\n        int b=nums2.length;\\n        if(a%2==0 && b%2==0){\\n            return 0;\\n        }else if(a%2==1 && b%2==1){\\n            return xor(nums1)^xor(nums2);\\n        }else if(a%2==0 && b%2==1){\\n            return xor(nums1);\\n        }\\n        return xor(nums2);\\n    }\\n    public int xor(int []nums){\\n        int total=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            total^=nums[i];\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int a=nums1.length;\\n        int b=nums2.length;\\n        if(a%2==0 && b%2==0){\\n            return 0;\\n        }else if(a%2==1 && b%2==1){\\n            return xor(nums1)^xor(nums2);\\n        }else if(a%2==0 && b%2==1){\\n            return xor(nums1);\\n        }\\n        return xor(nums2);\\n    }\\n    public int xor(int []nums){\\n        int total=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            total^=nums[i];\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684992,
                "title": "java-optimized-solution-beats-100-4-if-cases-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        //If both array has even number of elements\\n        if(nums1.length%2==0 && nums2.length%2==0)\\n            return 0;\\n\\n        //if num2 has odd elements and num1 has even\\n        int xor1=0;\\n        for(int i=0;i<nums1.length;i++)\\n            xor1=xor1^nums1[i];\\n        if(nums1.length%2==0 && nums2.length%2!=0)\\n            return xor1;\\n\\n        //if num2 has odd elements and num1 has even\\n        int xor2=0;\\n        for(int i=0;i<nums2.length;i++)\\n            xor2=xor2^nums2[i];\\n        if(nums1.length%2!=0 && nums2.length%2==0)\\n            return xor2;\\n            \\n        //if both has odd elements\\n        return xor1^xor2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        //If both array has even number of elements\\n        if(nums1.length%2==0 && nums2.length%2==0)\\n            return 0;\\n\\n        //if num2 has odd elements and num1 has even\\n        int xor1=0;\\n        for(int i=0;i<nums1.length;i++)\\n            xor1=xor1^nums1[i];\\n        if(nums1.length%2==0 && nums2.length%2!=0)\\n            return xor1;\\n\\n        //if num2 has odd elements and num1 has even\\n        int xor2=0;\\n        for(int i=0;i<nums2.length;i++)\\n            xor2=xor2^nums2[i];\\n        if(nums1.length%2!=0 && nums2.length%2==0)\\n            return xor2;\\n            \\n        //if both has odd elements\\n        return xor1^xor2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684542,
                "title": "simple-observation-xor-property-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        int xori = 0;\\n        if(n1 & 1) {\\n            for(auto &num:nums2) xori ^= num;\\n        }\\n        if(n2 & 1) {\\n            for(auto &num:nums1) xori ^= num;\\n        }\\n        return xori;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        int xori = 0;\\n        if(n1 & 1) {\\n            for(auto &num:nums2) xori ^= num;\\n        }\\n        if(n2 & 1) {\\n            for(auto &num:nums1) xori ^= num;\\n        }\\n        return xori;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678129,
                "title": "100-faster-solution-using-simple-bit-manipulation-and-observation",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        \\n        int n1 = nums1.length;\\n\\n        int n2 = nums2.length;\\n\\n        if( (n1 & 1) == 0 && (n2 & 1) == 0 ) return 0;\\n        else if( (n1 & 1) == 1 && (n2 & 1) == 1  ){\\n            int xor = 0;\\n            for( int e : nums1 ){\\n                xor ^= e;\\n            }\\n            for( int e : nums2 ){\\n                xor ^= e;\\n            }\\n            return xor;\\n        }\\n        else if( (n1 & 1 ) == 1 ){\\n            int xor = 0;\\n            for( int e : nums2 ){\\n                xor ^= e;\\n            }\\n            return xor;\\n        }\\n        int xor = 0;\\n        for( int e : nums1 ){\\n            xor ^= e;\\n        }\\n        return xor;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        \\n        int n1 = nums1.length;\\n\\n        int n2 = nums2.length;\\n\\n        if( (n1 & 1) == 0 && (n2 & 1) == 0 ) return 0;\\n        else if( (n1 & 1) == 1 && (n2 & 1) == 1  ){\\n            int xor = 0;\\n            for( int e : nums1 ){\\n                xor ^= e;\\n            }\\n            for( int e : nums2 ){\\n                xor ^= e;\\n            }\\n            return xor;\\n        }\\n        else if( (n1 & 1 ) == 1 ){\\n            int xor = 0;\\n            for( int e : nums2 ){\\n                xor ^= e;\\n            }\\n            return xor;\\n        }\\n        int xor = 0;\\n        for( int e : nums1 ){\\n            xor ^= e;\\n        }\\n        return xor;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677214,
                "title": "java-easy-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2)\\n    {\\n       int len1 = nums1.length;\\n       int len2 = nums2.length;\\n      \\n       if(len1 %2 == 0 && len2 % 2 == 0)\\n       {\\n           return 0;\\n       }     \\n      else if(len1 % 2 != 0 && len2 % 2 == 0)\\n       {\\n            int xor = 0;\\n            for(int i = 0;i<len2;i++)\\n            {\\n                xor = xor ^ nums2[i];\\n            }\\n            return xor;\\n       }\\n       else\\n       {\\n            int xor = 0;\\n            int xor2 = 0;\\n            for(int i = 0;i<len2;i++)\\n            {\\n                xor = xor ^ nums2[i];\\n            }\\n            for(int i = 0;i<len1;i++)\\n            {\\n               xor2 = xor2 ^ nums1[i]^xor;\\n            }\\n            return xor2;\\n       }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2)\\n    {\\n       int len1 = nums1.length;\\n       int len2 = nums2.length;\\n      \\n       if(len1 %2 == 0 && len2 % 2 == 0)\\n       {\\n           return 0;\\n       }     \\n      else if(len1 % 2 != 0 && len2 % 2 == 0)\\n       {\\n            int xor = 0;\\n            for(int i = 0;i<len2;i++)\\n            {\\n                xor = xor ^ nums2[i];\\n            }\\n            return xor;\\n       }\\n       else\\n       {\\n            int xor = 0;\\n            int xor2 = 0;\\n            for(int i = 0;i<len2;i++)\\n            {\\n                xor = xor ^ nums2[i];\\n            }\\n            for(int i = 0;i<len1;i++)\\n            {\\n               xor2 = xor2 ^ nums1[i]^xor;\\n            }\\n            return xor2;\\n       }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656042,
                "title": "c-easy-bit-manipulation",
                "content": "n1->length of nums1 \\nn2->length of nums2\\n\\nxor property : if both element is same then result will be 0\\n\\n**case 1:** both n1 and n2 even -> all element from both side will generate pair and become 0\\n\\n**case 2:** if both n1 and n2 odd -> single element from both array remaining so ans is xor of both arrays\\n\\n**case 3:** if any array has odd length will generate opposite array element xor \\nso if n1 id odd return xor of nums2 and vice versa\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size(),n2=nums2.size();\\n        if(n1%2==0 && n2%2==0) return 0;\\n        int x1=0,x2=0;\\n        for(int i=0;i<n1;i++){\\n            x1^=nums1[i];\\n        }\\n        for(int i=0;i<n2;i++){\\n            x2^=nums2[i];\\n        }\\n        if(n1%2!=0 && n2%2!=0) return x1^x2;\\n        if(n1%2==0 && n2%2!=0) return x1;\\n        return x2;\\n        \\n    }\\n};\\n```\\n\\nIf you understood please upvote :))",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size(),n2=nums2.size();\\n        if(n1%2==0 && n2%2==0) return 0;\\n        int x1=0,x2=0;\\n        for(int i=0;i<n1;i++){\\n            x1^=nums1[i];\\n        }\\n        for(int i=0;i<n2;i++){\\n            x2^=nums2[i];\\n        }\\n        if(n1%2!=0 && n2%2!=0) return x1^x2;\\n        if(n1%2==0 && n2%2!=0) return x1;\\n        return x2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597142,
                "title": "simple-java-approach-100-beats-1ms-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] n1, int[] n2) {\\n        int fx=0,sx=0;\\n        //xor of all elements in first array\\n        for(int i:n1){\\n            fx^=i;\\n        }\\n        //xor of all elements in second array\\n        for(int i:n2)\\n        {\\n            sx^=i;\\n        }\\n        //if lengths of both arrays are even then return 0\\n        if(n1.length%2==0&&n2.length%2==0)return 0;\\n        if(n1.length%2==0)return fx;\\n        if(n2.length%2==0)return sx;\\n        return fx^sx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] n1, int[] n2) {\\n        int fx=0,sx=0;\\n        //xor of all elements in first array\\n        for(int i:n1){\\n            fx^=i;\\n        }\\n        //xor of all elements in second array\\n        for(int i:n2)\\n        {\\n            sx^=i;\\n        }\\n        //if lengths of both arrays are even then return 0\\n        if(n1.length%2==0&&n2.length%2==0)return 0;\\n        if(n1.length%2==0)return fx;\\n        if(n2.length%2==0)return sx;\\n        return fx^sx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582922,
                "title": "java-100-faster-with-explanation",
                "content": "# Intuition\\nHere you should think of the property of xor operation. When it is applied to 2 equal numbers, then the result is 0. \\n\\nCase 1: \\nIf first array has even number of elements, it means that xor applied even number of times to the elements from the second array. This means that we will have only first elements left. As a result we apply xor to all elements from the first array.\\n\\nSuppose that we have nums1 = {a1, a2} and nums2 = {b1, b2, b3}.\\nNext step is: (a1 ^ b1) ^ (a1 ^ b2) ^ (a1 ^ b3) ^ (a2 ^ b1) ^ (a2 ^ b2) ^ (a2 ^ b3).\\nWe can open brackets and change the order:\\n(b1 ^ b1) ^ (b2 ^ b2) ^ (b3 ^ b3) ^ (a1 ^ a1) ^ a1 ^ (a2 ^ a2) ^ a2 =\\n0 ^ 0 ^ 0 ^ 0 ^ a1 ^ 0 ^ a2 = a1 ^ a2.\\nSo, you just need to find xor applied to the nums1 (or the array with even number of elements).\\n\\nOther 3 cases you can check for yourself. Same logic applied.\\n\\n# Complexity\\n- Time complexity: O(N + M)\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = 0;\\n        if (nums1.length % 2 == 0 && nums2.length % 2 == 0) return xor;\\n        if (nums1.length % 2 == 0) {\\n            for (int n : nums1) xor ^= n;\\n            return xor;\\n        } else if (nums2.length % 2 == 0) {\\n            for (int n : nums2) xor ^= n;\\n            return xor;\\n        }\\n        for (int n : nums1) xor ^= n;\\n        for (int n : nums2) xor ^= n;\\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor = 0;\\n        if (nums1.length % 2 == 0 && nums2.length % 2 == 0) return xor;\\n        if (nums1.length % 2 == 0) {\\n            for (int n : nums1) xor ^= n;\\n            return xor;\\n        } else if (nums2.length % 2 == 0) {\\n            for (int n : nums2) xor ^= n;\\n            return xor;\\n        }\\n        for (int n : nums1) xor ^= n;\\n        for (int n : nums2) xor ^= n;\\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575738,
                "title": "easy-o-m-n-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        a, b = nums1, nums2\\n        if len(b) < len(a):\\n            a, b = b, a\\n        l1 = len(a)\\n        l2 = len(b)\\n        res = 0\\n        \\n        if l1 % 2 == 1:\\n            for i in b:\\n                res = res ^ i\\n        if l2 % 2 == 1:\\n            for i in a:\\n                res = res ^ i\\n        return res     \\n\\n\\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        a, b = nums1, nums2\\n        if len(b) < len(a):\\n            a, b = b, a\\n        l1 = len(a)\\n        l2 = len(b)\\n        res = 0\\n        \\n        if l1 % 2 == 1:\\n            for i in b:\\n                res = res ^ i\\n        if l2 % 2 == 1:\\n            for i in a:\\n                res = res ^ i\\n        return res     \\n\\n\\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574408,
                "title": "python-3-easiest-1-liner-top-97",
                "content": "# Intuition\\nXor of a number with itself is 0, so we are looking for lists with odd length\\n\\n# Code\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        # nums1[1] will appear len(nums2) times, same for every element in nums1\\n        # for elements in nums2 the answer is len(nums1)      \\n        return (reduce(operator.xor, nums1) if len(nums2) % 2 else 0) ^ (reduce(operator.xor, nums2) if len(nums1) % 2 else 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        # nums1[1] will appear len(nums2) times, same for every element in nums1\\n        # for elements in nums2 the answer is len(nums1)      \\n        return (reduce(operator.xor, nums1) if len(nums2) % 2 else 0) ^ (reduce(operator.xor, nums2) if len(nums1) % 2 else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570124,
                "title": "simple-bits-storage-and-iteration",
                "content": "# Complexity\\n- Time complexity:\\nO((n+m)*32)\\n\\n- Space complexity:\\nO((n+m)*32)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<ll>> bits(n+m, vector<ll>(31, 0));\\n        for(int i = 0;i<n;i++){\\n            int x = nums1[i], j = 0;\\n            while(x){\\n                if(x&1)bits[i][j] = m;\\n                if(x<=1)break;\\n                x/=2;\\n                j++;\\n            }\\n        }\\n        \\n        for(int i = 0;i<m;i++){\\n            int x = nums2[i], j = 0;\\n            while(x){\\n                if(x&1)bits[i+n][j] = n;\\n                if(x<=1)break;\\n                x/=2;\\n                j++;\\n            }\\n        }\\n        \\n        vector<ll> help(31, 0);\\n        for(int i = 0;i<bits[0].size();i++){\\n            for(int j = 0;j<bits.size();j++){\\n                help[i] += bits[j][i];\\n            }\\n        }\\n        \\n        ll ans = 0;\\n        for(int i = 0;i<help.size();i++){\\n            if(help[i]%2 == 1)\\n                ans = ans + 1ll*pow(2, i);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<ll>> bits(n+m, vector<ll>(31, 0));\\n        for(int i = 0;i<n;i++){\\n            int x = nums1[i], j = 0;\\n            while(x){\\n                if(x&1)bits[i][j] = m;\\n                if(x<=1)break;\\n                x/=2;\\n                j++;\\n            }\\n        }\\n        \\n        for(int i = 0;i<m;i++){\\n            int x = nums2[i], j = 0;\\n            while(x){\\n                if(x&1)bits[i+n][j] = n;\\n                if(x<=1)break;\\n                x/=2;\\n                j++;\\n            }\\n        }\\n        \\n        vector<ll> help(31, 0);\\n        for(int i = 0;i<bits[0].size();i++){\\n            for(int j = 0;j<bits.size();j++){\\n                help[i] += bits[j][i];\\n            }\\n        }\\n        \\n        ll ans = 0;\\n        for(int i = 0;i<help.size();i++){\\n            if(help[i]%2 == 1)\\n                ans = ans + 1ll*pow(2, i);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552836,
                "title": "c-o-n-m-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        if (size(nums2) % 2)\\n            for (int& x : nums1)\\n                ans ^= x;\\n        if (size(nums1) % 2)\\n            for (int& x : nums2)\\n                ans ^= x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        if (size(nums2) % 2)\\n            for (int& x : nums1)\\n                ans ^= x;\\n        if (size(nums1) % 2)\\n            for (int& x : nums2)\\n                ans ^= x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543031,
                "title": "o-n-java-solution-bit-manipulation-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res1=0;\\n        int res2=0;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            res1^=nums1[i];\\n        }\\n         for(int i=0;i<nums2.length;i++)\\n        {\\n            res2^=nums2[i];\\n        }\\n          if(nums1.length%2!=0&&nums2.length%2!=0)\\n          return res1^res2;\\n          else if(nums2.length%2!=0)\\n          return res1;\\n          else if(nums1.length%2!=0)\\n          return res2;\\n           return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int res1=0;\\n        int res2=0;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            res1^=nums1[i];\\n        }\\n         for(int i=0;i<nums2.length;i++)\\n        {\\n            res2^=nums2[i];\\n        }\\n          if(nums1.length%2!=0&&nums2.length%2!=0)\\n          return res1^res2;\\n          else if(nums2.length%2!=0)\\n          return res1;\\n          else if(nums1.length%2!=0)\\n          return res2;\\n           return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495582,
                "title": "java-100-1ms-bitwise-xor-of-all-pairings",
                "content": "```\\nclass Solution {\\n    int xor(int[] a)\\n    {\\n        int temp=a[0];\\n        for(int i=1;i<a.length;i++)\\n        {\\n            temp^=a[i];\\n        }\\n        return temp;\\n    }\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n           int n=nums1.length;\\n        int m=nums2.length;\\n        if(n%2==0&& m%2==0)return 0;\\n        else if(n%2==0)return xor(nums1);\\n        else if(m%2==0)return xor(nums2);\\n        else return (xor(nums1)^xor(nums2));\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int xor(int[] a)\\n    {\\n        int temp=a[0];\\n        for(int i=1;i<a.length;i++)\\n        {\\n            temp^=a[i];\\n        }\\n        return temp;\\n    }\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n           int n=nums1.length;\\n        int m=nums2.length;\\n        if(n%2==0&& m%2==0)return 0;\\n        else if(n%2==0)return xor(nums1);\\n        else if(m%2==0)return xor(nums2);\\n        else return (xor(nums1)^xor(nums2));\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430286,
                "title": "easy-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n$$x^x=0,0^x=x$$, only the number of nums1 and nums2 matters\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size();\\n        if(n%2==0 and m%2==0) return 0;\\n        int result=0;\\n        if(n%2){\\n            for(auto c:nums2) result^=c;\\n        }\\n        if(m%2){\\n            for(auto c:nums1) result^=c;\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size(),m=nums2.size();\\n        if(n%2==0 and m%2==0) return 0;\\n        int result=0;\\n        if(n%2){\\n            for(auto c:nums2) result^=c;\\n        }\\n        if(m%2){\\n            for(auto c:nums1) result^=c;\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395637,
                "title": "java-easy-solution",
                "content": "Here a function to calculate the XOR of the array is made.\\n\\nIf the size of both the arrays are even then all the numbers will be repeated more than once hence producing the result to be 0 (XOR of same elements = 0).\\n\\nIf anyone of the arrays length is even then the XOR of that array is calculated as all the elements of the odd size array will repeat even times.\\n\\nIf the length of both arrays is odd then return the XOR of XOR of both array.\\n\\n# Code\\n```\\nclass Solution {\\n    public int XOR(int[] arr){\\n        int res = 0;\\n        for(int i = 0;i<arr.length;i++){\\n            res ^= arr[i];\\n        }\\n        return res;\\n    }\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int size1 = nums1.length;\\n        int size2 = nums2.length;\\n        if(size1%2 == 0 && size2%2== 0) return 0;\\n       if(size1%2 == 0) return XOR(nums1);\\n       else if(size2%2 == 0) return XOR(nums2);\\n        return XOR(nums1)^XOR(nums2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int XOR(int[] arr){\\n        int res = 0;\\n        for(int i = 0;i<arr.length;i++){\\n            res ^= arr[i];\\n        }\\n        return res;\\n    }\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int size1 = nums1.length;\\n        int size2 = nums2.length;\\n        if(size1%2 == 0 && size2%2== 0) return 0;\\n       if(size1%2 == 0) return XOR(nums1);\\n       else if(size2%2 == 0) return XOR(nums2);\\n        return XOR(nums1)^XOR(nums2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383682,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBit manipulation \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int ans =  0;\\n        if(nums2.length%2==1){\\n            for(int i=0;i<nums1.length;i++)ans^=nums1[i];\\n        }\\n        if(nums1.length%2==1){\\n            for(int i=0;i<nums2.length;i++)ans^=nums2[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int ans =  0;\\n        if(nums2.length%2==1){\\n            for(int i=0;i<nums1.length;i++)ans^=nums1[i];\\n        }\\n        if(nums1.length%2==1){\\n            for(int i=0;i<nums2.length;i++)ans^=nums2[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366047,
                "title": "easy-logical-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int x=0;\\n        int y=0;\\n        for(auto it:nums1){\\n            x^=it;\\n        }\\n        for(auto it:nums2){\\n            y^=it;\\n        }\\n        int ans=0;\\n        if(n%2==0){\\n            if(m%2==0){\\n                ans=0;\\n            }\\n            else{\\n                ans=x;\\n            }\\n\\n        }else{\\n            if(m%2==0){\\n                ans=y;\\n            }\\n            else{\\n                ans=x^y;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int x=0;\\n        int y=0;\\n        for(auto it:nums1){\\n            x^=it;\\n        }\\n        for(auto it:nums2){\\n            y^=it;\\n        }\\n        int ans=0;\\n        if(n%2==0){\\n            if(m%2==0){\\n                ans=0;\\n            }\\n            else{\\n                ans=x;\\n            }\\n\\n        }else{\\n            if(m%2==0){\\n                ans=y;\\n            }\\n            else{\\n                ans=x^y;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365969,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size() ;\\n        int n2 = nums2.size() ;\\n        vector<int>bit(31) ;\\n        if(n2%2){\\n            for(int i = 0; i < n1; i++){\\n                int k = nums1[i] ;\\n                int idx = 0 ;\\n                while(k > 0){\\n                    if(k % 2)\\n                        bit[idx] = 1 - bit[idx] ;\\n                    k /= 2 ;\\n                    idx++ ;\\n                }\\n            }\\n        }\\n        if(n1 %2){\\n            for(int i = 0; i < n2; i++){\\n                int k = nums2[i] ;\\n                int idx = 0 ;\\n                while(k > 0){\\n                    if(k % 2)\\n                        bit[idx] = 1 - bit[idx] ;\\n                    k /= 2 ;\\n                    idx++ ;\\n                }\\n            }\\n        }\\n        int ret = 0 ;\\n        for(int i = 0; i < 31; i++){\\n            ret += (bit[i] << i) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size() ;\\n        int n2 = nums2.size() ;\\n        vector<int>bit(31) ;\\n        if(n2%2){\\n            for(int i = 0; i < n1; i++){\\n                int k = nums1[i] ;\\n                int idx = 0 ;\\n                while(k > 0){\\n                    if(k % 2)\\n                        bit[idx] = 1 - bit[idx] ;\\n                    k /= 2 ;\\n                    idx++ ;\\n                }\\n            }\\n        }\\n        if(n1 %2){\\n            for(int i = 0; i < n2; i++){\\n                int k = nums2[i] ;\\n                int idx = 0 ;\\n                while(k > 0){\\n                    if(k % 2)\\n                        bit[idx] = 1 - bit[idx] ;\\n                    k /= 2 ;\\n                    idx++ ;\\n                }\\n            }\\n        }\\n        int ret = 0 ;\\n        for(int i = 0; i < 31; i++){\\n            ret += (bit[i] << i) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341594,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        if(nums1.size()%2==0 && nums2.size()%2==0){\\n            return 0;\\n        }\\n        if(nums1.size()%2==0 ||nums2.size()%2!=0){\\n        for(int i=0;i<nums1.size();i++){\\n            ans^=nums1[i];\\n        }\\n        }\\n        if(nums2.size()%2==0 || nums1.size()%2!=0){\\n        for(int j=0;j<nums2.size();j++){\\n            ans^=nums2[j];\\n        }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        if(nums1.size()%2==0 && nums2.size()%2==0){\\n            return 0;\\n        }\\n        if(nums1.size()%2==0 ||nums2.size()%2!=0){\\n        for(int i=0;i<nums1.size();i++){\\n            ans^=nums1[i];\\n        }\\n        }\\n        if(nums2.size()%2==0 || nums1.size()%2!=0){\\n        for(int j=0;j<nums2.size();j++){\\n            ans^=nums2[j];\\n        }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336705,
                "title": "c-xor",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size(), n2=nums2.size();\\n        int ans = 0;\\n        \\n        if(n2%2==1){\\n            for(int val:nums1){\\n                ans^=val;\\n            }\\n        }\\n\\n        if(n1%2==1){\\n            for(int val:nums2){\\n                ans^=val;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size(), n2=nums2.size();\\n        int ans = 0;\\n        \\n        if(n2%2==1){\\n            for(int val:nums1){\\n                ans^=val;\\n            }\\n        }\\n\\n        if(n1%2==1){\\n            for(int val:nums2){\\n                ans^=val;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311543,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int len1 = nums1.length , len2 = nums2.length ;\\n        int xor1 = 0 , xor2 = 0 ;\\n        \\n        if(len2%2 != 0) for(int nums : nums1) xor1 ^= nums ;\\n        if(len1%2 != 0) for(int nums : nums2) xor2 ^= nums ;\\n        \\n        return xor1 ^ xor2 ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int len1 = nums1.length , len2 = nums2.length ;\\n        int xor1 = 0 , xor2 = 0 ;\\n        \\n        if(len2%2 != 0) for(int nums : nums1) xor1 ^= nums ;\\n        if(len1%2 != 0) for(int nums : nums2) xor2 ^= nums ;\\n        \\n        return xor1 ^ xor2 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303119,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func xorAllNums(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        switch (nums1.count % 2, nums2.count % 2) {\\n        case (0, 0): return 0\\n        case (1, 0): return nums2.reduce(0, ^)\\n        case (0, 1): return nums1.reduce(0, ^)\\n        default: return (nums1 + nums2).reduce(0, ^)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func xorAllNums(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        switch (nums1.count % 2, nums2.count % 2) {\\n        case (0, 0): return 0\\n        case (1, 0): return nums2.reduce(0, ^)\\n        case (0, 1): return nums1.reduce(0, ^)\\n        default: return (nums1 + nums2).reduce(0, ^)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288595,
                "title": "easy-to-read-c-code",
                "content": "# Intuition\\nread code\\n\\n# Approach\\nread code\\n\\n# Complexity\\n- Time complexity: read code\\n- Space complexity: read code\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        if(n1%2 == 0 && n2%2 == 0)return 0;\\n        \\n        int xor1 = nums1[0];\\n        int xor2 = nums2[0];\\n        for(int i = 1; i < nums1.size(); i++)xor1 ^= nums1[i];\\n        for(int i = 1; i < nums2.size(); i++)xor2 ^= nums2[i];\\n        \\n        if(n1%2 != 0 && n2%2 == 0)return xor2;\\n        if(n1%2 == 0 && n2%2 != 0)return xor1;\\n        \\n        return xor1^xor2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        if(n1%2 == 0 && n2%2 == 0)return 0;\\n        \\n        int xor1 = nums1[0];\\n        int xor2 = nums2[0];\\n        for(int i = 1; i < nums1.size(); i++)xor1 ^= nums1[i];\\n        for(int i = 1; i < nums2.size(); i++)xor2 ^= nums2[i];\\n        \\n        if(n1%2 != 0 && n2%2 == 0)return xor2;\\n        if(n1%2 == 0 && n2%2 != 0)return xor1;\\n        \\n        return xor1^xor2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284887,
                "title": "c-even-odd",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size() % 2 == 0 && nums2.size() % 2 == 0) return 0;\\n        int ans = 0;\\n        if(nums1.size() % 2 == 1)\\n            for(int i = 0; i < nums2.size(); i++) ans ^= nums2[i];\\n        if(nums2.size() % 2 == 1)\\n            for(int i = 0; i < nums1.size(); i++) ans ^= nums1[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size() % 2 == 0 && nums2.size() % 2 == 0) return 0;\\n        int ans = 0;\\n        if(nums1.size() % 2 == 1)\\n            for(int i = 0; i < nums2.size(); i++) ans ^= nums2[i];\\n        if(nums2.size() % 2 == 1)\\n            for(int i = 0; i < nums1.size(); i++) ans ^= nums1[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280556,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        if(nums1.size()%2==0 && nums2.size()%2==0) return 0;\\n        if(nums1.size()%2==0)\\n        {\\n            int xo=0;\\n            for(auto it: nums1) xo^=it;\\n            return xo;\\n        }\\n        else if(nums2.size()%2==0)\\n        {\\n            int xo=0;\\n            for(auto it: nums2) xo^=it;\\n            return xo;\\n        }\\n        else\\n        {\\n            int xo=0;\\n            for(auto it: nums1) xo^=it;\\n            for(auto it: nums2) xo^=it;\\n            return xo;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        if(nums1.size()%2==0 && nums2.size()%2==0) return 0;\\n        if(nums1.size()%2==0)\\n        {\\n            int xo=0;\\n            for(auto it: nums1) xo^=it;\\n            return xo;\\n        }\\n        else if(nums2.size()%2==0)\\n        {\\n            int xo=0;\\n            for(auto it: nums2) xo^=it;\\n            return xo;\\n        }\\n        else\\n        {\\n            int xo=0;\\n            for(auto it: nums1) xo^=it;\\n            for(auto it: nums2) xo^=it;\\n            return xo;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253974,
                "title": "java-100-faster-no-any-space-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/58992422-0b3e-4640-be1a-6afaed326075_1677892137.3886273.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int xor(int[] nums) {\\n        int res = 0;\\n        for (int num : nums) {\\n            res ^= num;\\n        }\\n        return res;\\n    }\\n\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        if (nums1.length % 2 == 0 && nums2.length % 2 == 0) { // if both arrays have even length\\n            return 0;\\n        }\\n        int xorone = xor(nums1), xortwo = xor(nums2);\\n        // if both arrays have odd length then xor of both arrays is the answer or else\\n        // xor of one even length array is the answer\\n        return nums1.length % 2 == 1 && nums2.length % 2 == 1 ? xorone ^ xortwo\\n                : (nums1.length % 2 != 0 ? xortwo : xorone);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int xor(int[] nums) {\\n        int res = 0;\\n        for (int num : nums) {\\n            res ^= num;\\n        }\\n        return res;\\n    }\\n\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        if (nums1.length % 2 == 0 && nums2.length % 2 == 0) { // if both arrays have even length\\n            return 0;\\n        }\\n        int xorone = xor(nums1), xortwo = xor(nums2);\\n        // if both arrays have odd length then xor of both arrays is the answer or else\\n        // xor of one even length array is the answer\\n        return nums1.length % 2 == 1 && nums2.length % 2 == 1 ? xorone ^ xortwo\\n                : (nums1.length % 2 != 0 ? xortwo : xorone);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246134,
                "title": "javascript-2425-bitwise-xor-of-all-pairings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\n// Fail - Time Limit Exceeded\\nvar xorAllNums = function (a, b) {\\n    let x = 0;\\n\\n    for (let e of a)\\n        for (let e2 of b) {\\n            x = x ^ e ^ e2;\\n        }\\n\\n    return x;\\n};\\n```\\n\\n2\\n```\\n// Pass\\nvar xorAllNums = function (a, b) {\\n    let x = 0;\\n\\n    if (a.length % 2 === 1)\\n        for (let e2 of b) {\\n            x = x ^ e2;\\n        }\\n\\n    if (b.length % 2 === 1)\\n        for (let e of a) {\\n            x = x ^ e;\\n        }\\n\\n    return x;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Fail - Time Limit Exceeded\\nvar xorAllNums = function (a, b) {\\n    let x = 0;\\n\\n    for (let e of a)\\n        for (let e2 of b) {\\n            x = x ^ e ^ e2;\\n        }\\n\\n    return x;\\n};\\n```\n```\\n// Pass\\nvar xorAllNums = function (a, b) {\\n    let x = 0;\\n\\n    if (a.length % 2 === 1)\\n        for (let e2 of b) {\\n            x = x ^ e2;\\n        }\\n\\n    if (b.length % 2 === 1)\\n        for (let e of a) {\\n            x = x ^ e;\\n        }\\n\\n    return x;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3226043,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int a=nums1[0];\\n        int b=nums2[0];\\n        for(int i=1;i<nums1.size();i++) a^=nums1[i];\\n        for(int i=1;i<nums2.size();i++) b^=nums2[i];\\n        // cout<<a<<\" \"<<b;\\n        if(nums1.size()%2==0 && nums2.size()%2==0) return 0;\\n        else if(nums1.size()%2 && nums2.size()%2==0)  return b;\\n        else if(nums1.size()%2==0 && nums2.size()%2) return a;\\n        return a^b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int a=nums1[0];\\n        int b=nums2[0];\\n        for(int i=1;i<nums1.size();i++) a^=nums1[i];\\n        for(int i=1;i<nums2.size();i++) b^=nums2[i];\\n        // cout<<a<<\" \"<<b;\\n        if(nums1.size()%2==0 && nums2.size()%2==0) return 0;\\n        else if(nums1.size()%2 && nums2.size()%2==0)  return b;\\n        else if(nums1.size()%2==0 && nums2.size()%2) return a;\\n        return a^b;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3211094,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int s=0;\\n        if(nums1.size()%2==1)\\n        {\\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                s=s^nums2[i];\\n            }\\n        }\\n        if(nums2.size()%2==1)\\n        {\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                s=s^nums1[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int s=0;\\n        if(nums1.size()%2==1)\\n        {\\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                s=s^nums2[i];\\n            }\\n        }\\n        if(nums2.size()%2==1)\\n        {\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                s=s^nums1[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186078,
                "title": "easy-solution-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int x = 0;\\n        int y = 0;\\n\\n        for(auto a : nums1) x ^= a;\\n        for(auto b : nums2) y ^= b;\\n\\n        return (nums1.size()%2 * y) ^ (nums2.size()%2 * x);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int x = 0;\\n        int y = 0;\\n\\n        for(auto a : nums1) x ^= a;\\n        for(auto b : nums2) y ^= b;\\n\\n        return (nums1.size()%2 * y) ^ (nums2.size()%2 * x);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167657,
                "title": "0ms-just-simple-and-easy-solution",
                "content": "# Intuition\\na little observation and yes pen paper is must <-- important\\n\\n# Approach\\nfind whether length of arrays are even or odd and rest is just cakewalk\\n\\n# Complexity\\n- Time complexity:\\nO(N+M)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n       int l1=nums1.size(),l2=nums2.size();\\n       int ans=0;\\n     if(!(l1&1) and !(l2&1))return 0;\\n     else if((l1&1) and (l2&1))\\n     {\\n       for(auto x:nums1)ans^=x;\\n       for(auto x:nums2)ans^=x;\\n       return ans;\\n     }\\n     else if((l1&1) and !(l2&1))\\n     {\\n       for(auto x:nums2)ans^=x;\\n       return ans;\\n     }\\n     else \\n     {\\n       for(auto x:nums1)ans^=x;\\n       return ans;\\n     }\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n       int l1=nums1.size(),l2=nums2.size();\\n       int ans=0;\\n     if(!(l1&1) and !(l2&1))return 0;\\n     else if((l1&1) and (l2&1))\\n     {\\n       for(auto x:nums1)ans^=x;\\n       for(auto x:nums2)ans^=x;\\n       return ans;\\n     }\\n     else if((l1&1) and !(l2&1))\\n     {\\n       for(auto x:nums2)ans^=x;\\n       return ans;\\n     }\\n     else \\n     {\\n       for(auto x:nums1)ans^=x;\\n       return ans;\\n     }\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166425,
                "title": "3-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& n1, vector<int>& n2) {\\n        int sol = 0;\\n        if(n2.size()%2 != 0)for(int i = 0; i < n1.size(); i++)sol ^= n1[i];\\n        if(n1.size()%2 != 0)for(int i = 0; i < n2.size(); i++)sol ^= n2[i];\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& n1, vector<int>& n2) {\\n        int sol = 0;\\n        if(n2.size()%2 != 0)for(int i = 0; i < n1.size(); i++)sol ^= n1[i];\\n        if(n1.size()%2 != 0)for(int i = 0; i < n2.size(); i++)sol ^= n2[i];\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154160,
                "title": "c-golang-brainteaser",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        if(nums1.size() % 2) {\\n            for(int num : nums2) ans ^= num;\\n        }\\n        if(nums2.size() % 2) {\\n            for(int num : nums1) ans ^= num;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc xorAllNums(nums1 []int, nums2 []int) int {\\n    var ans int = 0\\n    if len(nums1) % 2 == 1 {\\n        for _, num := range nums2 {ans ^= num}\\n    }\\n    if len(nums2) % 2 == 1 {\\n        for _, num := range nums1 {ans ^= num}\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        if(nums1.size() % 2) {\\n            for(int num : nums2) ans ^= num;\\n        }\\n        if(nums2.size() % 2) {\\n            for(int num : nums1) ans ^= num;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc xorAllNums(nums1 []int, nums2 []int) int {\\n    var ans int = 0\\n    if len(nums1) % 2 == 1 {\\n        for _, num := range nums2 {ans ^= num}\\n    }\\n    if len(nums2) % 2 == 1 {\\n        for _, num := range nums1 {ans ^= num}\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152966,
                "title": "simple-xor-properties-bitmagic-python",
                "content": "# Intuition and Approach\\n* simple question if you know the properties of xor.\\n* find size of both lists then calculate xor.\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        #size|realfreqofbothlist\\n        # o o  1 1\\n        # e e  0 0\\n        # o e  0 1\\n        # e o  1 0\\n        n1=len(nums1)\\n        n2=len(nums2)\\n        if(n1%2==1 and n2%2==1):\\n            # print(\"both1\")\\n            xor=0\\n            for i in nums1:\\n                xor=xor^i\\n            for i in nums2:\\n                xor=xor^i\\n            return xor\\n        if(n1&1):\\n            # print(n1)\\n            xor=0\\n            for i in nums2:\\n                xor=xor^i\\n            return xor\\n        if(n2&1):\\n            # print(n2)\\n            xor=0\\n            for i in nums1:\\n                xor=xor^i\\n            return xor\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        #size|realfreqofbothlist\\n        # o o  1 1\\n        # e e  0 0\\n        # o e  0 1\\n        # e o  1 0\\n        n1=len(nums1)\\n        n2=len(nums2)\\n        if(n1%2==1 and n2%2==1):\\n            # print(\"both1\")\\n            xor=0\\n            for i in nums1:\\n                xor=xor^i\\n            for i in nums2:\\n                xor=xor^i\\n            return xor\\n        if(n1&1):\\n            # print(n1)\\n            xor=0\\n            for i in nums2:\\n                xor=xor^i\\n            return xor\\n        if(n2&1):\\n            # print(n2)\\n            xor=0\\n            for i in nums1:\\n                xor=xor^i\\n            return xor\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150634,
                "title": "easiest-solution-c-just-4-conditions-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size()%2==0 && nums2.size()%2==0) return 0;\\n        else if(nums1.size()%2!=0 && nums2.size()%2==0){\\n            int temp = 0;\\n            for(auto i:nums2) temp^=i;\\n            return temp;\\n        }\\n        else if(nums2.size()%2!=0 && nums1.size()%2==0){\\n            int temp = 0;\\n            for(auto i:nums1) temp^=i;\\n            return temp;\\n        }\\n        int temp = 0;\\n        for(auto i:nums2) temp^=i;\\n        for(auto i:nums1) temp^=i;\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        if(nums1.size()%2==0 && nums2.size()%2==0) return 0;\\n        else if(nums1.size()%2!=0 && nums2.size()%2==0){\\n            int temp = 0;\\n            for(auto i:nums2) temp^=i;\\n            return temp;\\n        }\\n        else if(nums2.size()%2!=0 && nums1.size()%2==0){\\n            int temp = 0;\\n            for(auto i:nums1) temp^=i;\\n            return temp;\\n        }\\n        int temp = 0;\\n        for(auto i:nums2) temp^=i;\\n        for(auto i:nums1) temp^=i;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131986,
                "title": "o-n-complexity-o-1-memory",
                "content": "# Intuition\\nIf we have two arrays x and y, then te results of the method should be:\\n\\n**sum = (x[0]^y[0]) ^ (x[1]^y[0]) ^ ... ^ (x[x.length - 1]^y[0]) ^\\n(x[0]^y[1]) ^ (x[1]^y[1]) ^ ... ^ (x[x.length - 1]^y[1]) ^\\n....\\n(x[0]^y[y.length - 1]) ^ (x[1]^y[y.length - 1]) ^ ... ^ (x[x.length - 1]^y[y.length - 1])**\\n\\nLet\\'s have a look on each line in the formula above. As we know, the xor operation has the following properties: \\n\\n- for any number t => t^t = 0\\n- for any numbers a and b => a^b = b^a\\n\\nIt means that in the first line we may extract all y[0] in the separate term: y[0]^y[0]^y[0] .... ^y[0] = (x.length % 2)*y[0].\\n\\nWe may do the same for all lines. And also we may do the same for x[0], x[1], x[2] etc. \\n\\nThe final formula is:\\n**sum = (x.length % 2)\\\\*(y[0]^y[1]^...y[y.length - 1])^(y.length % 2)\\\\*(x[0]^x[1]^...x[x.length - 1])**\\n\\n\\n# Code\\n```\\nobject Solution {\\n  def xorAllNums(nums1: Array[Int], nums2: Array[Int]): Int = {\\n    (nums2.length % 2) * nums1.reduceLeft((a, b) => a ^ b) ^ (nums1.length % 2) * nums2.reduceLeft((a, b) => a ^ b)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def xorAllNums(nums1: Array[Int], nums2: Array[Int]): Int = {\\n    (nums2.length % 2) * nums1.reduceLeft((a, b) => a ^ b) ^ (nums1.length % 2) * nums2.reduceLeft((a, b) => a ^ b)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3106019,
                "title": "python3-simple-code-and-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        ans=0\\n        if(len(nums1)%2):\\n            for i in nums2:\\n                ans=ans^i\\n        if(len(nums2)%2):\\n            for i in nums1:\\n                ans=ans^i\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        ans=0\\n        if(len(nums1)%2):\\n            for i in nums2:\\n                ans=ans^i\\n        if(len(nums2)%2):\\n            for i in nums1:\\n                ans=ans^i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102064,
                "title": "c-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int xor1=0,xor2=0;\\n        if(nums2.size()%2!=0) \\n        {\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                xor1^=nums1[i];\\n            }\\n        }\\n        if(nums1.size()%2!=0) \\n        {\\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                xor2^=nums2[i];\\n            }\\n        }\\n   return xor1^xor2; }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int xor1=0,xor2=0;\\n        if(nums2.size()%2!=0) \\n        {\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                xor1^=nums1[i];\\n            }\\n        }\\n        if(nums1.size()%2!=0) \\n        {\\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                xor2^=nums2[i];\\n            }\\n        }\\n   return xor1^xor2; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099083,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        vector <int> v;\\n        if (m%2 == 0 && n%2 == 0) {\\n            return 0;\\n        }\\n        for (int x : nums1) {\\n            if (n % 2 != 0) {\\n                v.push_back(x);\\n            }\\n        }\\n        for (int x : nums2) {\\n            if (m % 2 != 0) {\\n                v.push_back(x);\\n            }\\n        }\\n        int xory = v[0] ^ v[1];\\n        for (int i = 2;i < v.size();i++) {\\n            xory ^= v[i];\\n        }\\n        return xory;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        vector <int> v;\\n        if (m%2 == 0 && n%2 == 0) {\\n            return 0;\\n        }\\n        for (int x : nums1) {\\n            if (n % 2 != 0) {\\n                v.push_back(x);\\n            }\\n        }\\n        for (int x : nums2) {\\n            if (m % 2 != 0) {\\n                v.push_back(x);\\n            }\\n        }\\n        int xory = v[0] ^ v[1];\\n        for (int i = 2;i < v.size();i++) {\\n            xory ^= v[i];\\n        }\\n        return xory;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099082,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        vector <int> v;\\n        if (m%2 == 0 && n%2 == 0) {\\n            return 0;\\n        }\\n        for (int x : nums1) {\\n            if (n % 2 != 0) {\\n                v.push_back(x);\\n            }\\n        }\\n        for (int x : nums2) {\\n            if (m % 2 != 0) {\\n                v.push_back(x);\\n            }\\n        }\\n        int xory = v[0] ^ v[1];\\n        for (int i = 2;i < v.size();i++) {\\n            xory ^= v[i];\\n        }\\n        return xory;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        vector <int> v;\\n        if (m%2 == 0 && n%2 == 0) {\\n            return 0;\\n        }\\n        for (int x : nums1) {\\n            if (n % 2 != 0) {\\n                v.push_back(x);\\n            }\\n        }\\n        for (int x : nums2) {\\n            if (m % 2 != 0) {\\n                v.push_back(x);\\n            }\\n        }\\n        int xory = v[0] ^ v[1];\\n        for (int i = 2;i < v.size();i++) {\\n            xory ^= v[i];\\n        }\\n        return xory;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080712,
                "title": "java-solution-beats-100-in-runtime",
                "content": "# Intuition\\nIf nums1 is of even length, then elements in nums1 will be XORed even times in result value, which will be zero. Same goes to nums2. So XORing the elements of an array when other array length is odd will be suitable approach.\\n\\n\\n# Complexity\\n- Time complexity: O(m+n) m and n are size of two arrays\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length, n2 = nums2.length;\\n        int res = 0;\\n        if(n1%2 == 1){\\n            for(int i:nums2) res ^= i;\\n        }\\n        if(n2%2 == 1){\\n            for(int i:nums1) res ^= i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1 = nums1.length, n2 = nums2.length;\\n        int res = 0;\\n        if(n1%2 == 1){\\n            for(int i:nums2) res ^= i;\\n        }\\n        if(n2%2 == 1){\\n            for(int i:nums1) res ^= i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064441,
                "title": "python-inbuilt-function",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        n1=0 if not len(nums2)%2 else reduce(xor,nums1)\\n        n2=0 if not len(nums1)%2 else reduce(xor,nums2)\\n        return n1^n2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        n1=0 if not len(nums2)%2 else reduce(xor,nums1)\\n        n2=0 if not len(nums1)%2 else reduce(xor,nums2)\\n        return n1^n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062591,
                "title": "java-bit-manipulation-xor-properties",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe xor operation between two equal numbers is always 0.\\n\\n **(a^b)^(c^d)=(a^b^c^d) xor property**\\n\\nWhen two arrays of length n1 and n2 are performed operation mentioned in the problem, there arises 4 cases.\\n1. If n1 is even and n2 is even xor is 0.\\n2. If n1 is odd and n2 is even xor is xor of nums2.\\n3. If n1 is even and n2 is odd xor is xor of nums1.\\n4. If n1 is odd and n2 is odd xor value is xor of both nums1 and nums2.\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Initialise variable xor to 0.\\n2. If nums1 length is odd perform xor operations of **nums2** array.\\n3. If nums2 length is odd perform xor operations of **nums1** array.\\n4. return xor\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n1+n2)$$, where $$n1=nums1.length, n2=nums2.length$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n\\n        int xor=0;\\n\\n        if((nums1.length&1)==1)\\n        {\\n            for(int i:nums2)\\n            xor^=i;\\n        }\\n\\n        if((nums2.length&1)==1)\\n        {\\n            for(int i:nums1)\\n            xor^=i;\\n        }\\n\\n        return xor;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n\\n        int xor=0;\\n\\n        if((nums1.length&1)==1)\\n        {\\n            for(int i:nums2)\\n            xor^=i;\\n        }\\n\\n        if((nums2.length&1)==1)\\n        {\\n            for(int i:nums1)\\n            xor^=i;\\n        }\\n\\n        return xor;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052536,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int count1[32];\\n        int count2[32];\\n        memset(count1, 0, sizeof(count1));\\n        memset(count2, 0, sizeof(count2));\\n\\n        for(int ele: nums1) {\\n            for(int i=0;i<32;i++) {\\n                int check = (1<<i)&ele;\\n                if(check) {\\n                    count1[i]++;\\n                }\\n            }\\n        }\\n\\n\\n        for(int ele: nums2) {\\n            for(int i=0;i<32;i++) {\\n                int check = (1<<i)&ele;\\n                if(check) {\\n                    count2[i]++;\\n                }\\n            }\\n        }\\n\\n\\n        int res = 0;\\n        for(int i=0;i<32;i++) {\\n            int tmp = count1[i] * (nums2.size()-count2[i]) + (nums1.size() - count1[i]) * count2[i];\\n            if(tmp%2==1) {\\n                res |= 1<<i;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {\\n        int count1[32];\\n        int count2[32];\\n        memset(count1, 0, sizeof(count1));\\n        memset(count2, 0, sizeof(count2));\\n\\n        for(int ele: nums1) {\\n            for(int i=0;i<32;i++) {\\n                int check = (1<<i)&ele;\\n                if(check) {\\n                    count1[i]++;\\n                }\\n            }\\n        }\\n\\n\\n        for(int ele: nums2) {\\n            for(int i=0;i<32;i++) {\\n                int check = (1<<i)&ele;\\n                if(check) {\\n                    count2[i]++;\\n                }\\n            }\\n        }\\n\\n\\n        int res = 0;\\n        for(int i=0;i<32;i++) {\\n            int tmp = count1[i] * (nums2.size()-count2[i]) + (nums1.size() - count1[i]) * count2[i];\\n            if(tmp%2==1) {\\n                res |= 1<<i;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047586,
                "title": "easy-to-understand-in-o-n-with-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1=nums1.length;\\n        int n2=nums2.length;\\n        if(n1 % 2 ==0 && n2 % 2 ==0)return 0;\\n        if(n1 % 2 !=0 && n2 % 2 !=0)return getXOR(nums1,nums2);\\n        return n1 % 2==0 ? getXOR(nums1,new int[]{}) : getXOR(new int[]{},nums2);\\n    }\\n    int getXOR(int[] a, int[] b){\\n        int val=0;\\n        for(int i=0;i<a.length;i++)val^=a[i];\\n        if(b.length>0)\\n            for(int i=0;i<b.length;i++)val^=b[i];\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int n1=nums1.length;\\n        int n2=nums2.length;\\n        if(n1 % 2 ==0 && n2 % 2 ==0)return 0;\\n        if(n1 % 2 !=0 && n2 % 2 !=0)return getXOR(nums1,nums2);\\n        return n1 % 2==0 ? getXOR(nums1,new int[]{}) : getXOR(new int[]{},nums2);\\n    }\\n    int getXOR(int[] a, int[] b){\\n        int val=0;\\n        for(int i=0;i<a.length;i++)val^=a[i];\\n        if(b.length>0)\\n            for(int i=0;i<b.length;i++)val^=b[i];\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031753,
                "title": "simple-java-solution-explained",
                "content": "# Approach\\nSo let be xor1 the xor of all number in nums1 and xor2 the xor of all number in nums2.\\nLet be $$n_1$$ the length of nums1 and $$n_2$$ the length of nums2. \\n\\nThe xor of all pairing is (xor1 $$n_2$$ times )$$\\\\oplus$$ (xor2 $$n_1$$ times)\\n\\nSo:\\n- If $$n_1$$ and $$n_2$$ are both even, then the result is 0\\n- If $$n_1$$ is even and $$n_2$$ is odd, then the result is xor1\\n- If $$n_2$$ is even and $$n_1$$ is odd, then the result is xor2\\n- Or else the answer is just the xor of the two\\n\\n\\n# Complexity\\n- Time complexity: $$O(n_1+n_2)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor1=0;\\n        int xor2=0;\\n\\n        for(int x: nums1) { xor1 ^= x; } \\n        for(int y: nums2) { xor2 ^= y; }\\n\\n        xor1 = (nums2.length % 2 == 0) ? 0 : xor1;\\n        xor2 = (nums1.length % 2 == 0) ? 0 : xor2;\\n\\n        return xor1^xor2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int xor1=0;\\n        int xor2=0;\\n\\n        for(int x: nums1) { xor1 ^= x; } \\n        for(int y: nums2) { xor2 ^= y; }\\n\\n        xor1 = (nums2.length % 2 == 0) ? 0 : xor1;\\n        xor2 = (nums1.length % 2 == 0) ? 0 : xor2;\\n\\n        return xor1^xor2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009623,
                "title": "rust-simple-solution",
                "content": "# Approach\\nXor a even number of times = 0\\n    a odd  number of times = a\\n\\n# Complexity\\n- Time complexity:\\nWorst case $$O(n+m)$$ best is $$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn xor_all_nums(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        let xora = if nums2.len()%2 == 0{\\n            0\\n        }\\n        else{\\n            let mut r = 0;\\n            for &i in nums1.iter(){\\n                r ^= i;\\n            }\\n            r\\n        };\\n        let xorb = if nums1.len()%2 == 0{\\n            0\\n        }\\n        else{\\n            let mut r = 0;\\n            for &i in nums2.iter(){\\n                r ^= i;\\n            }\\n            r\\n        };\\n\\n        xora^xorb        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn xor_all_nums(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        let xora = if nums2.len()%2 == 0{\\n            0\\n        }\\n        else{\\n            let mut r = 0;\\n            for &i in nums1.iter(){\\n                r ^= i;\\n            }\\n            r\\n        };\\n        let xorb = if nums1.len()%2 == 0{\\n            0\\n        }\\n        else{\\n            let mut r = 0;\\n            for &i in nums2.iter(){\\n                r ^= i;\\n            }\\n            r\\n        };\\n\\n        xora^xorb        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3004398,
                "title": "simple-python-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=len(nums1)\\n        m=len(nums2)\\n        if n%2==0 and m%2==0:\\n            return 0\\n        elif n%2==1 and m%2==0:\\n            result=0\\n            for i in nums2:\\n                result^=i\\n            return result\\n        elif n%2==0 and m%2==1:\\n            result=0\\n            for i in nums1:\\n                result^=i\\n            return result\\n        else:\\n            result=0\\n            for i in nums1:\\n                result^=i\\n            for i in nums2:\\n                result^=i\\n            return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=len(nums1)\\n        m=len(nums2)\\n        if n%2==0 and m%2==0:\\n            return 0\\n        elif n%2==1 and m%2==0:\\n            result=0\\n            for i in nums2:\\n                result^=i\\n            return result\\n        elif n%2==0 and m%2==1:\\n            result=0\\n            for i in nums1:\\n                result^=i\\n            return result\\n        else:\\n            result=0\\n            for i in nums1:\\n                result^=i\\n            for i in nums2:\\n                result^=i\\n            return result\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2059424,
                "content": [
                    {
                        "username": "user5490Gj",
                        "content": "terrible formulation, what do you mean \"there exists another array, nums3\"? Should\\'ve said let nums3 be..."
                    },
                    {
                        "username": "Shivangi_c0",
                        "content": "\\nJust check 2 cases :\\n1. If length of nums1 is odd ,  xor all elements of nums2 once.\\n2. If length of nums2 is odd ,  xor all elements of nums1 once.\\nLOGIC : Because XOR of same elements is 0 i.e cancels out\\n\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int ansxor=0;        \\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n       \\n        if(n1 % 2 == 1){\\n            for(int i=0; i<n2; i++){\\n                ansxor ^= nums2[i];\\n            }\\n        } \\n        if(n2 % 2 == 1){\\n            for(int i=0; i<n1; i++){\\n                ansxor ^= nums1[i];\\n            }\\n        } \\n       return ansxor;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1626213,
                "content": [
                    {
                        "username": "user5490Gj",
                        "content": "terrible formulation, what do you mean \"there exists another array, nums3\"? Should\\'ve said let nums3 be..."
                    },
                    {
                        "username": "Shivangi_c0",
                        "content": "\\nJust check 2 cases :\\n1. If length of nums1 is odd ,  xor all elements of nums2 once.\\n2. If length of nums2 is odd ,  xor all elements of nums1 once.\\nLOGIC : Because XOR of same elements is 0 i.e cancels out\\n\\n```\\nclass Solution {\\n    public int xorAllNums(int[] nums1, int[] nums2) {\\n        int ansxor=0;        \\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n       \\n        if(n1 % 2 == 1){\\n            for(int i=0; i<n2; i++){\\n                ansxor ^= nums2[i];\\n            }\\n        } \\n        if(n2 % 2 == 1){\\n            for(int i=0; i<n1; i++){\\n                ansxor ^= nums1[i];\\n            }\\n        } \\n       return ansxor;\\n    }\\n}\\n```"
                    }
                ]
            }
        ]
    }
]